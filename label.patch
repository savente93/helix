diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index 93fcb9816..f712a5315 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -8,6 +8,11 @@ on:
   schedule:
     - cron: "00 01 * * *"
 
+env:
+  MSRV: "1.76"
+  # This key can be changed to bust the cache of tree-sitter grammars.
+  GRAMMAR_CACHE_VERSION: ""
+
 jobs:
   check:
     name: Check (msrv)
@@ -16,13 +21,23 @@ jobs:
     steps:
       - name: Checkout sources
         uses: actions/checkout@v4
-      - name: Install stable toolchain
-        uses: dtolnay/rust-toolchain@1.70
+
+      - name: Install MSRV toolchain
+        uses: dtolnay/rust-toolchain@master
+        with:
+          toolchain: ${{ env.MSRV }}
 
       - uses: Swatinem/rust-cache@v2
         with:
           shared-key: "build"
 
+      - name: Cache tree-sitter grammars
+        uses: actions/cache@v4
+        with:
+          path: runtime/grammars
+          key: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-${{ hashFiles('languages.toml') }}
+          restore-keys: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-
+
       - name: Run cargo check
         run: cargo check
 
@@ -37,19 +52,21 @@ jobs:
       - name: Checkout sources
         uses: actions/checkout@v4
 
-      - name: Install stable toolchain
-        uses: dtolnay/rust-toolchain@1.70
+      - name: Install MSRV toolchain
+        uses: dtolnay/rust-toolchain@master
+        with:
+          toolchain: ${{ env.MSRV }}
 
       - uses: Swatinem/rust-cache@v2
         with:
           shared-key: "build"
 
-      - name: Cache test tree-sitter grammar
+      - name: Cache tree-sitter grammars
         uses: actions/cache@v4
         with:
           path: runtime/grammars
-          key: ${{ runner.os }}-stable-v${{ env.CACHE_VERSION }}-tree-sitter-grammars-${{ hashFiles('languages.toml') }}
-          restore-keys: ${{ runner.os }}-stable-v${{ env.CACHE_VERSION }}-tree-sitter-grammars-
+          key: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-${{ hashFiles('languages.toml') }}
+          restore-keys: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-
 
       - name: Run cargo test
         run: cargo test --workspace
@@ -69,15 +86,23 @@ jobs:
       - name: Checkout sources
         uses: actions/checkout@v4
 
-      - name: Install stable toolchain
-        uses: dtolnay/rust-toolchain@1.70
+      - name: Install MSRV toolchain
+        uses: dtolnay/rust-toolchain@master
         with:
+          toolchain: ${{ env.MSRV }}
           components: rustfmt, clippy
 
       - uses: Swatinem/rust-cache@v2
         with:
           shared-key: "build"
 
+      - name: Cache tree-sitter grammars
+        uses: actions/cache@v4
+        with:
+          path: runtime/grammars
+          key: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-${{ hashFiles('languages.toml') }}
+          restore-keys: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-
+
       - name: Run cargo fmt
         run: cargo fmt --all --check
 
@@ -97,16 +122,28 @@ jobs:
       - name: Checkout sources
         uses: actions/checkout@v4
 
-      - name: Install stable toolchain
-        uses: dtolnay/rust-toolchain@1.70
+      - name: Install MSRV toolchain
+        uses: dtolnay/rust-toolchain@master
+        with:
+          toolchain: ${{ env.MSRV }}
 
       - uses: Swatinem/rust-cache@v2
         with:
           shared-key: "build"
 
+      - name: Cache tree-sitter grammars
+        uses: actions/cache@v4
+        with:
+          path: runtime/grammars
+          key: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-${{ hashFiles('languages.toml') }}
+          restore-keys: ${{ runner.os }}-stable-v${{ env.GRAMMAR_CACHE_VERSION }}-tree-sitter-grammars-
+
       - name: Validate queries
         run: cargo xtask query-check
 
+      - name: Validate themes
+        run: cargo xtask theme-check
+
       - name: Generate docs
         run: cargo xtask docgen
 
diff --git a/.github/workflows/cachix.yml b/.github/workflows/cachix.yml
index b8be02e16..9a25cbe45 100644
--- a/.github/workflows/cachix.yml
+++ b/.github/workflows/cachix.yml
@@ -14,7 +14,7 @@ jobs:
       uses: actions/checkout@v4
 
     - name: Install nix
-      uses: cachix/install-nix-action@V27
+      uses: cachix/install-nix-action@v30
 
     - name: Authenticate with Cachix
       uses: cachix/cachix-action@v15
diff --git a/.github/workflows/gh-pages.yml b/.github/workflows/gh-pages.yml
index 39dc08982..d42ab1c80 100644
--- a/.github/workflows/gh-pages.yml
+++ b/.github/workflows/gh-pages.yml
@@ -1,4 +1,4 @@
-name: Github Pages
+name: GitHub Pages
 
 on:
   push:
@@ -16,8 +16,8 @@ jobs:
       - name: Setup mdBook
         uses: peaceiris/actions-mdbook@v2
         with:
-          mdbook-version: 'latest'
-          # mdbook-version: '0.4.8'
+          # mdbook-version: 'latest'
+          mdbook-version: '0.4.43'
 
       - run: mdbook build book
       
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index b483e3af0..de0a25f67 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -61,17 +61,17 @@ jobs:
         build: [x86_64-linux, x86_64-macos, x86_64-windows] #, x86_64-win-gnu, win32-msvc
         include:
         - build: x86_64-linux
-          os: ubuntu-latest
+          os: ubuntu-22.04
           rust: stable
           target: x86_64-unknown-linux-gnu
           cross: false
         - build: aarch64-linux
-          os: ubuntu-latest
+          os: ubuntu-22.04
           rust: stable
           target: aarch64-unknown-linux-gnu
           cross: true
         # - build: riscv64-linux
-        #   os: ubuntu-latest
+        #   os: ubuntu-22.04
         #   rust: stable
         #   target: riscv64gc-unknown-linux-gnu
         #   cross: true
@@ -147,16 +147,8 @@ jobs:
         if: "!matrix.skip_tests"
         run: ${{ env.CARGO }} test --release --locked --target ${{ matrix.target }} --workspace
 
-      - name: Set profile.release.strip = true
-        shell: bash
-        run: |
-          cat >> .cargo/config.toml <<EOF
-          [profile.release]
-          strip = true
-          EOF
-
       - name: Build release binary
-        run: ${{ env.CARGO }} build --release --locked --target ${{ matrix.target }}
+        run: ${{ env.CARGO }} build --profile opt --locked --target ${{ matrix.target }}
 
       - name: Build AppImage
         shell: bash
@@ -183,7 +175,7 @@ jobs:
 
           mkdir -p "$APP.AppDir"/usr/{bin,lib/helix}
 
-          cp "target/${{ matrix.target }}/release/hx" "$APP.AppDir/usr/bin/hx"
+          cp "target/${{ matrix.target }}/opt/hx" "$APP.AppDir/usr/bin/hx"
           rm -rf runtime/grammars/sources
           cp -r runtime "$APP.AppDir/usr/lib/helix/runtime"
 
@@ -206,14 +198,25 @@ jobs:
           mv "$APP-$VERSION-$ARCH.AppImage" \
               "$APP-$VERSION-$ARCH.AppImage.zsync" dist
 
+      - name: Build Deb
+        shell: bash
+        if: matrix.build == 'x86_64-linux'
+        run: |
+          cargo install cargo-deb
+          mkdir -p target/release
+          cp target/${{ matrix.target }}/opt/hx target/release/
+          cargo deb --no-build
+          mkdir -p dist
+          mv target/debian/*.deb dist/
+
       - name: Build archive
         shell: bash
         run: |
           mkdir -p dist
           if [ "${{ matrix.os }}" = "windows-2019" ]; then
-            cp "target/${{ matrix.target }}/release/hx.exe" "dist/"
+            cp "target/${{ matrix.target }}/opt/hx.exe" "dist/"
           else
-            cp "target/${{ matrix.target }}/release/hx" "dist/"
+            cp "target/${{ matrix.target }}/opt/hx" "dist/"
           fi
           if [ -d runtime/grammars/sources ]; then
             rm -rf runtime/grammars/sources
@@ -241,6 +244,7 @@ jobs:
           set -ex
 
           source="$(pwd)"
+          tag=${GITHUB_REF_NAME//\//}
           mkdir -p runtime/grammars/sources
           tar xJf grammars/grammars.tar.xz -C runtime/grammars/sources
           rm -rf grammars
@@ -254,7 +258,7 @@ jobs:
               if [[ $platform =~ "windows" ]]; then
                   exe=".exe"
               fi
-              pkgname=helix-$GITHUB_REF_NAME-$platform
+              pkgname=helix-$tag-$platform
               mkdir -p $pkgname
               cp $source/LICENSE $source/README.md $pkgname
               mkdir $pkgname/contrib
@@ -265,6 +269,7 @@ jobs:
 
               if [[ "$platform" = "x86_64-linux" ]]; then
                   mv bins-$platform/helix-*.AppImage* dist/
+                  mv bins-$platform/*.deb dist/
               fi
 
               if [ "$exe" = "" ]; then
@@ -274,7 +279,7 @@ jobs:
               fi
           done
 
-          tar cJf dist/helix-$GITHUB_REF_NAME-source.tar.xz -C $source .
+          tar cJf dist/helix-$tag-source.tar.xz -C $source .
           mv dist $source/
 
       - name: Upload binaries to release
diff --git a/.gitignore b/.gitignore
index 6a6fc782a..64a837dfd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@ target
 helix-term/rustfmt.toml
 result
 runtime/grammars
+.DS_Store
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 491edb204..61c05ae7d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,302 @@
+<!--
+# YY.0M (YYYY-0M-0D)
+
+Breaking changes:
+
+Features:
+
+Commands:
+
+Usability improvements:
+
+Fixes:
+
+Themes:
+
+New languages:
+
+Updated languages and queries:
+
+Packaging:
+-->
+
+# 25.01.1 (2025-01-19)
+
+25.01.1 is a patch release focusing on fixing bugs and panics from changes in 25.01.
+
+Usability improvements:
+
+* Run external formatters from the document's directory ([#12315](https://github.com/helix-editor/helix/pull/12315))
+
+Fixes:
+
+* Fix blank buffer picker preview on doc with no views ([917174e](https://github.com/helix-editor/helix/commit/917174e))
+* Fix `join_selections` behavior on tabs ([#12452](https://github.com/helix-editor/helix/pull/12452))
+* Fix recognition for color LSP completion hex codes for some language servers ([#12501](https://github.com/helix-editor/helix/pull/12501))
+* Fix offsets to selections updated by `open_below`/`open_above` (`o`/`O`) in multi-cursor scenarios ([#12465](https://github.com/helix-editor/helix/pull/12465))
+* Fix offsets to selections updated by `insert_newline` when trimming whitespace in multi-cursor scenarios ([4bd17e5](https://github.com/helix-editor/helix/commit/4bd17e5))
+* Fix panic in path completion from resolving variables like `${HOME:-$HOME}` ([#12556](https://github.com/helix-editor/helix/pull/12556))
+* Prevent line comment continuation when using `change_selection` (`c`) on a line above a comment ([#12575](https://github.com/helix-editor/helix/pull/12575))
+
+Themes:
+
+* Update `onelight` ([#12399](https://github.com/helix-editor/helix/pull/12399))
+* Add cursorline color to iceberg themes ([#12404](https://github.com/helix-editor/helix/pull/12404))
+* Update `special`, `ui.text.directory` and `ui.virtual.wrap` in `dark_plus` ([#12530](https://github.com/helix-editor/helix/pull/12530))
+
+New languages:
+
+* CodeQL ([#12470](https://github.com/helix-editor/helix/pull/12470))
+* Gren ([#12525](https://github.com/helix-editor/helix/pull/12525))
+
+Updated languages and queries:
+
+* Fix Teal LSP name ([#12395](https://github.com/helix-editor/helix/pull/12395))
+* Highlight `:` in Rust as a delimiter ([#12408](https://github.com/helix-editor/helix/pull/12408))
+* Update Swift highlights ([#12409](https://github.com/helix-editor/helix/pull/12409))
+* Highlight JSX attributes as `@attribute` ([#12416](https://github.com/helix-editor/helix/pull/12416))
+* Improve markdown heading highlights ([#12417](https://github.com/helix-editor/helix/pull/12417))
+* Add comment tokens configuration for JSONC ([b26903c](https://github.com/helix-editor/helix/commit/b26903c))
+* Highlight the never type `!` as a type in Rust ([#12485](https://github.com/helix-editor/helix/pull/12485))
+* Expand builtin function highlights for ECMA languages, Rust and Haskell ([#12488](https://github.com/helix-editor/helix/pull/12488))
+* Recognize `.clang-tidy` as YAML ([#12498](https://github.com/helix-editor/helix/pull/12498))
+* Update MATLAB grammar and indent queries ([#12518](https://github.com/helix-editor/helix/pull/12518))
+* Recognize `rockspec` as Lua ([#12516](https://github.com/helix-editor/helix/pull/12516))
+* Add `///` to Dart comment tokens configuration ([99d33c7](https://github.com/helix-editor/helix/commit/99d33c7))
+* Update Solidity grammar and queries ([#12457](https://github.com/helix-editor/helix/pull/12457))
+* Update Spade grammar and queries ([#12583](https://github.com/helix-editor/helix/pull/12583))
+* Re-enable Hare fetching and building by default ([#11507](https://github.com/helix-editor/helix/pull/11507))
+
+Packaging:
+
+* `--version` now prints a leading zero for single-digit months, for example `25.01` (03f35af)
+* Pin the Ubuntu GitHub Actions runners used for releases to `ubuntu-22.04` ([#12464](https://github.com/helix-editor/helix/pull/12464))
+* Produce a Debian package (`.deb` file) in the release GitHub Actions workflow ([#12453](https://github.com/helix-editor/helix/pull/12453))
+
+# 25.01 (2025-01-03)
+
+As always, a big thank you to all of the contributors! This release saw changes from 171 contributors.
+
+Breaking changes:
+
+* The `editor.lsp.display-messages` key now controls messages sent with the LSP `window/showMessage` notification rather than progress messages. If you want to enable progress messages you should now enable the `editor.lsp.display-progress-messages` key instead. ([#5535](https://github.com/helix-editor/helix/pull/5535))
+
+Features:
+
+* Big refactor for `Picker`s ([#9647](https://github.com/helix-editor/helix/pull/9647), [#11209](https://github.com/helix-editor/helix/pull/11209), [#11216](https://github.com/helix-editor/helix/pull/11216), [#11211](https://github.com/helix-editor/helix/pull/11211), [#11343](https://github.com/helix-editor/helix/pull/11343), [#11406](https://github.com/helix-editor/helix/pull/11406))
+    * Use a table layout and allow filtering by column
+    * Reimplement `global_search` to allow changing the query dynamically
+* Add an alternative "inline" display for LSP diagnostics ([#6417](https://github.com/helix-editor/helix/pull/6417), [#11815](https://github.com/helix-editor/helix/pull/11815))
+* Support defining keybindings as macros ([#4709](https://github.com/helix-editor/helix/pull/4709))
+* Continue line comments in `o`/`O` and on `<ret>` in insert mode ([#10996](https://github.com/helix-editor/helix/pull/10996), [#12213](https://github.com/helix-editor/helix/pull/12213), [#12215](https://github.com/helix-editor/helix/pull/12215))
+* Allow configuring and switching clipboard providers at runtime ([#10839](https://github.com/helix-editor/helix/pull/10839), [b855cd0](https://github.com/helix-editor/helix/commit/b855cd0), [467fad5](https://github.com/helix-editor/helix/commit/467fad5), [191b0f0](https://github.com/helix-editor/helix/commit/191b0f0))
+* Add support for path completion ([#2608](https://github.com/helix-editor/helix/pull/2608))
+* Support bindings with the Super (Cmd/Win/Meta) modifier ([#6592](https://github.com/helix-editor/helix/pull/6592))
+* Support rendering and jumping between tabstops in snippet completions ([#9801](https://github.com/helix-editor/helix/pull/9801))
+* Allow theming directory completions ([#12205](https://github.com/helix-editor/helix/pull/12205), [#12295](https://github.com/helix-editor/helix/pull/12295))
+
+Commands:
+
+* Add commands to move within snake_case or camelCase words ([#8147](https://github.com/helix-editor/helix/pull/8147))
+* Add `search_selection_detect_word_boundaries` ([#12126](https://github.com/helix-editor/helix/pull/12126))
+    * This command takes the `*` key in normal and select mode, replacing `search_selection` which was moved to `A-*`.
+
+Usability improvements:
+
+* Add `:edit` and `:e` aliases for `:open` ([#11186](https://github.com/helix-editor/helix/pull/11186), [#11196](https://github.com/helix-editor/helix/pull/11196))
+* Trim trailing newline from pipe command outputs when the input doesn't have a trailing newline ([#11183](https://github.com/helix-editor/helix/pull/11183), [4f63a46](https://github.com/helix-editor/helix/commit/4f63a46))
+* Add `:mv` alias for `:move` ([#11256](https://github.com/helix-editor/helix/pull/11256))
+* Return document display name instead of absolute path from the `%` special register ([#11275](https://github.com/helix-editor/helix/pull/11275))
+* Track view position on a per-view instead of per-document basis ([#10559](https://github.com/helix-editor/helix/pull/10559))
+* Improve scrolloff calculation to leave a gap in the middle ([#11323](https://github.com/helix-editor/helix/pull/11323))
+* Show a popup for stderr printed by failed `:sh` commands ([#11239](https://github.com/helix-editor/helix/pull/11239))
+* Add statusline errors when nothing is selected with `s`, `K`, `A-K` ([#11370](https://github.com/helix-editor/helix/pull/11370))
+* Add `.svn` as a workspace root marker ([#11429](https://github.com/helix-editor/helix/pull/11429))
+* Trim the end of `:sh` outputs ([#11161](https://github.com/helix-editor/helix/pull/11161))
+* Show LSP `window/showMessage` messages in the statusline ([#5535](https://github.com/helix-editor/helix/pull/5535))
+* Support finding workspace directories via `.jj` directories ([#11685](https://github.com/helix-editor/helix/pull/11685))
+* Join single-line comments with `join_selections` (`J`) ([#11742](https://github.com/helix-editor/helix/pull/11742))
+* Show anonymous syntax tree nodes in `:tree-sitter-subtree` ([#11663](https://github.com/helix-editor/helix/pull/11663), [38e8382](https://github.com/helix-editor/helix/commit/38e8382))
+* Save an undo checkpoint before paste in insert mode ([#8121](https://github.com/helix-editor/helix/pull/8121))
+* Only break on ASCII spaces in `:reflow` ([#12048](https://github.com/helix-editor/helix/pull/12048))
+* Add a `default-yank-register` config option ([#11430](https://github.com/helix-editor/helix/pull/11430))
+* Show a statusline error for `:format` when a formatter is not available ([#12183](https://github.com/helix-editor/helix/pull/12183))
+* Change to the home directory with `:cd` with no arguments ([#12042](https://github.com/helix-editor/helix/pull/12042))
+* Change default comment token to `#` for unrecognized files ([#12080](https://github.com/helix-editor/helix/pull/12080), [#12266](https://github.com/helix-editor/helix/pull/12266), [bae6a58](https://github.com/helix-editor/helix/commit/bae6a58))
+* Trim all trailing whitespace on `insert_newline` ([#12177](https://github.com/helix-editor/helix/pull/12177))
+* Change to the prior directory with `:cd -` ([#12194](https://github.com/helix-editor/helix/pull/12194))
+* Allow parsing `-` (with no modifiers) as a keybinding ([#12191](https://github.com/helix-editor/helix/pull/12191))
+* Improve opening statusline and error messages when opening duplicate files or directories ([#12199](https://github.com/helix-editor/helix/pull/12199))
+* Trim trailing colons in paths passed on the argv ([#9963](https://github.com/helix-editor/helix/pull/9963))
+* Show tree-sitter parser availability in `hx --health <lang>` ([#12228](https://github.com/helix-editor/helix/pull/12228))
+* Show a preview block for colors in the LSP completion menu ([#12299](https://github.com/helix-editor/helix/pull/12299))
+* Add infobox help for `surround_add`, `surround_replace` and `surround_delete` ([#12262](https://github.com/helix-editor/helix/pull/12262))
+
+Fixes:
+
+* Respect document indentation settings in `format_selections` (`=`) ([#11169](https://github.com/helix-editor/helix/pull/11169))
+* Avoid switching the current document to normal mode during an LSP `workspace/applyEdit` operation ([#11176](https://github.com/helix-editor/helix/pull/11176))
+* Fix off-by-one in LSP `find_completion_range` ([#11266](https://github.com/helix-editor/helix/pull/11266))
+* Prefer file-system mtime to local system time for detecting external modifications ([#11142](https://github.com/helix-editor/helix/pull/11142), [#11352](https://github.com/helix-editor/helix/pull/11352), [#11358](https://github.com/helix-editor/helix/pull/11358), [#11361](https://github.com/helix-editor/helix/pull/11361))
+* Fix writing of hardlinks ([#11340](https://github.com/helix-editor/helix/pull/11340))
+* Prevent language servers from being automatically restarted when stopped with `:lsp-stop` ([#11321](https://github.com/helix-editor/helix/pull/11321))
+* Stable-sort LSP text edits ([#11357](https://github.com/helix-editor/helix/pull/11357))
+* Fix determination of current language layer in documents with nested language injections ([#11365](https://github.com/helix-editor/helix/pull/11365))
+* Fix a panic from `:move`ing a file to a new extension which starts a language server ([#11387](https://github.com/helix-editor/helix/pull/11387))
+* Fix a panic from duplicating the diff gutter ([#11092](https://github.com/helix-editor/helix/pull/11092))
+* Keep cursor position when exactly replacing text ([#5930](https://github.com/helix-editor/helix/pull/5930))
+* Fix a panic from `jump_backward` on a newly opened split ([#11508](https://github.com/helix-editor/helix/pull/11508))
+* Fix a panic from language servers sending an unknown diagnostic severity ([#11569](https://github.com/helix-editor/helix/pull/11569))
+* Fix a panic when drawing at the edge of the screen ([#11737](https://github.com/helix-editor/helix/pull/11737))
+* Fix git repo detection on symlinks ([#11732](https://github.com/helix-editor/helix/pull/11732))
+* Fix a panic from a language server sending an out-of-range active signature index in `textDocument/signatureHelp` ([#11825](https://github.com/helix-editor/helix/pull/11825))
+* Fix a panic from using `C-k` in a prompt ending in a multi-byte character ([#12237](https://github.com/helix-editor/helix/pull/12237))
+* Expand tildes in paths passed to `:read` ([#12271](https://github.com/helix-editor/helix/pull/12271))
+* Respect per-language `workspace-lsp-roots` configuration when opening new documents ([#12223](https://github.com/helix-editor/helix/pull/12223))
+* Consistently replace line-endings in paste/replace commands ([c262fe4](https://github.com/helix-editor/helix/commit/c262fe4))
+* Fix formatting in error statusline messages when inspecting variables in DAP ([#12354](https://github.com/helix-editor/helix/pull/12354))
+* Fix invisible printing of headers in `--health` output on light terminals ([#12355](https://github.com/helix-editor/helix/pull/12355))
+* Accept integers serialized as floats in the JSONRPC `id` field ([#12376](https://github.com/helix-editor/helix/pull/12376))
+
+Themes:
+
+* Bring `kanagawa` colors better in line with neovim version ([#11187](https://github.com/helix-editor/helix/pull/11187), [#11270](https://github.com/helix-editor/helix/pull/11270))
+* Add `ao` ([#11063](https://github.com/helix-editor/helix/pull/11063))
+* Update `dark_plus` ([#11415](https://github.com/helix-editor/helix/pull/11415))
+* Add `iceberg-light` and `iceberg-dark` ([#10674](https://github.com/helix-editor/helix/pull/10674))
+* Update everforest themes ([#11459](https://github.com/helix-editor/helix/pull/11459))
+* Update gruvbox themes ([#11477](https://github.com/helix-editor/helix/pull/11477))
+* Change primary selection cursor color for `naysayer` ([#11617](https://github.com/helix-editor/helix/pull/11617))
+* Style picker column names in `horizon-dark` ([#11649](https://github.com/helix-editor/helix/pull/11649))
+* Style picker column names in Darcula themes ([#11649](https://github.com/helix-editor/helix/pull/11649))
+* Update diagnostics colors in `snazzy` ([#11731](https://github.com/helix-editor/helix/pull/11731))
+* Update bogster themes ([#11353](https://github.com/helix-editor/helix/pull/11353))
+* Highlight `keyword.storage` in `onedark` ([#11802](https://github.com/helix-editor/helix/pull/11802))
+* Add `ui.virtual.jump-label` to `serika-dark` ([#11911](https://github.com/helix-editor/helix/pull/11911))
+* Add `adwaita-light` ([#10869](https://github.com/helix-editor/helix/pull/10869))
+* Add seoul256 themes ([#11466](https://github.com/helix-editor/helix/pull/11466))
+* Add yo themes ([#11703](https://github.com/helix-editor/helix/pull/11703))
+* Add `eiffel` ([#11679](https://github.com/helix-editor/helix/pull/11679))
+* Add `carbonfox` ([#11558](https://github.com/helix-editor/helix/pull/11558))
+* Set tags color in monokai themes ([#11917](https://github.com/helix-editor/helix/pull/11917))
+* Improve readability of spacebones picker selection ([#12064](https://github.com/helix-editor/helix/pull/12064))
+* Update modus themes ([#11949](https://github.com/helix-editor/helix/pull/11949))
+* Use bold for statusline mode indicator in `onedarker` ([#11958](https://github.com/helix-editor/helix/pull/11958))
+* Update hex themes, add a new hex theme ([#10849](https://github.com/helix-editor/helix/pull/10849))
+* Add `sunset` ([#12093](https://github.com/helix-editor/helix/pull/12093))
+* Add bufferline highlighting for flexoki themes ([#12146](https://github.com/helix-editor/helix/pull/12146))
+* Add colors for (un)checked list items to catppuccin themes ([#12167](https://github.com/helix-editor/helix/pull/12167))
+* Update `voxed` ([#9328](https://github.com/helix-editor/helix/pull/9328))
+* Add `vintage` ([#9361](https://github.com/helix-editor/helix/pull/9361))
+* Add directory style to everforest themes ([#12287](https://github.com/helix-editor/helix/pull/12287))
+* Add inactive text and update jump label highlights in `dark_plus` ([#12289](https://github.com/helix-editor/helix/pull/12289))
+* Sync changes with catppuccin themes ([#12304](https://github.com/helix-editor/helix/pull/12304))
+* Add `ui.text.directory` to `nightfox` ([#12328](https://github.com/helix-editor/helix/pull/12328))
+* Add `ui.text.directory` to `sunset` ([#12328](https://github.com/helix-editor/helix/pull/12328))
+* Add `diagnostic.unnecessary` to Catppuccin themes ([#12391](https://github.com/helix-editor/helix/pull/12391))
+
+New languages:
+
+* `jjdescription` ([#11271](https://github.com/helix-editor/helix/pull/11271), [#11857](https://github.com/helix-editor/helix/pull/11857), [#12305](https://github.com/helix-editor/helix/pull/12305))
+* i3wm and Sway configs ([#11424](https://github.com/helix-editor/helix/pull/11424))
+* TypeSpec ([#11412](https://github.com/helix-editor/helix/pull/11412))
+* jq ([#11393](https://github.com/helix-editor/helix/pull/11393))
+* Thrift ([#11367](https://github.com/helix-editor/helix/pull/11367))
+* Gherkin ([#11083](https://github.com/helix-editor/helix/pull/11083))
+* Circom ([#11676](https://github.com/helix-editor/helix/pull/11676))
+* Dune ([#11829](https://github.com/helix-editor/helix/pull/11829))
+* Snakemake ([#11858](https://github.com/helix-editor/helix/pull/11858), [#11936](https://github.com/helix-editor/helix/pull/11936))
+* Cylc ([#11830](https://github.com/helix-editor/helix/pull/11830))
+* textproto ([#11874](https://github.com/helix-editor/helix/pull/11874))
+* Spade ([#11448](https://github.com/helix-editor/helix/pull/11448), [#12276](https://github.com/helix-editor/helix/pull/12276))
+* NestedText ([#11987](https://github.com/helix-editor/helix/pull/11987))
+* Quint ([#11898](https://github.com/helix-editor/helix/pull/11898))
+* Amber-lang ([#12021](https://github.com/helix-editor/helix/pull/12021))
+* Vento ([#12147](https://github.com/helix-editor/helix/pull/12147))
+* Teal ([#12081](https://github.com/helix-editor/helix/pull/12081))
+* Koto ([#12307](https://github.com/helix-editor/helix/pull/12307))
+* NGINX ([#12309](https://github.com/helix-editor/helix/pull/12309))
+
+Updated languages and queries:
+
+* Add comment injections for Hare ([#11173](https://github.com/helix-editor/helix/pull/11173))
+* Improve highlights for `blade.php` files ([#11138](https://github.com/helix-editor/helix/pull/11138))
+* Update tree-sitter-slint ([#11224](https://github.com/helix-editor/helix/pull/11224), [#11757](https://github.com/helix-editor/helix/pull/11757), [#12297](https://github.com/helix-editor/helix/pull/12297))
+* Recognize `just` files as Just ([#11286](https://github.com/helix-editor/helix/pull/11286))
+* Recognize `mdx` as Markdown ([#11122](https://github.com/helix-editor/helix/pull/11122))
+* Update Just grammar and queries ([#11306](https://github.com/helix-editor/helix/pull/11306))
+* Recognize `tclsh` as TCL ([#11236](https://github.com/helix-editor/helix/pull/11236))
+* Update Godot grammar and queries ([#11235](https://github.com/helix-editor/helix/pull/11235))
+* Update Gleam grammar and queries ([#11427](https://github.com/helix-editor/helix/pull/11427))
+* Add `mesonlsp` for Meson ([#11416](https://github.com/helix-editor/helix/pull/11416))
+* Update HTML highlights ([#11400](https://github.com/helix-editor/helix/pull/11400))
+* Add comment textobjects for Verilog ([#11388](https://github.com/helix-editor/helix/pull/11388))
+* Switch tree-sitter-just grammar ([#11380](https://github.com/helix-editor/helix/pull/11380), [#11606](https://github.com/helix-editor/helix/pull/11606), [#12141](https://github.com/helix-editor/helix/pull/12141))
+* Update tree-sitter-fsharp ([#11061](https://github.com/helix-editor/helix/pull/11061))
+* Add `nixd` for Nix ([#10767](https://github.com/helix-editor/helix/pull/10767))
+* Highlight types and enum members from the Rust prelude ([#8535](https://github.com/helix-editor/helix/pull/8535))
+* Improve textobjects for HCL, Nix ([#11513](https://github.com/helix-editor/helix/pull/11513))
+* Add textobjects queries for docker-compose, dockerfile, env, git-config, hcl, hocon, prisma, SQL and YAML ([#11513](https://github.com/helix-editor/helix/pull/11513))
+* Recognize cshtml files as HTML ([#11540](https://github.com/helix-editor/helix/pull/11540))
+* Set a memory limit for the Lean language server ([#11683](https://github.com/helix-editor/helix/pull/11683))
+* Add configurations for jedi and ruff language servers ([#11630](https://github.com/helix-editor/helix/pull/11630))
+* Update Vue highlights ([#11706](https://github.com/helix-editor/helix/pull/11706))
+* Switch tree-sitter-hcl grammar ([#11749](https://github.com/helix-editor/helix/pull/11749))
+* Fix `odinfmt` formatter configuration ([#11759](https://github.com/helix-editor/helix/pull/11759))
+* Recognize `rbs` files as Ruby ([#11786](https://github.com/helix-editor/helix/pull/11786))
+* Update tree-sitter-nickel ([#11771](https://github.com/helix-editor/helix/pull/11771))
+* Recognize `ldtk` and `ldtkl` files as JSON ([#11793](https://github.com/helix-editor/helix/pull/11793))
+* Fix highlights for builtin functions in Fish ([#11792](https://github.com/helix-editor/helix/pull/11792))
+* Add `superhtml` for HTML ([#11609](https://github.com/helix-editor/helix/pull/11609))
+* Add a configuration for the Vale language server ([#11636](https://github.com/helix-editor/helix/pull/11636))
+* Add Erlang Language Platform (`elp`) for Erlang ([#11499](https://github.com/helix-editor/helix/pull/11499))
+* Update Odin highlights ([#11804](https://github.com/helix-editor/helix/pull/11804))
+* Remove auto-pairs for single quotes in SML ([#11838](https://github.com/helix-editor/helix/pull/11838))
+* Add `glsl_analyzer` for GLSL ([#11891](https://github.com/helix-editor/helix/pull/11891))
+* Recognize `.prettierrc` as YAML ([#11997](https://github.com/helix-editor/helix/pull/11997))
+* Fix `swift-format` formatter configuration ([#12052](https://github.com/helix-editor/helix/pull/12052))
+* Add `package.json` and `tsconfig.json` as JS/TS workspace roots ([#10652](https://github.com/helix-editor/helix/pull/10652))
+* Add "INVARIANT" to comment error highlights ([#12094](https://github.com/helix-editor/helix/pull/12094))
+* Update Rescript grammar and queries ([#11165](https://github.com/helix-editor/helix/pull/11165))
+* Update tree-sitter-nasm ([#11795](https://github.com/helix-editor/helix/pull/11795))
+* Update LLVM grammars ([#11851](https://github.com/helix-editor/helix/pull/11851))
+* Update Perl and Pod grammars ([#11848](https://github.com/helix-editor/helix/pull/11848))
+* Add Nim injections in Nix ([#11837](https://github.com/helix-editor/helix/pull/11837))
+* Recognize `livemd` as Markdown ([#12034](https://github.com/helix-editor/helix/pull/12034))
+* Update Unison grammar and queries ([#12039](https://github.com/helix-editor/helix/pull/12039))
+* Turn off Swift auto-format by default ([#12071](https://github.com/helix-editor/helix/pull/12071))
+* Recognize `.swift-format` as JSON ([#12071](https://github.com/helix-editor/helix/pull/12071))
+* Recognize `.clangd` and `.clang-format` as YAML ([#12032](https://github.com/helix-editor/helix/pull/12032))
+* Recognize `ssh_config.d/*.conf` as sshclientconfig ([#11947](https://github.com/helix-editor/helix/pull/11947))
+* Update comment token configs for Zig ([#12049](https://github.com/helix-editor/helix/pull/12049))
+* Update tree-sitter-bicep ([#11525](https://github.com/helix-editor/helix/pull/11525))
+* Add `hyperls` for Hyperlang ([#11056](https://github.com/helix-editor/helix/pull/11056))
+* Add highlight queries for Solidity ([#12102](https://github.com/helix-editor/helix/pull/12102))
+* Recognize `WORKSPACE.bzlmod` as Starlark ([#12103](https://github.com/helix-editor/helix/pull/12103))
+* Update Ada grammar and queries ([#12131](https://github.com/helix-editor/helix/pull/12131))
+* Restrict Hocon file-types glob patterns ([#12156](https://github.com/helix-editor/helix/pull/12156))
+* Update Mojo language server to Magic ([#12195](https://github.com/helix-editor/helix/pull/12195))
+* Switch tree-sitter-v grammar ([#12236](https://github.com/helix-editor/helix/pull/12236))
+* Add "COMPLIANCE" to comment error highlights ([#12094](https://github.com/helix-editor/helix/pull/12094))
+* Add a language server configuration for `ltex-ls-plus` ([#12251](https://github.com/helix-editor/helix/pull/12251))
+* Update tree-sitter-dockerfile ([#12230](https://github.com/helix-editor/helix/pull/12230))
+* Add `]` to PHP outdents ([#12286](https://github.com/helix-editor/helix/pull/12286))
+* Add textobjects for Odin ([#12302](https://github.com/helix-editor/helix/pull/12302))
+* Update tree-sitter-heex and queries ([#12334](https://github.com/helix-editor/helix/pull/12334))
+* Update protobuf highlights ([#12339](https://github.com/helix-editor/helix/pull/12339))
+* Switch tree-sitter-query (TSQ) grammar ([#12148](https://github.com/helix-editor/helix/pull/12148), [e0bccd2](https://github.com/helix-editor/helix/commit/e0bccd2))
+* Add block comment configurations for jinja and nunjucks ([#12348](https://github.com/helix-editor/helix/pull/12348))
+* Add `uv` shebang for python ([#12360](https://github.com/helix-editor/helix/pull/12360))
+* Update tree-sitter-vento ([#12368](https://github.com/helix-editor/helix/pull/12368))
+* Switch Protobuf tree-sitter grammar ([#12225](https://github.com/helix-editor/helix/pull/12225))
+* Recognize `hypr/*.conf` as Hyprland ([#12384](https://github.com/helix-editor/helix/pull/12384))
+
+Packaging:
+
+* Add completions for Nushell ([#11262](https://github.com/helix-editor/helix/pull/11262), [#11346](https://github.com/helix-editor/helix/pull/11346))
+* Fix completion of flags in Bash completions ([#11246](https://github.com/helix-editor/helix/pull/11246))
+* Include shell completions in Nix outputs ([#11518](https://github.com/helix-editor/helix/pull/11518))
+
 # 24.07 (2024-07-14)
 
 Thanks to all of the contributors! This release has changes from 160 contributors.
@@ -436,7 +735,7 @@ # 24.03 (2024-03-30)
 - Recognize common Dockerfile file types ([#9772](https://github.com/helix-editor/helix/pull/9772))
 - Recognize NUON files as Nu ([#9839](https://github.com/helix-editor/helix/pull/9839))
 - Add textobjects for Java native functions and constructors ([#9806](https://github.com/helix-editor/helix/pull/9806))
-- Fix "braket" typeo in JSX highlights ([#9910](https://github.com/helix-editor/helix/pull/9910))
+- Fix "braket" typo in JSX highlights ([#9910](https://github.com/helix-editor/helix/pull/9910))
 - Update tree-sitter-hurl ([#9775](https://github.com/helix-editor/helix/pull/9775))
 - Add textobjects queries for Vala ([#8541](https://github.com/helix-editor/helix/pull/8541))
 - Update tree-sitter-git-config ([9610254](https://github.com/helix-editor/helix/commit/9610254))
@@ -643,7 +942,7 @@ # 23.10 (2023-10-24)
 - Add Fortran comment injections ([#7305](https://github.com/helix-editor/helix/pull/7305))
 - Switch Vue language server to `vue-language-server` ([#7312](https://github.com/helix-editor/helix/pull/7312))
 - Update tree-sitter-sql ([#7387](https://github.com/helix-editor/helix/pull/7387), [#8464](https://github.com/helix-editor/helix/pull/8464))
-- Replace the MATLAB tre-sitter grammar ([#7388](https://github.com/helix-editor/helix/pull/7388), [#7442](https://github.com/helix-editor/helix/pull/7442), [#7491](https://github.com/helix-editor/helix/pull/7491), [#7493](https://github.com/helix-editor/helix/pull/7493), [#7511](https://github.com/helix-editor/helix/pull/7511), [#7532](https://github.com/helix-editor/helix/pull/7532), [#8040](https://github.com/helix-editor/helix/pull/8040))
+- Replace the MATLAB tree-sitter grammar ([#7388](https://github.com/helix-editor/helix/pull/7388), [#7442](https://github.com/helix-editor/helix/pull/7442), [#7491](https://github.com/helix-editor/helix/pull/7491), [#7493](https://github.com/helix-editor/helix/pull/7493), [#7511](https://github.com/helix-editor/helix/pull/7511), [#7532](https://github.com/helix-editor/helix/pull/7532), [#8040](https://github.com/helix-editor/helix/pull/8040))
 - Highlight TOML table headers ([#7441](https://github.com/helix-editor/helix/pull/7441))
 - Recognize `cppm` file-type as C++ ([#7492](https://github.com/helix-editor/helix/pull/7492))
 - Refactor ecma language queries into private and public queries ([#7207](https://github.com/helix-editor/helix/pull/7207))
@@ -1130,7 +1429,7 @@ # 22.12 (2022-12-06)
 - Support underline styles and colors ([#4061](https://github.com/helix-editor/helix/pull/4061), [98c121c](https://github.com/helix-editor/helix/commit/98c121c))
 - Inheritance for themes ([#3067](https://github.com/helix-editor/helix/pull/3067), [#4096](https://github.com/helix-editor/helix/pull/4096))
 - Cursorcolumn ([#4084](https://github.com/helix-editor/helix/pull/4084))
-- Overhauled system for writing files and quiting ([#2267](https://github.com/helix-editor/helix/pull/2267), [#4397](https://github.com/helix-editor/helix/pull/4397))
+- Overhauled system for writing files and quitting ([#2267](https://github.com/helix-editor/helix/pull/2267), [#4397](https://github.com/helix-editor/helix/pull/4397))
 - Autosave when terminal loses focus ([#3178](https://github.com/helix-editor/helix/pull/3178))
 - Use OSC52 as a fallback for the system clipboard ([#3220](https://github.com/helix-editor/helix/pull/3220))
 - Show git diffs in the gutter ([#3890](https://github.com/helix-editor/helix/pull/3890), [#5012](https://github.com/helix-editor/helix/pull/5012), [#4995](https://github.com/helix-editor/helix/pull/4995))
@@ -1285,7 +1584,7 @@ # 22.12 (2022-12-06)
 - Update `pop-dark` ([#4323](https://github.com/helix-editor/helix/pull/4323))
 - Update `rose_pine` ([#4221](https://github.com/helix-editor/helix/pull/4221))
 - Add `kanagawa` ([#4300](https://github.com/helix-editor/helix/pull/4300))
-- Add `hex_steel`, `hex_toxic` and `hex_lavendar` ([#4367](https://github.com/helix-editor/helix/pull/4367), [#4990](https://github.com/helix-editor/helix/pull/4990))
+- Add `hex_steel`, `hex_toxic` and `hex_lavender` ([#4367](https://github.com/helix-editor/helix/pull/4367), [#4990](https://github.com/helix-editor/helix/pull/4990))
 - Update `tokyonight` and `tokyonight_storm` ([#4415](https://github.com/helix-editor/helix/pull/4415))
 - Update `gruvbox` ([#4626](https://github.com/helix-editor/helix/pull/4626))
 - Update `dark_plus` ([#4661](https://github.com/helix-editor/helix/pull/4661), [#4678](https://github.com/helix-editor/helix/pull/4678))
@@ -1452,7 +1751,7 @@ # 22.08 (2022-08-31)
 - Introduce `keyword.storage` highlight scope ([#2731](https://github.com/helix-editor/helix/pull/2731))
 - Handle symlinks more consistently ([#2718](https://github.com/helix-editor/helix/pull/2718))
 - Improve markdown list rendering ([#2687](https://github.com/helix-editor/helix/pull/2687))
-- Update auto-pairs and idle-timout settings when the config is reloaded ([#2736](https://github.com/helix-editor/helix/pull/2736))
+- Update auto-pairs and idle-timeout settings when the config is reloaded ([#2736](https://github.com/helix-editor/helix/pull/2736))
 - Fix panic on closing last buffer ([#2658](https://github.com/helix-editor/helix/pull/2658))
 - Prevent modifying jumplist until jumping to a reference ([#2670](https://github.com/helix-editor/helix/pull/2670))
 - Ensure `:quit` and `:quit!` take no arguments ([#2654](https://github.com/helix-editor/helix/pull/2654))
diff --git a/Cargo.lock b/Cargo.lock
index d33f430f9..8531d0a3d 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -4,9 +4,9 @@ version = 3
 
 [[package]]
 name = "addr2line"
-version = "0.20.0"
+version = "0.22.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f4fa78e18c64fce05e902adecd7a5eed15a5e0a3439f7b0e169f0252214865e3"
+checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
 dependencies = [
  "gimli",
 ]
@@ -17,6 +17,12 @@ version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
 
+[[package]]
+name = "adler2"
+version = "2.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"
+
 [[package]]
 name = "ahash"
 version = "0.8.11"
@@ -24,7 +30,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
 dependencies = [
  "cfg-if",
- "getrandom",
+ "getrandom 0.2.15",
  "once_cell",
  "version_check",
  "zerocopy",
@@ -32,18 +38,18 @@ dependencies = [
 
 [[package]]
 name = "aho-corasick"
-version = "1.1.2"
+version = "1.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0"
+checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "allocator-api2"
-version = "0.2.14"
+version = "0.2.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4f263788a35611fba42eb41ff811c5d0360c58b97402570312a350736e2542e"
+checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"
 
 [[package]]
 name = "android-tzdata"
@@ -62,9 +68,9 @@ dependencies = [
 
 [[package]]
 name = "anyhow"
-version = "1.0.86"
+version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b3d1d046238990b9cf5bcde22a3fb3584ee5cf65fb2765f454ed428c7a0063da"
+checksum = "34ac096ce696dc2fcabef30516bb13c0a68a11d30131d3df6f04711467681b04"
 
 [[package]]
 name = "arc-swap"
@@ -74,42 +80,36 @@ checksum = "69f7f8c3906b62b754cd5326047894316021dcfe5a194c8ea52bdd94934a3457"
 
 [[package]]
 name = "autocfg"
-version = "1.1.0"
+version = "1.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
+checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"
 
 [[package]]
 name = "backtrace"
-version = "0.3.68"
+version = "0.3.73"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4319208da049c43661739c5fade2ba182f09d1dc2299b32298d3a31692b17e12"
+checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
 dependencies = [
  "addr2line",
  "cc",
  "cfg-if",
  "libc",
- "miniz_oxide",
+ "miniz_oxide 0.7.4",
  "object",
  "rustc-demangle",
 ]
 
 [[package]]
 name = "bitflags"
-version = "1.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
-
-[[package]]
-name = "bitflags"
-version = "2.6.0"
+version = "2.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"
+checksum = "8f68f53c83ab957f72c32642f3868eec03eb974d1fb82e453128456482613d36"
 
 [[package]]
 name = "bstr"
-version = "1.8.0"
+version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "542f33a8835a0884b006a0c3df3dadd99c0c3f296ed26c2fdc8028e01ad6230c"
+checksum = "40723b8fb387abc38f4f4a37c09073622e41dd12327033091ef8950659e6dc0c"
 dependencies = [
  "memchr",
  "regex-automata",
@@ -118,15 +118,15 @@ dependencies = [
 
 [[package]]
 name = "bumpalo"
-version = "3.12.0"
+version = "3.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d261e256854913907f67ed06efbc3338dfe6179796deefc1ff763fc1aee5535"
+checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"
 
 [[package]]
 name = "bytes"
-version = "1.4.0"
+version = "1.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
+checksum = "8318a53db07bb3f8dca91a600466bdb3f2eaadeedfdbcf02e1accbad9271ba50"
 
 [[package]]
 name = "cassowary"
@@ -136,9 +136,9 @@ checksum = "df8670b8c7b9dae1793364eafadf7239c40d669904660c5960d74cfd80b46a53"
 
 [[package]]
 name = "cc"
-version = "1.1.13"
+version = "1.2.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "72db2f7947ecee9b03b510377e8bb9077afa27176fdbff55c51027e976fdcc48"
+checksum = "e4730490333d58093109dc02c23174c3f4d490998c3fed3cc8e82d57afedb9cf"
 dependencies = [
  "shlex",
 ]
@@ -162,9 +162,9 @@ dependencies = [
 
 [[package]]
 name = "chrono"
-version = "0.4.38"
+version = "0.4.39"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
+checksum = "7e36cc9d416881d2e24f9a963be5fb1cd90966419ac844274161d10488b3e825"
 dependencies = [
  "android-tzdata",
  "iana-time-zone",
@@ -183,19 +183,9 @@ dependencies = [
 
 [[package]]
 name = "clru"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b8191fa7302e03607ff0e237d4246cc043ff5b3cb9409d995172ba3bea16b807"
-
-[[package]]
-name = "codespan-reporting"
-version = "0.11.1"
+version = "0.6.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
-dependencies = [
- "termcolor",
- "unicode-width",
-]
+checksum = "cbd0f76e066e64fdc5631e3bb46381254deab9ef1158292f27c8c57e3bf3fe59"
 
 [[package]]
 name = "content_inspector"
@@ -208,61 +198,43 @@ dependencies = [
 
 [[package]]
 name = "core-foundation-sys"
-version = "0.8.4"
+version = "0.8.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"
+checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"
 
 [[package]]
 name = "crc32fast"
-version = "1.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
-dependencies = [
- "cfg-if",
-]
-
-[[package]]
-name = "crossbeam-channel"
-version = "0.5.8"
+version = "1.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200"
+checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
 dependencies = [
  "cfg-if",
- "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-deque"
-version = "0.8.3"
+version = "0.8.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef"
+checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
 dependencies = [
- "cfg-if",
  "crossbeam-epoch",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-epoch"
-version = "0.9.15"
+version = "0.9.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7"
+checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
 dependencies = [
- "autocfg",
- "cfg-if",
  "crossbeam-utils",
- "memoffset",
- "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.16"
+version = "0.8.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294"
-dependencies = [
- "cfg-if",
-]
+checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"
 
 [[package]]
 name = "crossterm"
@@ -270,7 +242,7 @@ version = "0.28.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "829d955a0bb380ef178a640b91779e3987da38c9aea133b20614cfed8cdea9c6"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "crossterm_winapi",
  "filedescriptor",
  "futures-core",
@@ -292,70 +264,29 @@ dependencies = [
  "winapi",
 ]
 
-[[package]]
-name = "cxx"
-version = "1.0.94"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f61f1b6389c3fe1c316bf8a4dccc90a38208354b330925bce1f74a6c4756eb93"
-dependencies = [
- "cc",
- "cxxbridge-flags",
- "cxxbridge-macro",
- "link-cplusplus",
-]
-
-[[package]]
-name = "cxx-build"
-version = "1.0.94"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12cee708e8962df2aeb38f594aae5d827c022b6460ac71a7a3e2c3c2aae5a07b"
-dependencies = [
- "cc",
- "codespan-reporting",
- "once_cell",
- "proc-macro2",
- "quote",
- "scratch",
- "syn 2.0.48",
-]
-
-[[package]]
-name = "cxxbridge-flags"
-version = "1.0.94"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7944172ae7e4068c533afbb984114a56c46e9ccddda550499caa222902c7f7bb"
-
-[[package]]
-name = "cxxbridge-macro"
-version = "1.0.94"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2345488264226bf682893e25de0769f3360aac9957980ec49361b083ddaa5bc5"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.48",
-]
-
 [[package]]
 name = "dashmap"
-version = "5.4.0"
+version = "6.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "907076dfda823b0b36d2a1bb5f90c96660a5bbcd7729e10727f07858f22c4edc"
+checksum = "5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf"
 dependencies = [
  "cfg-if",
- "hashbrown 0.12.3",
+ "crossbeam-utils",
+ "hashbrown 0.14.5",
  "lock_api",
  "once_cell",
  "parking_lot_core",
 ]
 
 [[package]]
-name = "deranged"
-version = "0.3.11"
+name = "displaydoc"
+version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
+checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
 dependencies = [
- "powerfmt",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
@@ -366,15 +297,15 @@ checksum = "92773504d58c093f6de2459af4af33faa518c13451eb8f2b5698ed3d36e7c813"
 
 [[package]]
 name = "either"
-version = "1.9.0"
+version = "1.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
+checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.34"
+version = "0.8.35"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b45de904aa0b010bce2ab45264d0631681847fa7b6f2eaa7dab7619943bc4f59"
+checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
 dependencies = [
  "cfg-if",
 ]
@@ -388,27 +319,33 @@ dependencies = [
  "encoding_rs",
 ]
 
+[[package]]
+name = "env_home"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7f84e12ccf0a7ddc17a6c41c93326024c42920d7ee630d04950e6926645c0fe"
+
 [[package]]
 name = "equivalent"
-version = "1.0.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "88bffebc5d80432c9b140ee17875ff173a8ab62faad5b257da912bd2f6c1c0a1"
+checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
 
 [[package]]
 name = "errno"
-version = "0.3.8"
+version = "0.3.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245"
+checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
 dependencies = [
  "libc",
- "windows-sys 0.52.0",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
 name = "error-code"
-version = "3.0.0"
+version = "3.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "281e452d3bad4005426416cdba5ccfd4f5c1280e10099e21db27f7c1c28347fc"
+checksum = "a0474425d51df81997e2f90a21591180b38eccf27292d755f3e30750225c175b"
 
 [[package]]
 name = "etcetera"
@@ -426,18 +363,21 @@ name = "faster-hex"
 version = "0.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a2a2b11eda1d40935b26cf18f6833c526845ae8c41e58d09af6adeb6f0269183"
+dependencies = [
+ "serde",
+]
 
 [[package]]
 name = "fastrand"
-version = "2.1.0"
+version = "2.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"
+checksum = "e8c02a5121d4ea3eb16a80748c74f5549a5665e4c21333c6098f283870fbdea6"
 
 [[package]]
 name = "fern"
-version = "0.6.2"
+version = "0.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d9f0c14694cbd524c8720dd69b0e3179344f04ebb5f90f2e4a440c6ea3b2f1ee"
+checksum = "4316185f709b23713e41e3195f90edef7fb00c3ed4adc79769cf09cc762a3b29"
 dependencies = [
  "log",
 ]
@@ -449,30 +389,30 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7199d965852c3bac31f779ef99cbb4537f80e952e2d6aa0ffeb30cce00f4f46e"
 dependencies = [
  "libc",
- "thiserror",
+ "thiserror 1.0.69",
  "winapi",
 ]
 
 [[package]]
 name = "filetime"
-version = "0.2.23"
+version = "0.2.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ee447700ac8aa0b2f2bd7bc4462ad686ba06baa6727ac149a2d6277f0d240fd"
+checksum = "35c0522e981e68cbfa8c3f978441a5f34b30b96e146b33cd3359176b50fe8586"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall 0.4.1",
- "windows-sys 0.52.0",
+ "libredox",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
 name = "flate2"
-version = "1.0.27"
+version = "1.0.33"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c6c98ee8095e9d1dcbf2fcc6d95acccb90d1c81db1e44725c6a984b1dbdfb010"
+checksum = "324a1be68054ef05ad64b861cc9eaf1d623d2d8cb25b4bf2cb9cdd902b4bf253"
 dependencies = [
  "crc32fast",
- "miniz_oxide",
+ "miniz_oxide 0.8.0",
 ]
 
 [[package]]
@@ -481,6 +421,12 @@ version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
 
+[[package]]
+name = "foldhash"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a0d2fde1f7b3d48b8395d5f2de76c18a528bd6a9cdde438df747bfcba3e05d6f"
+
 [[package]]
 name = "form_urlencoded"
 version = "1.2.1"
@@ -492,15 +438,15 @@ dependencies = [
 
 [[package]]
 name = "futures-core"
-version = "0.3.30"
+version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"
+checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"
 
 [[package]]
 name = "futures-executor"
-version = "0.3.30"
+version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a576fc72ae164fca6b9db127eaa9a9dda0d61316034f33a0a0d4eda41f02b01d"
+checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
 dependencies = [
  "futures-core",
  "futures-task",
@@ -509,15 +455,15 @@ dependencies = [
 
 [[package]]
 name = "futures-task"
-version = "0.3.30"
+version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "38d84fa142264698cdce1a9f9172cf383a0c82de1bddcf3092901442c4097004"
+checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"
 
 [[package]]
 name = "futures-util"
-version = "0.3.30"
+version = "0.3.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3d6401deb83407ab3da39eba7e33987a73c3df0c82b4bb5813ee871c19c41d48"
+checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
 dependencies = [
  "futures-core",
  "futures-task",
@@ -528,26 +474,38 @@ dependencies = [
 
 [[package]]
 name = "getrandom"
-version = "0.2.9"
+version = "0.2.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "wasi 0.11.0+wasi-snapshot-preview1",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c85e1d9ab2eadba7e5040d4e09cbd6d072b76a557ad64e797c2cb9d4da21d7e4"
+checksum = "43a49c392881ce6d5c3b8cb70f98717b7c07aabbdff06687b9030dbfbe2725f8"
 dependencies = [
  "cfg-if",
  "libc",
- "wasi",
+ "wasi 0.13.3+wasi-0.2.2",
+ "windows-targets 0.52.6",
 ]
 
 [[package]]
 name = "gimli"
-version = "0.27.3"
+version = "0.29.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b6c80984affa11d98d1b88b66ac8853f143217b399d3c74116778ff8fdb4ed2e"
+checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"
 
 [[package]]
 name = "gix"
-version = "0.64.0"
+version = "0.70.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d78414d29fcc82329080166077e0f7689f4016551fdb334d787c3d040fe2634f"
+checksum = "736f14636705f3a56ea52b553e67282519418d9a35bb1e90b3a9637a00296b68"
 dependencies = [
  "gix-actor",
  "gix-attributes",
@@ -567,17 +525,18 @@ dependencies = [
  "gix-ignore",
  "gix-index",
  "gix-lock",
- "gix-macros",
  "gix-object",
  "gix-odb",
  "gix-pack",
  "gix-path",
  "gix-pathspec",
+ "gix-protocol",
  "gix-ref",
  "gix-refspec",
  "gix-revision",
  "gix-revwalk",
  "gix-sec",
+ "gix-shallow",
  "gix-status",
  "gix-submodule",
  "gix-tempfile",
@@ -589,28 +548,28 @@ dependencies = [
  "gix-worktree",
  "once_cell",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-actor"
-version = "0.31.5"
+version = "0.33.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a0e454357e34b833cc3a00b6efbbd3dd4d18b24b9fb0c023876ec2645e8aa3f2"
+checksum = "20018a1a6332e065f1fcc8305c1c932c6b8c9985edea2284b3c79dc6fa3ee4b2"
 dependencies = [
  "bstr",
  "gix-date",
  "gix-utils",
  "itoa",
- "thiserror",
+ "thiserror 2.0.11",
  "winnow",
 ]
 
 [[package]]
 name = "gix-attributes"
-version = "0.22.3"
+version = "0.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e37ce99c7e81288c28b703641b6d5d119aacc45c1a6b247156e6249afa486257"
+checksum = "f151000bf662ef5f641eca6102d942ee31ace80f271a3ef642e99776ce6ddb38"
 dependencies = [
  "bstr",
  "gix-glob",
@@ -619,33 +578,33 @@ dependencies = [
  "gix-trace",
  "kstring",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
  "unicode-bom",
 ]
 
 [[package]]
 name = "gix-bitmap"
-version = "0.2.11"
+version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a371db66cbd4e13f0ed9dc4c0fea712d7276805fccc877f77e96374d317e87ae"
+checksum = "b1db9765c69502650da68f0804e3dc2b5f8ccc6a2d104ca6c85bc40700d37540"
 dependencies = [
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-chunk"
-version = "0.4.8"
+version = "0.4.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "45c8751169961ba7640b513c3b24af61aa962c967aaf04116734975cd5af0c52"
+checksum = "0b1f1d8764958699dc764e3f727cef280ff4d1bd92c107bbf8acd85b30c1bd6f"
 dependencies = [
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-command"
-version = "0.3.8"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d76867867da891cbe32021ad454e8cae90242f6afb06762e4dd0d357afd1d7b"
+checksum = "cb410b84d6575db45e62025a9118bdbf4d4b099ce7575a76161e898d9ca98df1"
 dependencies = [
  "bstr",
  "gix-path",
@@ -655,23 +614,23 @@ dependencies = [
 
 [[package]]
 name = "gix-commitgraph"
-version = "0.24.3"
+version = "0.26.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "133b06f67f565836ec0c473e2116a60fb74f80b6435e21d88013ac0e3c60fc78"
+checksum = "e23a8ec2d8a16026a10dafdb6ed51bcfd08f5d97f20fa52e200bc50cb72e4877"
 dependencies = [
  "bstr",
  "gix-chunk",
  "gix-features",
  "gix-hash",
  "memmap2",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-config"
-version = "0.38.0"
+version = "0.43.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "28f53fd03d1bf09ebcc2c8654f08969439c4556e644ca925f27cf033bc43e658"
+checksum = "377c1efd2014d5d469e0b3cd2952c8097bce9828f634e04d5665383249f1d9e9"
 dependencies = [
  "bstr",
  "gix-config-value",
@@ -683,61 +642,65 @@ dependencies = [
  "memchr",
  "once_cell",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
  "unicode-bom",
  "winnow",
 ]
 
 [[package]]
 name = "gix-config-value"
-version = "0.14.7"
+version = "0.14.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b328997d74dd15dc71b2773b162cb4af9a25c424105e4876e6d0686ab41c383e"
+checksum = "11365144ef93082f3403471dbaa94cfe4b5e72743bdb9560719a251d439f4cee"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "bstr",
  "gix-path",
  "libc",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-date"
-version = "0.8.7"
+version = "0.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9eed6931f21491ee0aeb922751bd7ec97b4b2fe8fbfedcb678e2a2dce5f3b8c0"
+checksum = "c57c477b645ee248b173bb1176b52dd528872f12c50375801a58aaf5ae91113f"
 dependencies = [
  "bstr",
  "itoa",
- "thiserror",
- "time",
+ "jiff",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-diff"
-version = "0.44.1"
+version = "0.50.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1996d5c8a305b59709467d80617c9fde48d9d75fd1f4179ea970912630886c9d"
+checksum = "62afb7f4ca0acdf4e9dad92065b2eb1bf2993bcc5014b57bc796e3a365b17c4d"
 dependencies = [
  "bstr",
+ "gix-attributes",
  "gix-command",
  "gix-filter",
  "gix-fs",
  "gix-hash",
+ "gix-index",
  "gix-object",
  "gix-path",
+ "gix-pathspec",
  "gix-tempfile",
  "gix-trace",
+ "gix-traverse",
  "gix-worktree",
  "imara-diff",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-dir"
-version = "0.6.0"
+version = "0.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c975679aa00dd2d757bfd3ddb232e8a188c0094c3306400575a0813858b1365"
+checksum = "c1d78db3927a12f7d1b788047b84efacaab03ef25738bd1c77856ad8966bd57b"
 dependencies = [
  "bstr",
  "gix-discover",
@@ -750,14 +713,14 @@ dependencies = [
  "gix-trace",
  "gix-utils",
  "gix-worktree",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-discover"
-version = "0.33.0"
+version = "0.38.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "67662731cec3cb31ba3ed2463809493f76d8e5d6c6d245de8b0560438c13450e"
+checksum = "d0c2414bdf04064e0f5a5aa029dfda1e663cf9a6c4bfc8759f2d369299bb65d8"
 dependencies = [
  "bstr",
  "dunce",
@@ -766,14 +729,14 @@ dependencies = [
  "gix-path",
  "gix-ref",
  "gix-sec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-features"
-version = "0.38.2"
+version = "0.40.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac7045ac9fe5f9c727f38799d002a7ed3583cd777e3322a7c4b43e3cf437dc69"
+checksum = "8bfdd4838a8d42bd482c9f0cb526411d003ee94cc7c7b08afe5007329c71d554"
 dependencies = [
  "crc32fast",
  "flate2",
@@ -784,15 +747,15 @@ dependencies = [
  "once_cell",
  "prodash",
  "sha1_smol",
- "thiserror",
+ "thiserror 2.0.11",
  "walkdir",
 ]
 
 [[package]]
 name = "gix-filter"
-version = "0.11.3"
+version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e6547738da28275f4dff4e9f3a0f28509f53f94dd6bd822733c91cb306bca61a"
+checksum = "bdcc36cd7dbc63ed0ec3558645886553d1afd3cd09daa5efb9cba9cceb942bbb"
 dependencies = [
  "bstr",
  "encoding_rs",
@@ -806,14 +769,14 @@ dependencies = [
  "gix-trace",
  "gix-utils",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-fs"
-version = "0.11.2"
+version = "0.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6adf99c27cdf17b1c4d77680c917e0d94d8783d4e1c73d3be0d1d63107163d7a"
+checksum = "182e7fa7bfdf44ffb7cfe7451b373cdf1e00870ac9a488a49587a110c562063d"
 dependencies = [
  "fastrand",
  "gix-features",
@@ -822,11 +785,11 @@ dependencies = [
 
 [[package]]
 name = "gix-glob"
-version = "0.16.4"
+version = "0.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa7df15afa265cc8abe92813cd354d522f1ac06b29ec6dfa163ad320575cb447"
+checksum = "4e9c7249fa0a78f9b363aa58323db71e0a6161fd69860ed6f48dedf0ef3a314e"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "bstr",
  "gix-features",
  "gix-path",
@@ -834,19 +797,19 @@ dependencies = [
 
 [[package]]
 name = "gix-hash"
-version = "0.14.2"
+version = "0.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f93d7df7366121b5018f947a04d37f034717e113dcf9ccd85c34b58e57a74d5e"
+checksum = "e81c5ec48649b1821b3ed066a44efb95f1a268b35c1d91295e61252539fbe9f8"
 dependencies = [
  "faster-hex",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-hashtable"
-version = "0.5.2"
+version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7ddf80e16f3c19ac06ce415a38b8591993d3f73aede049cb561becb5b3a8e242"
+checksum = "189130bc372accd02e0520dc5ab1cef318dcc2bc829b76ab8d84bbe90ac212d1"
 dependencies = [
  "gix-hash",
  "hashbrown 0.14.5",
@@ -855,9 +818,9 @@ dependencies = [
 
 [[package]]
 name = "gix-ignore"
-version = "0.11.3"
+version = "0.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5e6afb8f98e314d4e1adc822449389ada863c174b5707cedd327d67b84dba527"
+checksum = "4f529dcb80bf9855c0a7c49f0ac588df6d6952d63a63fefc254b9c869d2cdf6f"
 dependencies = [
  "bstr",
  "gix-glob",
@@ -868,11 +831,11 @@ dependencies = [
 
 [[package]]
 name = "gix-index"
-version = "0.33.1"
+version = "0.38.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9a9a44eb55bd84bb48f8a44980e951968ced21e171b22d115d1cdcef82a7d73f"
+checksum = "acd12e3626879369310fffe2ac61acc828613ef656b50c4ea984dd59d7dc85d8"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "bstr",
  "filetime",
  "fnv",
@@ -891,75 +854,67 @@ dependencies = [
  "memmap2",
  "rustix",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-lock"
-version = "14.0.0"
+version = "16.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3bc7fe297f1f4614774989c00ec8b1add59571dc9b024b4c00acb7dedd4e19d"
+checksum = "9739815270ff6940968441824d162df9433db19211ca9ba8c3fc1b50b849c642"
 dependencies = [
  "gix-tempfile",
  "gix-utils",
- "thiserror",
-]
-
-[[package]]
-name = "gix-macros"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "999ce923619f88194171a67fb3e6d613653b8d4d6078b529b15a765da0edcc17"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.48",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-object"
-version = "0.42.3"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "25da2f46b4e7c2fa7b413ce4dffb87f69eaf89c2057e386491f4c55cadbfe386"
+checksum = "ddc4b3a0044244f0fe22347fb7a79cca165e37829d668b41b85ff46a43e5fd68"
 dependencies = [
  "bstr",
  "gix-actor",
  "gix-date",
  "gix-features",
  "gix-hash",
+ "gix-hashtable",
+ "gix-path",
  "gix-utils",
  "gix-validate",
  "itoa",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
  "winnow",
 ]
 
 [[package]]
 name = "gix-odb"
-version = "0.61.1"
+version = "0.67.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "20d384fe541d93d8a3bb7d5d5ef210780d6df4f50c4e684ccba32665a5e3bc9b"
+checksum = "3e93457df69cd09573608ce9fa4f443fbd84bc8d15d8d83adecd471058459c1b"
 dependencies = [
  "arc-swap",
  "gix-date",
  "gix-features",
  "gix-fs",
  "gix-hash",
+ "gix-hashtable",
  "gix-object",
  "gix-pack",
  "gix-path",
  "gix-quote",
  "parking_lot",
  "tempfile",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-pack"
-version = "0.51.1"
+version = "0.57.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3e0594491fffe55df94ba1c111a6566b7f56b3f8d2e1efc750e77d572f5f5229"
+checksum = "fc13a475b3db735617017fb35f816079bf503765312d4b1913b18cf96f3fa515"
 dependencies = [
  "clru",
  "gix-chunk",
@@ -970,65 +925,96 @@ dependencies = [
  "gix-path",
  "memmap2",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
+]
+
+[[package]]
+name = "gix-packetline"
+version = "0.18.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c7e5ae6bc3ac160a6bf44a55f5537813ca3ddb08549c0fd3e7ef699c73c439cd"
+dependencies = [
+ "bstr",
+ "faster-hex",
+ "gix-trace",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-packetline-blocking"
-version = "0.17.4"
+version = "0.18.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c31d42378a3d284732e4d589979930d0d253360eccf7ec7a80332e5ccb77e14a"
+checksum = "c1cbf8767c6abd5a6779f586702b5bcd8702380f4208219449cf1c9d0cd1e17c"
 dependencies = [
  "bstr",
  "faster-hex",
  "gix-trace",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-path"
-version = "0.10.9"
+version = "0.10.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8d23d5bbda31344d8abc8de7c075b3cf26e5873feba7c4a15d916bce67382bd9"
+checksum = "c40f12bb65a8299be0cfb90fe718e3be236b7a94b434877012980863a883a99f"
 dependencies = [
  "bstr",
  "gix-trace",
  "home",
  "once_cell",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-pathspec"
-version = "0.7.6"
+version = "0.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d307d1b8f84dc8386c4aa20ce0cf09242033840e15469a3ecba92f10cfb5c046"
+checksum = "6430d3a686c08e9d59019806faa78c17315fe22ae73151a452195857ca02f86c"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "bstr",
  "gix-attributes",
  "gix-config-value",
  "gix-glob",
  "gix-path",
- "thiserror",
+ "thiserror 2.0.11",
+]
+
+[[package]]
+name = "gix-protocol"
+version = "0.48.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c61bd61afc6b67d213241e2100394c164be421e3f7228d3521b04f48ca5ba90"
+dependencies = [
+ "bstr",
+ "gix-date",
+ "gix-features",
+ "gix-hash",
+ "gix-ref",
+ "gix-shallow",
+ "gix-transport",
+ "gix-utils",
+ "maybe-async",
+ "thiserror 2.0.11",
+ "winnow",
 ]
 
 [[package]]
 name = "gix-quote"
-version = "0.4.12"
+version = "0.4.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cbff4f9b9ea3fa7a25a70ee62f545143abef624ac6aa5884344e70c8b0a1d9ff"
+checksum = "e49357fccdb0c85c0d3a3292a9f6db32d9b3535959b5471bb9624908f4a066c6"
 dependencies = [
  "bstr",
  "gix-utils",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-ref"
-version = "0.45.0"
+version = "0.50.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "636e96a0a5562715153fee098c217110c33a6f8218f08f4687ff99afde159bb5"
+checksum = "47adf4c5f933429f8554e95d0d92eee583cfe4b95d2bf665cd6fd4a1531ee20c"
 dependencies = [
  "gix-actor",
  "gix-features",
@@ -1041,43 +1027,44 @@ dependencies = [
  "gix-utils",
  "gix-validate",
  "memmap2",
- "thiserror",
+ "thiserror 2.0.11",
  "winnow",
 ]
 
 [[package]]
 name = "gix-refspec"
-version = "0.23.1"
+version = "0.28.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6868f8cd2e62555d1f7c78b784bece43ace40dd2a462daf3b588d5416e603f37"
+checksum = "59650228d8f612f68e7f7a25f517fcf386c5d0d39826085492e94766858b0a90"
 dependencies = [
  "bstr",
  "gix-hash",
  "gix-revision",
  "gix-validate",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-revision"
-version = "0.27.2"
+version = "0.32.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "01b13e43c2118c4b0537ddac7d0821ae0dfa90b7b8dbf20c711e153fb749adce"
+checksum = "3fe28bbccca55da6d66e6c6efc6bb4003c29d407afd8178380293729733e6b53"
 dependencies = [
  "bstr",
+ "gix-commitgraph",
  "gix-date",
  "gix-hash",
  "gix-object",
  "gix-revwalk",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-revwalk"
-version = "0.13.2"
+version = "0.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b030ccaab71af141f537e0225f19b9e74f25fefdba0372246b844491cab43e0"
+checksum = "d4ecb80c235b1e9ef2b99b23a81ea50dd569a88a9eb767179793269e0e616247"
 dependencies = [
  "gix-commitgraph",
  "gix-date",
@@ -1085,26 +1072,38 @@ dependencies = [
  "gix-hashtable",
  "gix-object",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-sec"
-version = "0.10.7"
+version = "0.10.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1547d26fa5693a7f34f05b4a3b59a90890972922172653bcb891ab3f09f436df"
+checksum = "d84dae13271f4313f8d60a166bf27e54c968c7c33e2ffd31c48cafe5da649875"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "gix-path",
  "libc",
  "windows-sys 0.52.0",
 ]
 
+[[package]]
+name = "gix-shallow"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ab72543011e303e52733c85bef784603ef39632ddf47f69723def52825e35066"
+dependencies = [
+ "bstr",
+ "gix-hash",
+ "gix-lock",
+ "thiserror 2.0.11",
+]
+
 [[package]]
 name = "gix-status"
-version = "0.11.0"
+version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "83f7b084cb65c3d007ce6bb479755ca13d602ca3cd91c4f08d7e59904de33736"
+checksum = "414cc1d85079d7ca32c3ab4a6479bf7e174cd251c74a82339c6cc393da3f4883"
 dependencies = [
  "bstr",
  "filetime",
@@ -1120,14 +1119,14 @@ dependencies = [
  "gix-pathspec",
  "gix-worktree",
  "portable-atomic",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-submodule"
-version = "0.12.0"
+version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0f2e0f69aa00805e39d39ec80472a7e9da20ed5d73318b27925a2cc198e854fd"
+checksum = "74972fe8d46ac8a09490ae1e843b4caf221c5b157c5ac17057e8e1c38417a3ac"
 dependencies = [
  "bstr",
  "gix-config",
@@ -1135,14 +1134,14 @@ dependencies = [
  "gix-pathspec",
  "gix-refspec",
  "gix-url",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-tempfile"
-version = "14.0.0"
+version = "16.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3b0e276cd08eb2a22e9f286a4f13a222a01be2defafa8621367515375644b99"
+checksum = "2558f423945ef24a8328c55d1fd6db06b8376b0e7013b1bb476cc4ffdf678501"
 dependencies = [
  "dashmap",
  "gix-fs",
@@ -1154,17 +1153,33 @@ dependencies = [
 
 [[package]]
 name = "gix-trace"
-version = "0.1.9"
+version = "0.1.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7c396a2036920c69695f760a65e7f2677267ccf483f25046977d87e4cb2665f7"
+
+[[package]]
+name = "gix-transport"
+version = "0.45.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f924267408915fddcd558e3f37295cc7d6a3e50f8bd8b606cee0808c3915157e"
+checksum = "11187418489477b1b5b862ae1aedbbac77e582f2c4b0ef54280f20cfe5b964d9"
+dependencies = [
+ "bstr",
+ "gix-command",
+ "gix-features",
+ "gix-packetline",
+ "gix-quote",
+ "gix-sec",
+ "gix-url",
+ "thiserror 2.0.11",
+]
 
 [[package]]
 name = "gix-traverse"
-version = "0.39.2"
+version = "0.44.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e499a18c511e71cf4a20413b743b9f5bcf64b3d9e81e9c3c6cd399eae55a8840"
+checksum = "2bec70e53896586ef32a3efa7e4427b67308531ed186bb6120fb3eca0f0d61b4"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "gix-commitgraph",
  "gix-date",
  "gix-hash",
@@ -1172,28 +1187,28 @@ dependencies = [
  "gix-object",
  "gix-revwalk",
  "smallvec",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-url"
-version = "0.27.4"
+version = "0.29.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e2eb9b35bba92ea8f0b5ab406fad3cf6b87f7929aa677ff10aa042c6da621156"
+checksum = "29218c768b53dd8f116045d87fec05b294c731a4b2bdd257eeca2084cc150b13"
 dependencies = [
  "bstr",
  "gix-features",
  "gix-path",
- "home",
- "thiserror",
+ "percent-encoding",
+ "thiserror 2.0.11",
  "url",
 ]
 
 [[package]]
 name = "gix-utils"
-version = "0.1.12"
+version = "0.1.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "35192df7fd0fa112263bad8021e2df7167df4cc2a6e6d15892e1e55621d3d4dc"
+checksum = "ff08f24e03ac8916c478c8419d7d3c33393da9bb41fa4c24455d5406aeefd35f"
 dependencies = [
  "bstr",
  "fastrand",
@@ -1202,19 +1217,19 @@ dependencies = [
 
 [[package]]
 name = "gix-validate"
-version = "0.8.5"
+version = "0.9.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "82c27dd34a49b1addf193c92070bcbf3beaf6e10f16a78544de6372e146a0acf"
+checksum = "9eaa01c3337d885617c0a42e92823922a2aea71f4caeace6fe87002bdcadbd90"
 dependencies = [
  "bstr",
- "thiserror",
+ "thiserror 2.0.11",
 ]
 
 [[package]]
 name = "gix-worktree"
-version = "0.34.1"
+version = "0.39.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26f7326ebe0b9172220694ea69d344c536009a9b98fb0f9de092c440f3efe7a6"
+checksum = "6673512f7eaa57a6876adceca6978a501d6c6569a4f177767dc405f8b9778958"
 dependencies = [
  "bstr",
  "gix-attributes",
@@ -1231,9 +1246,9 @@ dependencies = [
 
 [[package]]
 name = "globset"
-version = "0.4.14"
+version = "0.4.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "57da3b9b5b85bd66f31093f8c408b90a74431672542466497dcbdfdc02034be1"
+checksum = "15f1ce686646e7f1e19bf7d5533fe443a45dbfb990e00629110797578b42fb19"
 dependencies = [
  "aho-corasick",
  "bstr",
@@ -1253,9 +1268,9 @@ dependencies = [
 
 [[package]]
 name = "grep-regex"
-version = "0.1.12"
+version = "0.1.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f748bb135ca835da5cbc67ca0e6955f968db9c5df74ca4f56b18e1ddbc68230d"
+checksum = "9edd147c7e3296e7a26bd3a81345ce849557d5a8e48ed88f736074e760f91f7e"
 dependencies = [
  "bstr",
  "grep-matcher",
@@ -1266,9 +1281,9 @@ dependencies = [
 
 [[package]]
 name = "grep-searcher"
-version = "0.1.13"
+version = "0.1.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ba536ae4f69bec62d8839584dd3153d3028ef31bb229f04e09fb5a9e5a193c54"
+checksum = "b9b6c14b3fc2e0a107d6604d3231dec0509e691e62447104bc385a46a7892cda"
 dependencies = [
  "bstr",
  "encoding_rs",
@@ -1279,12 +1294,6 @@ dependencies = [
  "memmap2",
 ]
 
-[[package]]
-name = "hashbrown"
-version = "0.12.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
-
 [[package]]
 name = "hashbrown"
 version = "0.14.5"
@@ -1295,13 +1304,23 @@ dependencies = [
  "allocator-api2",
 ]
 
+[[package]]
+name = "hashbrown"
+version = "0.15.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
+dependencies = [
+ "foldhash",
+]
+
 [[package]]
 name = "helix-core"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "ahash",
+ "anyhow",
  "arc-swap",
- "bitflags 2.6.0",
+ "bitflags",
  "chrono",
  "dunce",
  "encoding_rs",
@@ -1309,6 +1328,7 @@ dependencies = [
  "globset",
  "hashbrown 0.14.5",
  "helix-loader",
+ "helix-parsec",
  "helix-stdx",
  "imara-diff",
  "indoc",
@@ -1318,6 +1338,7 @@ dependencies = [
  "parking_lot",
  "quickcheck",
  "regex",
+ "regex-cursor",
  "ropey",
  "serde",
  "serde_json",
@@ -1335,7 +1356,7 @@ dependencies = [
 
 [[package]]
 name = "helix-dap"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "fern",
@@ -1344,13 +1365,13 @@ dependencies = [
  "log",
  "serde",
  "serde_json",
- "thiserror",
+ "thiserror 2.0.11",
  "tokio",
 ]
 
 [[package]]
 name = "helix-event"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "ahash",
  "anyhow",
@@ -1364,7 +1385,7 @@ dependencies = [
 
 [[package]]
 name = "helix-loader"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "cc",
@@ -1383,7 +1404,7 @@ dependencies = [
 
 [[package]]
 name = "helix-lsp"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "arc-swap",
@@ -1400,7 +1421,7 @@ dependencies = [
  "serde",
  "serde_json",
  "slotmap",
- "thiserror",
+ "thiserror 2.0.11",
  "tokio",
  "tokio-stream",
 ]
@@ -1409,7 +1430,7 @@ dependencies = [
 name = "helix-lsp-types"
 version = "0.95.1"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "serde",
  "serde_json",
  "serde_repr",
@@ -1418,26 +1439,29 @@ dependencies = [
 
 [[package]]
 name = "helix-parsec"
-version = "24.7.0"
+version = "25.1.1"
 
 [[package]]
 name = "helix-stdx"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "dunce",
  "etcetera",
+ "once_cell",
+ "regex-automata",
  "regex-cursor",
  "ropey",
  "rustix",
  "tempfile",
+ "unicode-segmentation",
  "which",
  "windows-sys 0.59.0",
 ]
 
 [[package]]
 name = "helix-term"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "arc-swap",
@@ -1458,6 +1482,7 @@ dependencies = [
  "helix-vcs",
  "helix-view",
  "ignore",
+ "indexmap",
  "indoc",
  "libc",
  "log",
@@ -1473,7 +1498,7 @@ dependencies = [
  "smallvec",
  "tempfile",
  "termini",
- "thiserror",
+ "thiserror 2.0.11",
  "tokio",
  "tokio-stream",
  "toml",
@@ -1482,9 +1507,9 @@ dependencies = [
 
 [[package]]
 name = "helix-tui"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "cassowary",
  "crossterm",
  "helix-core",
@@ -1498,7 +1523,7 @@ dependencies = [
 
 [[package]]
 name = "helix-vcs"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "arc-swap",
@@ -1514,11 +1539,11 @@ dependencies = [
 
 [[package]]
 name = "helix-view"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "anyhow",
  "arc-swap",
- "bitflags 2.6.0",
+ "bitflags",
  "chardetng",
  "clipboard-win",
  "crossterm",
@@ -1540,22 +1565,13 @@ dependencies = [
  "serde_json",
  "slotmap",
  "tempfile",
- "thiserror",
+ "thiserror 2.0.11",
  "tokio",
  "tokio-stream",
  "toml",
  "url",
 ]
 
-[[package]]
-name = "hermit-abi"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7"
-dependencies = [
- "libc",
-]
-
 [[package]]
 name = "hermit-abi"
 version = "0.3.9"
@@ -1573,159 +1589,319 @@ dependencies = [
 
 [[package]]
 name = "iana-time-zone"
-version = "0.1.56"
+version = "0.1.60"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0722cd7114b7de04316e7ea5456a0bbb20e4adb46fd27a3697adb812cff0f37c"
+checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
  "iana-time-zone-haiku",
  "js-sys",
  "wasm-bindgen",
- "windows",
+ "windows-core",
 ]
 
 [[package]]
 name = "iana-time-zone-haiku"
-version = "0.1.1"
+version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0703ae284fc167426161c2e3f1da3ea71d94b21bedbcc9494e92b28e334e3dca"
+checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
 dependencies = [
- "cxx",
- "cxx-build",
+ "cc",
 ]
 
 [[package]]
-name = "idna"
-version = "0.5.0"
+name = "icu_collections"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
+checksum = "db2fa452206ebee18c4b5c2274dbf1de17008e874b4dc4f0aea9d01ca79e4526"
 dependencies = [
- "unicode-bidi",
- "unicode-normalization",
+ "displaydoc",
+ "yoke",
+ "zerofrom",
+ "zerovec",
 ]
 
 [[package]]
-name = "ignore"
-version = "0.4.22"
+name = "icu_locid"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b46810df39e66e925525d6e38ce1e7f6e1d208f72dc39757880fcb66e2c58af1"
+checksum = "13acbb8371917fc971be86fc8057c41a64b521c184808a698c02acc242dbf637"
 dependencies = [
- "crossbeam-deque",
- "globset",
- "log",
- "memchr",
- "regex-automata",
- "same-file",
- "walkdir",
- "winapi-util",
+ "displaydoc",
+ "litemap",
+ "tinystr",
+ "writeable",
+ "zerovec",
 ]
 
 [[package]]
-name = "imara-diff"
-version = "0.1.7"
+name = "icu_locid_transform"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fc9da1a252bd44cd341657203722352efc9bc0c847d06ea6d2dc1cd1135e0a01"
+checksum = "01d11ac35de8e40fdeda00d9e1e9d92525f3f9d887cdd7aa81d727596788b54e"
 dependencies = [
- "ahash",
- "hashbrown 0.14.5",
+ "displaydoc",
+ "icu_locid",
+ "icu_locid_transform_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
 ]
 
 [[package]]
-name = "indexmap"
-version = "2.0.0"
+name = "icu_locid_transform_data"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d"
-dependencies = [
- "equivalent",
- "hashbrown 0.14.5",
-]
+checksum = "fdc8ff3388f852bede6b579ad4e978ab004f139284d7b28715f773507b946f6e"
 
 [[package]]
-name = "indoc"
-version = "2.0.5"
+name = "icu_normalizer"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b248f5224d1d606005e02c97f5aa4e88eeb230488bcc03bc9ca4d7991399f2b5"
+checksum = "19ce3e0da2ec68599d193c93d088142efd7f9c5d6fc9b803774855747dc6a84f"
+dependencies = [
+ "displaydoc",
+ "icu_collections",
+ "icu_normalizer_data",
+ "icu_properties",
+ "icu_provider",
+ "smallvec",
+ "utf16_iter",
+ "utf8_iter",
+ "write16",
+ "zerovec",
+]
 
 [[package]]
-name = "is-docker"
-version = "0.2.0"
+name = "icu_normalizer_data"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "928bae27f42bc99b60d9ac7334e3a21d10ad8f1835a4e12ec3ec0464765ed1b3"
-dependencies = [
- "once_cell",
-]
+checksum = "f8cafbf7aa791e9b22bec55a167906f9e1215fd475cd22adfcf660e03e989516"
 
 [[package]]
-name = "is-wsl"
-version = "0.4.0"
+name = "icu_properties"
+version = "1.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "173609498df190136aa7dea1a91db051746d339e18476eed5ca40521f02d7aa5"
+checksum = "93d6020766cfc6302c15dbbc9c8778c37e62c14427cb7f6e601d849e092aeef5"
 dependencies = [
- "is-docker",
- "once_cell",
+ "displaydoc",
+ "icu_collections",
+ "icu_locid_transform",
+ "icu_properties_data",
+ "icu_provider",
+ "tinystr",
+ "zerovec",
 ]
 
 [[package]]
-name = "itoa"
-version = "1.0.6"
+name = "icu_properties_data"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6"
+checksum = "67a8effbc3dd3e4ba1afa8ad918d5684b8868b3b26500753effea8d2eed19569"
 
 [[package]]
-name = "js-sys"
-version = "0.3.61"
+name = "icu_provider"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "445dde2150c55e483f3d8416706b97ec8e8237c307e5b7b4b8dd15e6af2a0730"
+checksum = "6ed421c8a8ef78d3e2dbc98a973be2f3770cb42b606e3ab18d6237c4dfde68d9"
 dependencies = [
- "wasm-bindgen",
+ "displaydoc",
+ "icu_locid",
+ "icu_provider_macros",
+ "stable_deref_trait",
+ "tinystr",
+ "writeable",
+ "yoke",
+ "zerofrom",
+ "zerovec",
 ]
 
 [[package]]
-name = "kstring"
-version = "2.0.0"
+name = "icu_provider_macros"
+version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec3066350882a1cd6d950d055997f379ac37fd39f81cd4d8ed186032eb3c5747"
+checksum = "1ec89e9337638ecdc08744df490b221a7399bf8d164eb52a665454e60e075ad6"
 dependencies = [
- "static_assertions",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
-name = "libc"
-version = "0.2.158"
+name = "idna"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "686f825264d630750a544639377bae737628043f20d38bbc029e8f29ea968a7e"
+dependencies = [
+ "idna_adapter",
+ "smallvec",
+ "utf8_iter",
+]
+
+[[package]]
+name = "idna_adapter"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "daca1df1c957320b2cf139ac61e7bd64fed304c5040df000a745aa1de3b4ef71"
+dependencies = [
+ "icu_normalizer",
+ "icu_properties",
+]
+
+[[package]]
+name = "ignore"
+version = "0.4.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d89fd380afde86567dfba715db065673989d6253f42b88179abd3eae47bda4b"
+dependencies = [
+ "crossbeam-deque",
+ "globset",
+ "log",
+ "memchr",
+ "regex-automata",
+ "same-file",
+ "walkdir",
+ "winapi-util",
+]
+
+[[package]]
+name = "imara-diff"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17d34b7d42178945f775e84bc4c36dde7c1c6cdfea656d3354d009056f2bb3d2"
+dependencies = [
+ "hashbrown 0.15.2",
+]
+
+[[package]]
+name = "indexmap"
+version = "2.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8c9c992b02b5b4c94ea26e32fe5bccb7aa7d9f390ab5c1221ff895bc7ea8b652"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.15.2",
+]
+
+[[package]]
+name = "indoc"
+version = "2.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b248f5224d1d606005e02c97f5aa4e88eeb230488bcc03bc9ca4d7991399f2b5"
+
+[[package]]
+name = "is-docker"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "928bae27f42bc99b60d9ac7334e3a21d10ad8f1835a4e12ec3ec0464765ed1b3"
+dependencies = [
+ "once_cell",
+]
+
+[[package]]
+name = "is-wsl"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "173609498df190136aa7dea1a91db051746d339e18476eed5ca40521f02d7aa5"
+dependencies = [
+ "is-docker",
+ "once_cell",
+]
+
+[[package]]
+name = "itoa"
+version = "1.0.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"
+
+[[package]]
+name = "jiff"
+version = "0.1.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8a45489186a6123c128fdf6016183fcfab7113e1820eb813127e036e287233fb"
+dependencies = [
+ "jiff-tzdb-platform",
+ "windows-sys 0.59.0",
+]
+
+[[package]]
+name = "jiff-tzdb"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91335e575850c5c4c673b9bd467b0e025f164ca59d0564f69d0c2ee0ffad4653"
+
+[[package]]
+name = "jiff-tzdb-platform"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9835f0060a626fe59f160437bc725491a6af23133ea906500027d1bd2f8f4329"
+dependencies = [
+ "jiff-tzdb",
+]
+
+[[package]]
+name = "js-sys"
+version = "0.3.70"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a"
+dependencies = [
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "kstring"
+version = "2.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d8adc4bb1803a324070e64a98ae98f38934d91957a99cfb3a43dcbc01bc56439"
+checksum = "558bf9508a558512042d3095138b1f7b8fe90c5467d94f9f1da28b3731c5dbd1"
+dependencies = [
+ "static_assertions",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.169"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b5aba8db14291edd000dfcc4d620c7ebfb122c613afb886ca8803fa4e128a20a"
 
 [[package]]
 name = "libloading"
-version = "0.8.5"
+version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4979f22fdb869068da03c9f7528f8297c6fd2606bc3a4affe42e6a823fdb8da4"
+checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
 dependencies = [
  "cfg-if",
  "windows-targets 0.52.6",
 ]
 
 [[package]]
-name = "link-cplusplus"
-version = "1.0.8"
+name = "libredox"
+version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ecd207c9c713c34f95a097a5b029ac2ce6010530c7b49d7fea24d977dede04f5"
+checksum = "c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d"
 dependencies = [
- "cc",
+ "bitflags",
+ "libc",
+ "redox_syscall",
 ]
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.4.12"
+version = "0.4.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4cd1a83af159aa67994778be9070f0ae1bd732942279cabb14f86f986a21456"
+checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"
+
+[[package]]
+name = "litemap"
+version = "0.7.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "643cb0b8d4fcc284004d5fd0d67ccf61dfffadb7f75e1e71bc420f4688a3a704"
 
 [[package]]
 name = "lock_api"
-version = "0.4.9"
+version = "0.4.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df"
+checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
 dependencies = [
  "autocfg",
  "scopeguard",
@@ -1733,53 +1909,64 @@ dependencies = [
 
 [[package]]
 name = "log"
-version = "0.4.22"
+version = "0.4.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"
+checksum = "04cbf5b083de1c7e0222a7a51dbfdba1cbe1c6ab0b15e29fff3f6c077fd9cd9f"
+
+[[package]]
+name = "maybe-async"
+version = "0.2.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5cf92c10c7e361d6b99666ec1c6f9805b0bea2c3bd8c78dc6fe98ac5bd78db11"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
 
 [[package]]
 name = "memchr"
-version = "2.6.3"
+version = "2.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f232d6ef707e1956a43342693d2a31e72989554d58299d7a88738cc95b0d35c"
+checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"
 
 [[package]]
 name = "memmap2"
-version = "0.9.0"
+version = "0.9.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "deaba38d7abf1d4cca21cc89e932e542ba2b9258664d2a9ef0e61512039c9375"
+checksum = "fe751422e4a8caa417e13c3ea66452215d7d63e19e604f4980461212f3ae1322"
 dependencies = [
  "libc",
 ]
 
 [[package]]
-name = "memoffset"
-version = "0.9.0"
+name = "miniz_oxide"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
+checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
 dependencies = [
- "autocfg",
+ "adler",
 ]
 
 [[package]]
 name = "miniz_oxide"
-version = "0.7.1"
+version = "0.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
+checksum = "e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1"
 dependencies = [
- "adler",
+ "adler2",
 ]
 
 [[package]]
 name = "mio"
-version = "1.0.1"
+version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4569e456d394deccd22ce1c1913e6ea0e54519f577285001215d33557431afe4"
+checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
 dependencies = [
- "hermit-abi 0.3.9",
+ "hermit-abi",
  "libc",
  "log",
- "wasi",
+ "wasi 0.11.0+wasi-snapshot-preview1",
  "windows-sys 0.52.0",
 ]
 
@@ -1804,60 +1991,45 @@ dependencies = [
  "unicode-segmentation",
 ]
 
-[[package]]
-name = "num-conv"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
-
 [[package]]
 name = "num-traits"
-version = "0.2.15"
+version = "0.2.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
+checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
 dependencies = [
  "autocfg",
 ]
 
 [[package]]
 name = "num_cpus"
-version = "1.15.0"
+version = "1.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b"
-dependencies = [
- "hermit-abi 0.2.6",
- "libc",
-]
-
-[[package]]
-name = "num_threads"
-version = "0.1.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2819ce041d2ee131036f4fc9d6ae7ae125a3a40e97ba64d04fe799ad9dabbb44"
+checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
 dependencies = [
+ "hermit-abi",
  "libc",
 ]
 
 [[package]]
 name = "object"
-version = "0.31.1"
+version = "0.36.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8bda667d9f2b5051b8833f59f3bf748b28ef54f850f4fcb389a252aa383866d1"
+checksum = "084f1a5821ac4c651660a94a7153d27ac9d8a53736203f58b31945ded098070a"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "once_cell"
-version = "1.19.0"
+version = "1.20.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
+checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"
 
 [[package]]
 name = "open"
-version = "5.3.0"
+version = "5.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "61a877bf6abd716642a53ef1b89fb498923a4afca5c754f9050b4d081c05c4b3"
+checksum = "e2483562e62ea94312f3576a7aca397306df7990b8d89033e18766744377ef95"
 dependencies = [
  "is-wsl",
  "libc",
@@ -1876,15 +2048,15 @@ dependencies = [
 
 [[package]]
 name = "parking_lot_core"
-version = "0.9.7"
+version = "0.9.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9069cbb9f99e3a5083476ccb29ceb1de18b9118cafa53e90c9551235de2b9521"
+checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall 0.2.16",
+ "redox_syscall",
  "smallvec",
- "windows-sys 0.45.0",
+ "windows-targets 0.52.6",
 ]
 
 [[package]]
@@ -1901,9 +2073,9 @@ checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
 
 [[package]]
 name = "pin-project-lite"
-version = "0.2.12"
+version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12cc1b0bf1727a77a54b6654e7b5f1af8604923edc8b81885f8ec92f9e3f0a05"
+checksum = "bda66fc9667c18cb2758a2ac84d1167245054bcf85d5d1aaa6923f45801bdd02"
 
 [[package]]
 name = "pin-utils"
@@ -1917,34 +2089,32 @@ version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "da544ee218f0d287a911e9c99a39a8c9bc8fcad3cb8db5959940044ecfc67265"
 
-[[package]]
-name = "powerfmt"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
-
 [[package]]
 name = "proc-macro2"
-version = "1.0.76"
+version = "1.0.86"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "95fc56cda0b5c3325f5fbbd7ff9fda9e02bb00bb3dac51252d2f1bfa1cb8cc8c"
+checksum = "5e719e8df665df0d1c8fbfd238015744736151d4445ec0836b8e628aae103b77"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "prodash"
-version = "28.0.0"
+version = "29.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "744a264d26b88a6a7e37cbad97953fa233b94d585236310bcbc88474b4092d79"
+checksum = "a266d8d6020c61a437be704c5e618037588e1985c7dbb7bf8d265db84cffe325"
+dependencies = [
+ "log",
+ "parking_lot",
+]
 
 [[package]]
 name = "pulldown-cmark"
-version = "0.12.0"
+version = "0.12.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4d31cbfcd94884c3a67ec210c83efb06cb43674043458b0ad59f6947f8462c23"
+checksum = "f86ba2052aebccc42cbbb3ed234b8b13ce76f75c3551a303cb2bcffcff12bb14"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "memchr",
  "unicase",
 ]
@@ -1960,9 +2130,9 @@ dependencies = [
 
 [[package]]
 name = "quote"
-version = "1.0.35"
+version = "1.0.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
+checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
 dependencies = [
  "proc-macro2",
 ]
@@ -1982,14 +2152,14 @@ version = "0.6.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
 dependencies = [
- "getrandom",
+ "getrandom 0.2.15",
 ]
 
 [[package]]
 name = "rayon"
-version = "1.7.0"
+version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b"
+checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
 dependencies = [
  "either",
  "rayon-core",
@@ -1997,39 +2167,28 @@ dependencies = [
 
 [[package]]
 name = "rayon-core"
-version = "1.11.0"
+version = "1.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d"
+checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
 dependencies = [
- "crossbeam-channel",
  "crossbeam-deque",
  "crossbeam-utils",
- "num_cpus",
 ]
 
 [[package]]
 name = "redox_syscall"
-version = "0.2.16"
+version = "0.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
+checksum = "2a908a6e00f1fdd0dfd9c0eb08ce85126f6d8bbda50017e74bc4a4b7d4a926a4"
 dependencies = [
- "bitflags 1.3.2",
-]
-
-[[package]]
-name = "redox_syscall"
-version = "0.4.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
-dependencies = [
- "bitflags 1.3.2",
+ "bitflags",
 ]
 
 [[package]]
 name = "regex"
-version = "1.10.6"
+version = "1.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4219d74c6b67a3654a9fbebc4b419e22126d13d2f3c4a07ee0cb61ff79a79619"
+checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -2039,9 +2198,9 @@ dependencies = [
 
 [[package]]
 name = "regex-automata"
-version = "0.4.5"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5bb987efffd3c6d0d8f5f89510bb458559eab11e4f869acb20bf845e016259cd"
+checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -2063,9 +2222,9 @@ dependencies = [
 
 [[package]]
 name = "regex-syntax"
-version = "0.8.2"
+version = "0.8.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"
+checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
 
 [[package]]
 name = "ropey"
@@ -2079,28 +2238,28 @@ dependencies = [
 
 [[package]]
 name = "rustc-demangle"
-version = "0.1.23"
+version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
+checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"
 
 [[package]]
 name = "rustix"
-version = "0.38.34"
+version = "0.38.44"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
+checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
 dependencies = [
- "bitflags 2.6.0",
+ "bitflags",
  "errno",
  "libc",
  "linux-raw-sys",
- "windows-sys 0.52.0",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
 name = "ryu"
-version = "1.0.13"
+version = "1.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041"
+checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"
 
 [[package]]
 name = "same-file"
@@ -2113,41 +2272,35 @@ dependencies = [
 
 [[package]]
 name = "scopeguard"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
-
-[[package]]
-name = "scratch"
-version = "1.0.5"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1792db035ce95be60c3f8853017b3999209281c24e2ba5bc8e59bf97a0c590c1"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
 
 [[package]]
 name = "serde"
-version = "1.0.208"
+version = "1.0.217"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cff085d2cb684faa248efb494c39b68e522822ac0de72ccf08109abde717cfb2"
+checksum = "02fc4265df13d6fa1d00ecff087228cc0a2b5f3c0e87e258d8b94a156e984c70"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.208"
+version = "1.0.217"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "24008e81ff7613ed8e5ba0cfaf24e2c2f1e5b8a0495711e44fcd4882fca62bcf"
+checksum = "5a9bf7cf98d04a2b28aead066b7496853d4779c9cc183c440dbac457641e19a0"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.125"
+version = "1.0.138"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "83c8e735a073ccf5be70aa8066aa984eaf2fa000db6c8d0100ae605b366d31ed"
+checksum = "d434192e7da787e94a6ea7e9670b26a036d0ca41e0b7efb2676dd32bae872949"
 dependencies = [
  "itoa",
  "memchr",
@@ -2163,7 +2316,7 @@ checksum = "6c64451ba24fc7a6a2d60fc75dd9c83c90903b19028d4eff35e88fc1e86564e9"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn",
 ]
 
 [[package]]
@@ -2177,9 +2330,9 @@ dependencies = [
 
 [[package]]
 name = "sha1_smol"
-version = "1.0.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ae1a47186c03a32177042e55dbc5fd5aee900b8e0069a8d70fba96a9375cd012"
+checksum = "bbfa15b3dddfee50a0fff136974b3e1bde555604ba463834a7eb7deb6417705d"
 
 [[package]]
 name = "shell-words"
@@ -2216,9 +2369,9 @@ dependencies = [
 
 [[package]]
 name = "signal-hook-registry"
-version = "1.4.1"
+version = "1.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
+checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
 dependencies = [
  "libc",
 ]
@@ -2237,9 +2390,9 @@ dependencies = [
 
 [[package]]
 name = "slab"
-version = "0.4.8"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
+checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
 dependencies = [
  "autocfg",
 ]
@@ -2272,20 +2425,26 @@ dependencies = [
 
 [[package]]
 name = "smawk"
-version = "0.3.1"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f67ad224767faa3c7d8b6d91985b78e70a1324408abcb1cfcc2be4c06bc06043"
+checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"
 
 [[package]]
 name = "socket2"
-version = "0.5.5"
+version = "0.5.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b5fac59a5cb5dd637972e5fca70daf0523c9067fcdc4842f053dae04a18f8e9"
+checksum = "ce305eb0b4296696835b71df73eb912e0f1ffd2556a501fcede6e0c50349191c"
 dependencies = [
  "libc",
- "windows-sys 0.48.0",
+ "windows-sys 0.52.0",
 ]
 
+[[package]]
+name = "stable_deref_trait"
+version = "1.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
+
 [[package]]
 name = "static_assertions"
 version = "1.1.0"
@@ -2294,15 +2453,15 @@ checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"
 
 [[package]]
 name = "str_indices"
-version = "0.4.1"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f026164926842ec52deb1938fae44f83dfdb82d0a5b0270c5bd5935ab74d6dd"
+checksum = "e9557cb6521e8d009c51a8666f09356f4b817ba9ba0981a305bd86aee47bd35c"
 
 [[package]]
 name = "syn"
-version = "1.0.109"
+version = "2.0.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+checksum = "25aa4ce346d03a6dcd68dd8b4010bcb74e54e62c90c573f394c46eae99aba32d"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -2310,38 +2469,30 @@ dependencies = [
 ]
 
 [[package]]
-name = "syn"
-version = "2.0.48"
+name = "synstructure"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0f3531638e407dfc0814761abb7c00a5b54992b849452a0646b7f65c9f770f3f"
+checksum = "c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971"
 dependencies = [
  "proc-macro2",
  "quote",
- "unicode-ident",
+ "syn",
 ]
 
 [[package]]
 name = "tempfile"
-version = "3.12.0"
+version = "3.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "04cbcdd0c794ebb0d4cf35e88edd2f7d2c4c3e9a5a6dab322839b321c6a87a64"
+checksum = "38c246215d7d24f48ae091a2902398798e05d978b24315d6efbc00ede9a8bb91"
 dependencies = [
  "cfg-if",
  "fastrand",
+ "getrandom 0.3.1",
  "once_cell",
  "rustix",
  "windows-sys 0.59.0",
 ]
 
-[[package]]
-name = "termcolor"
-version = "1.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
-dependencies = [
- "winapi-util",
-]
-
 [[package]]
 name = "termini"
 version = "1.0.0"
@@ -2364,71 +2515,68 @@ dependencies = [
 
 [[package]]
 name = "thiserror"
-version = "1.0.63"
+version = "1.0.69"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c0342370b38b6a11b6cc11d6a805569958d54cfa061a29969c3b5ce2ea405724"
+checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
 dependencies = [
- "thiserror-impl",
+ "thiserror-impl 1.0.69",
 ]
 
 [[package]]
-name = "thiserror-impl"
-version = "1.0.63"
+name = "thiserror"
+version = "2.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4558b58466b9ad7ca0f102865eccc95938dca1a74a856f2b57b6629050da261"
+checksum = "d452f284b73e6d76dd36758a0c8684b1d5be31f92b89d07fd5822175732206fc"
 dependencies = [
- "proc-macro2",
- "quote",
- "syn 2.0.48",
+ "thiserror-impl 2.0.11",
 ]
 
 [[package]]
-name = "threadpool"
-version = "1.8.1"
+name = "thiserror-impl"
+version = "1.0.69"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa"
+checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
 dependencies = [
- "num_cpus",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
-name = "time"
-version = "0.3.36"
+name = "thiserror-impl"
+version = "2.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885"
+checksum = "26afc1baea8a989337eeb52b6e72a039780ce45c3edfcc9c5b9d112feeb173c2"
 dependencies = [
- "deranged",
- "itoa",
- "libc",
- "num-conv",
- "num_threads",
- "powerfmt",
- "serde",
- "time-core",
- "time-macros",
+ "proc-macro2",
+ "quote",
+ "syn",
 ]
 
 [[package]]
-name = "time-core"
-version = "0.1.2"
+name = "threadpool"
+version = "1.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"
+checksum = "d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa"
+dependencies = [
+ "num_cpus",
+]
 
 [[package]]
-name = "time-macros"
-version = "0.2.18"
+name = "tinystr"
+version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf"
+checksum = "9117f5d4db391c1cf6927e7bea3db74b9a1c1add8f7eda9ffd5364f40f57b82f"
 dependencies = [
- "num-conv",
- "time-core",
+ "displaydoc",
+ "zerovec",
 ]
 
 [[package]]
 name = "tinyvec"
-version = "1.6.0"
+version = "1.8.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
+checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
 dependencies = [
  "tinyvec_macros",
 ]
@@ -2441,9 +2589,9 @@ checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.39.3"
+version = "1.43.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9babc99b9923bfa4804bd74722ff02c0381021eafa4db9949217e3be8e84fff5"
+checksum = "3d61fa4ffa3de412bfea335c6ecff681de2b609ba3c77ef3e00e521813a9ed9e"
 dependencies = [
  "backtrace",
  "bytes",
@@ -2459,20 +2607,20 @@ dependencies = [
 
 [[package]]
 name = "tokio-macros"
-version = "2.4.0"
+version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
+checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn",
 ]
 
 [[package]]
 name = "tokio-stream"
-version = "0.1.15"
+version = "0.1.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "267ac89e0bec6e691e5813911606935d77c476ff49024f98abcea3e7b15e37af"
+checksum = "eca58d7bba4a75707817a2c44174253f9236b2d5fbd055602e9d5c07c139a047"
 dependencies = [
  "futures-core",
  "pin-project-lite",
@@ -2525,36 +2673,30 @@ dependencies = [
 
 [[package]]
 name = "unicase"
-version = "2.6.0"
+version = "2.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6"
+checksum = "f7d2d4dafb69621809a81864c9c1b864479e1235c0dd4e199924b9742439ed89"
 dependencies = [
  "version_check",
 ]
 
-[[package]]
-name = "unicode-bidi"
-version = "0.3.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75"
-
 [[package]]
 name = "unicode-bom"
-version = "2.0.2"
+version = "2.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "98e90c70c9f0d4d1ee6d0a7d04aa06cb9bbd53d8cfbdd62a0269a7c2eb640552"
+checksum = "7eec5d1121208364f6793f7d2e222bf75a915c19557537745b195b253dd64217"
 
 [[package]]
 name = "unicode-general-category"
-version = "0.6.0"
+version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2281c8c1d221438e373249e065ca4989c4c36952c211ff21a0ee91c44a3869e7"
+checksum = "24adfe8311434967077a6adff125729161e6e4934d76f6b7c55318ac5c9246d3"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.8"
+version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4"
+checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
 
 [[package]]
 name = "unicode-linebreak"
@@ -2564,18 +2706,18 @@ checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"
 
 [[package]]
 name = "unicode-normalization"
-version = "0.1.22"
+version = "0.1.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
+checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
 dependencies = [
  "tinyvec",
 ]
 
 [[package]]
 name = "unicode-segmentation"
-version = "1.11.0"
+version = "1.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"
+checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"
 
 [[package]]
 name = "unicode-width"
@@ -2585,9 +2727,9 @@ checksum = "68f5e5f3158ecfd4b8ff6fe086db7c8467a2dfdac97fe420f2b7c4aa97af66d6"
 
 [[package]]
 name = "url"
-version = "2.5.2"
+version = "2.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "22784dbdf76fdde8af1aeda5622b546b422b6fc585325248a2bf9f5e41e94d6c"
+checksum = "32f8b686cadd1473f4bd0117a5d28d36b1ade384ea9b5069a1c40aefed7fda60"
 dependencies = [
  "form_urlencoded",
  "idna",
@@ -2595,17 +2737,29 @@ dependencies = [
  "serde",
 ]
 
+[[package]]
+name = "utf16_iter"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c8232dd3cdaed5356e0f716d285e4b40b932ac434100fe9b7e0e8e935b9e6246"
+
+[[package]]
+name = "utf8_iter"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"
+
 [[package]]
 name = "version_check"
-version = "0.9.4"
+version = "0.9.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
+checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"
 
 [[package]]
 name = "walkdir"
-version = "2.4.0"
+version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d71d857dc86794ca4c280d616f7da00d2dbfd8cd788846559a6813e6aa4b54ee"
+checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
 dependencies = [
  "same-file",
  "winapi-util",
@@ -2617,36 +2771,46 @@ version = "0.11.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
+[[package]]
+name = "wasi"
+version = "0.13.3+wasi-0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "26816d2e1a4a36a2940b96c5296ce403917633dff8f3440e9b236ed6f6bacad2"
+dependencies = [
+ "wit-bindgen-rt",
+]
+
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.84"
+version = "0.2.93"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "31f8dcbc21f30d9b8f2ea926ecb58f6b91192c17e9d33594b3df58b2007ca53b"
+checksum = "a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5"
 dependencies = [
  "cfg-if",
+ "once_cell",
  "wasm-bindgen-macro",
 ]
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.84"
+version = "0.2.93"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "95ce90fd5bcc06af55a641a86428ee4229e44e07033963a2290a8e241607ccb9"
+checksum = "9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.84"
+version = "0.2.93"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c21f77c0bedc37fd5dc21f897894a5ca01e7bb159884559461862ae90c0b4c5"
+checksum = "585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -2654,31 +2818,31 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.84"
+version = "0.2.93"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2aff81306fcac3c7515ad4e177f521b5c9a15f2b08f4e32d823066102f35a5f6"
+checksum = "afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 1.0.109",
+ "syn",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.84"
+version = "0.2.93"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0046fef7e28c3804e5e38bfa31ea2a0f73905319b677e57ebe37e49358989b5d"
+checksum = "c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484"
 
 [[package]]
 name = "which"
-version = "6.0.3"
+version = "7.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b4ee928febd44d98f2f459a4a79bd4d928591333a494a10a868418ac1b39cf1f"
+checksum = "fb4a9e33648339dc1642b0e36e21b3385e6148e289226f657c809dee59df5028"
 dependencies = [
  "either",
- "home",
+ "env_home",
  "rustix",
  "winsafe",
 ]
@@ -2701,11 +2865,11 @@ checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
 
 [[package]]
 name = "winapi-util"
-version = "0.1.5"
+version = "0.1.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
+checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
 dependencies = [
- "winapi",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
@@ -2715,21 +2879,12 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
-name = "windows"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
-dependencies = [
- "windows-targets 0.48.0",
-]
-
-[[package]]
-name = "windows-sys"
-version = "0.45.0"
+name = "windows-core"
+version = "0.52.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
+checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
 dependencies = [
- "windows-targets 0.42.2",
+ "windows-targets 0.52.6",
 ]
 
 [[package]]
@@ -2738,7 +2893,7 @@ version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
 dependencies = [
- "windows-targets 0.48.0",
+ "windows-targets 0.48.5",
 ]
 
 [[package]]
@@ -2761,32 +2916,17 @@ dependencies = [
 
 [[package]]
 name = "windows-targets"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
-dependencies = [
- "windows_aarch64_gnullvm 0.42.2",
- "windows_aarch64_msvc 0.42.2",
- "windows_i686_gnu 0.42.2",
- "windows_i686_msvc 0.42.2",
- "windows_x86_64_gnu 0.42.2",
- "windows_x86_64_gnullvm 0.42.2",
- "windows_x86_64_msvc 0.42.2",
-]
-
-[[package]]
-name = "windows-targets"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b1eb6f0cd7c80c79759c929114ef071b87354ce476d9d94271031c0497adfd5"
+checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
 dependencies = [
- "windows_aarch64_gnullvm 0.48.0",
- "windows_aarch64_msvc 0.48.0",
- "windows_i686_gnu 0.48.0",
- "windows_i686_msvc 0.48.0",
- "windows_x86_64_gnu 0.48.0",
- "windows_x86_64_gnullvm 0.48.0",
- "windows_x86_64_msvc 0.48.0",
+ "windows_aarch64_gnullvm 0.48.5",
+ "windows_aarch64_msvc 0.48.5",
+ "windows_i686_gnu 0.48.5",
+ "windows_i686_msvc 0.48.5",
+ "windows_x86_64_gnu 0.48.5",
+ "windows_x86_64_gnullvm 0.48.5",
+ "windows_x86_64_msvc 0.48.5",
 ]
 
 [[package]]
@@ -2807,15 +2947,9 @@ dependencies = [
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.42.2"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
-
-[[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"
+checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
 
 [[package]]
 name = "windows_aarch64_gnullvm"
@@ -2825,15 +2959,9 @@ checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.42.2"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
-
-[[package]]
-name = "windows_aarch64_msvc"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"
+checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
@@ -2843,15 +2971,9 @@ checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
-
-[[package]]
-name = "windows_i686_gnu"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"
+checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
 
 [[package]]
 name = "windows_i686_gnu"
@@ -2867,15 +2989,9 @@ checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.42.2"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
-
-[[package]]
-name = "windows_i686_msvc"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"
+checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
 
 [[package]]
 name = "windows_i686_msvc"
@@ -2885,15 +3001,9 @@ checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
-
-[[package]]
-name = "windows_x86_64_gnu"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"
+checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
 
 [[package]]
 name = "windows_x86_64_gnu"
@@ -2903,15 +3013,9 @@ checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.42.2"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
-version = "0.48.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"
+checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
@@ -2921,15 +3025,9 @@ checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
-
-[[package]]
-name = "windows_x86_64_msvc"
-version = "0.48.0"
+version = "0.48.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
+checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
 
 [[package]]
 name = "windows_x86_64_msvc"
@@ -2952,9 +3050,30 @@ version = "0.0.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d135d17ab770252ad95e9a872d365cf3090e3be864a34ab46f48555993efc904"
 
+[[package]]
+name = "wit-bindgen-rt"
+version = "0.33.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3268f3d866458b787f390cf61f4bbb563b922d091359f9608842999eaee3943c"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "write16"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d1890f4022759daae28ed4fe62859b1236caebfc61ede2f63ed4e695f3f6d936"
+
+[[package]]
+name = "writeable"
+version = "0.5.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e9df38ee2d2c3c5948ea468a8406ff0db0b29ae1ffde1bcf20ef305bcc95c51"
+
 [[package]]
 name = "xtask"
-version = "24.7.0"
+version = "25.1.1"
 dependencies = [
  "helix-core",
  "helix-loader",
@@ -2963,22 +3082,89 @@ dependencies = [
  "toml",
 ]
 
+[[package]]
+name = "yoke"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c5b1314b079b0930c31e3af543d8ee1757b1951ae1e1565ec704403a7240ca5"
+dependencies = [
+ "serde",
+ "stable_deref_trait",
+ "yoke-derive",
+ "zerofrom",
+]
+
+[[package]]
+name = "yoke-derive"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28cc31741b18cb6f1d5ff12f5b7523e3d6eb0852bbbad19d73905511d9849b95"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
 [[package]]
 name = "zerocopy"
-version = "0.7.31"
+version = "0.7.35"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1c4061bedbb353041c12f413700357bec76df2c7e2ca8e4df8bac24c6bf68e3d"
+checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
 dependencies = [
  "zerocopy-derive",
 ]
 
 [[package]]
 name = "zerocopy-derive"
-version = "0.7.31"
+version = "0.7.35"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "zerofrom"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "91ec111ce797d0e0784a1116d0ddcdbea84322cd79e5d5ad173daeba4f93ab55"
+dependencies = [
+ "zerofrom-derive",
+]
+
+[[package]]
+name = "zerofrom-derive"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ea7b4a3637ea8669cedf0f1fd5c286a17f3de97b8dd5a70a6c167a1730e63a5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+ "synstructure",
+]
+
+[[package]]
+name = "zerovec"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa2b893d79df23bfb12d5461018d408ea19dfafe76c2c7ef6d4eba614f8ff079"
+dependencies = [
+ "yoke",
+ "zerofrom",
+ "zerovec-derive",
+]
+
+[[package]]
+name = "zerovec-derive"
+version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b3c129550b3e6de3fd0ba67ba5c81818f9805e58b8d7fee80a3a59d2c9fc601a"
+checksum = "6eafa6dfb17584ea3e2bd6e76e0cc15ad7af12b09abdd1ca55961bed9b1063c6"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.48",
+ "syn",
 ]
diff --git a/Cargo.toml b/Cargo.toml
index 763992480..56234a863 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -22,13 +22,12 @@ default-members = [
 
 [profile.release]
 lto = "thin"
-# debug = true
 
 [profile.opt]
 inherits = "release"
 lto = "fat"
 codegen-units = 1
-# strip = "debuginfo" # TODO: or strip = true
+strip = true
 opt-level = 3
 
 [profile.integration]
@@ -41,14 +40,18 @@ package.helix-term.opt-level = 2
 tree-sitter = { version = "0.22" }
 nucleo = "0.5.0"
 slotmap = "1.0.7"
-thiserror = "1.0"
+thiserror = "2.0"
+tempfile = "3.16.0"
+bitflags = "2.8"
+unicode-segmentation = "1.2"
+ropey = { version = "1.6.1", default-features = false, features = ["simd"] }
 
 [workspace.package]
-version = "24.7.0"
+version = "25.1.1"
 edition = "2021"
 authors = ["Bla Hrastnik <blaz@mxxn.io>"]
 categories = ["editor"]
 repository = "https://github.com/helix-editor/helix"
 homepage = "https://helix-editor.com"
 license = "MPL-2.0"
-rust-version = "1.70"
+rust-version = "1.76"
diff --git a/README.md b/README.md
index 3b639214d..11a909b26 100644
--- a/README.md
+++ b/README.md
@@ -37,8 +37,8 @@ # Features
 - Built-in language server support
 - Smart, incremental syntax highlighting and code editing via tree-sitter
 
-It's a terminal-based editor first, but I'd like to explore a custom renderer
-(similar to Emacs) in wgpu or skulpin.
+Although it's primarily a terminal-based editor, I am interested in exploring
+a custom renderer (similar to Emacs) using wgpu or skulpin.
 
 Note: Only certain languages have indentation definitions at the moment. Check
 `runtime/queries/<lang>/` for `indents.scm`.
@@ -47,7 +47,7 @@ # Installation
 
 [Installation documentation](https://docs.helix-editor.com/install.html).
 
-[![Packaging status](https://repology.org/badge/vertical-allrepos/helix.svg?exclude_unsupported=1)](https://repology.org/project/helix/versions)
+[![Packaging status](https://repology.org/badge/vertical-allrepos/helix-editor.svg?exclude_unsupported=1)](https://repology.org/project/helix-editor/versions)
 
 # Contributing
 
diff --git a/book/src/building-from-source.md b/book/src/building-from-source.md
index 42ed57a27..fc8631b00 100644
--- a/book/src/building-from-source.md
+++ b/book/src/building-from-source.md
@@ -7,6 +7,7 @@ ## Building from source
   - [Note to packagers](#note-to-packagers)
 - [Validating the installation](#validating-the-installation)
 - [Configure the desktop shortcut](#configure-the-desktop-shortcut)
+- [Building the Debian package](#building-the-debian-package)
 
 Requirements:
 
@@ -63,11 +64,9 @@ #### Linux and macOS
 Or, create a symbolic link:
 
 ```sh
-ln -Ts $PWD/runtime ~/.config/helix/runtime
+ln -Tsf $PWD/runtime ~/.config/helix/runtime
 ```
 
-If the above command fails to create a symbolic link because the file exists either move `~/.config/helix/runtime` to a new location or delete it, then run the symlink command above again.
-
 #### Windows
 
 Either set the `HELIX_RUNTIME` environment variable to point to the runtime files using the Windows setting (search for
@@ -75,7 +74,7 @@ #### Windows
 Cmd:
 
 ```sh
-setx HELIX_RUNTIME "%userprofile%\source\repos\helix\runtime"
+setx HELIX_RUNTIME "%userprofile%\src\helix\runtime"
 ```
 
 >  `%userprofile%` resolves to your user directory like
@@ -117,7 +116,7 @@ #### Note to packagers
 script could follow are:
 
 1. `export HELIX_DEFAULT_RUNTIME=/usr/lib/helix/runtime`
-1. `cargo build --profile opt --locked --path helix-term`
+1. `cargo build --profile opt --locked`
 1. `cp -r runtime $BUILD_DIR/usr/lib/helix/`
 1. `cp target/opt/hx $BUILD_DIR/usr/bin/hx`
 
@@ -162,3 +161,39 @@ ### Configure the desktop shortcut
 sed -i "s|Exec=hx %F|Exec=kitty hx %F|g" ~/.local/share/applications/Helix.desktop
 sed -i "s|Terminal=true|Terminal=false|g" ~/.local/share/applications/Helix.desktop
 ```
+
+### Building the Debian package
+
+If the `.deb` file provided on the release page uses a `libc` version higher
+than that used by your Debian, Ubuntu, or Mint system, you can build the package
+from source to match your system's dependencies.
+
+Install `cargo-deb`, the tool used for building the `.deb` file:
+
+```sh
+cargo install cargo-deb
+```
+
+After cloning and entering the Helix repository as previously described,
+use the following command to build the release binary and package it into a `.deb` file in a single step.
+
+```sh
+cargo deb -- --locked
+```
+
+>  This locks you into the `--release` profile. But you can also build helix in any way you like.
+> As long as you leave a `target/release/hx` file, it will get packaged with `cargo deb --no-build` 
+
+>  Don't worry about the repeated
+> ```
+> warning: Failed to find dependency specification
+> ```
+> warnings. Cargo deb just reports which packaged files it didn't derive dependencies for. But
+> so far the dependency deriving seams very good, even if some of the grammar files are skipped.
+
+You can find the resulted `.deb` in `target/debian/`. It should contain everything it needs, including the
+
+- completions for bash, fish, zsh
+- .desktop file
+- icon (though desktop environments might use their own since the name of the package is correctly `helix`)
+- launcher to the binary with the runtime
diff --git a/book/src/commands.md b/book/src/commands.md
index 047a30a91..ee507276b 100644
--- a/book/src/commands.md
+++ b/book/src/commands.md
@@ -1,5 +1,16 @@
 # Commands
 
-Command mode can be activated by pressing `:`. The built-in commands are:
+- [Typable commands](#typable-commands)
+- [Static commands](#static-commands)
+
+## Typable commands
+
+Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`. The built-in typable commands are:
 
 {{#include ./generated/typable-cmd.md}}
+
+## Static Commands
+
+Static commands take no arguments and can be bound to keys. Static commands can also be executed from the command picker (`<space>?`). The built-in static commands are:
+
+{{#include ./generated/static-cmd.md}}
diff --git a/book/src/configuration.md b/book/src/configuration.md
index 0cd12568b..317007efc 100644
--- a/book/src/configuration.md
+++ b/book/src/configuration.md
@@ -27,8 +27,8 @@ # Configuration
 
 You can use a custom configuration file by specifying it with the `-c` or
 `--config` command line argument, for example `hx -c path/to/custom-config.toml`.
-Additionally, you can reload the configuration file by sending the USR1
-signal to the Helix process on Unix operating systems, such as by using the command `pkill -USR1 hx`.
+You can reload the config file by issuing the `:config-reload` command. Alternatively, on Unix operating systems, you can reload it by sending the USR1
+signal to the Helix process, such as by using the command `pkill -USR1 hx`.
 
 Finally, you can have a `config.toml` local to a project by putting it under a `.helix` directory in your repository.
 Its settings will be merged with the configuration directory `config.toml` and the built-in configuration.
diff --git a/book/src/editor.md b/book/src/editor.md
index 82d5f8461..2baa907f9 100644
--- a/book/src/editor.md
+++ b/book/src/editor.md
@@ -1,11 +1,13 @@
 ## Editor
 
 - [`[editor]` Section](#editor-section)
+- [`[editor.clipboard-provider]` Section](#editorclipboard-provider-section)
 - [`[editor.statusline]` Section](#editorstatusline-section)
 - [`[editor.lsp]` Section](#editorlsp-section)
 - [`[editor.cursor-shape]` Section](#editorcursor-shape-section)
 - [`[editor.file-picker]` Section](#editorfile-picker-section)
 - [`[editor.auto-pairs]` Section](#editorauto-pairs-section)
+- [`[editor.auto-save]` Section](#editorauto-save-section)
 - [`[editor.search]` Section](#editorsearch-section)
 - [`[editor.whitespace]` Section](#editorwhitespace-section)
 - [`[editor.indent-guides]` Section](#editorindent-guides-section)
@@ -24,14 +26,17 @@ ### `[editor]` Section
 |--|--|---------|
 | `scrolloff` | Number of lines of padding around the edge of the screen when scrolling | `5` |
 | `mouse` | Enable mouse mode | `true` |
+| `default-yank-register` | Default register used for yank/paste | `"` |
 | `middle-click-paste` | Middle click paste support | `true` |
 | `scroll-lines` | Number of lines to scroll per scroll wheel step | `3` |
 | `shell` | Shell to use when running external commands | Unix: `["sh", "-c"]`<br/>Windows: `["cmd", "/C"]` |
 | `line-number` | Line number display: `absolute` simply shows each line's number, while `relative` shows the distance from the current line. When unfocused or in insert mode, `relative` will still show absolute line numbers | `absolute` |
 | `cursorline` | Highlight all lines with a cursor | `false` |
 | `cursorcolumn` | Highlight all columns with a cursor | `false` |
+| `continue-comments` | if helix should automatically add a line comment token if you create a new line inside a comment. | `true` |
 | `gutters` | Gutters to display: Available are `diagnostics` and `diff` and `line-numbers` and `spacer`, note that `diagnostics` also includes other features like breakpoints, 1-width padding will be inserted if gutters is non-empty | `["diagnostics", "spacer", "line-numbers", "spacer", "diff"]` |
 | `auto-completion` | Enable automatic pop up of auto-completion | `true` |
+| `path-completion` | Enable filepath completion. Show files and directories if an existing path at the cursor was recognized, either absolute or relative to the current opened document or current working directory (if the buffer is not yet saved). Defaults to true. | `true` |
 | `auto-format` | Enable automatic formatting on save | `true` |
 | `idle-timeout` | Time in milliseconds since last keypress before idle timers trigger. | `250` |
 | `completion-timeout` | Time in milliseconds after typing a word character before completions are shown, set to 5 for instant.  | `250` |
@@ -52,6 +57,30 @@ ### `[editor]` Section
 | `indent-heuristic` | How the indentation for a newly inserted line is computed: `simple` just copies the indentation level from the previous line, `tree-sitter` computes the indentation based on the syntax tree and `hybrid` combines both approaches. If the chosen heuristic is not available, a different one will be used as a fallback (the fallback order being `hybrid` -> `tree-sitter` -> `simple`). | `hybrid`
 | `jump-label-alphabet` | The characters that are used to generate two character jump labels. Characters at the start of the alphabet are used first. | `"abcdefghijklmnopqrstuvwxyz"`
 | `end-of-line-diagnostics` | Minimum severity of diagnostics to render at the end of the line. Set to `disable` to disable entirely. Refer to the setting about `inline-diagnostics` for more details | "disable"
+| `clipboard-provider` | Which API to use for clipboard interaction. One of `pasteboard` (MacOS), `wayland`, `x-clip`, `x-sel`, `win-32-yank`, `termux`, `tmux`, `windows`, `termcode`, `none`, or a custom command set. | Platform and environment specific. |
+
+### `[editor.clipboard-provider]` Section
+
+Helix can be configured either to use a builtin clipboard configuration or to use
+a provided command.
+
+For instance, setting it to use OSC 52 termcodes, the configuration would be:
+```toml
+[editor]
+clipboard-provider = "termcode"
+```
+
+Alternatively, Helix can be configured to use arbitrary commands for clipboard integration:
+
+```toml
+[editor.clipboard-provider.custom]
+yank = { command = "cat",  args = ["test.txt"] }
+paste = { command = "tee",  args = ["test.txt"] }
+primary-yank = { command = "cat",  args = ["test-primary.txt"] } # optional
+primary-paste = { command = "tee",  args = ["test-primary.txt"] } # optional
+```
+
+For custom commands the contents of the yank/paste is communicated over stdin/stdout.
 
 ### `[editor.statusline]` Section
 
@@ -116,7 +145,8 @@ ### `[editor.lsp]` Section
 | Key                   | Description                                                 | Default |
 | ---                   | -----------                                                 | ------- |
 | `enable`              | Enables LSP integration. Setting to false will completely disable language servers regardless of language settings.| `true` |
-| `display-messages`    | Display LSP progress messages below statusline[^1]          | `false` |
+| `display-messages`    | Display LSP `window/showMessage` messages below statusline[^1] | `true` |
+| `display-progress-messages` | Display LSP progress messages below statusline[^1]    | `false` |
 | `auto-signature-help` | Enable automatic popup of signature help (parameter hints)  | `true`  |
 | `display-inlay-hints` | Display inlay hints[^2]                                     | `false` |
 | `display-signature-help-docs` | Display docs under signature help popup             | `true`  |
@@ -125,7 +155,7 @@ ### `[editor.lsp]` Section
 
 [^1]: By default, a progress spinner is shown in the statusline beside the file path.
 
-[^2]: You may also have to activate them in the LSP config for them to appear, not just in Helix. Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances. Please report any bugs you see so we can fix them!
+[^2]: You may also have to activate them in the language server config for them to appear, not just in Helix. Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances. Please report any bugs you see so we can fix them!
 
 ### `[editor.cursor-shape]` Section
 
@@ -415,6 +445,8 @@ ### `[editor.inline-diagnostics]` Section
 | `max-wrap` | Equivalent of the `editor.soft-wrap.max-wrap` option for diagnostics.  | `20` |
 | `max-diagnostics` | Maximum number of diagnostics to render inline for a given line  | `10` |
 
+The allowed values for `cursor-line` and `other-lines` are: `error`, `warning`, `info`, `hint`.
+
 The (first) diagnostic with the highest severity that is not shown inline is rendered at the end of the line (as long as its severity is higher than the `end-of-line-diagnostics` config option):
 
 ```
@@ -428,7 +460,8 @@ ### `[editor.inline-diagnostics]` Section
 
 The new diagnostic rendering is not yet enabled by default. As soon as end of line or inline diagnostics are enabled the old diagnostics rendering is automatically disabled. The recommended default setting are:
 
-```
+```toml
+[editor]
 end-of-line-diagnostics = "hint"
 [editor.inline-diagnostics]
 cursor-line = "warning" # show warnings and errors on the cursorline inline
diff --git a/book/src/generated/lang-support.md b/book/src/generated/lang-support.md
index cb1c815f2..f5491abae 100644
--- a/book/src/generated/lang-support.md
+++ b/book/src/generated/lang-support.md
@@ -1,13 +1,14 @@
-| Language | Syntax Highlighting | Treesitter Textobjects | Auto Indent | Default LSP |
+| Language | Syntax Highlighting | Treesitter Textobjects | Auto Indent | Default language servers |
 | --- | --- | --- | --- | --- |
 | ada |  |  |  | `ada_language_server` |
 | adl |  |  |  |  |
 | agda |  |  |  |  |
+| amber |  |  |  |  |
 | astro |  |  |  |  |
 | awk |  |  |  | `awk-language-server` |
 | bash |  |  |  | `bash-language-server` |
 | bass |  |  |  | `bass` |
-| beancount |  |  |  |  |
+| beancount |  |  |  | `beancount-language-server` |
 | bibtex |  |  |  | `texlab` |
 | bicep |  |  |  | `bicep-langserver` |
 | bitbake |  |  |  | `bitbake-language-server` |
@@ -19,25 +20,31 @@
 | cairo |  |  |  | `cairo-language-server` |
 | capnp |  |  |  |  |
 | cel |  |  |  |  |
+| circom |  |  |  | `circom-lsp` |
 | clojure |  |  |  | `clojure-lsp` |
 | cmake |  |  |  | `cmake-language-server` |
+| codeql |  |  |  | `codeql` |
 | comment |  |  |  |  |
 | common-lisp |  |  |  | `cl-lsp` |
 | cpon |  |  |  |  |
 | cpp |  |  |  | `clangd` |
 | crystal |  |  |  | `crystalline` |
 | css |  |  |  | `vscode-css-language-server` |
+| csv |  |  |  |  |
 | cue |  |  |  | `cuelsp` |
+| cylc |  |  |  |  |
 | d |  |  |  | `serve-d` |
 | dart |  |  |  | `dart` |
 | dbml |  |  |  |  |
 | devicetree |  |  |  |  |
 | dhall |  |  |  | `dhall-lsp-server` |
 | diff |  |  |  |  |
+| djot |  |  |  |  |
 | docker-compose |  |  |  | `docker-compose-langserver`, `yaml-language-server` |
 | dockerfile |  |  |  | `docker-langserver` |
 | dot |  |  |  | `dot-language-server` |
 | dtd |  |  |  |  |
+| dune |  |  |  |  |
 | earthfile |  |  |  | `earthlyls` |
 | edoc |  |  |  |  |
 | eex |  |  |  |  |
@@ -48,17 +55,19 @@
 | elvish |  |  |  | `elvish` |
 | env |  |  |  |  |
 | erb |  |  |  |  |
-| erlang |  |  |  | `erlang_ls` |
+| erlang |  |  |  | `erlang_ls`, `elp` |
 | esdl |  |  |  |  |
+| fga |  |  |  |  |
 | fidl |  |  |  |  |
-| fish |  |  |  |  |
+| fish |  |  |  | `fish-lsp` |
 | forth |  |  |  | `forth-lsp` |
 | fortran |  |  |  | `fortls` |
 | fsharp |  |  |  | `fsautocomplete` |
-| gas |  |  |  |  |
+| gas |  |  |  | `asm-lsp` |
 | gdscript |  |  |  |  |
 | gemini |  |  |  |  |
 | gherkin |  |  |  |  |
+| ghostty |  |  |  |  |
 | git-attributes |  |  |  |  |
 | git-commit |  |  |  |  |
 | git-config |  |  |  |  |
@@ -67,14 +76,16 @@
 | gjs |  |  |  | `typescript-language-server`, `vscode-eslint-language-server`, `ember-language-server` |
 | gleam |  |  |  | `gleam` |
 | glimmer |  |  |  | `ember-language-server` |
-| glsl |  |  |  |  |
+| glsl |  |  |  | `glsl_analyzer` |
 | gn |  |  |  |  |
 | go |  |  |  | `gopls`, `golangci-lint-langserver` |
 | godot-resource |  |  |  |  |
 | gomod |  |  |  | `gopls` |
 | gotmpl |  |  |  | `gopls` |
 | gowork |  |  |  | `gopls` |
+| gpr |  |  |  | `ada_language_server` |
 | graphql |  |  |  | `graphql-lsp` |
+| gren |  |  |  |  |
 | groovy |  |  |  |  |
 | gts |  |  |  | `typescript-language-server`, `vscode-eslint-language-server`, `ember-language-server` |
 | hare |  |  |  |  |
@@ -86,9 +97,9 @@
 | hocon |  |  |  |  |
 | hoon |  |  |  |  |
 | hosts |  |  |  |  |
-| html |  |  |  | `vscode-html-language-server` |
+| html |  |  |  | `vscode-html-language-server`, `superhtml` |
 | hurl |  |  |  |  |
-| hyprlang |  |  |  |  |
+| hyprlang |  |  |  | `hyprls` |
 | idris |  |  |  | `idris2-lsp` |
 | iex |  |  |  |  |
 | ini |  |  |  |  |
@@ -110,6 +121,7 @@
 | kdl |  |  |  |  |
 | koka |  |  |  | `koka` |
 | kotlin |  |  |  | `kotlin-language-server` |
+| koto |  |  |  | `koto-ls` |
 | latex |  |  |  | `texlab` |
 | ld |  |  |  |  |
 | ldif |  |  |  |  |
@@ -129,18 +141,20 @@
 | mermaid |  |  |  |  |
 | meson |  |  |  | `mesonlsp` |
 | mint |  |  |  | `mint` |
-| mojo |  |  |  | `mojo-lsp-server` |
+| mojo |  |  |  | `magic` |
 | move |  |  |  |  |
 | msbuild |  |  |  |  |
-| nasm |  |  |  |  |
+| nasm |  |  |  | `asm-lsp` |
+| nestedtext |  |  |  |  |
+| nginx |  |  |  |  |
 | nickel |  |  |  | `nls` |
 | nim |  |  |  | `nimlangserver` |
-| nix |  |  |  | `nil`, `nixd` |
+| nix |  |  |  | `nil`, `nixd` |
 | nu |  |  |  | `nu` |
 | nunjucks |  |  |  |  |
 | ocaml |  |  |  | `ocamllsp` |
 | ocaml-interface |  |  |  | `ocamllsp` |
-| odin |  |  |  | `ols` |
+| odin |  |  |  | `ols` |
 | ohm |  |  |  |  |
 | opencl |  |  |  | `clangd` |
 | openscad |  |  |  | `openscad-lsp` |
@@ -163,8 +177,9 @@
 | protobuf |  |  |  | `bufls`, `pb` |
 | prql |  |  |  |  |
 | purescript |  |  |  | `purescript-language-server` |
-| python |  |  |  | `pylsp` |
+| python |  |  |  | `ruff`, `jedi-language-server`, `pylsp` |
 | qml |  |  |  | `qmlls` |
+| quint |  |  |  | `quint-language-server` |
 | r |  |  |  | `R` |
 | racket |  |  |  | `racket` |
 | regex |  |  |  |  |
@@ -174,7 +189,7 @@
 | robot |  |  |  | `robotframework_ls` |
 | ron |  |  |  |  |
 | rst |  |  |  |  |
-| ruby |  |  |  | `solargraph` |
+| ruby |  |  |  | `ruby-lsp`, `solargraph` |
 | rust |  |  |  | `rust-analyzer` |
 | sage |  |  |  |  |
 | scala |  |  |  | `metals` |
@@ -184,7 +199,9 @@
 | smali |  |  |  |  |
 | smithy |  |  |  | `cs` |
 | sml |  |  |  |  |
+| snakemake |  |  |  | `pylsp` |
 | solidity |  |  |  | `solc` |
+| spade |  |  |  | `spade-language-server` |
 | spicedb |  |  |  |  |
 | sql |  |  |  |  |
 | sshclientconfig |  |  |  |  |
@@ -199,28 +216,32 @@
 | tact |  |  |  |  |
 | task |  |  |  |  |
 | tcl |  |  |  |  |
+| teal |  |  |  | `teal-language-server` |
 | templ |  |  |  | `templ` |
+| tera |  |  |  |  |
+| textproto |  |  |  |  |
 | tfvars |  |  |  | `terraform-ls` |
 | thrift |  |  |  |  |
 | todotxt |  |  |  |  |
 | toml |  |  |  | `taplo` |
-| tsq |  |  |  |  |
+| tsq |  |  |  | `ts_query_ls` |
 | tsx |  |  |  | `typescript-language-server` |
 | twig |  |  |  |  |
 | typescript |  |  |  | `typescript-language-server` |
 | typespec |  |  |  | `tsp-server` |
 | typst |  |  |  | `tinymist`, `typst-lsp` |
 | ungrammar |  |  |  |  |
-| unison |  |  |  |  |
+| unison |  |  |  |  |
 | uxntal |  |  |  |  |
 | v |  |  |  | `v-analyzer` |
 | vala |  |  |  | `vala-language-server` |
+| vento |  |  |  |  |
 | verilog |  |  |  | `svlangserver` |
 | vhdl |  |  |  | `vhdl_ls` |
 | vhs |  |  |  |  |
 | vue |  |  |  | `vue-language-server` |
 | wast |  |  |  |  |
-| wat |  |  |  |  |
+| wat |  |  |  | `wat_server` |
 | webc |  |  |  |  |
 | wgsl |  |  |  | `wgsl_analyzer` |
 | wit |  |  |  |  |
@@ -229,5 +250,6 @@
 | xml |  |  |  |  |
 | xtc |  |  |  |  |
 | yaml |  |  |  | `yaml-language-server`, `ansible-language-server` |
+| yara |  |  |  | `yls` |
 | yuck |  |  |  |  |
 | zig |  |  |  | `zls` |
diff --git a/book/src/generated/static-cmd.md b/book/src/generated/static-cmd.md
new file mode 100644
index 000000000..af7515b8e
--- /dev/null
+++ b/book/src/generated/static-cmd.md
@@ -0,0 +1,300 @@
+| Name | Description | Default keybinds |
+| --- | --- | --- |
+| `no_op` | Do nothing |  |
+| `move_char_left` | Move left | normal: `` h ``, `` <left> ``, insert: `` <left> `` |
+| `move_char_right` | Move right | normal: `` l ``, `` <right> ``, insert: `` <right> `` |
+| `move_line_up` | Move up | normal: `` gk `` |
+| `move_line_down` | Move down | normal: `` gj `` |
+| `move_visual_line_up` | Move up | normal: `` k ``, `` <up> ``, insert: `` <up> `` |
+| `move_visual_line_down` | Move down | normal: `` j ``, `` <down> ``, insert: `` <down> `` |
+| `extend_char_left` | Extend left | select: `` h ``, `` <left> `` |
+| `extend_char_right` | Extend right | select: `` l ``, `` <right> `` |
+| `extend_line_up` | Extend up | select: `` gk `` |
+| `extend_line_down` | Extend down | select: `` gj `` |
+| `extend_visual_line_up` | Extend up | select: `` k ``, `` <up> `` |
+| `extend_visual_line_down` | Extend down | select: `` j ``, `` <down> `` |
+| `copy_selection_on_next_line` | Copy selection on next line | normal: `` C ``, select: `` C `` |
+| `copy_selection_on_prev_line` | Copy selection on previous line | normal: `` <A-C> ``, select: `` <A-C> `` |
+| `move_next_word_start` | Move to start of next word | normal: `` w `` |
+| `move_prev_word_start` | Move to start of previous word | normal: `` b `` |
+| `move_next_word_end` | Move to end of next word | normal: `` e `` |
+| `move_prev_word_end` | Move to end of previous word |  |
+| `move_next_long_word_start` | Move to start of next long word | normal: `` W `` |
+| `move_prev_long_word_start` | Move to start of previous long word | normal: `` B `` |
+| `move_next_long_word_end` | Move to end of next long word | normal: `` E `` |
+| `move_prev_long_word_end` | Move to end of previous long word |  |
+| `move_next_sub_word_start` | Move to start of next sub word |  |
+| `move_prev_sub_word_start` | Move to start of previous sub word |  |
+| `move_next_sub_word_end` | Move to end of next sub word |  |
+| `move_prev_sub_word_end` | Move to end of previous sub word |  |
+| `move_parent_node_end` | Move to end of the parent node | normal: `` <A-e> `` |
+| `move_parent_node_start` | Move to beginning of the parent node | normal: `` <A-b> `` |
+| `extend_next_word_start` | Extend to start of next word | select: `` w `` |
+| `extend_prev_word_start` | Extend to start of previous word | select: `` b `` |
+| `extend_next_word_end` | Extend to end of next word | select: `` e `` |
+| `extend_prev_word_end` | Extend to end of previous word |  |
+| `extend_next_long_word_start` | Extend to start of next long word | select: `` W `` |
+| `extend_prev_long_word_start` | Extend to start of previous long word | select: `` B `` |
+| `extend_next_long_word_end` | Extend to end of next long word | select: `` E `` |
+| `extend_prev_long_word_end` | Extend to end of prev long word |  |
+| `extend_next_sub_word_start` | Extend to start of next sub word |  |
+| `extend_prev_sub_word_start` | Extend to start of previous sub word |  |
+| `extend_next_sub_word_end` | Extend to end of next sub word |  |
+| `extend_prev_sub_word_end` | Extend to end of prev sub word |  |
+| `extend_parent_node_end` | Extend to end of the parent node | select: `` <A-e> `` |
+| `extend_parent_node_start` | Extend to beginning of the parent node | select: `` <A-b> `` |
+| `find_till_char` | Move till next occurrence of char | normal: `` t `` |
+| `find_next_char` | Move to next occurrence of char | normal: `` f `` |
+| `extend_till_char` | Extend till next occurrence of char | select: `` t `` |
+| `extend_next_char` | Extend to next occurrence of char | select: `` f `` |
+| `till_prev_char` | Move till previous occurrence of char | normal: `` T `` |
+| `find_prev_char` | Move to previous occurrence of char | normal: `` F `` |
+| `extend_till_prev_char` | Extend till previous occurrence of char | select: `` T `` |
+| `extend_prev_char` | Extend to previous occurrence of char | select: `` F `` |
+| `repeat_last_motion` | Repeat last motion | normal: `` <A-.> ``, select: `` <A-.> `` |
+| `replace` | Replace with new char | normal: `` r ``, select: `` r `` |
+| `switch_case` | Switch (toggle) case | normal: `` ~ ``, select: `` ~ `` |
+| `switch_to_uppercase` | Switch to uppercase | normal: `` <A-`> ``, select: `` <A-`> `` |
+| `switch_to_lowercase` | Switch to lowercase | normal: `` ` ``, select: `` ` `` |
+| `page_up` | Move page up | normal: `` <C-b> ``, `` Z<C-b> ``, `` z<C-b> ``, `` <pageup> ``, `` Z<pageup> ``, `` z<pageup> ``, select: `` <C-b> ``, `` Z<C-b> ``, `` z<C-b> ``, `` <pageup> ``, `` Z<pageup> ``, `` z<pageup> ``, insert: `` <pageup> `` |
+| `page_down` | Move page down | normal: `` <C-f> ``, `` Z<C-f> ``, `` z<C-f> ``, `` <pagedown> ``, `` Z<pagedown> ``, `` z<pagedown> ``, select: `` <C-f> ``, `` Z<C-f> ``, `` z<C-f> ``, `` <pagedown> ``, `` Z<pagedown> ``, `` z<pagedown> ``, insert: `` <pagedown> `` |
+| `half_page_up` | Move half page up |  |
+| `half_page_down` | Move half page down |  |
+| `page_cursor_up` | Move page and cursor up |  |
+| `page_cursor_down` | Move page and cursor down |  |
+| `page_cursor_half_up` | Move page and cursor half up | normal: `` <C-u> ``, `` Z<C-u> ``, `` z<C-u> ``, `` Z<backspace> ``, `` z<backspace> ``, select: `` <C-u> ``, `` Z<C-u> ``, `` z<C-u> ``, `` Z<backspace> ``, `` z<backspace> `` |
+| `page_cursor_half_down` | Move page and cursor half down | normal: `` <C-d> ``, `` Z<C-d> ``, `` z<C-d> ``, `` Z<space> ``, `` z<space> ``, select: `` <C-d> ``, `` Z<C-d> ``, `` z<C-d> ``, `` Z<space> ``, `` z<space> `` |
+| `select_all` | Select whole document | normal: `` % ``, select: `` % `` |
+| `select_regex` | Select all regex matches inside selections | normal: `` s ``, select: `` s `` |
+| `split_selection` | Split selections on regex matches | normal: `` S ``, select: `` S `` |
+| `split_selection_on_newline` | Split selection on newlines | normal: `` <A-s> ``, select: `` <A-s> `` |
+| `merge_selections` | Merge selections | normal: `` <A-minus> ``, select: `` <A-minus> `` |
+| `merge_consecutive_selections` | Merge consecutive selections | normal: `` <A-_> ``, select: `` <A-_> `` |
+| `search` | Search for regex pattern | normal: `` / ``, `` Z/ ``, `` z/ ``, select: `` / ``, `` Z/ ``, `` z/ `` |
+| `rsearch` | Reverse search for regex pattern | normal: `` ? ``, `` Z? ``, `` z? ``, select: `` ? ``, `` Z? ``, `` z? `` |
+| `search_next` | Select next search match | normal: `` n ``, `` Zn ``, `` zn ``, select: `` Zn ``, `` zn `` |
+| `search_prev` | Select previous search match | normal: `` N ``, `` ZN ``, `` zN ``, select: `` ZN ``, `` zN `` |
+| `extend_search_next` | Add next search match to selection | select: `` n `` |
+| `extend_search_prev` | Add previous search match to selection | select: `` N `` |
+| `search_selection` | Use current selection as search pattern | normal: `` <A-*> ``, select: `` <A-*> `` |
+| `search_selection_detect_word_boundaries` | Use current selection as the search pattern, automatically wrapping with `\b` on word boundaries | normal: `` * ``, select: `` * `` |
+| `make_search_word_bounded` | Modify current search to make it word bounded |  |
+| `global_search` | Global search in workspace folder | normal: `` <space>/ ``, select: `` <space>/ `` |
+| `extend_line` | Select current line, if already selected, extend to another line based on the anchor |  |
+| `extend_line_below` | Select current line, if already selected, extend to next line | normal: `` x ``, select: `` x `` |
+| `extend_line_above` | Select current line, if already selected, extend to previous line |  |
+| `select_line_above` | Select current line, if already selected, extend or shrink line above based on the anchor |  |
+| `select_line_below` | Select current line, if already selected, extend or shrink line below based on the anchor |  |
+| `extend_to_line_bounds` | Extend selection to line bounds | normal: `` X ``, select: `` X `` |
+| `shrink_to_line_bounds` | Shrink selection to line bounds | normal: `` <A-x> ``, select: `` <A-x> `` |
+| `delete_selection` | Delete selection | normal: `` d ``, select: `` d `` |
+| `delete_selection_noyank` | Delete selection without yanking | normal: `` <A-d> ``, select: `` <A-d> `` |
+| `change_selection` | Change selection | normal: `` c ``, select: `` c `` |
+| `change_selection_noyank` | Change selection without yanking | normal: `` <A-c> ``, select: `` <A-c> `` |
+| `collapse_selection` | Collapse selection into single cursor | normal: `` ; ``, select: `` ; `` |
+| `flip_selections` | Flip selection cursor and anchor | normal: `` <A-;> ``, select: `` <A-;> `` |
+| `ensure_selections_forward` | Ensure all selections face forward | normal: `` <A-:> ``, select: `` <A-:> `` |
+| `insert_mode` | Insert before selection | normal: `` i ``, select: `` i `` |
+| `append_mode` | Append after selection | normal: `` a ``, select: `` a `` |
+| `command_mode` | Enter command mode | normal: `` : ``, select: `` : `` |
+| `file_picker` | Open file picker | normal: `` <space>f ``, select: `` <space>f `` |
+| `file_picker_in_current_buffer_directory` | Open file picker at current buffer's directory |  |
+| `file_picker_in_current_directory` | Open file picker at current working directory | normal: `` <space>F ``, select: `` <space>F `` |
+| `file_explorer` | Open file explorer in workspace root | normal: `` <space>e ``, select: `` <space>e `` |
+| `file_explorer_in_current_buffer_directory` | Open file explorer at current buffer's directory | normal: `` <space>E ``, select: `` <space>E `` |
+| `file_explorer_in_current_directory` | Open file explorer at current working directory |  |
+| `code_action` | Perform code action | normal: `` <space>a ``, select: `` <space>a `` |
+| `buffer_picker` | Open buffer picker | normal: `` <space>b ``, select: `` <space>b `` |
+| `jumplist_picker` | Open jumplist picker | normal: `` <space>j ``, select: `` <space>j `` |
+| `symbol_picker` | Open symbol picker | normal: `` <space>s ``, select: `` <space>s `` |
+| `changed_file_picker` | Open changed file picker | normal: `` <space>g ``, select: `` <space>g `` |
+| `select_references_to_symbol_under_cursor` | Select symbol references | normal: `` <space>h ``, select: `` <space>h `` |
+| `workspace_symbol_picker` | Open workspace symbol picker | normal: `` <space>S ``, select: `` <space>S `` |
+| `diagnostics_picker` | Open diagnostic picker | normal: `` <space>d ``, select: `` <space>d `` |
+| `workspace_diagnostics_picker` | Open workspace diagnostic picker | normal: `` <space>D ``, select: `` <space>D `` |
+| `last_picker` | Open last picker | normal: `` <space>' ``, select: `` <space>' `` |
+| `insert_at_line_start` | Insert at start of line | normal: `` I ``, select: `` I `` |
+| `insert_at_line_end` | Insert at end of line | normal: `` A ``, select: `` A `` |
+| `open_below` | Open new line below selection | normal: `` o ``, select: `` o `` |
+| `open_above` | Open new line above selection | normal: `` O ``, select: `` O `` |
+| `normal_mode` | Enter normal mode | normal: `` <esc> ``, select: `` v ``, insert: `` <esc> `` |
+| `select_mode` | Enter selection extend mode | normal: `` v `` |
+| `exit_select_mode` | Exit selection mode | select: `` <esc> `` |
+| `goto_definition` | Goto definition | normal: `` gd ``, select: `` gd `` |
+| `goto_declaration` | Goto declaration | normal: `` gD ``, select: `` gD `` |
+| `add_newline_above` | Add newline above | normal: `` [<space> ``, select: `` [<space> `` |
+| `add_newline_below` | Add newline below | normal: `` ]<space> ``, select: `` ]<space> `` |
+| `goto_type_definition` | Goto type definition | normal: `` gy ``, select: `` gy `` |
+| `goto_implementation` | Goto implementation | normal: `` gi ``, select: `` gi `` |
+| `goto_file_start` | Goto line number <n> else file start | normal: `` gg ``, select: `` gg `` |
+| `goto_file_end` | Goto file end |  |
+| `goto_file` | Goto files/URLs in selections | normal: `` gf ``, select: `` gf `` |
+| `goto_file_hsplit` | Goto files in selections (hsplit) | normal: `` <C-w>f ``, `` <space>wf ``, select: `` <C-w>f ``, `` <space>wf `` |
+| `goto_file_vsplit` | Goto files in selections (vsplit) | normal: `` <C-w>F ``, `` <space>wF ``, select: `` <C-w>F ``, `` <space>wF `` |
+| `goto_reference` | Goto references | normal: `` gr ``, select: `` gr `` |
+| `goto_window_top` | Goto window top | normal: `` gt ``, select: `` gt `` |
+| `goto_window_center` | Goto window center | normal: `` gc ``, select: `` gc `` |
+| `goto_window_bottom` | Goto window bottom | normal: `` gb ``, select: `` gb `` |
+| `goto_last_accessed_file` | Goto last accessed file | normal: `` ga ``, select: `` ga `` |
+| `goto_last_modified_file` | Goto last modified file | normal: `` gm ``, select: `` gm `` |
+| `goto_last_modification` | Goto last modification | normal: `` g. ``, select: `` g. `` |
+| `goto_line` | Goto line | normal: `` G ``, select: `` G `` |
+| `goto_last_line` | Goto last line | normal: `` ge ``, select: `` ge `` |
+| `goto_first_diag` | Goto first diagnostic | normal: `` [D ``, select: `` [D `` |
+| `goto_last_diag` | Goto last diagnostic | normal: `` ]D ``, select: `` ]D `` |
+| `goto_next_diag` | Goto next diagnostic | normal: `` ]d ``, select: `` ]d `` |
+| `goto_prev_diag` | Goto previous diagnostic | normal: `` [d ``, select: `` [d `` |
+| `goto_next_change` | Goto next change | normal: `` ]g ``, select: `` ]g `` |
+| `goto_prev_change` | Goto previous change | normal: `` [g ``, select: `` [g `` |
+| `goto_first_change` | Goto first change | normal: `` [G ``, select: `` [G `` |
+| `goto_last_change` | Goto last change | normal: `` ]G ``, select: `` ]G `` |
+| `goto_line_start` | Goto line start | normal: `` gh ``, `` <home> ``, select: `` gh ``, insert: `` <home> `` |
+| `goto_line_end` | Goto line end | normal: `` gl ``, `` <end> ``, select: `` gl `` |
+| `goto_next_buffer` | Goto next buffer | normal: `` gn ``, select: `` gn `` |
+| `goto_previous_buffer` | Goto previous buffer | normal: `` gp ``, select: `` gp `` |
+| `goto_line_end_newline` | Goto newline at line end | insert: `` <end> `` |
+| `goto_first_nonwhitespace` | Goto first non-blank in line | normal: `` gs ``, select: `` gs `` |
+| `trim_selections` | Trim whitespace from selections | normal: `` _ ``, select: `` _ `` |
+| `extend_to_line_start` | Extend to line start | select: `` <home> `` |
+| `extend_to_first_nonwhitespace` | Extend to first non-blank in line |  |
+| `extend_to_line_end` | Extend to line end | select: `` <end> `` |
+| `extend_to_line_end_newline` | Extend to line end |  |
+| `signature_help` | Show signature help |  |
+| `smart_tab` | Insert tab if all cursors have all whitespace to their left; otherwise, run a separate command. | insert: `` <tab> `` |
+| `insert_tab` | Insert tab char | insert: `` <S-tab> `` |
+| `insert_newline` | Insert newline char | insert: `` <C-j> ``, `` <ret> `` |
+| `delete_char_backward` | Delete previous char | insert: `` <C-h> ``, `` <backspace> ``, `` <S-backspace> `` |
+| `delete_char_forward` | Delete next char | insert: `` <C-d> ``, `` <del> `` |
+| `delete_word_backward` | Delete previous word | insert: `` <C-w> ``, `` <A-backspace> `` |
+| `delete_word_forward` | Delete next word | insert: `` <A-d> ``, `` <A-del> `` |
+| `kill_to_line_start` | Delete till start of line | insert: `` <C-u> `` |
+| `kill_to_line_end` | Delete till end of line | insert: `` <C-k> `` |
+| `undo` | Undo change | normal: `` u ``, select: `` u `` |
+| `redo` | Redo change | normal: `` U ``, select: `` U `` |
+| `earlier` | Move backward in history | normal: `` <A-u> ``, select: `` <A-u> `` |
+| `later` | Move forward in history | normal: `` <A-U> ``, select: `` <A-U> `` |
+| `commit_undo_checkpoint` | Commit changes to new checkpoint | insert: `` <C-s> `` |
+| `yank` | Yank selection | normal: `` y ``, select: `` y `` |
+| `yank_to_clipboard` | Yank selections to clipboard | normal: `` <space>y ``, select: `` <space>y `` |
+| `yank_to_primary_clipboard` | Yank selections to primary clipboard |  |
+| `yank_joined` | Join and yank selections |  |
+| `yank_joined_to_clipboard` | Join and yank selections to clipboard |  |
+| `yank_main_selection_to_clipboard` | Yank main selection to clipboard | normal: `` <space>Y ``, select: `` <space>Y `` |
+| `yank_joined_to_primary_clipboard` | Join and yank selections to primary clipboard |  |
+| `yank_main_selection_to_primary_clipboard` | Yank main selection to primary clipboard |  |
+| `replace_with_yanked` | Replace with yanked text | normal: `` R ``, select: `` R `` |
+| `replace_selections_with_clipboard` | Replace selections by clipboard content | normal: `` <space>R ``, select: `` <space>R `` |
+| `replace_selections_with_primary_clipboard` | Replace selections by primary clipboard |  |
+| `paste_after` | Paste after selection | normal: `` p ``, select: `` p `` |
+| `paste_before` | Paste before selection | normal: `` P ``, select: `` P `` |
+| `paste_clipboard_after` | Paste clipboard after selections | normal: `` <space>p ``, select: `` <space>p `` |
+| `paste_clipboard_before` | Paste clipboard before selections | normal: `` <space>P ``, select: `` <space>P `` |
+| `paste_primary_clipboard_after` | Paste primary clipboard after selections |  |
+| `paste_primary_clipboard_before` | Paste primary clipboard before selections |  |
+| `indent` | Indent selection | normal: `` <gt> ``, select: `` <gt> `` |
+| `unindent` | Unindent selection | normal: `` <lt> ``, select: `` <lt> `` |
+| `format_selections` | Format selection | normal: `` = ``, select: `` = `` |
+| `join_selections` | Join lines inside selection | normal: `` J ``, select: `` J `` |
+| `join_selections_space` | Join lines inside selection and select spaces | normal: `` <A-J> ``, select: `` <A-J> `` |
+| `keep_selections` | Keep selections matching regex | normal: `` K ``, select: `` K `` |
+| `remove_selections` | Remove selections matching regex | normal: `` <A-K> ``, select: `` <A-K> `` |
+| `align_selections` | Align selections in column | normal: `` & ``, select: `` & `` |
+| `keep_primary_selection` | Keep primary selection | normal: `` , ``, select: `` , `` |
+| `remove_primary_selection` | Remove primary selection | normal: `` <A-,> ``, select: `` <A-,> `` |
+| `completion` | Invoke completion popup | insert: `` <C-x> `` |
+| `hover` | Show docs for item under cursor | normal: `` <space>k ``, select: `` <space>k `` |
+| `toggle_comments` | Comment/uncomment selections | normal: `` <C-c> ``, `` <space>c ``, select: `` <C-c> ``, `` <space>c `` |
+| `toggle_line_comments` | Line comment/uncomment selections | normal: `` <space><A-c> ``, select: `` <space><A-c> `` |
+| `toggle_block_comments` | Block comment/uncomment selections | normal: `` <space>C ``, select: `` <space>C `` |
+| `rotate_selections_forward` | Rotate selections forward | normal: `` ) ``, select: `` ) `` |
+| `rotate_selections_backward` | Rotate selections backward | normal: `` ( ``, select: `` ( `` |
+| `rotate_selection_contents_forward` | Rotate selection contents forward | normal: `` <A-)> ``, select: `` <A-)> `` |
+| `rotate_selection_contents_backward` | Rotate selections contents backward | normal: `` <A-(> ``, select: `` <A-(> `` |
+| `reverse_selection_contents` | Reverse selections contents |  |
+| `expand_selection` | Expand selection to parent syntax node | normal: `` <A-o> ``, `` <A-up> ``, select: `` <A-o> ``, `` <A-up> `` |
+| `shrink_selection` | Shrink selection to previously expanded syntax node | normal: `` <A-i> ``, `` <A-down> ``, select: `` <A-i> ``, `` <A-down> `` |
+| `select_next_sibling` | Select next sibling in the syntax tree | normal: `` <A-n> ``, `` <A-right> ``, select: `` <A-n> ``, `` <A-right> `` |
+| `select_prev_sibling` | Select previous sibling the in syntax tree | normal: `` <A-p> ``, `` <A-left> ``, select: `` <A-p> ``, `` <A-left> `` |
+| `select_all_siblings` | Select all siblings of the current node | normal: `` <A-a> ``, select: `` <A-a> `` |
+| `select_all_children` | Select all children of the current node | normal: `` <A-I> ``, `` <S-A-down> ``, select: `` <A-I> ``, `` <S-A-down> `` |
+| `jump_forward` | Jump forward on jumplist | normal: `` <C-i> ``, `` <tab> ``, select: `` <C-i> ``, `` <tab> `` |
+| `jump_backward` | Jump backward on jumplist | normal: `` <C-o> ``, select: `` <C-o> `` |
+| `save_selection` | Save current selection to jumplist | normal: `` <C-s> ``, select: `` <C-s> `` |
+| `jump_view_right` | Jump to right split | normal: `` <C-w>l ``, `` <space>wl ``, `` <C-w><C-l> ``, `` <C-w><right> ``, `` <space>w<C-l> ``, `` <space>w<right> ``, select: `` <C-w>l ``, `` <space>wl ``, `` <C-w><C-l> ``, `` <C-w><right> ``, `` <space>w<C-l> ``, `` <space>w<right> `` |
+| `jump_view_left` | Jump to left split | normal: `` <C-w>h ``, `` <space>wh ``, `` <C-w><C-h> ``, `` <C-w><left> ``, `` <space>w<C-h> ``, `` <space>w<left> ``, select: `` <C-w>h ``, `` <space>wh ``, `` <C-w><C-h> ``, `` <C-w><left> ``, `` <space>w<C-h> ``, `` <space>w<left> `` |
+| `jump_view_up` | Jump to split above | normal: `` <C-w>k ``, `` <C-w><up> ``, `` <space>wk ``, `` <C-w><C-k> ``, `` <space>w<up> ``, `` <space>w<C-k> ``, select: `` <C-w>k ``, `` <C-w><up> ``, `` <space>wk ``, `` <C-w><C-k> ``, `` <space>w<up> ``, `` <space>w<C-k> `` |
+| `jump_view_down` | Jump to split below | normal: `` <C-w>j ``, `` <space>wj ``, `` <C-w><C-j> ``, `` <C-w><down> ``, `` <space>w<C-j> ``, `` <space>w<down> ``, select: `` <C-w>j ``, `` <space>wj ``, `` <C-w><C-j> ``, `` <C-w><down> ``, `` <space>w<C-j> ``, `` <space>w<down> `` |
+| `swap_view_right` | Swap with right split | normal: `` <C-w>L ``, `` <space>wL ``, select: `` <C-w>L ``, `` <space>wL `` |
+| `swap_view_left` | Swap with left split | normal: `` <C-w>H ``, `` <space>wH ``, select: `` <C-w>H ``, `` <space>wH `` |
+| `swap_view_up` | Swap with split above | normal: `` <C-w>K ``, `` <space>wK ``, select: `` <C-w>K ``, `` <space>wK `` |
+| `swap_view_down` | Swap with split below | normal: `` <C-w>J ``, `` <space>wJ ``, select: `` <C-w>J ``, `` <space>wJ `` |
+| `transpose_view` | Transpose splits | normal: `` <C-w>t ``, `` <space>wt ``, `` <C-w><C-t> ``, `` <space>w<C-t> ``, select: `` <C-w>t ``, `` <space>wt ``, `` <C-w><C-t> ``, `` <space>w<C-t> `` |
+| `rotate_view` | Goto next window | normal: `` <C-w>w ``, `` <space>ww ``, `` <C-w><C-w> ``, `` <space>w<C-w> ``, select: `` <C-w>w ``, `` <space>ww ``, `` <C-w><C-w> ``, `` <space>w<C-w> `` |
+| `rotate_view_reverse` | Goto previous window |  |
+| `hsplit` | Horizontal bottom split | normal: `` <C-w>s ``, `` <space>ws ``, `` <C-w><C-s> ``, `` <space>w<C-s> ``, select: `` <C-w>s ``, `` <space>ws ``, `` <C-w><C-s> ``, `` <space>w<C-s> `` |
+| `hsplit_new` | Horizontal bottom split scratch buffer | normal: `` <C-w>ns ``, `` <space>wns ``, `` <C-w>n<C-s> ``, `` <space>wn<C-s> ``, select: `` <C-w>ns ``, `` <space>wns ``, `` <C-w>n<C-s> ``, `` <space>wn<C-s> `` |
+| `vsplit` | Vertical right split | normal: `` <C-w>v ``, `` <space>wv ``, `` <C-w><C-v> ``, `` <space>w<C-v> ``, select: `` <C-w>v ``, `` <space>wv ``, `` <C-w><C-v> ``, `` <space>w<C-v> `` |
+| `vsplit_new` | Vertical right split scratch buffer | normal: `` <C-w>nv ``, `` <space>wnv ``, `` <C-w>n<C-v> ``, `` <space>wn<C-v> ``, select: `` <C-w>nv ``, `` <space>wnv ``, `` <C-w>n<C-v> ``, `` <space>wn<C-v> `` |
+| `wclose` | Close window | normal: `` <C-w>q ``, `` <space>wq ``, `` <C-w><C-q> ``, `` <space>w<C-q> ``, select: `` <C-w>q ``, `` <space>wq ``, `` <C-w><C-q> ``, `` <space>w<C-q> `` |
+| `wonly` | Close windows except current | normal: `` <C-w>o ``, `` <space>wo ``, `` <C-w><C-o> ``, `` <space>w<C-o> ``, select: `` <C-w>o ``, `` <space>wo ``, `` <C-w><C-o> ``, `` <space>w<C-o> `` |
+| `select_register` | Select register | normal: `` " ``, select: `` " `` |
+| `insert_register` | Insert register | insert: `` <C-r> `` |
+| `copy_between_registers` | Copy between two registers |  |
+| `align_view_middle` | Align view middle | normal: `` Zm ``, `` zm ``, select: `` Zm ``, `` zm `` |
+| `align_view_top` | Align view top | normal: `` Zt ``, `` zt ``, select: `` Zt ``, `` zt `` |
+| `align_view_center` | Align view center | normal: `` Zc ``, `` Zz ``, `` zc ``, `` zz ``, select: `` Zc ``, `` Zz ``, `` zc ``, `` zz `` |
+| `align_view_bottom` | Align view bottom | normal: `` Zb ``, `` zb ``, select: `` Zb ``, `` zb `` |
+| `scroll_up` | Scroll view up | normal: `` Zk ``, `` zk ``, `` Z<up> ``, `` z<up> ``, select: `` Zk ``, `` zk ``, `` Z<up> ``, `` z<up> `` |
+| `scroll_down` | Scroll view down | normal: `` Zj ``, `` zj ``, `` Z<down> ``, `` z<down> ``, select: `` Zj ``, `` zj ``, `` Z<down> ``, `` z<down> `` |
+| `match_brackets` | Goto matching bracket | normal: `` mm ``, select: `` mm `` |
+| `surround_add` | Surround add | normal: `` ms ``, select: `` ms `` |
+| `surround_replace` | Surround replace | normal: `` mr ``, select: `` mr `` |
+| `surround_delete` | Surround delete | normal: `` md ``, select: `` md `` |
+| `select_textobject_around` | Select around object | normal: `` ma ``, select: `` ma `` |
+| `select_textobject_inner` | Select inside object | normal: `` mi ``, select: `` mi `` |
+| `goto_next_function` | Goto next function | normal: `` ]f ``, select: `` ]f `` |
+| `goto_prev_function` | Goto previous function | normal: `` [f ``, select: `` [f `` |
+| `goto_next_class` | Goto next type definition | normal: `` ]t ``, select: `` ]t `` |
+| `goto_prev_class` | Goto previous type definition | normal: `` [t ``, select: `` [t `` |
+| `goto_next_parameter` | Goto next parameter | normal: `` ]a ``, select: `` ]a `` |
+| `goto_prev_parameter` | Goto previous parameter | normal: `` [a ``, select: `` [a `` |
+| `goto_next_comment` | Goto next comment | normal: `` ]c ``, select: `` ]c `` |
+| `goto_prev_comment` | Goto previous comment | normal: `` [c ``, select: `` [c `` |
+| `goto_next_test` | Goto next test | normal: `` ]T ``, select: `` ]T `` |
+| `goto_prev_test` | Goto previous test | normal: `` [T ``, select: `` [T `` |
+| `goto_next_entry` | Goto next pairing | normal: `` ]e ``, select: `` ]e `` |
+| `goto_prev_entry` | Goto previous pairing | normal: `` [e ``, select: `` [e `` |
+| `goto_next_paragraph` | Goto next paragraph | normal: `` ]p ``, select: `` ]p `` |
+| `goto_prev_paragraph` | Goto previous paragraph | normal: `` [p ``, select: `` [p `` |
+| `dap_launch` | Launch debug target | normal: `` <space>Gl ``, select: `` <space>Gl `` |
+| `dap_restart` | Restart debugging session | normal: `` <space>Gr ``, select: `` <space>Gr `` |
+| `dap_toggle_breakpoint` | Toggle breakpoint | normal: `` <space>Gb ``, select: `` <space>Gb `` |
+| `dap_continue` | Continue program execution | normal: `` <space>Gc ``, select: `` <space>Gc `` |
+| `dap_pause` | Pause program execution | normal: `` <space>Gh ``, select: `` <space>Gh `` |
+| `dap_step_in` | Step in | normal: `` <space>Gi ``, select: `` <space>Gi `` |
+| `dap_step_out` | Step out | normal: `` <space>Go ``, select: `` <space>Go `` |
+| `dap_next` | Step to next | normal: `` <space>Gn ``, select: `` <space>Gn `` |
+| `dap_variables` | List variables | normal: `` <space>Gv ``, select: `` <space>Gv `` |
+| `dap_terminate` | End debug session | normal: `` <space>Gt ``, select: `` <space>Gt `` |
+| `dap_edit_condition` | Edit breakpoint condition on current line | normal: `` <space>G<C-c> ``, select: `` <space>G<C-c> `` |
+| `dap_edit_log` | Edit breakpoint log message on current line | normal: `` <space>G<C-l> ``, select: `` <space>G<C-l> `` |
+| `dap_switch_thread` | Switch current thread | normal: `` <space>Gst ``, select: `` <space>Gst `` |
+| `dap_switch_stack_frame` | Switch stack frame | normal: `` <space>Gsf ``, select: `` <space>Gsf `` |
+| `dap_enable_exceptions` | Enable exception breakpoints | normal: `` <space>Ge ``, select: `` <space>Ge `` |
+| `dap_disable_exceptions` | Disable exception breakpoints | normal: `` <space>GE ``, select: `` <space>GE `` |
+| `shell_pipe` | Pipe selections through shell command | normal: `` \| ``, select: `` \| `` |
+| `shell_pipe_to` | Pipe selections into shell command ignoring output | normal: `` <A-\|> ``, select: `` <A-\|> `` |
+| `shell_insert_output` | Insert shell command output before selections | normal: `` ! ``, select: `` ! `` |
+| `shell_append_output` | Append shell command output after selections | normal: `` <A-!> ``, select: `` <A-!> `` |
+| `shell_keep_pipe` | Filter selections with shell predicate | normal: `` $ ``, select: `` $ `` |
+| `suspend` | Suspend and return to shell | normal: `` <C-z> ``, select: `` <C-z> `` |
+| `rename_symbol` | Rename symbol | normal: `` <space>r ``, select: `` <space>r `` |
+| `increment` | Increment item under cursor | normal: `` <C-a> ``, select: `` <C-a> `` |
+| `decrement` | Decrement item under cursor | normal: `` <C-x> ``, select: `` <C-x> `` |
+| `record_macro` | Record macro | normal: `` Q ``, select: `` Q `` |
+| `replay_macro` | Replay macro | normal: `` q ``, select: `` q `` |
+| `command_palette` | Open command palette | normal: `` <space>? ``, select: `` <space>? `` |
+| `goto_word` | Jump to a two-character label | normal: `` gw `` |
+| `extend_to_word` | Extend to a two-character label | select: `` gw `` |
+| `goto_next_tabstop` | goto next snippet placeholder |  |
+| `goto_prev_tabstop` | goto next snippet placeholder |  |
diff --git a/book/src/generated/typable-cmd.md b/book/src/generated/typable-cmd.md
index f48e1490a..55820e08b 100644
--- a/book/src/generated/typable-cmd.md
+++ b/book/src/generated/typable-cmd.md
@@ -16,7 +16,7 @@
 | `:write-buffer-close`, `:wbc` | Write changes to disk and closes the buffer. Accepts an optional path (:write-buffer-close some/path.txt) |
 | `:write-buffer-close!`, `:wbc!` | Force write changes to disk creating necessary subdirectories and closes the buffer. Accepts an optional path (:write-buffer-close! some/path.txt) |
 | `:new`, `:n` | Create a new scratch buffer. |
-| `:format`, `:fmt` | Format the file using the LSP formatter. |
+| `:format`, `:fmt` | Format the file using an external formatter or language server. |
 | `:indent-style` | Set the indentation style for editing. ('t' for tabs or 1-16 for number of spaces.) |
 | `:line-ending` | Set the document's default line ending. Options: crlf, lf. |
 | `:earlier`, `:ear` | Jump back to an earlier point in edit history. Accepts a number of steps or a time span. |
@@ -52,8 +52,8 @@
 | `:reload-all`, `:rla` | Discard changes and reload all documents from the source files. |
 | `:update`, `:u` | Write changes only if the file has been modified. |
 | `:lsp-workspace-command` | Open workspace command picker |
-| `:lsp-restart` | Restarts the language servers used by the current doc |
-| `:lsp-stop` | Stops the language servers that are used by the current doc |
+| `:lsp-restart` | Restarts the given language servers, or all language servers that are used by the current file if no arguments are supplied |
+| `:lsp-stop` | Stops the given language servers, or all language servers that are used by the current file if no arguments are supplied |
 | `:tree-sitter-scopes` | Display tree sitter scopes, primarily for theming and development. |
 | `:tree-sitter-highlight-name` | Display name of tree-sitter highlight scope under the cursor. |
 | `:debug-start`, `:dbg` | Start a debug session from a given template with given parameters. |
@@ -72,7 +72,7 @@
 | `:sort` | Sort ranges in selection. |
 | `:rsort` | Sort ranges in selection in reverse order. |
 | `:reflow` | Hard-wrap the current selection of lines to a given width. |
-| `:tree-sitter-subtree`, `:ts-subtree` | Display tree sitter subtree under cursor, primarily for debugging queries. |
+| `:tree-sitter-subtree`, `:ts-subtree` | Display the smallest tree-sitter subtree that spans the primary selection, primarily for debugging queries. |
 | `:config-reload` | Refresh user config. |
 | `:config-open` | Open the user config.toml file. |
 | `:config-open-workspace` | Open the workspace config.toml file. |
diff --git a/book/src/guides/adding_languages.md b/book/src/guides/adding_languages.md
index aa4bf0c5c..f98242155 100644
--- a/book/src/guides/adding_languages.md
+++ b/book/src/guides/adding_languages.md
@@ -34,16 +34,10 @@ ## Queries
 2. Create a new directory for the language with the path
    `runtime/queries/<name>/`.
 3. Refer to the
-   [tree-sitter website](https://tree-sitter.github.io/tree-sitter/syntax-highlighting#queries)
+   [tree-sitter website](https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#highlights)
    for more information on writing queries.
 4. A list of highlight captures can be found [on the themes page](https://docs.helix-editor.com/themes.html#scopes).
 
->  In Helix, the first matching query takes precedence when evaluating
-> queries, which is different from other editors such as Neovim where the last
-> matching query supersedes the ones before it. See
-> [this issue](https://github.com/helix-editor/helix/pull/1170#issuecomment-997294090)
-> for an example.
-
 ## Common issues
 
 - If you encounter errors when running Helix after switching branches, you may
diff --git a/book/src/guides/injection.md b/book/src/guides/injection.md
index c0f750941..729a2c99e 100644
--- a/book/src/guides/injection.md
+++ b/book/src/guides/injection.md
@@ -57,4 +57,4 @@ ## Predicates
 - `#any-of?` (standard):
 The first argument (a capture) must be one of the other arguments (strings).
 
-[upstream-docs]: http://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection
+[upstream-docs]: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection
diff --git a/book/src/guides/textobject.md b/book/src/guides/textobject.md
index 4d33ab676..2cf3d3bec 100644
--- a/book/src/guides/textobject.md
+++ b/book/src/guides/textobject.md
@@ -44,6 +44,6 @@ ## Queries for textobject based navigation
 `function.movement` should be defined only if the node captured by `function.around`
 doesn't make sense in a navigation context.
 
-[tree-sitter-queries]: https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax
-[tree-sitter-captures]: https://tree-sitter.github.io/tree-sitter/using-parsers#capturing-nodes
+[tree-sitter-queries]: https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html
+[tree-sitter-captures]: https://tree-sitter.github.io/tree-sitter/using-parsers/queries/2-operators.html#capturing-nodes
 [textobject-examples]: https://github.com/search?q=repo%3Ahelix-editor%2Fhelix+path%3A%2A%2A/textobjects.scm&type=Code&ref=advsearch&l=&l=
diff --git a/book/src/install.md b/book/src/install.md
index 387b8b658..6c536a881 100644
--- a/book/src/install.md
+++ b/book/src/install.md
@@ -8,7 +8,7 @@ # Installing Helix
 
 - To take full advantage of Helix, install the language servers for your
   preferred programming languages. See the
-  [wiki](https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers)
+  [wiki](https://github.com/helix-editor/helix/wiki/Language-Server-Configurations)
   for instructions.
 
 ## Pre-built binaries
diff --git a/book/src/keymap.md b/book/src/keymap.md
index e7ae6ae47..2797eaee2 100644
--- a/book/src/keymap.md
+++ b/book/src/keymap.md
@@ -112,39 +112,43 @@ #### Shell
 
 ### Selection manipulation
 
-| Key                   | Description                                                       | Command                              |
-| -----                 | -----------                                                       | -------                              |
-| `s`                   | Select all regex matches inside selections                        | `select_regex`                       |
-| `S`                   | Split selection into sub selections on regex matches              | `split_selection`                    |
-| `Alt-s`               | Split selection on newlines                                       | `split_selection_on_newline`         |
-| `Alt-minus`           | Merge selections                                                  | `merge_selections`                   |
-| `Alt-_`               | Merge consecutive selections                                      | `merge_consecutive_selections`       |
-| `&`                   | Align selection in columns                                        | `align_selections`                   |
-| `_`                   | Trim whitespace from the selection                                | `trim_selections`                    |
-| `;`                   | Collapse selection onto a single cursor                           | `collapse_selection`                 |
-| `Alt-;`               | Flip selection cursor and anchor                                  | `flip_selections`                    |
-| `Alt-:`               | Ensures the selection is in forward direction                     | `ensure_selections_forward`          |
-| `,`                   | Keep only the primary selection                                   | `keep_primary_selection`             |
-| `Alt-,`               | Remove the primary selection                                      | `remove_primary_selection`           |
-| `C`                   | Copy selection onto the next line (Add cursor below)              | `copy_selection_on_next_line`        |
-| `Alt-C`               | Copy selection onto the previous line (Add cursor above)          | `copy_selection_on_prev_line`        |
-| `(`                   | Rotate main selection backward                                    | `rotate_selections_backward`         |
-| `)`                   | Rotate main selection forward                                     | `rotate_selections_forward`          |
-| `Alt-(`               | Rotate selection contents backward                                | `rotate_selection_contents_backward` |
-| `Alt-)`               | Rotate selection contents forward                                 | `rotate_selection_contents_forward`  |
-| `%`                   | Select entire file                                                | `select_all`                         |
-| `x`                   | Select current line, if already selected, extend to next line     | `extend_line_below`                  |
-| `X`                   | Extend selection to line bounds (line-wise selection)             | `extend_to_line_bounds`              |
-| `Alt-x`               | Shrink selection to line bounds (line-wise selection)             | `shrink_to_line_bounds`              |
-| `J`                   | Join lines inside selection                                       | `join_selections`                    |
-| `Alt-J`               | Join lines inside selection and select the inserted space         | `join_selections_space`              |
-| `K`                   | Keep selections matching the regex                                | `keep_selections`                    |
-| `Alt-K`               | Remove selections matching the regex                              | `remove_selections`                  |
-| `Ctrl-c`              | Comment/uncomment the selections                                  | `toggle_comments`                    |
-| `Alt-o`, `Alt-up`     | Expand selection to parent syntax node (**TS**)                   | `expand_selection`                   |
-| `Alt-i`, `Alt-down`   | Shrink syntax tree object selection (**TS**)                      | `shrink_selection`                   |
-| `Alt-p`, `Alt-left`   | Select previous sibling node in syntax tree (**TS**)              | `select_prev_sibling`                |
-| `Alt-n`, `Alt-right`  | Select next sibling node in syntax tree (**TS**)                  | `select_next_sibling`                |
+| Key                      | Description                                                       | Command                              |
+| -----                    | -----------                                                       | -------                              |
+| `s`                      | Select all regex matches inside selections                        | `select_regex`                       |
+| `S`                      | Split selection into sub selections on regex matches              | `split_selection`                    |
+| `Alt-s`                  | Split selection on newlines                                       | `split_selection_on_newline`         |
+| `Alt-minus`              | Merge selections                                                  | `merge_selections`                   |
+| `Alt-_`                  | Merge consecutive selections                                      | `merge_consecutive_selections`       |
+| `&`                      | Align selection in columns                                        | `align_selections`                   |
+| `_`                      | Trim whitespace from the selection                                | `trim_selections`                    |
+| `;`                      | Collapse selection onto a single cursor                           | `collapse_selection`                 |
+| `Alt-;`                  | Flip selection cursor and anchor                                  | `flip_selections`                    |
+| `Alt-:`                  | Ensures the selection is in forward direction                     | `ensure_selections_forward`          |
+| `,`                      | Keep only the primary selection                                   | `keep_primary_selection`             |
+| `Alt-,`                  | Remove the primary selection                                      | `remove_primary_selection`           |
+| `C`                      | Copy selection onto the next line (Add cursor below)              | `copy_selection_on_next_line`        |
+| `Alt-C`                  | Copy selection onto the previous line (Add cursor above)          | `copy_selection_on_prev_line`        |
+| `(`                      | Rotate main selection backward                                    | `rotate_selections_backward`         |
+| `)`                      | Rotate main selection forward                                     | `rotate_selections_forward`          |
+| `Alt-(`                  | Rotate selection contents backward                                | `rotate_selection_contents_backward` |
+| `Alt-)`                  | Rotate selection contents forward                                 | `rotate_selection_contents_forward`  |
+| `%`                      | Select entire file                                                | `select_all`                         |
+| `x`                      | Select current line, if already selected, extend to next line     | `extend_line_below`                  |
+| `X`                      | Extend selection to line bounds (line-wise selection)             | `extend_to_line_bounds`              |
+| `Alt-x`                  | Shrink selection to line bounds (line-wise selection)             | `shrink_to_line_bounds`              |
+| `J`                      | Join lines inside selection                                       | `join_selections`                    |
+| `Alt-J`                  | Join lines inside selection and select the inserted space         | `join_selections_space`              |
+| `K`                      | Keep selections matching the regex                                | `keep_selections`                    |
+| `Alt-K`                  | Remove selections matching the regex                              | `remove_selections`                  |
+| `Ctrl-c`                 | Comment/uncomment the selections                                  | `toggle_comments`                    |
+| `Alt-o`, `Alt-up`        | Expand selection to parent syntax node (**TS**)                   | `expand_selection`                   |
+| `Alt-i`, `Alt-down`      | Shrink syntax tree object selection (**TS**)                      | `shrink_selection`                   |
+| `Alt-p`, `Alt-left`      | Select previous sibling node in syntax tree (**TS**)              | `select_prev_sibling`                |
+| `Alt-n`, `Alt-right`     | Select next sibling node in syntax tree (**TS**)                  | `select_next_sibling`                |
+| `Alt-a`                  | Select all sibling nodes in syntax tree (**TS**)                  | `select_all_siblings`                |
+| `Alt-I`, `Alt-Shift-down`| Select all children nodes in syntax tree (**TS**)                 | `select_all_children`                |
+| `Alt-e`                  | Move to end of parent node in syntax tree (**TS**)                | `move_parent_node_end`               |
+| `Alt-b`                  | Move to start of parent node in syntax tree (**TS**)              | `move_parent_node_start`             |
 
 ### Search
 
@@ -156,7 +160,8 @@ ### Search
 | `?`   | Search for previous pattern                 | `rsearch`            |
 | `n`   | Select next search match                    | `search_next`        |
 | `N`   | Select previous search match                | `search_prev`        |
-| `*`   | Use current selection as the search pattern | `search_selection`   |
+| `*`   | Use current selection as the search pattern, automatically wrapping with `\b` on word boundaries | `search_selection_detect_word_boundaries` |
+| `Alt-*` | Use current selection as the search pattern | `search_selection` |
 
 ### Minor modes
 
@@ -278,7 +283,7 @@ #### Space mode
 
 | Key     | Description                                                             | Command                                    |
 | -----   | -----------                                                             | -------                                    |
-| `f`     | Open file picker                                                        | `file_picker`                              |
+| `f`     | Open file picker at LSP workspace root                                  | `file_picker`                              |
 | `F`     | Open file picker at current working directory                           | `file_picker_in_current_directory`         |
 | `b`     | Open buffer picker                                                      | `buffer_picker`                            |
 | `j`     | Open jumplist picker                                                    | `jumplist_picker`                          |
diff --git a/book/src/languages.md b/book/src/languages.md
index fe105cced..8db121ce1 100644
--- a/book/src/languages.md
+++ b/book/src/languages.md
@@ -13,7 +13,7 @@ ## `languages.toml` files
 
 2. In your [configuration directory](./configuration.md). This overrides values
    from the built-in language configuration. For example, to disable
-   auto-LSP-formatting in Rust:
+   auto-formatting for Rust:
 
    ```toml
    # in <config_dir>/helix/languages.toml
@@ -60,15 +60,17 @@ ## Language configuration
 | `shebangs`            | The interpreters from the shebang line, for example `["sh", "bash"]` |
 | `roots`               | A set of marker files to look for when trying to find the workspace root. For example `Cargo.lock`, `yarn.lock` |
 | `auto-format`         | Whether to autoformat this language when saving               |
-| `diagnostic-severity` | Minimal severity of diagnostic for it to be displayed. (Allowed values: `Error`, `Warning`, `Info`, `Hint`) |
+| `diagnostic-severity` | Minimal severity of diagnostic for it to be displayed. (Allowed values: `error`, `warning`, `info`, `hint`) |
 | `comment-tokens`      | The tokens to use as a comment token, either a single token `"//"` or an array `["//", "///", "//!"]` (the first token will be used for commenting). Also configurable as `comment-token` for backwards compatibility|
 | `block-comment-tokens`| The start and end tokens for a multiline comment either an array or single table of `{ start = "/*", end = "*/"}`. The first set of tokens will be used for commenting, any pairs in the array can be uncommented |
 | `indent`              | The indent to use. Has sub keys `unit` (the text inserted into the document when indenting; usually set to N spaces or `"\t"` for tabs) and `tab-width` (the number of spaces rendered for a tab) |
 | `language-servers`    | The Language Servers used for this language. See below for more information in the section [Configuring Language Servers for a language](#configuring-language-servers-for-a-language)   |
 | `grammar`             | The tree-sitter grammar to use (defaults to the value of `name`) |
 | `formatter`           | The formatter for the language, it will take precedence over the lsp when defined. The formatter must be able to take the original file as input from stdin and write the formatted file to stdout |
-| `soft-wrap` | [editor.softwrap](./configuration.md#editorsoft-wrap-section)
+| `soft-wrap`           | [editor.softwrap](./editor.md#editorsoft-wrap-section)
 | `text-width`          |  Maximum line length. Used for the `:reflow` command and soft-wrapping if `soft-wrap.wrap-at-text-width` is set, defaults to `editor.text-width`   |
+| `rulers`              | Overrides the `editor.rulers` config key for the language. |
+| `path-completion`     | Overrides the `editor.path-completion` config key for the language. |
 | `workspace-lsp-roots`     | Directories relative to the workspace root that are treated as LSP roots. Should only be set in `.helix/config.toml`. Overwrites the setting of the same name in `config.toml` if set. |
 | `persistent-diagnostic-sources` | An array of LSP diagnostic sources assumed unchanged when the language server resends the same set of diagnostics. Helix can track the position for these diagnostics internally instead. Useful for diagnostics that are recomputed on save.
 
@@ -127,7 +129,7 @@ ## Language Server configuration
 | ----                       | -----------                                                                                                                       |
 | `command`                  | The name or path of the language server binary to execute. Binaries must be in `$PATH`                                            |
 | `args`                     | A list of arguments to pass to the language server binary                                                                         |
-| `config`                   | LSP initialization options                                                                                                        |
+| `config`                   | Language server initialization options                                                                                            |
 | `timeout`                  | The maximum time a request to the language server may take, in seconds. Defaults to `20`                                          |
 | `environment`              | Any environment variables that will be used when starting the language server `{ "KEY1" = "Value1", "KEY2" = "Value2" }`          |
 | `required-root-patterns`   | A list of `glob` patterns to look for in the working directory. The language server is started if at least one of them is found.  |
@@ -240,4 +242,4 @@ # or
 
 When omitted, all grammars are fetched and built.
 
-[treesitter-language-injection]: https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection
+[treesitter-language-injection]: https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection
diff --git a/book/src/package-managers.md b/book/src/package-managers.md
index 3cfd31003..c3b1f4e7d 100644
--- a/book/src/package-managers.md
+++ b/book/src/package-managers.md
@@ -1,7 +1,8 @@
 ## Package managers
 
 - [Linux](#linux)
-  - [Ubuntu](#ubuntu)
+  - [Ubuntu/Debian](#ubuntudebian)
+  - [Ubuntu (PPA)](#ubuntu-ppa)
   - [Fedora/RHEL](#fedorarhel)
   - [Arch Linux extra](#arch-linux-extra)
   - [NixOS](#nixos)
@@ -17,13 +18,20 @@ ## Package managers
   - [Chocolatey](#chocolatey)
   - [MSYS2](#msys2)
 
-[![Packaging status](https://repology.org/badge/vertical-allrepos/helix.svg)](https://repology.org/project/helix/versions)
+[![Packaging status](https://repology.org/badge/vertical-allrepos/helix-editor.svg)](https://repology.org/project/helix-editor/versions)
 
 ## Linux
 
 The following third party repositories are available:
 
-### Ubuntu
+### Ubuntu/Debian
+
+Install the Debian package from the release page.
+
+If you are running a system older than Ubuntu 22.04, Mint 21, or Debian 12, you can build the `.deb` file locally
+[from source](./building-from-source.md#building-the-debian-package).
+
+### Ubuntu (PPA)
 
 Add the `PPA` for Helix:
 
@@ -101,7 +109,15 @@ ### AppImage
 chmod +x helix-*.AppImage # change permission for executable mode
 ./helix-*.AppImage # run helix
 ```
- 
+
+You can optionally [add the `.desktop` file](./building-from-source.md#configure-the-desktop-shortcut). Helix must be installed in `PATH` with the name `hx`. For example:
+```sh
+mkdir -p "$HOME/.local/bin"
+mv helix-*.AppImage "$HOME/.local/bin/hx"
+```
+
+and make sure `~/.local/bin` is in your `PATH`.
+
 ## macOS
 
 ### Homebrew Core
@@ -113,7 +129,7 @@ ### Homebrew Core
 ### MacPorts
 
 ```sh
-port install helix
+sudo port install helix
 ```
 
 ## Windows
diff --git a/book/src/pickers.md b/book/src/pickers.md
index 4149e560b..67a195a65 100644
--- a/book/src/pickers.md
+++ b/book/src/pickers.md
@@ -4,7 +4,7 @@ ## Using pickers
 
 ### Filtering Picker Results
 
-Most pickers perform fuzzy matching using [fzf syntax](https://github.com/junegunn/fzf?tab=readme-ov-file#search-syntax). Two exceptions are the global search picker, which uses regex, and the workspace symbol picker, which passes search terms to the LSP. Note that OR operations (`|`) are not currently supported.
+Most pickers perform fuzzy matching using [fzf syntax](https://github.com/junegunn/fzf?tab=readme-ov-file#search-syntax). Two exceptions are the global search picker, which uses regex, and the workspace symbol picker, which passes search terms to the language server. Note that OR operations (`|`) are not currently supported.
 
 If a picker shows multiple columns, you may apply the filter to a specific column by prefixing the column name with `%`. Column names can be shortened to any prefix, so `%p`, `%pa` or `%pat` all mean the same as `%path`. For example, a query of `helix %p .toml !lang` in the global search picker searches for the term "helix" within files with paths ending in ".toml" but not including "lang".
 
diff --git a/book/src/remapping.md b/book/src/remapping.md
index 4fb92109e..4eb14c558 100644
--- a/book/src/remapping.md
+++ b/book/src/remapping.md
@@ -4,10 +4,31 @@ ## Key remapping
 file. (More powerful solutions such as rebinding via commands will be
 available in the future).
 
+There are three kinds of commands that can be used in keymaps:
+
+* Static commands: commands like `move_char_right` which are usually bound to
+  keys and used for movement and editing. A list of static commands is
+  available in the [Keymap](./keymap.html) documentation and in the source code
+  in [`helix-term/src/commands.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands.rs)
+  at the invocation of `static_commands!` macro.
+* Typable commands: commands that can be executed from command mode (`:`), for
+  example `:write!`. See the [Commands](./commands.html) documentation for a
+  list of available typeable commands or the `TypableCommandList` declaration in
+  the source code at [`helix-term/src/commands/typed.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands/typed.rs).
+* Macros: sequences of keys that are executed in order. These keybindings
+  start with `@` and then list any number of keys to be executed. For example
+  `@miw` can be used to select the surrounding word. For now, macro keybindings
+  are not allowed in keybinding sequences due to limitations in the way that
+  command sequences are executed. Modifier keys (e.g. Alt+o) can be used
+  like `"<A-o>"`, e.g. `"@miw<A-o>"`
+
 To remap keys, create a `config.toml` file in your `helix` configuration
 directory (default `~/.config/helix` on Linux systems) with a structure like
 this:
 
+>  To set a modifier + key as a keymap, type `A-X = ...` or  `C-X = ...` for Alt + X or Ctrl + X. Combine with Shift using a dash, e.g. `C-S-esc`. 
+> Within macros, wrap them in `<>`, e.g. `<A-X>` and `<C-X>` to distinguish from the `A` or `C` keys.
+
 ```toml
 # At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'
 [keys.normal]
@@ -18,13 +39,7 @@ # At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'
 "C-S-esc" = "extend_line" # Maps Ctrl-Shift-Escape to extend_line
 g = { a = "code_action" } # Maps `ga` to show possible code actions
 "ret" = ["open_below", "normal_mode"] # Maps the enter key to open_below then re-enter normal mode
-
-# You can create labeled sub-menus and provide friendly labels for typeable commands
-[keys.normal.space.f] # Registering multiple mappings under a single entry creates a sub-menu (accessed by 'space', 'f' in this case)
-label = "File" # The menu is called file and within it:
-f = "file_picker" # 'f' opens the file picker
-s = { label = "Save", command = ":write" } # 's' saves the current file
-c = { label = "Edit Config", command = ":open ~/.config/helix/config.toml" } # 'c' opens the helix config file
+"A-x" = "@x<A-d>" # Maps Alt-x to a macro selecting the whole line and deleting it without yanking it
 
 [keys.insert]
 "A-x" = "normal_mode"     # Maps Alt-X to enter normal mode
@@ -57,15 +72,28 @@ # create a new minor mode bound to `+`
 
 ## Special keys and modifiers
 
-Ctrl, Shift and Alt modifiers are encoded respectively with the prefixes
-`C-`, `S-` and `A-`. Special keys are encoded as follows:
+Ctrl, Shift and Alt modifiers are encoded respectively with the prefixes `C-`, `S-` and `A-`.
+
+The [Super key](https://en.wikipedia.org/wiki/Super_key_(keyboard_button)) - the Windows/Linux
+key or the Command key on Mac keyboards - is also supported when using a terminal emulator that
+supports the [enhanced keyboard protocol](https://github.com/helix-editor/helix/wiki/Terminal-Support#enhanced-keyboard-protocol).
+The super key is encoded with prefixes `Meta-`, `Cmd-` or `Win-`. These are all synonyms for the
+super modifier - binding a key with a `Win-` modifier will mean it can be used with the
+Windows/Linux key or the Command key.
+
+```toml
+[keys.normal]
+C-s = ":write" # Ctrl and 's' to write
+Cmd-s = ":write" # Cmd or Win or Meta and 's' to write
+```
+
+Special keys are encoded as follows:
 
 | Key name     | Representation |
 | ---          | ---            |
 | Backspace    | `"backspace"`  |
 | Space        | `"space"`      |
 | Return/Enter | `"ret"`        |
-| \-           | `"minus"`      |
 | Left         | `"left"`       |
 | Right        | `"right"`      |
 | Up           | `"up"`         |
@@ -82,20 +110,13 @@ ## Special keys and modifiers
 
 Keys can be disabled by binding them to the `no_op` command.
 
-## Commands
+All other keys such as `?`, `!`, `-` etc. can be used literally:
 
-There are three kinds of commands that can be used in keymaps:
+```toml
+[keys.normal]
+"?" = ":write"
+"!" = ":write"
+"-" = ":write"
+```
 
-* Static commands: commands like `move_char_right` which are usually bound to
-  keys and used for movement and editing. A list of static commands is
-  available in the [Keymap](./keymap.html) documentation and in the source code
-  in [`helix-term/src/commands.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands.rs)
-  at the invocation of `static_commands!` macro and the `TypableCommandList`.
-* Typable commands: commands that can be executed from command mode (`:`), for
-  example `:write!`. See the [Commands](./commands.html) documentation for a
-  list of available typeable commands.
-* Macros: sequences of keys that are executed in order. These keybindings
-  start with `@` and then list any number of keys to be executed. For example
-  `@miw` can be used to select the surrounding word. For now, macro keybindings
-  are not allowed in keybinding sequences due to limitations in the way that
-  command sequences are executed.
+Note: `-` can't be used when combined with a modifier, for example `Alt` + `-` should be written as `A-minus`. `A--` is not accepted.
diff --git a/book/src/themes.md b/book/src/themes.md
index 1bc2627dd..412d17efc 100644
--- a/book/src/themes.md
+++ b/book/src/themes.md
@@ -136,7 +136,7 @@ ### Scopes
 
 #### Syntax highlighting
 
-These keys match [tree-sitter scopes](https://tree-sitter.github.io/tree-sitter/syntax-highlighting#theme).
+These keys match [tree-sitter scopes](https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#highlights).
 
 When determining styling for a highlight, the longest matching theme key will be used. For example, if the highlight is `function.builtin.static`, the key `function.builtin` will be used instead of `function`.
 
@@ -283,7 +283,6 @@ #### Interface
 | `ui.debug.active`                 | Indicator for the line at which debugging execution is paused at, found in the gutter          |
 | `ui.gutter`                       | Gutter                                                                                         |
 | `ui.gutter.selected`              | Gutter for the line the cursor is on                                                           |
-| `ui.highlight.frameline`          | Line at which debugging execution is paused at                                                 |
 | `ui.linenr`                       | Line numbers                                                                                   |
 | `ui.linenr.selected`              | Line number for the line the cursor is on                                                      |
 | `ui.statusline`                   | Statusline                                                                                     |
@@ -297,7 +296,7 @@ #### Interface
 | `ui.bufferline.background`        | Style for bufferline background                                                                |
 | `ui.popup`                        | Documentation popups (e.g. Space + k)                                                          |
 | `ui.popup.info`                   | Prompt for multiple key options                                                                |
-| `ui.picker.header`                | Header row area in pickers with multiple columns                                              |
+| `ui.picker.header`                | Header row area in pickers with multiple columns                                               |
 | `ui.picker.header.column`         | Column names in pickers with multiple columns                                                  |
 | `ui.picker.header.column.active`  | The column name in pickers with multiple columns where the cursor is entering into.            |
 | `ui.window`                       | Borderlines separating splits                                                                  |
@@ -306,12 +305,13 @@ #### Interface
 | `ui.text.focus`                   | The currently selected line in the picker                                                      |
 | `ui.text.inactive`                | Same as `ui.text` but when the text is inactive (e.g. suggestions)                             |
 | `ui.text.info`                    | The key: command text in `ui.popup.info` boxes                                                 |
+| `ui.text.directory`               | Directory names in prompt completion                                                           |
 | `ui.virtual.ruler`                | Ruler columns (see the [`editor.rulers` config][editor-section])                               |
 | `ui.virtual.whitespace`           | Visible whitespace characters                                                                  |
 | `ui.virtual.indent-guide`         | Vertical indent width guides                                                                   |
 | `ui.virtual.inlay-hint`           | Default style for inlay hints of all kinds                                                     |
-| `ui.virtual.inlay-hint.parameter` | Style for inlay hints of kind `parameter` (LSPs are not required to set a kind)                |
-| `ui.virtual.inlay-hint.type`      | Style for inlay hints of kind `type` (LSPs are not required to set a kind)                     |
+| `ui.virtual.inlay-hint.parameter` | Style for inlay hints of kind `parameter` (language servers are not required to set a kind)    |
+| `ui.virtual.inlay-hint.type`      | Style for inlay hints of kind `type` (language servers are not required to set a kind)         |
 | `ui.virtual.wrap`                 | Soft-wrap indicator (see the [`editor.soft-wrap` config][editor-section])                      |
 | `ui.virtual.jump-label`           | Style for virtual jump labels                                                                  |
 | `ui.menu`                         | Code and command completion menus                                                              |
@@ -320,6 +320,7 @@ #### Interface
 | `ui.selection`                    | For selections in the editing area                                                             |
 | `ui.selection.primary`            |                                                                                                |
 | `ui.highlight`                    | Highlighted lines in the picker preview                                                        |
+| `ui.highlight.frameline`          | Line at which debugging execution is paused at                                                 |
 | `ui.cursorline.primary`           | The line of the primary cursor ([if cursorline is enabled][editor-section])                    |
 | `ui.cursorline.secondary`         | The lines of any other cursors ([if cursorline is enabled][editor-section])                    |
 | `ui.cursorcolumn.primary`         | The column of the primary cursor ([if cursorcolumn is enabled][editor-section])                |
@@ -335,5 +336,6 @@ #### Interface
 | `diagnostic.error`                | Diagnostics error (editing area)                                                               |
 | `diagnostic.unnecessary`          | Diagnostics with unnecessary tag (editing area)                                                |
 | `diagnostic.deprecated`           | Diagnostics with deprecated tag (editing area)                                                 |
+| `tabstop`                         | Snippet placeholder                                                                            |
 
 [editor-section]: ./configuration.md#editor-section
diff --git a/book/src/usage.md b/book/src/usage.md
index 859cb6709..b0d77613c 100644
--- a/book/src/usage.md
+++ b/book/src/usage.md
@@ -7,3 +7,27 @@ # Using Helix
 >  Currently, not all functionality is fully documented, please refer to the
 > [key mappings](./keymap.md) list.
 
+## Modes
+
+Helix is a modal editor, meaning it has different modes for different tasks. The main modes are:
+
+* [Normal mode](./keymap.md#normal-mode): For navigation and editing commands. This is the default mode.
+* [Insert mode](./keymap.md#insert-mode): For typing text directly into the document. Access by typing `i` in normal mode.
+* [Select/extend mode](./keymap.md#select--extend-mode): For making selections and performing operations on them. Access by typing `v` in normal mode.
+
+## Buffers
+
+Buffers are in-memory representations of files. You can have multiple buffers open at once. Use [pickers](./pickers.md) or commands like `:buffer-next` and `:buffer-previous` to open buffers or switch between them.
+
+## Selection-first editing
+
+Inspired by [Kakoune](http://kakoune.org/), Helix follows the `selection  action` model. This means that whatever you are going to act on (a word, a paragraph, a line, etc.) is selected first and the action itself (delete, change, yank, etc.) comes second. A cursor is simply a single width selection.
+
+## Multiple selections
+
+Also inspired by Kakoune, multiple selections are a core mode of interaction in Helix. For example, the standard way of replacing multiple instances of a word is to first select all instances (so there is one selection per instance) and then use the change action (`c`) to edit them all at the same time.
+
+## Motions
+
+Motions are commands that move the cursor or modify selections. They're used for navigation and text manipulation. Examples include `w` to move to the next word, or `f` to find a character. See the [Movement](./keymap.md#movement) section of the keymap for more motions.
+
diff --git a/book/theme/index.hbs b/book/theme/index.hbs
index 0a0bc5501..0a46ac649 100644
--- a/book/theme/index.hbs
+++ b/book/theme/index.hbs
@@ -1,5 +1,5 @@
 <!DOCTYPE HTML>
-<html lang="{{ language }}" class="{{ default_theme }}" dir="{{ text_direction }}">
+<html lang="{{ language }}" class="{{ default_theme }} sidebar-visible" dir="{{ text_direction }}">
     <head>
         <!-- Book generated using mdBook -->
         <meta charset="UTF-8">
@@ -52,15 +52,17 @@
         <!-- MathJax -->
         <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
         {{/if}}
-    </head>
-    <body class="sidebar-visible no-js">
-    <div id="body-container">
+
         <!-- Provide site root to javascript -->
         <script>
             var path_to_root = "{{ path_to_root }}";
             var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "{{ preferred_dark_theme }}" : "{{ default_theme }}";
         </script>
-
+        <!-- Start loading toc.js asap -->
+        <script src="{{ path_to_root }}toc.js"></script>
+    </head>
+    <body>
+    <div id="body-container">
         <!-- Work around some values being stored in localStorage wrapped in quotes -->
         <script>
             try {
@@ -82,19 +84,16 @@
             var theme;
             try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
             if (theme === null || theme === undefined) { theme = default_theme; }
-            var html = document.querySelector('html');
+            const html = document.documentElement;
             html.classList.remove('{{ default_theme }}')
             html.classList.add(theme);
-            var body = document.querySelector('body');
-            body.classList.remove('no-js')
-            body.classList.add('js');
+            html.classList.add("js");
         </script>
 
         <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">
 
         <!-- Hide / unhide sidebar before it is displayed -->
         <script>
-            var body = document.querySelector('body');
             var sidebar = null;
             var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
             if (document.body.clientWidth >= 1080) {
@@ -104,39 +103,21 @@
                 sidebar = 'hidden';
             }
             sidebar_toggle.checked = sidebar === 'visible';
-            body.classList.remove('sidebar-visible');
-            body.classList.add("sidebar-" + sidebar);
+            html.classList.remove('sidebar-visible');
+            html.classList.add("sidebar-" + sidebar);
         </script>
 
         <nav id="sidebar" class="sidebar" aria-label="Table of contents">
-            <div class="sidebar-scrollbox">
-                {{#toc}}{{/toc}}
+            <!-- populated by js -->
+            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
+            <noscript>
+                <iframe class="sidebar-iframe-outer" src="{{ path_to_root }}toc.html"></iframe>
+            </noscript>
+            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
+                <div class="sidebar-resize-indicator"></div>
             </div>
-            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
         </nav>
 
-        <!-- Track and set sidebar scroll position -->
-        <script>
-            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
-            sidebarScrollbox.addEventListener('click', function(e) {
-                if (e.target.tagName === 'A') {
-                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
-                }
-            }, { passive: true });
-            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
-            sessionStorage.removeItem('sidebar-scroll');
-            if (sidebarScrollTop) {
-                // preserve sidebar scroll position when navigating via links within sidebar
-                sidebarScrollbox.scrollTop = sidebarScrollTop;
-            } else {
-                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
-                var activeSection = document.querySelector('#sidebar .active');
-                if (activeSection) {
-                    activeSection.scrollIntoView({ block: 'center' });
-                }
-            }
-        </script>
-
         <div id="page-wrapper" class="page-wrapper">
 
             <div class="page">
diff --git a/contrib/Helix.appdata.xml b/contrib/Helix.appdata.xml
index 90b3d415a..b32bbebd1 100644
--- a/contrib/Helix.appdata.xml
+++ b/contrib/Helix.appdata.xml
@@ -47,6 +47,12 @@
   <content_rating type="oars-1.1" />
 
   <releases>
+    <release version="25.01.1" date="2025-01-19">
+      <url>https://github.com/helix-editor/helix/releases/tag/25.01.1</url>
+    </release>
+    <release version="25.01" date="2025-01-03">
+      <url>https://helix-editor.com/news/release-25-01-highlights/</url>
+    </release>
     <release version="24.07" date="2024-07-14">
       <url>https://github.com/helix-editor/helix/releases/tag/24.07</url>
     </release>
diff --git a/contrib/completion/hx.bash b/contrib/completion/hx.bash
index 1b102017b..37893bf56 100644
--- a/contrib/completion/hx.bash
+++ b/contrib/completion/hx.bash
@@ -9,23 +9,23 @@ _hx() {
 
     case "$prev" in
     -g | --grammar)
-        COMPREPLY=($(compgen -W 'fetch build' -- "$cur"))
+        mapfile -t COMPREPLY < <(compgen -W 'fetch build' -- "$cur")
         return 0
         ;;
     --health)
         languages=$(hx --health | tail -n '+7' | awk '{print $1}' | sed 's/\x1b\[[0-9;]*m//g')
-        COMPREPLY=($(compgen -W """$languages""" -- "$cur"))
+        mapfile -t COMPREPLY < <(compgen -W """$languages""" -- "$cur")
         return 0
         ;;
     esac
 
     case "$2" in
     -*)
-        COMPREPLY=($(compgen -W "-h --help --tutor -V --version -v -vv -vvv --health -g --grammar --vsplit --hsplit -c --config --log" -- """$2"""))
+        mapfile -t COMPREPLY < <(compgen -W "-h --help --tutor -V --version -v -vv -vvv --health -g --grammar --vsplit --hsplit -c --config --log" -- """$2""")
         return 0
         ;;
     *)
-        COMPREPLY=($(compgen -fd -- """$2"""))
+        mapfile -t COMPREPLY < <(compgen -fd -- """$2""")
         return 0
         ;;
     esac
diff --git a/contrib/completion/hx.elv b/contrib/completion/hx.elv
index 42c88585c..8d86ed7af 100644
--- a/contrib/completion/hx.elv
+++ b/contrib/completion/hx.elv
@@ -20,7 +20,7 @@ var config = [ "--config" "-c" ]
 set edit:completion:arg-completer[hx] = {|@args|
   var n = (count $args)
   if (>= $n 3) {
-    # Stop completions if passed arg will take presedence
+    # Stop completions if passed arg will take precedence
     # and invalidate further input
     if (has-value $skips $args[-2]) {
       return
diff --git a/contrib/completion/hx.nu b/contrib/completion/hx.nu
index c93d0b52a..e390cdad6 100644
--- a/contrib/completion/hx.nu
+++ b/contrib/completion/hx.nu
@@ -2,7 +2,7 @@
 #
 # NOTE: the `+N` syntax is not supported in Nushell (https://github.com/nushell/nushell/issues/13418)
 #       so it has not been specified here and will not be proposed in the autocompletion of Nushell.
-#       The help message won't be overriden though, so it will still be present here
+#       The help message won't be overridden though, so it will still be present here
 
 def health_categories [] {
     let languages = ^hx --health languages | detect columns | get Language | filter { $in != null }
diff --git a/contrib/hx_launcher.sh b/contrib/hx_launcher.sh
new file mode 100755
index 000000000..148f7776a
--- /dev/null
+++ b/contrib/hx_launcher.sh
@@ -0,0 +1,3 @@
+#!/usr/bin/env sh
+
+HELIX_RUNTIME=/usr/lib/helix/runtime exec /usr/lib/helix/hx "$@"
diff --git a/docs/CONTRIBUTING.md b/docs/CONTRIBUTING.md
index 86caff717..efb397169 100644
--- a/docs/CONTRIBUTING.md
+++ b/docs/CONTRIBUTING.md
@@ -15,6 +15,8 @@ # Contributing
 - If your preferred language is missing, integrating a tree-sitter grammar for
     it and defining syntax highlight queries for it is straight forward and
     doesn't require much knowledge of the internals.
+- If you don't use the Nix development shell and are getting your rust-analyzer binary from rustup, you may need to run `rustup component add rust-analyzer`.
+  This is because `rust-toolchain.toml` selects our MSRV for the development toolchain but doesn't download the matching rust-analyzer automatically.
 
 We provide an [architecture.md][architecture.md] that should give you
 a good overview of the internals.
@@ -59,10 +61,16 @@ ## Integration tests
 
 ## Minimum Stable Rust Version (MSRV) Policy
 
-Helix follows the MSRV of Firefox.
-The current MSRV and future changes to the MSRV are listed in the [Firefox documentation].
+Helix keeps an intentionally low MSRV for the sake of easy building and packaging
+downstream. We follow [Firefox's MSRV policy]. Once Firefox's MSRV increases we
+may bump ours as well, but be sure to check that popular distributions like Ubuntu
+package the new MSRV version. When increasing the MSRV, update these three places:
 
-[Firefox documentation]: https://firefox-source-docs.mozilla.org/writing-rust-code/update-policy.html
+* the `workspace.package.rust-version` key in `Cargo.toml` in the repository root
+* the `env.MSRV` key at the top of `.github/workflows/build.yml`
+* the `toolchain.channel` key in `rust-toolchain.toml`
+
+[Firefox's MSRV policy]: https://firefox-source-docs.mozilla.org/writing-rust-code/update-policy.html
 [good-first-issue]: https://github.com/helix-editor/helix/labels/E-easy
 [log-file]: https://github.com/helix-editor/helix/wiki/FAQ#access-the-log-file
 [architecture.md]: ./architecture.md
diff --git a/docs/releases.md b/docs/releases.md
index 84f95c97e..41b523c52 100644
--- a/docs/releases.md
+++ b/docs/releases.md
@@ -16,7 +16,7 @@ ## Checklist
     * Add new `<release>` entry in `contrib/Helix.appdata.xml` with release information according to the [AppStream spec](https://www.freedesktop.org/software/appstream/docs/sect-Metadata-Releases.html)
 * Tag and push
     * Switch to master and pull
-    * `git tag -s -m "<tag>" -a <tag> && git push` (note the `-s` which signs the tag)
+    * `git tag -s -m "<tag>" -a <tag> && git push origin <tag>` (note the `-s` which signs the tag)
 * Wait for the Release CI to finish
     * It will automatically turn the git tag into a GitHub release when it uploads artifacts
 * Edit the new release
diff --git a/flake.lock b/flake.lock
index 48fb4a59f..62ff34477 100644
--- a/flake.lock
+++ b/flake.lock
@@ -1,17 +1,12 @@
 {
   "nodes": {
     "crane": {
-      "inputs": {
-        "nixpkgs": [
-          "nixpkgs"
-        ]
-      },
       "locked": {
-        "lastModified": 1709610799,
-        "narHash": "sha256-5jfLQx0U9hXbi2skYMGodDJkIgffrjIOgMRjZqms2QE=",
+        "lastModified": 1737563566,
+        "narHash": "sha256-GLJvkOG29XCynQm8XWPyykMRqIhxKcBARVu7Ydrz02M=",
         "owner": "ipetkov",
         "repo": "crane",
-        "rev": "81c393c776d5379c030607866afef6406ca1be57",
+        "rev": "849376434956794ebc7a6b487d31aace395392ba",
         "type": "github"
       },
       "original": {
@@ -25,11 +20,11 @@
         "systems": "systems"
       },
       "locked": {
-        "lastModified": 1709126324,
-        "narHash": "sha256-q6EQdSeUZOG26WelxqkmR7kArjgWCdw5sfJVHPH/7j8=",
+        "lastModified": 1731533236,
+        "narHash": "sha256-l0KFg5HjrsfsO/JpG+r7fRrqm12kzFHyUHqHCVpMMbI=",
         "owner": "numtide",
         "repo": "flake-utils",
-        "rev": "d465f4819400de7c8d874d50b982301f28a84605",
+        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
         "type": "github"
       },
       "original": {
@@ -40,11 +35,11 @@
     },
     "nixpkgs": {
       "locked": {
-        "lastModified": 1709479366,
-        "narHash": "sha256-n6F0n8UV6lnTZbYPl1A9q1BS0p4hduAv1mGAP17CVd0=",
+        "lastModified": 1728018373,
+        "narHash": "sha256-NOiTvBbRLIOe5F6RbHaAh6++BNjsb149fGZd1T4+KBg=",
         "owner": "nixos",
         "repo": "nixpkgs",
-        "rev": "b8697e57f10292a6165a20f03d2f42920dfaf973",
+        "rev": "bc947f541ae55e999ffdb4013441347d83b00feb",
         "type": "github"
       },
       "original": {
@@ -64,19 +59,16 @@
     },
     "rust-overlay": {
       "inputs": {
-        "flake-utils": [
-          "flake-utils"
-        ],
         "nixpkgs": [
           "nixpkgs"
         ]
       },
       "locked": {
-        "lastModified": 1709604635,
-        "narHash": "sha256-le4fwmWmjGRYWwkho0Gr7mnnZndOOe4XGbLw68OvF40=",
+        "lastModified": 1737599167,
+        "narHash": "sha256-S2rHCrQWCDVp63XxL/AQbGr1g5M8Zx14C7Jooa4oM8o=",
         "owner": "oxalica",
         "repo": "rust-overlay",
-        "rev": "e86c0fb5d3a22a5f30d7f64ecad88643fe26449d",
+        "rev": "38374302ae9edf819eac666d1f276d62c712dd06",
         "type": "github"
       },
       "original": {
diff --git a/flake.nix b/flake.nix
index c7e4fdce5..1fda3fa94 100644
--- a/flake.nix
+++ b/flake.nix
@@ -6,15 +6,9 @@
     flake-utils.url = "github:numtide/flake-utils";
     rust-overlay = {
       url = "github:oxalica/rust-overlay";
-      inputs = {
-        nixpkgs.follows = "nixpkgs";
-        flake-utils.follows = "flake-utils";
-      };
-    };
-    crane = {
-      url = "github:ipetkov/crane";
       inputs.nixpkgs.follows = "nixpkgs";
     };
+    crane.url = "github:ipetkov/crane";
   };
 
   outputs = {
@@ -114,7 +108,7 @@
         if pkgs.stdenv.isLinux
         then pkgs.stdenv
         else pkgs.clangStdenv;
-      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux "-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment";
+      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux "-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable";
       rustToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;
       craneLibMSRV = (crane.mkLib pkgs).overrideToolchain rustToolchain;
       craneLibStable = (crane.mkLib pkgs).overrideToolchain pkgs.pkgsBuildHost.rust-bin.stable.latest.default;
@@ -144,6 +138,8 @@
               cp contrib/helix.png $out/share/icons/hicolor/256x256/apps
               installShellCompletion contrib/completion/hx.{bash,fish,zsh}
             '';
+            # set git revision for nix flake builds, see 'git_hash' in helix-loader/build.rs
+            HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;
           });
         helix = makeOverridableHelix self.packages.${system}.helix-unwrapped {};
         default = self.packages.${system}.helix;
diff --git a/grammars.nix b/grammars.nix
index 5152b5204..967b1b136 100644
--- a/grammars.nix
+++ b/grammars.nix
@@ -122,11 +122,11 @@
   }) grammarsToBuild;
   extensibleGrammars =
     lib.makeExtensible (self: builtins.listToAttrs builtGrammars);
-  overlayedGrammars = lib.pipe extensibleGrammars
+  overlaidGrammars = lib.pipe extensibleGrammars
     (builtins.map (overlay: grammar: grammar.extend overlay) grammarOverlays);
   grammarLinks = lib.mapAttrsToList
     (name: artifact: "ln -s ${artifact}/${name}.so $out/${name}.so")
-    (lib.filterAttrs (n: v: lib.isDerivation v) overlayedGrammars);
+    (lib.filterAttrs (n: v: lib.isDerivation v) overlaidGrammars);
 in
   runCommand "consolidated-helix-grammars" {} ''
     mkdir -p $out
diff --git a/helix-core/Cargo.toml b/helix-core/Cargo.toml
index 90eb747a9..ad229b710 100644
--- a/helix-core/Cargo.toml
+++ b/helix-core/Cargo.toml
@@ -18,35 +18,37 @@ integration = []
 [dependencies]
 helix-stdx = { path = "../helix-stdx" }
 helix-loader = { path = "../helix-loader" }
+helix-parsec = { path = "../helix-parsec" }
 
-ropey = { version = "1.6.1", default-features = false, features = ["simd"] }
+ropey.workspace = true
 smallvec = "1.13"
 smartstring = "1.0.1"
-unicode-segmentation = "1.11"
+unicode-segmentation.workspace = true
 # unicode-width is changing width definitions
 # that both break our logic and disagree with common
 # width definitions in terminals, we need to replace it.
 # For now lets lock the version to avoid rendering glitches
 # when installing without `--locked`
 unicode-width = "=0.1.12"
-unicode-general-category = "0.6"
+unicode-general-category = "1.0"
 slotmap.workspace = true
 tree-sitter.workspace = true
-once_cell = "1.19"
+once_cell = "1.20"
 arc-swap = "1"
 regex = "1"
-bitflags = "2.6"
+bitflags.workspace = true
 ahash = "0.8.11"
 hashbrown = { version = "0.14.5", features = ["raw"] }
 dunce = "1.0"
-url = "2.5.0"
+url = "2.5.4"
 
 log = "0.4"
+anyhow = "1.0"
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
 toml = "0.8"
 
-imara-diff = "0.1.7"
+imara-diff = "0.1.8"
 
 encoding_rs = "0.8"
 
@@ -57,7 +59,8 @@ textwrap = "0.16.1"
 
 nucleo.workspace = true
 parking_lot = "0.12"
-globset = "0.4.14"
+globset = "0.4.15"
+regex-cursor = "0.1.4"
 
 [dev-dependencies]
 quickcheck = { version = "1", default-features = false }
diff --git a/helix-core/src/case_conversion.rs b/helix-core/src/case_conversion.rs
new file mode 100644
index 000000000..2054a2bb5
--- /dev/null
+++ b/helix-core/src/case_conversion.rs
@@ -0,0 +1,69 @@
+use crate::Tendril;
+
+// todo: should this be grapheme aware?
+
+pub fn to_pascal_case(text: impl Iterator<Item = char>) -> Tendril {
+    let mut res = Tendril::new();
+    to_pascal_case_with(text, &mut res);
+    res
+}
+
+pub fn to_pascal_case_with(text: impl Iterator<Item = char>, buf: &mut Tendril) {
+    let mut at_word_start = true;
+    for c in text {
+        // we don't count _ as a word char here so case conversions work well
+        if !c.is_alphanumeric() {
+            at_word_start = true;
+            continue;
+        }
+        if at_word_start {
+            at_word_start = false;
+            buf.extend(c.to_uppercase());
+        } else {
+            buf.push(c)
+        }
+    }
+}
+
+pub fn to_upper_case_with(text: impl Iterator<Item = char>, buf: &mut Tendril) {
+    for c in text {
+        for c in c.to_uppercase() {
+            buf.push(c)
+        }
+    }
+}
+
+pub fn to_lower_case_with(text: impl Iterator<Item = char>, buf: &mut Tendril) {
+    for c in text {
+        for c in c.to_lowercase() {
+            buf.push(c)
+        }
+    }
+}
+
+pub fn to_camel_case(text: impl Iterator<Item = char>) -> Tendril {
+    let mut res = Tendril::new();
+    to_camel_case_with(text, &mut res);
+    res
+}
+pub fn to_camel_case_with(mut text: impl Iterator<Item = char>, buf: &mut Tendril) {
+    for c in &mut text {
+        if c.is_alphanumeric() {
+            buf.extend(c.to_lowercase())
+        }
+    }
+    let mut at_word_start = false;
+    for c in text {
+        // we don't count _ as a word char here so case conversions work well
+        if !c.is_alphanumeric() {
+            at_word_start = true;
+            continue;
+        }
+        if at_word_start {
+            at_word_start = false;
+            buf.extend(c.to_uppercase());
+        } else {
+            buf.push(c)
+        }
+    }
+}
diff --git a/helix-core/src/comment.rs b/helix-core/src/comment.rs
index 536b710ab..6bb1f300c 100644
--- a/helix-core/src/comment.rs
+++ b/helix-core/src/comment.rs
@@ -9,6 +9,24 @@
 use helix_stdx::rope::RopeSliceExt;
 use std::borrow::Cow;
 
+pub const DEFAULT_COMMENT_TOKEN: &str = "#";
+
+/// Returns the longest matching comment token of the given line (if it exists).
+pub fn get_comment_token<'a, S: AsRef<str>>(
+    text: RopeSlice,
+    tokens: &'a [S],
+    line_num: usize,
+) -> Option<&'a str> {
+    let line = text.line(line_num);
+    let start = line.first_non_whitespace_char()?;
+
+    tokens
+        .iter()
+        .map(AsRef::as_ref)
+        .filter(|token| line.slice(start..).starts_with(token))
+        .max_by_key(|token| token.len())
+}
+
 /// Given text, a comment token, and a set of line indices, returns the following:
 /// - Whether the given lines should be considered commented
 ///     - If any of the lines are uncommented, all lines are considered as such.
@@ -28,21 +46,20 @@ fn find_line_comment(
     let mut min = usize::MAX; // minimum col for first_non_whitespace_char
     let mut margin = 1;
     let token_len = token.chars().count();
+
     for line in lines {
         let line_slice = text.line(line);
         if let Some(pos) = line_slice.first_non_whitespace_char() {
             let len = line_slice.len_chars();
 
-            if pos < min {
-                min = pos;
-            }
+            min = std::cmp::min(min, pos);
 
             // line can be shorter than pos + token len
             let fragment = Cow::from(line_slice.slice(pos..std::cmp::min(pos + token.len(), len)));
 
+            // as soon as one of the non-blank lines doesn't have a comment, the whole block is
+            // considered uncommented.
             if fragment != token {
-                // as soon as one of the non-blank lines doesn't have a comment, the whole block is
-                // considered uncommented.
                 commented = false;
             }
 
@@ -56,6 +73,7 @@ fn find_line_comment(
             to_change.push(line);
         }
     }
+
     (commented, to_change, min, margin)
 }
 
@@ -63,7 +81,7 @@ fn find_line_comment(
 pub fn toggle_line_comments(doc: &Rope, selection: &Selection, token: Option<&str>) -> Transaction {
     let text = doc.slice(..);
 
-    let token = token.unwrap_or("//");
+    let token = token.unwrap_or(DEFAULT_COMMENT_TOKEN);
     let comment = Tendril::from(format!("{} ", token));
 
     let mut lines: Vec<usize> = Vec::with_capacity(selection.len());
@@ -129,10 +147,7 @@ pub fn find_block_comments(
     let mut only_whitespace = true;
     let mut comment_changes = Vec::with_capacity(selection.len());
     let default_tokens = tokens.first().cloned().unwrap_or_default();
-    // TODO: check if this can be removed on MSRV bump
-    #[allow(clippy::redundant_clone)]
     let mut start_token = default_tokens.start.clone();
-    #[allow(clippy::redundant_clone)]
     let mut end_token = default_tokens.end.clone();
 
     let mut tokens = tokens.to_vec();
@@ -189,13 +204,9 @@ pub fn find_block_comments(
                     range: *range,
                     start_pos,
                     end_pos,
-                    start_margin: selection_slice
-                        .get_char(after_start)
-                        .map_or(false, |c| c == ' '),
+                    start_margin: selection_slice.get_char(after_start) == Some(' '),
                     end_margin: after_start != before_end
-                        && selection_slice
-                            .get_char(before_end)
-                            .map_or(false, |c| c == ' '),
+                        && (selection_slice.get_char(before_end) == Some(' ')),
                     start_token: start_token.to_string(),
                     end_token: end_token.to_string(),
                 });
@@ -317,56 +328,87 @@ pub fn split_lines_of_selection(text: RopeSlice, selection: &Selection) -> Selec
 mod test {
     use super::*;
 
-    #[test]
-    fn test_find_line_comment() {
-        // four lines, two space indented, except for line 1 which is blank.
-        let mut doc = Rope::from("  1\n\n  2\n  3");
-        // select whole document
-        let mut selection = Selection::single(0, doc.len_chars() - 1);
+    mod find_line_comment {
+        use super::*;
 
-        let text = doc.slice(..);
+        #[test]
+        fn not_commented() {
+            // four lines, two space indented, except for line 1 which is blank.
+            let doc = Rope::from("  1\n\n  2\n  3");
 
-        let res = find_line_comment("//", text, 0..3);
-        // (commented = true, to_change = [line 0, line 2], min = col 2, margin = 0)
-        assert_eq!(res, (false, vec![0, 2], 2, 0));
+            let text = doc.slice(..);
 
-        // comment
-        let transaction = toggle_line_comments(&doc, &selection, None);
-        transaction.apply(&mut doc);
-        selection = selection.map(transaction.changes());
+            let res = find_line_comment("//", text, 0..3);
+            // (commented = false, to_change = [line 0, line 2], min = col 2, margin = 0)
+            assert_eq!(res, (false, vec![0, 2], 2, 0));
+        }
 
-        assert_eq!(doc, "  // 1\n\n  // 2\n  // 3");
+        #[test]
+        fn is_commented() {
+            // three lines where the second line is empty.
+            let doc = Rope::from("// hello\n\n// there");
 
-        // uncomment
-        let transaction = toggle_line_comments(&doc, &selection, None);
-        transaction.apply(&mut doc);
-        selection = selection.map(transaction.changes());
-        assert_eq!(doc, "  1\n\n  2\n  3");
-        assert!(selection.len() == 1); // to ignore the selection unused warning
+            let res = find_line_comment("//", doc.slice(..), 0..3);
 
-        // 0 margin comments
-        doc = Rope::from("  //1\n\n  //2\n  //3");
-        // reset the selection.
-        selection = Selection::single(0, doc.len_chars() - 1);
+            // (commented = true, to_change = [line 0, line 2], min = col 0, margin = 1)
+            assert_eq!(res, (true, vec![0, 2], 0, 1));
+        }
+    }
 
-        let transaction = toggle_line_comments(&doc, &selection, None);
-        transaction.apply(&mut doc);
-        selection = selection.map(transaction.changes());
-        assert_eq!(doc, "  1\n\n  2\n  3");
-        assert!(selection.len() == 1); // to ignore the selection unused warning
+    // TODO: account for uncommenting with uneven comment indentation
+    mod toggle_line_comment {
+        use super::*;
 
-        // 0 margin comments, with no space
-        doc = Rope::from("//");
-        // reset the selection.
-        selection = Selection::single(0, doc.len_chars() - 1);
+        #[test]
+        fn comment() {
+            // four lines, two space indented, except for line 1 which is blank.
+            let mut doc = Rope::from("  1\n\n  2\n  3");
+            // select whole document
+            let selection = Selection::single(0, doc.len_chars() - 1);
 
-        let transaction = toggle_line_comments(&doc, &selection, None);
-        transaction.apply(&mut doc);
-        selection = selection.map(transaction.changes());
-        assert_eq!(doc, "");
-        assert!(selection.len() == 1); // to ignore the selection unused warning
+            let transaction = toggle_line_comments(&doc, &selection, None);
+            transaction.apply(&mut doc);
+
+            assert_eq!(doc, "  # 1\n\n  # 2\n  # 3");
+        }
 
-        // TODO: account for uncommenting with uneven comment indentation
+        #[test]
+        fn uncomment() {
+            let mut doc = Rope::from("  # 1\n\n  # 2\n  # 3");
+            let mut selection = Selection::single(0, doc.len_chars() - 1);
+
+            let transaction = toggle_line_comments(&doc, &selection, None);
+            transaction.apply(&mut doc);
+            selection = selection.map(transaction.changes());
+
+            assert_eq!(doc, "  1\n\n  2\n  3");
+            assert!(selection.len() == 1); // to ignore the selection unused warning
+        }
+
+        #[test]
+        fn uncomment_0_margin_comments() {
+            let mut doc = Rope::from("  #1\n\n  #2\n  #3");
+            let mut selection = Selection::single(0, doc.len_chars() - 1);
+
+            let transaction = toggle_line_comments(&doc, &selection, None);
+            transaction.apply(&mut doc);
+            selection = selection.map(transaction.changes());
+
+            assert_eq!(doc, "  1\n\n  2\n  3");
+            assert!(selection.len() == 1); // to ignore the selection unused warning
+        }
+
+        #[test]
+        fn uncomment_0_margin_comments_with_no_space() {
+            let mut doc = Rope::from("#");
+            let mut selection = Selection::single(0, doc.len_chars() - 1);
+
+            let transaction = toggle_line_comments(&doc, &selection, None);
+            transaction.apply(&mut doc);
+            selection = selection.map(transaction.changes());
+            assert_eq!(doc, "");
+            assert!(selection.len() == 1); // to ignore the selection unused warning
+        }
     }
 
     #[test]
@@ -413,4 +455,32 @@ fn test_find_block_comments() {
         transaction.apply(&mut doc);
         assert_eq!(doc, "");
     }
+
+    /// Test, if `get_comment_tokens` works, even if the content of the file includes chars, whose
+    /// byte size unequal the amount of chars
+    #[test]
+    fn test_get_comment_with_char_boundaries() {
+        let rope = Rope::from("");
+        let tokens = ["//", "///"];
+
+        assert_eq!(
+            super::get_comment_token(rope.slice(..), tokens.as_slice(), 0),
+            None
+        );
+    }
+
+    /// Test for `get_comment_token`.
+    ///
+    /// Assuming the comment tokens are stored as `["///", "//"]`, `get_comment_token` should still
+    /// return `///` instead of `//` if the user is in a doc-comment section.
+    #[test]
+    fn test_use_longest_comment() {
+        let text = Rope::from("    /// amogus");
+        let tokens = ["///", "//"];
+
+        assert_eq!(
+            super::get_comment_token(text.slice(..), tokens.as_slice(), 0),
+            Some("///")
+        );
+    }
 }
diff --git a/helix-core/src/completion.rs b/helix-core/src/completion.rs
new file mode 100644
index 000000000..29c86b738
--- /dev/null
+++ b/helix-core/src/completion.rs
@@ -0,0 +1,25 @@
+use std::borrow::Cow;
+
+use crate::{diagnostic::LanguageServerId, Transaction};
+
+#[derive(Debug, PartialEq, Clone)]
+pub struct CompletionItem {
+    pub transaction: Transaction,
+    pub label: Cow<'static, str>,
+    pub kind: Cow<'static, str>,
+    /// Containing Markdown
+    pub documentation: Option<String>,
+    pub provider: CompletionProvider,
+}
+
+#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
+pub enum CompletionProvider {
+    Lsp(LanguageServerId),
+    Path,
+}
+
+impl From<LanguageServerId> for CompletionProvider {
+    fn from(id: LanguageServerId) -> Self {
+        CompletionProvider::Lsp(id)
+    }
+}
diff --git a/helix-core/src/diagnostic.rs b/helix-core/src/diagnostic.rs
index 4e89361d2..333c94096 100644
--- a/helix-core/src/diagnostic.rs
+++ b/helix-core/src/diagnostic.rs
@@ -1,6 +1,7 @@
 //! LSP diagnostic utility types.
 use std::fmt;
 
+pub use helix_stdx::range::Range;
 use serde::{Deserialize, Serialize};
 
 /// Describes the severity level of a [`Diagnostic`].
@@ -19,19 +20,6 @@ fn default() -> Self {
     }
 }
 
-/// A range of `char`s within the text.
-#[derive(Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq)]
-pub struct Range {
-    pub start: usize,
-    pub end: usize,
-}
-
-impl Range {
-    pub fn contains(self, pos: usize) -> bool {
-        (self.start..self.end).contains(&pos)
-    }
-}
-
 #[derive(Debug, Eq, Hash, PartialEq, Clone, Deserialize, Serialize)]
 pub enum NumberOrString {
     Number(i32),
diff --git a/helix-core/src/doc_formatter.rs b/helix-core/src/doc_formatter.rs
index 3cfc15708..d74709420 100644
--- a/helix-core/src/doc_formatter.rs
+++ b/helix-core/src/doc_formatter.rs
@@ -19,10 +19,12 @@
 
 use unicode_segmentation::{Graphemes, UnicodeSegmentation};
 
+use helix_stdx::rope::{RopeGraphemes, RopeSliceExt};
+
 use crate::graphemes::{Grapheme, GraphemeStr};
 use crate::syntax::Highlight;
 use crate::text_annotations::TextAnnotations;
-use crate::{Position, RopeGraphemes, RopeSlice};
+use crate::{Position, RopeSlice};
 
 /// TODO make Highlight a u32 to reduce the size of this enum to a single word.
 #[derive(Debug, Clone, Copy)]
@@ -219,7 +221,7 @@ pub fn new_at_prev_checkpoint(
             text_fmt,
             annotations,
             visual_pos: Position { row: 0, col: 0 },
-            graphemes: RopeGraphemes::new(text.slice(block_char_idx..)),
+            graphemes: text.slice(block_char_idx..).graphemes(),
             char_pos: block_char_idx,
             exhausted: false,
             indent_level: None,
@@ -370,8 +372,8 @@ fn advance_to_next_word(&mut self) {
             match col.cmp(&(self.text_fmt.viewport_width as usize)) {
                 // The EOF char and newline chars are always selectable in helix. That means
                 // that wrapping happens "too-early" if a word fits a line perfectly. This
-                // is intentional so that all selectable graphemes are always visisble (and
-                // therefore the cursor never dissapears). However if the user manually set a
+                // is intentional so that all selectable graphemes are always visible (and
+                // therefore the cursor never disappears). However if the user manually set a
                 // lower softwrap width then this is undesirable. Just increasing the viewport-
                 // width by one doesn't work because if a line is wrapped multiple times then
                 // some words may extend past the specified width.
@@ -380,9 +382,10 @@ fn advance_to_next_word(&mut self) {
                 // by a newline/eof character here.
                 Ordering::Equal
                     if self.text_fmt.soft_wrap_at_text_width
-                        && self.peek_grapheme(col, char_pos).map_or(false, |grapheme| {
-                            grapheme.is_newline() || grapheme.is_eof()
-                        }) => {}
+                        && self
+                            .peek_grapheme(col, char_pos)
+                            .is_some_and(|grapheme| grapheme.is_newline() || grapheme.is_eof()) => {
+                }
                 Ordering::Equal if word_width > self.text_fmt.max_wrap as usize => return,
                 Ordering::Greater if word_width > self.text_fmt.max_wrap as usize => {
                     self.peeked_grapheme = self.word_buf.pop();
diff --git a/helix-core/src/doc_formatter/test.rs b/helix-core/src/doc_formatter/test.rs
index 415ce8f6a..21be2e535 100644
--- a/helix-core/src/doc_formatter/test.rs
+++ b/helix-core/src/doc_formatter/test.rs
@@ -102,6 +102,14 @@ fn long_word_softwrap() {
     );
 }
 
+#[test]
+fn softwrap_multichar_grapheme() {
+    assert_eq!(
+        softwrap_text("xxxx xxxx xxx a\u{0301}bc\n"),
+        "xxxx xxxx xxx \n.abc \n "
+    )
+}
+
 fn softwrap_text_at_text_width(text: &str) -> String {
     let mut text_fmt = TextFormat::new_test(true);
     text_fmt.soft_wrap_at_text_width = true;
diff --git a/helix-core/src/graphemes.rs b/helix-core/src/graphemes.rs
index 91f11e620..33d237cb9 100644
--- a/helix-core/src/graphemes.rs
+++ b/helix-core/src/graphemes.rs
@@ -1,7 +1,7 @@
 //! Utility functions to traverse the unicode graphemes of a `Rope`'s text contents.
 //!
 //! Based on <https://github.com/cessen/led/blob/c4fa72405f510b7fd16052f90a598c429b3104a6/src/graphemes.rs>
-use ropey::{iter::Chunks, str_utils::byte_to_char_idx, RopeSlice};
+use ropey::{str_utils::byte_to_char_idx, RopeSlice};
 use unicode_segmentation::{GraphemeCursor, GraphemeIncomplete};
 use unicode_width::UnicodeWidthStr;
 
@@ -64,7 +64,7 @@ pub fn width(&self) -> usize {
     }
 
     pub fn is_whitespace(&self) -> bool {
-        !matches!(&self, Grapheme::Other { g } if !g.chars().all(char_is_whitespace))
+        !matches!(&self, Grapheme::Other { g } if !g.chars().next().is_some_and(char_is_whitespace))
     }
 
     // TODO currently word boundaries are used for softwrapping.
@@ -72,7 +72,7 @@ pub fn is_whitespace(&self) -> bool {
     // This could however be improved in the future by considering unicode
     // character classes but
     pub fn is_word_boundary(&self) -> bool {
-        !matches!(&self, Grapheme::Other { g,.. } if g.chars().all(char_is_word))
+        !matches!(&self, Grapheme::Other { g,.. } if g.chars().next().is_some_and(char_is_word))
     }
 }
 
@@ -119,6 +119,9 @@ pub fn grapheme_width(g: &str) -> usize {
     }
 }
 
+// NOTE: for byte indexing versions of these functions see `RopeSliceExt`'s
+// `floor_grapheme_boundary` and `ceil_grapheme_boundary` and the rope grapheme iterators.
+
 #[must_use]
 pub fn nth_prev_grapheme_boundary(slice: RopeSlice, char_idx: usize, n: usize) -> usize {
     // Bounds check
@@ -208,43 +211,6 @@ pub fn nth_next_grapheme_boundary(slice: RopeSlice, char_idx: usize, n: usize) -
     chunk_char_idx + tmp
 }
 
-#[must_use]
-pub fn nth_next_grapheme_boundary_byte(slice: RopeSlice, mut byte_idx: usize, n: usize) -> usize {
-    // Bounds check
-    debug_assert!(byte_idx <= slice.len_bytes());
-
-    // Get the chunk with our byte index in it.
-    let (mut chunk, mut chunk_byte_idx, mut _chunk_char_idx, _) = slice.chunk_at_byte(byte_idx);
-
-    // Set up the grapheme cursor.
-    let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);
-
-    // Find the nth next grapheme cluster boundary.
-    for _ in 0..n {
-        loop {
-            match gc.next_boundary(chunk, chunk_byte_idx) {
-                Ok(None) => return slice.len_bytes(),
-                Ok(Some(n)) => {
-                    byte_idx = n;
-                    break;
-                }
-                Err(GraphemeIncomplete::NextChunk) => {
-                    chunk_byte_idx += chunk.len();
-                    let (a, _, _c, _) = slice.chunk_at_byte(chunk_byte_idx);
-                    chunk = a;
-                    // chunk_char_idx = c;
-                }
-                Err(GraphemeIncomplete::PreContext(n)) => {
-                    let ctx_chunk = slice.chunk_at_byte(n - 1).0;
-                    gc.provide_context(ctx_chunk, n - ctx_chunk.len());
-                }
-                _ => unreachable!(),
-            }
-        }
-    }
-    byte_idx
-}
-
 /// Finds the next grapheme boundary after the given char position.
 #[must_use]
 #[inline(always)]
@@ -252,13 +218,6 @@ pub fn next_grapheme_boundary(slice: RopeSlice, char_idx: usize) -> usize {
     nth_next_grapheme_boundary(slice, char_idx, 1)
 }
 
-/// Finds the next grapheme boundary after the given byte position.
-#[must_use]
-#[inline(always)]
-pub fn next_grapheme_boundary_byte(slice: RopeSlice, byte_idx: usize) -> usize {
-    nth_next_grapheme_boundary_byte(slice, byte_idx, 1)
-}
-
 /// Returns the passed char index if it's already a grapheme boundary,
 /// or the next grapheme boundary char index if not.
 #[must_use]
@@ -311,187 +270,6 @@ pub fn is_grapheme_boundary(slice: RopeSlice, char_idx: usize) -> bool {
     }
 }
 
-/// Returns whether the given byte position is a grapheme boundary.
-#[must_use]
-pub fn is_grapheme_boundary_byte(slice: RopeSlice, byte_idx: usize) -> bool {
-    // Bounds check
-    debug_assert!(byte_idx <= slice.len_bytes());
-
-    // Get the chunk with our byte index in it.
-    let (chunk, chunk_byte_idx, _, _) = slice.chunk_at_byte(byte_idx);
-
-    // Set up the grapheme cursor.
-    let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);
-
-    // Determine if the given position is a grapheme cluster boundary.
-    loop {
-        match gc.is_boundary(chunk, chunk_byte_idx) {
-            Ok(n) => return n,
-            Err(GraphemeIncomplete::PreContext(n)) => {
-                let (ctx_chunk, ctx_byte_start, _, _) = slice.chunk_at_byte(n - 1);
-                gc.provide_context(ctx_chunk, ctx_byte_start);
-            }
-            Err(_) => unreachable!(),
-        }
-    }
-}
-
-/// An iterator over the graphemes of a `RopeSlice`.
-#[derive(Clone)]
-pub struct RopeGraphemes<'a> {
-    text: RopeSlice<'a>,
-    chunks: Chunks<'a>,
-    cur_chunk: &'a str,
-    cur_chunk_start: usize,
-    cursor: GraphemeCursor,
-}
-
-impl<'a> fmt::Debug for RopeGraphemes<'a> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_struct("RopeGraphemes")
-            .field("text", &self.text)
-            .field("chunks", &self.chunks)
-            .field("cur_chunk", &self.cur_chunk)
-            .field("cur_chunk_start", &self.cur_chunk_start)
-            // .field("cursor", &self.cursor)
-            .finish()
-    }
-}
-
-impl<'a> RopeGraphemes<'a> {
-    #[must_use]
-    pub fn new(slice: RopeSlice) -> RopeGraphemes {
-        let mut chunks = slice.chunks();
-        let first_chunk = chunks.next().unwrap_or("");
-        RopeGraphemes {
-            text: slice,
-            chunks,
-            cur_chunk: first_chunk,
-            cur_chunk_start: 0,
-            cursor: GraphemeCursor::new(0, slice.len_bytes(), true),
-        }
-    }
-}
-
-impl<'a> Iterator for RopeGraphemes<'a> {
-    type Item = RopeSlice<'a>;
-
-    fn next(&mut self) -> Option<RopeSlice<'a>> {
-        let a = self.cursor.cur_cursor();
-        let b;
-        loop {
-            match self
-                .cursor
-                .next_boundary(self.cur_chunk, self.cur_chunk_start)
-            {
-                Ok(None) => {
-                    return None;
-                }
-                Ok(Some(n)) => {
-                    b = n;
-                    break;
-                }
-                Err(GraphemeIncomplete::NextChunk) => {
-                    self.cur_chunk_start += self.cur_chunk.len();
-                    self.cur_chunk = self.chunks.next().unwrap_or("");
-                }
-                Err(GraphemeIncomplete::PreContext(idx)) => {
-                    let (chunk, byte_idx, _, _) = self.text.chunk_at_byte(idx.saturating_sub(1));
-                    self.cursor.provide_context(chunk, byte_idx);
-                }
-                _ => unreachable!(),
-            }
-        }
-
-        if a < self.cur_chunk_start {
-            Some(self.text.byte_slice(a..b))
-        } else {
-            let a2 = a - self.cur_chunk_start;
-            let b2 = b - self.cur_chunk_start;
-            Some((&self.cur_chunk[a2..b2]).into())
-        }
-    }
-}
-
-/// An iterator over the graphemes of a `RopeSlice` in reverse.
-#[derive(Clone)]
-pub struct RevRopeGraphemes<'a> {
-    text: RopeSlice<'a>,
-    chunks: Chunks<'a>,
-    cur_chunk: &'a str,
-    cur_chunk_start: usize,
-    cursor: GraphemeCursor,
-}
-
-impl<'a> fmt::Debug for RevRopeGraphemes<'a> {
-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        f.debug_struct("RevRopeGraphemes")
-            .field("text", &self.text)
-            .field("chunks", &self.chunks)
-            .field("cur_chunk", &self.cur_chunk)
-            .field("cur_chunk_start", &self.cur_chunk_start)
-            // .field("cursor", &self.cursor)
-            .finish()
-    }
-}
-
-impl<'a> RevRopeGraphemes<'a> {
-    #[must_use]
-    pub fn new(slice: RopeSlice) -> RevRopeGraphemes {
-        let (mut chunks, mut cur_chunk_start, _, _) = slice.chunks_at_byte(slice.len_bytes());
-        chunks.reverse();
-        let first_chunk = chunks.next().unwrap_or("");
-        cur_chunk_start -= first_chunk.len();
-        RevRopeGraphemes {
-            text: slice,
-            chunks,
-            cur_chunk: first_chunk,
-            cur_chunk_start,
-            cursor: GraphemeCursor::new(slice.len_bytes(), slice.len_bytes(), true),
-        }
-    }
-}
-
-impl<'a> Iterator for RevRopeGraphemes<'a> {
-    type Item = RopeSlice<'a>;
-
-    fn next(&mut self) -> Option<RopeSlice<'a>> {
-        let a = self.cursor.cur_cursor();
-        let b;
-        loop {
-            match self
-                .cursor
-                .prev_boundary(self.cur_chunk, self.cur_chunk_start)
-            {
-                Ok(None) => {
-                    return None;
-                }
-                Ok(Some(n)) => {
-                    b = n;
-                    break;
-                }
-                Err(GraphemeIncomplete::PrevChunk) => {
-                    self.cur_chunk = self.chunks.next().unwrap_or("");
-                    self.cur_chunk_start -= self.cur_chunk.len();
-                }
-                Err(GraphemeIncomplete::PreContext(idx)) => {
-                    let (chunk, byte_idx, _, _) = self.text.chunk_at_byte(idx.saturating_sub(1));
-                    self.cursor.provide_context(chunk, byte_idx);
-                }
-                _ => unreachable!(),
-            }
-        }
-
-        if a >= self.cur_chunk_start + self.cur_chunk.len() {
-            Some(self.text.byte_slice(b..a))
-        } else {
-            let a2 = a - self.cur_chunk_start;
-            let b2 = b - self.cur_chunk_start;
-            Some((&self.cur_chunk[b2..a2]).into())
-        }
-    }
-}
-
 /// A highly compressed Cow<'a, str> that holds
 /// atmost u31::MAX bytes and is readonly
 pub struct GraphemeStr<'a> {
@@ -542,7 +320,7 @@ fn from(g: &'a str) -> Self {
     }
 }
 
-impl<'a> From<String> for GraphemeStr<'a> {
+impl From<String> for GraphemeStr<'_> {
     fn from(g: String) -> Self {
         let len = g.len();
         let ptr = Box::into_raw(g.into_bytes().into_boxed_slice()) as *mut u8;
diff --git a/helix-core/src/indent.rs b/helix-core/src/indent.rs
index ae26c13e0..04ce9a28d 100644
--- a/helix-core/src/indent.rs
+++ b/helix-core/src/indent.rs
@@ -1,4 +1,4 @@
-use std::{borrow::Cow, collections::HashMap};
+use std::{borrow::Cow, collections::HashMap, iter};
 
 use helix_stdx::rope::RopeSliceExt;
 use tree_sitter::{Query, QueryCursor, QueryPredicateArg};
@@ -8,7 +8,7 @@
     graphemes::{grapheme_width, tab_width_at},
     syntax::{IndentationHeuristic, LanguageConfiguration, RopeProvider, Syntax},
     tree_sitter::Node,
-    Position, Rope, RopeGraphemes, RopeSlice,
+    Position, Rope, RopeSlice, Tendril,
 };
 
 /// Enum representing indentation style.
@@ -200,7 +200,7 @@ pub fn indent_level_for_line(line: RopeSlice, tab_width: usize, indent_width: us
 /// Create a string of tabs & spaces that has the same visual width as the given RopeSlice (independent of the tab width).
 fn whitespace_with_same_width(text: RopeSlice) -> String {
     let mut s = String::new();
-    for grapheme in RopeGraphemes::new(text) {
+    for grapheme in text.graphemes() {
         if grapheme == "\t" {
             s.push('\t');
         } else {
@@ -210,6 +210,36 @@ fn whitespace_with_same_width(text: RopeSlice) -> String {
     s
 }
 
+/// normalizes indentation to tabs/spaces based on user configuration
+/// This function does not change the actual indentation width, just the character
+/// composition.
+pub fn normalize_indentation(
+    prefix: RopeSlice<'_>,
+    line: RopeSlice<'_>,
+    dst: &mut Tendril,
+    indent_style: IndentStyle,
+    tab_width: usize,
+) -> usize {
+    #[allow(deprecated)]
+    let off = crate::visual_coords_at_pos(prefix, prefix.len_chars(), tab_width).col;
+    let mut len = 0;
+    let mut original_len = 0;
+    for ch in line.chars() {
+        match ch {
+            '\t' => len += tab_width_at(len + off, tab_width as u16),
+            ' ' => len += 1,
+            _ => break,
+        }
+        original_len += 1;
+    }
+    if indent_style == IndentStyle::Tabs {
+        dst.extend(iter::repeat('\t').take(len / tab_width));
+        len %= tab_width;
+    }
+    dst.extend(iter::repeat(' ').take(len));
+    original_len
+}
+
 fn add_indent_level(
     mut base_indent: String,
     added_indent_level: isize,
@@ -386,7 +416,7 @@ enum IndentCaptureType<'a> {
     Align(RopeSlice<'a>),
 }
 
-impl<'a> IndentCaptureType<'a> {
+impl IndentCaptureType<'_> {
     fn default_scope(&self) -> IndentScope {
         match self {
             IndentCaptureType::Indent | IndentCaptureType::IndentAlways => IndentScope::Tail,
@@ -426,7 +456,7 @@ struct IndentQueryResult<'a> {
 fn get_node_start_line(node: Node, new_line_byte_pos: Option<usize>) -> usize {
     let mut node_line = node.start_position().row;
     // Adjust for the new line that will be inserted
-    if new_line_byte_pos.map_or(false, |pos| node.start_byte() >= pos) {
+    if new_line_byte_pos.is_some_and(|pos| node.start_byte() >= pos) {
         node_line += 1;
     }
     node_line
@@ -434,7 +464,7 @@ fn get_node_start_line(node: Node, new_line_byte_pos: Option<usize>) -> usize {
 fn get_node_end_line(node: Node, new_line_byte_pos: Option<usize>) -> usize {
     let mut node_line = node.end_position().row;
     // Adjust for the new line that will be inserted (with a strict inequality since end_byte is exclusive)
-    if new_line_byte_pos.map_or(false, |pos| node.end_byte() > pos) {
+    if new_line_byte_pos.is_some_and(|pos| node.end_byte() > pos) {
         node_line += 1;
     }
     node_line
diff --git a/helix-core/src/lib.rs b/helix-core/src/lib.rs
index 9165560d0..89c960ed5 100644
--- a/helix-core/src/lib.rs
+++ b/helix-core/src/lib.rs
@@ -1,8 +1,10 @@
 pub use encoding_rs as encoding;
 
 pub mod auto_pairs;
+pub mod case_conversion;
 pub mod chars;
 pub mod comment;
+pub mod completion;
 pub mod config;
 pub mod diagnostic;
 pub mod diff;
@@ -21,6 +23,7 @@
 pub mod search;
 pub mod selection;
 pub mod shellwords;
+pub mod snippets;
 pub mod surround;
 pub mod syntax;
 pub mod test;
@@ -51,7 +54,6 @@ pub mod unicode {
 #[doc(inline)]
 pub use {regex, tree_sitter};
 
-pub use graphemes::RopeGraphemes;
 pub use position::{
     char_idx_at_visual_offset, coords_at_pos, pos_at_coords, softwrapped_dimensions,
     visual_offset_from_anchor, visual_offset_from_block, Position, VisualOffsetError,
@@ -63,6 +65,7 @@ pub mod unicode {
 pub use smallvec::{smallvec, SmallVec};
 pub use syntax::Syntax;
 
+pub use completion::CompletionItem;
 pub use diagnostic::Diagnostic;
 
 pub use line_ending::{LineEnding, NATIVE_LINE_ENDING};
diff --git a/helix-core/src/position.rs b/helix-core/src/position.rs
index 1b3789110..cea0b6071 100644
--- a/helix-core/src/position.rs
+++ b/helix-core/src/position.rs
@@ -4,10 +4,12 @@
     ops::{Add, AddAssign, Sub, SubAssign},
 };
 
+use helix_stdx::rope::RopeSliceExt;
+
 use crate::{
     chars::char_is_line_ending,
     doc_formatter::{DocumentFormatter, TextFormat},
-    graphemes::{ensure_grapheme_boundary_prev, grapheme_width, RopeGraphemes},
+    graphemes::{ensure_grapheme_boundary_prev, grapheme_width},
     line_ending::line_end_char_index,
     text_annotations::TextAnnotations,
     RopeSlice,
@@ -101,7 +103,7 @@ pub fn coords_at_pos(text: RopeSlice, pos: usize) -> Position {
 
     let line_start = text.line_to_char(line);
     let pos = ensure_grapheme_boundary_prev(text, pos);
-    let col = RopeGraphemes::new(text.slice(line_start..pos)).count();
+    let col = text.slice(line_start..pos).graphemes().count();
 
     Position::new(line, col)
 }
@@ -126,7 +128,7 @@ pub fn visual_coords_at_pos(text: RopeSlice, pos: usize, tab_width: usize) -> Po
 
     let mut col = 0;
 
-    for grapheme in RopeGraphemes::new(text.slice(line_start..pos)) {
+    for grapheme in text.slice(line_start..pos).graphemes() {
         if grapheme == "\t" {
             col += tab_width - (col % tab_width);
         } else {
@@ -275,7 +277,7 @@ pub fn pos_at_coords(text: RopeSlice, coords: Position, limit_before_line_ending
     };
 
     let mut col_char_offset = 0;
-    for (i, g) in RopeGraphemes::new(text.slice(line_start..line_end)).enumerate() {
+    for (i, g) in text.slice(line_start..line_end).graphemes().enumerate() {
         if i == col {
             break;
         }
@@ -306,7 +308,7 @@ pub fn pos_at_visual_coords(text: RopeSlice, coords: Position, tab_width: usize)
 
     let mut col_char_offset = 0;
     let mut cols_remaining = col;
-    for grapheme in RopeGraphemes::new(text.slice(line_start..line_end)) {
+    for grapheme in text.slice(line_start..line_end).graphemes() {
         let grapheme_width = if grapheme == "\t" {
             tab_width - ((col - cols_remaining) % tab_width)
         } else {
diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index a382a7186..1db2d619e 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -9,8 +9,9 @@
     },
     line_ending::get_line_ending,
     movement::Direction,
-    Assoc, ChangeSet, RopeGraphemes, RopeSlice,
+    Assoc, ChangeSet, RopeSlice,
 };
+use helix_stdx::range::is_subset;
 use helix_stdx::rope::{self, RopeSliceExt};
 use smallvec::{smallvec, SmallVec};
 use std::{borrow::Cow, iter, slice};
@@ -378,7 +379,7 @@ pub fn cursor_line(&self, text: RopeSlice) -> usize {
 
     /// Returns true if this Range covers a single grapheme in the given text
     pub fn is_single_grapheme(&self, doc: RopeSlice) -> bool {
-        let mut graphemes = RopeGraphemes::new(doc.slice(self.from()..self.to()));
+        let mut graphemes = doc.slice(self.from()..self.to()).graphemes();
         let first = graphemes.next();
         let second = graphemes.next();
         first.is_some() && second.is_none()
@@ -401,6 +402,15 @@ fn from((anchor, head): (usize, usize)) -> Self {
     }
 }
 
+impl From<Range> for helix_stdx::Range {
+    fn from(range: Range) -> Self {
+        Self {
+            start: range.from(),
+            end: range.to(),
+        }
+    }
+}
+
 /// A selection consists of one or more selection ranges.
 /// invariant: A selection can never be empty (always contains at least primary range).
 #[derive(Debug, Clone, PartialEq, Eq)]
@@ -513,6 +523,10 @@ pub fn line_ranges<'a>(&'a self, text: RopeSlice<'a>) -> LineRangeIter<'a> {
         }
     }
 
+    pub fn range_bounds(&self) -> impl Iterator<Item = helix_stdx::Range> + '_ {
+        self.ranges.iter().map(|&range| range.into())
+    }
+
     pub fn primary_index(&self) -> usize {
         self.primary_index
     }
@@ -605,7 +619,6 @@ pub fn merge_consecutive_ranges(mut self) -> Self {
         self
     }
 
-    // TODO: consume an iterator or a vec to reduce allocations?
     #[must_use]
     pub fn new(ranges: SmallVec<[Range; 1]>, primary_index: usize) -> Self {
         assert!(!ranges.is_empty());
@@ -660,7 +673,7 @@ pub fn cursors(self, text: RopeSlice) -> Self {
     pub fn fragments<'a>(
         &'a self,
         text: RopeSlice<'a>,
-    ) -> impl DoubleEndedIterator<Item = Cow<'a, str>> + ExactSizeIterator<Item = Cow<str>> + 'a
+    ) -> impl DoubleEndedIterator<Item = Cow<'a, str>> + ExactSizeIterator<Item = Cow<'a, str>>
     {
         self.ranges.iter().map(move |range| range.fragment(text))
     }
@@ -683,32 +696,9 @@ pub fn len(&self) -> usize {
         self.ranges.len()
     }
 
-    // returns true if self  other
+    /// returns true if self  other
     pub fn contains(&self, other: &Selection) -> bool {
-        let (mut iter_self, mut iter_other) = (self.iter(), other.iter());
-        let (mut ele_self, mut ele_other) = (iter_self.next(), iter_other.next());
-
-        loop {
-            match (ele_self, ele_other) {
-                (Some(ra), Some(rb)) => {
-                    if !ra.contains_range(rb) {
-                        // `self` doesn't contain next element from `other`, advance `self`, we need to match all from `other`
-                        ele_self = iter_self.next();
-                    } else {
-                        // matched element from `other`, advance `other`
-                        ele_other = iter_other.next();
-                    };
-                }
-                (None, Some(_)) => {
-                    // exhausted `self`, we can't match the reminder of `other`
-                    return false;
-                }
-                (_, None) => {
-                    // no elements from `other` left to match, `self` contains `other`
-                    return true;
-                }
-            }
-        }
+        is_subset::<true>(self.range_bounds(), other.range_bounds())
     }
 }
 
@@ -730,6 +720,12 @@ impl IntoIterator for Selection {
     }
 }
 
+impl FromIterator<Range> for Selection {
+    fn from_iter<T: IntoIterator<Item = Range>>(ranges: T) -> Self {
+        Self::new(ranges.into_iter().collect(), 0)
+    }
+}
+
 impl From<Range> for Selection {
     fn from(range: Range) -> Self {
         Self {
@@ -744,7 +740,7 @@ pub struct LineRangeIter<'a> {
     text: RopeSlice<'a>,
 }
 
-impl<'a> Iterator for LineRangeIter<'a> {
+impl Iterator for LineRangeIter<'_> {
     type Item = (usize, usize);
 
     fn next(&mut self) -> Option<Self::Item> {
diff --git a/helix-core/src/snippets.rs b/helix-core/src/snippets.rs
new file mode 100644
index 000000000..3dd3b9c3d
--- /dev/null
+++ b/helix-core/src/snippets.rs
@@ -0,0 +1,13 @@
+mod active;
+mod elaborate;
+mod parser;
+mod render;
+
+#[derive(PartialEq, Eq, Hash, Debug, PartialOrd, Ord, Clone, Copy)]
+pub struct TabstopIdx(usize);
+pub const LAST_TABSTOP_IDX: TabstopIdx = TabstopIdx(usize::MAX);
+
+pub use active::ActiveSnippet;
+pub use elaborate::{Snippet, SnippetElement, Transform};
+pub use render::RenderedSnippet;
+pub use render::SnippetRenderCtx;
diff --git a/helix-core/src/snippets/active.rs b/helix-core/src/snippets/active.rs
new file mode 100644
index 000000000..98007ab68
--- /dev/null
+++ b/helix-core/src/snippets/active.rs
@@ -0,0 +1,272 @@
+use std::ops::{Index, IndexMut};
+
+use hashbrown::HashSet;
+use helix_stdx::range::{is_exact_subset, is_subset};
+use helix_stdx::Range;
+use ropey::Rope;
+
+use crate::movement::Direction;
+use crate::snippets::render::{RenderedSnippet, Tabstop};
+use crate::snippets::TabstopIdx;
+use crate::{Assoc, ChangeSet, Selection, Transaction};
+
+pub struct ActiveSnippet {
+    ranges: Vec<Range>,
+    active_tabstops: HashSet<TabstopIdx>,
+    current_tabstop: TabstopIdx,
+    tabstops: Vec<Tabstop>,
+}
+
+impl Index<TabstopIdx> for ActiveSnippet {
+    type Output = Tabstop;
+    fn index(&self, index: TabstopIdx) -> &Tabstop {
+        &self.tabstops[index.0]
+    }
+}
+
+impl IndexMut<TabstopIdx> for ActiveSnippet {
+    fn index_mut(&mut self, index: TabstopIdx) -> &mut Tabstop {
+        &mut self.tabstops[index.0]
+    }
+}
+
+impl ActiveSnippet {
+    pub fn new(snippet: RenderedSnippet) -> Option<Self> {
+        let snippet = Self {
+            ranges: snippet.ranges,
+            tabstops: snippet.tabstops,
+            active_tabstops: HashSet::new(),
+            current_tabstop: TabstopIdx(0),
+        };
+        (snippet.tabstops.len() != 1).then_some(snippet)
+    }
+
+    pub fn is_valid(&self, new_selection: &Selection) -> bool {
+        is_subset::<false>(self.ranges.iter().copied(), new_selection.range_bounds())
+    }
+
+    pub fn tabstops(&self) -> impl Iterator<Item = &Tabstop> {
+        self.tabstops.iter()
+    }
+
+    pub fn delete_placeholder(&self, doc: &Rope) -> Transaction {
+        Transaction::delete(
+            doc,
+            self[self.current_tabstop]
+                .ranges
+                .iter()
+                .map(|range| (range.start, range.end)),
+        )
+    }
+
+    /// maps the active snippets through a `ChangeSet` updating all tabstop ranges
+    pub fn map(&mut self, changes: &ChangeSet) -> bool {
+        let positions_to_map = self.ranges.iter_mut().flat_map(|range| {
+            [
+                (&mut range.start, Assoc::After),
+                (&mut range.end, Assoc::Before),
+            ]
+        });
+        changes.update_positions(positions_to_map);
+
+        for (i, tabstop) in self.tabstops.iter_mut().enumerate() {
+            if self.active_tabstops.contains(&TabstopIdx(i)) {
+                let positions_to_map = tabstop.ranges.iter_mut().flat_map(|range| {
+                    let end_assoc = if range.start == range.end {
+                        Assoc::Before
+                    } else {
+                        Assoc::After
+                    };
+                    [
+                        (&mut range.start, Assoc::Before),
+                        (&mut range.end, end_assoc),
+                    ]
+                });
+                changes.update_positions(positions_to_map);
+            } else {
+                let positions_to_map = tabstop.ranges.iter_mut().flat_map(|range| {
+                    let end_assoc = if range.start == range.end {
+                        Assoc::After
+                    } else {
+                        Assoc::Before
+                    };
+                    [
+                        (&mut range.start, Assoc::After),
+                        (&mut range.end, end_assoc),
+                    ]
+                });
+                changes.update_positions(positions_to_map);
+            }
+            let mut snippet_ranges = self.ranges.iter();
+            let mut snippet_range = snippet_ranges.next().unwrap();
+            let mut tabstop_i = 0;
+            let mut prev = Range { start: 0, end: 0 };
+            let num_ranges = tabstop.ranges.len() / self.ranges.len();
+            tabstop.ranges.retain_mut(|range| {
+                if tabstop_i == num_ranges {
+                    snippet_range = snippet_ranges.next().unwrap();
+                    tabstop_i = 0;
+                }
+                tabstop_i += 1;
+                let retain = snippet_range.start <= snippet_range.end;
+                if retain {
+                    range.start = range.start.max(snippet_range.start);
+                    range.end = range.end.max(range.start).min(snippet_range.end);
+                    // guaranteed by assoc
+                    debug_assert!(prev.start <= range.start);
+                    debug_assert!(range.start <= range.end);
+                    if prev.end > range.start {
+                        // not really sure what to do in this case. It shouldn't
+                        // really occur in practice, the below just ensures
+                        // our invariants hold
+                        range.start = prev.end;
+                        range.end = range.end.max(range.start)
+                    }
+                    prev = *range;
+                }
+                retain
+            });
+        }
+        self.ranges.iter().all(|range| range.end <= range.start)
+    }
+
+    pub fn next_tabstop(&mut self, current_selection: &Selection) -> (Selection, bool) {
+        let primary_idx = self.primary_idx(current_selection);
+        while self.current_tabstop.0 + 1 < self.tabstops.len() {
+            self.current_tabstop.0 += 1;
+            if self.activate_tabstop() {
+                let selection = self.tabstop_selection(primary_idx, Direction::Forward);
+                return (selection, self.current_tabstop.0 + 1 == self.tabstops.len());
+            }
+        }
+
+        (
+            self.tabstop_selection(primary_idx, Direction::Forward),
+            true,
+        )
+    }
+
+    pub fn prev_tabstop(&mut self, current_selection: &Selection) -> Option<Selection> {
+        let primary_idx = self.primary_idx(current_selection);
+        while self.current_tabstop.0 != 0 {
+            self.current_tabstop.0 -= 1;
+            if self.activate_tabstop() {
+                return Some(self.tabstop_selection(primary_idx, Direction::Forward));
+            }
+        }
+        None
+    }
+    // computes the primary idx adjusted for the number of cursors in the current tabstop
+    fn primary_idx(&self, current_selection: &Selection) -> usize {
+        let primary: Range = current_selection.primary().into();
+        let res = self
+            .ranges
+            .iter()
+            .position(|&range| range.contains(primary));
+        res.unwrap_or_else(|| {
+            unreachable!(
+                "active snippet must be valid {current_selection:?} {:?}",
+                self.ranges
+            )
+        })
+    }
+
+    fn activate_tabstop(&mut self) -> bool {
+        let tabstop = &self[self.current_tabstop];
+        if tabstop.has_placeholder() && tabstop.ranges.iter().all(|range| range.is_empty()) {
+            return false;
+        }
+        self.active_tabstops.clear();
+        self.active_tabstops.insert(self.current_tabstop);
+        let mut parent = self[self.current_tabstop].parent;
+        while let Some(tabstop) = parent {
+            self.active_tabstops.insert(tabstop);
+            parent = self[tabstop].parent;
+        }
+        true
+        // TODO: if the user removes the selection(s) in one snippet (but
+        // there are still other cursors in other snippets) and jumps to the
+        // next tabstop the selection in that tabstop is restored (at the
+        // next tabstop). This could be annoying since its not possible to
+        // remove a snippet cursor until the snippet is complete. On the other
+        // hand it may be useful since the user may just have meant to edit
+        // a subselection (like with s) of the tabstops and so the selection
+        // removal was just temporary. Potentially this could have some sort of
+        // separate keymap
+    }
+
+    pub fn tabstop_selection(&self, primary_idx: usize, direction: Direction) -> Selection {
+        let tabstop = &self[self.current_tabstop];
+        tabstop.selection(direction, primary_idx, self.ranges.len())
+    }
+
+    pub fn insert_subsnippet(mut self, snippet: RenderedSnippet) -> Option<Self> {
+        if snippet.ranges.len() % self.ranges.len() != 0
+            || !is_exact_subset(self.ranges.iter().copied(), snippet.ranges.iter().copied())
+        {
+            log::warn!("number of subsnippets did not match, discarding outer snippet");
+            return ActiveSnippet::new(snippet);
+        }
+        let mut cnt = 0;
+        let parent = self[self.current_tabstop].parent;
+        let tabstops = snippet.tabstops.into_iter().map(|mut tabstop| {
+            cnt += 1;
+            if let Some(parent) = &mut tabstop.parent {
+                parent.0 += self.current_tabstop.0;
+            } else {
+                tabstop.parent = parent;
+            }
+            tabstop
+        });
+        self.tabstops
+            .splice(self.current_tabstop.0..=self.current_tabstop.0, tabstops);
+        self.activate_tabstop();
+        Some(self)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use std::iter::{self};
+
+    use ropey::Rope;
+
+    use crate::snippets::{ActiveSnippet, Snippet, SnippetRenderCtx};
+    use crate::{Selection, Transaction};
+
+    #[test]
+    fn fully_remove() {
+        let snippet = Snippet::parse("foo(${1:bar})$0").unwrap();
+        let mut doc = Rope::from("bar.\n");
+        let (transaction, _, snippet) = snippet.render(
+            &doc,
+            &Selection::point(4),
+            |_| (4, 4),
+            &mut SnippetRenderCtx::test_ctx(),
+        );
+        assert!(transaction.apply(&mut doc));
+        assert_eq!(doc, "bar.foo(bar)\n");
+        let mut snippet = ActiveSnippet::new(snippet).unwrap();
+        let edit = Transaction::change(&doc, iter::once((4, 12, None)));
+        assert!(edit.apply(&mut doc));
+        snippet.map(edit.changes());
+        assert!(!snippet.is_valid(&Selection::point(4)))
+    }
+
+    #[test]
+    fn tabstop_zero_with_placeholder() {
+        // The `$0` tabstop should not have placeholder text. When we receive a snippet like this
+        // (from older versions of clangd for example) we should discard the placeholder text.
+        let snippet = Snippet::parse("sizeof(${0:expression-or-type})").unwrap();
+        let mut doc = Rope::from("\n");
+        let (transaction, _, snippet) = snippet.render(
+            &doc,
+            &Selection::point(0),
+            |_| (0, 0),
+            &mut SnippetRenderCtx::test_ctx(),
+        );
+        assert!(transaction.apply(&mut doc));
+        assert_eq!(doc, "sizeof()\n");
+        assert!(ActiveSnippet::new(snippet).is_none());
+    }
+}
diff --git a/helix-core/src/snippets/elaborate.rs b/helix-core/src/snippets/elaborate.rs
new file mode 100644
index 000000000..012d1db77
--- /dev/null
+++ b/helix-core/src/snippets/elaborate.rs
@@ -0,0 +1,385 @@
+use std::mem::swap;
+use std::ops::Index;
+use std::sync::Arc;
+
+use anyhow::{anyhow, Result};
+use helix_stdx::rope::RopeSliceExt;
+use helix_stdx::Range;
+use regex_cursor::engines::meta::Builder as RegexBuilder;
+use regex_cursor::engines::meta::Regex;
+use regex_cursor::regex_automata::util::syntax::Config as RegexConfig;
+use ropey::RopeSlice;
+
+use crate::case_conversion::to_lower_case_with;
+use crate::case_conversion::to_upper_case_with;
+use crate::case_conversion::{to_camel_case_with, to_pascal_case_with};
+use crate::snippets::parser::{self, CaseChange, FormatItem};
+use crate::snippets::{TabstopIdx, LAST_TABSTOP_IDX};
+use crate::Tendril;
+
+#[derive(Debug)]
+pub struct Snippet {
+    elements: Vec<SnippetElement>,
+    tabstops: Vec<Tabstop>,
+}
+
+impl Snippet {
+    pub fn parse(snippet: &str) -> Result<Self> {
+        let parsed_snippet = parser::parse(snippet)
+            .map_err(|rest| anyhow!("Failed to parse snippet. Remaining input: {}", rest))?;
+        Ok(Snippet::new(parsed_snippet))
+    }
+
+    pub fn new(elements: Vec<parser::SnippetElement>) -> Snippet {
+        let mut res = Snippet {
+            elements: Vec::new(),
+            tabstops: Vec::new(),
+        };
+        res.elements = res.elaborate(elements, None).into();
+        res.fixup_tabstops();
+        res.ensure_last_tabstop();
+        res.renumber_tabstops();
+        res
+    }
+
+    pub fn elements(&self) -> &[SnippetElement] {
+        &self.elements
+    }
+
+    pub fn tabstops(&self) -> impl Iterator<Item = &Tabstop> {
+        self.tabstops.iter()
+    }
+
+    fn renumber_tabstops(&mut self) {
+        Self::renumber_tabstops_in(&self.tabstops, &mut self.elements);
+        for i in 0..self.tabstops.len() {
+            if let Some(parent) = self.tabstops[i].parent {
+                let parent = self
+                    .tabstops
+                    .binary_search_by_key(&parent, |tabstop| tabstop.idx)
+                    .expect("all tabstops have been resolved");
+                self.tabstops[i].parent = Some(TabstopIdx(parent));
+            }
+            let tabstop = &mut self.tabstops[i];
+            if let TabstopKind::Placeholder { default } = &tabstop.kind {
+                let mut default = default.clone();
+                tabstop.kind = TabstopKind::Empty;
+                Self::renumber_tabstops_in(&self.tabstops, Arc::get_mut(&mut default).unwrap());
+                self.tabstops[i].kind = TabstopKind::Placeholder { default };
+            }
+        }
+    }
+
+    fn renumber_tabstops_in(tabstops: &[Tabstop], elements: &mut [SnippetElement]) {
+        for elem in elements {
+            match elem {
+                SnippetElement::Tabstop { idx } => {
+                    idx.0 = tabstops
+                        .binary_search_by_key(&*idx, |tabstop| tabstop.idx)
+                        .expect("all tabstops have been resolved")
+                }
+                SnippetElement::Variable { default, .. } => {
+                    if let Some(default) = default {
+                        Self::renumber_tabstops_in(tabstops, default);
+                    }
+                }
+                SnippetElement::Text(_) => (),
+            }
+        }
+    }
+
+    fn fixup_tabstops(&mut self) {
+        self.tabstops.sort_by_key(|tabstop| tabstop.idx);
+        self.tabstops.dedup_by(|tabstop1, tabstop2| {
+            if tabstop1.idx != tabstop2.idx {
+                return false;
+            }
+            // use the first non empty tabstop for all multicursor tabstops
+            if tabstop2.kind.is_empty() {
+                swap(tabstop2, tabstop1)
+            }
+            true
+        })
+    }
+
+    fn ensure_last_tabstop(&mut self) {
+        if matches!(self.tabstops.last(), Some(tabstop) if tabstop.idx == LAST_TABSTOP_IDX) {
+            return;
+        }
+        self.tabstops.push(Tabstop {
+            idx: LAST_TABSTOP_IDX,
+            parent: None,
+            kind: TabstopKind::Empty,
+        });
+        self.elements.push(SnippetElement::Tabstop {
+            idx: LAST_TABSTOP_IDX,
+        })
+    }
+
+    fn elaborate(
+        &mut self,
+        default: Vec<parser::SnippetElement>,
+        parent: Option<TabstopIdx>,
+    ) -> Box<[SnippetElement]> {
+        default
+            .into_iter()
+            .map(|val| match val {
+                parser::SnippetElement::Tabstop {
+                    tabstop,
+                    transform: None,
+                } => SnippetElement::Tabstop {
+                    idx: self.elaborate_placeholder(tabstop, parent, Vec::new()),
+                },
+                parser::SnippetElement::Tabstop {
+                    tabstop,
+                    transform: Some(transform),
+                } => SnippetElement::Tabstop {
+                    idx: self.elaborate_transform(tabstop, parent, transform),
+                },
+                parser::SnippetElement::Placeholder { tabstop, value } => SnippetElement::Tabstop {
+                    idx: self.elaborate_placeholder(tabstop, parent, value),
+                },
+                parser::SnippetElement::Choice { tabstop, choices } => SnippetElement::Tabstop {
+                    idx: self.elaborate_choice(tabstop, parent, choices),
+                },
+                parser::SnippetElement::Variable {
+                    name,
+                    default,
+                    transform,
+                } => SnippetElement::Variable {
+                    name,
+                    default: default.map(|default| self.elaborate(default, parent)),
+                    // TODO: error for invalid transforms
+                    transform: transform.and_then(Transform::new).map(Box::new),
+                },
+                parser::SnippetElement::Text(text) => SnippetElement::Text(text),
+            })
+            .collect()
+    }
+
+    fn elaborate_choice(
+        &mut self,
+        idx: usize,
+        parent: Option<TabstopIdx>,
+        choices: Vec<Tendril>,
+    ) -> TabstopIdx {
+        let idx = TabstopIdx::elaborate(idx);
+        self.tabstops.push(Tabstop {
+            idx,
+            parent,
+            kind: TabstopKind::Choice {
+                choices: choices.into(),
+            },
+        });
+        idx
+    }
+
+    fn elaborate_placeholder(
+        &mut self,
+        idx: usize,
+        parent: Option<TabstopIdx>,
+        mut default: Vec<parser::SnippetElement>,
+    ) -> TabstopIdx {
+        let idx = TabstopIdx::elaborate(idx);
+        if idx == LAST_TABSTOP_IDX && !default.is_empty() {
+            // Older versions of clangd for example may send a snippet like `${0:placeholder}`
+            // which is considered by VSCode to be a misuse of the `$0` tabstop.
+            log::warn!("Discarding placeholder text for the `$0` tabstop ({default:?}). \
+                The `$0` tabstop signifies the final cursor position and should not include placeholder text.");
+            default.clear();
+        }
+        let default = self.elaborate(default, Some(idx));
+        self.tabstops.push(Tabstop {
+            idx,
+            parent,
+            kind: TabstopKind::Placeholder {
+                default: default.into(),
+            },
+        });
+        idx
+    }
+
+    fn elaborate_transform(
+        &mut self,
+        idx: usize,
+        parent: Option<TabstopIdx>,
+        transform: parser::Transform,
+    ) -> TabstopIdx {
+        let idx = TabstopIdx::elaborate(idx);
+        if let Some(transform) = Transform::new(transform) {
+            self.tabstops.push(Tabstop {
+                idx,
+                parent,
+                kind: TabstopKind::Transform(Arc::new(transform)),
+            })
+        } else {
+            // TODO: proper error
+            self.tabstops.push(Tabstop {
+                idx,
+                parent,
+                kind: TabstopKind::Empty,
+            })
+        }
+        idx
+    }
+}
+
+impl Index<TabstopIdx> for Snippet {
+    type Output = Tabstop;
+    fn index(&self, index: TabstopIdx) -> &Tabstop {
+        &self.tabstops[index.0]
+    }
+}
+
+#[derive(Debug)]
+pub enum SnippetElement {
+    Tabstop {
+        idx: TabstopIdx,
+    },
+    Variable {
+        name: Tendril,
+        default: Option<Box<[SnippetElement]>>,
+        transform: Option<Box<Transform>>,
+    },
+    Text(Tendril),
+}
+
+#[derive(Debug)]
+pub struct Tabstop {
+    idx: TabstopIdx,
+    pub parent: Option<TabstopIdx>,
+    pub kind: TabstopKind,
+}
+
+#[derive(Debug)]
+pub enum TabstopKind {
+    Choice { choices: Arc<[Tendril]> },
+    Placeholder { default: Arc<[SnippetElement]> },
+    Empty,
+    Transform(Arc<Transform>),
+}
+
+impl TabstopKind {
+    pub fn is_empty(&self) -> bool {
+        matches!(self, TabstopKind::Empty)
+    }
+}
+
+#[derive(Debug)]
+pub struct Transform {
+    regex: Regex,
+    regex_str: Box<str>,
+    global: bool,
+    replacement: Box<[FormatItem]>,
+}
+
+impl PartialEq for Transform {
+    fn eq(&self, other: &Self) -> bool {
+        self.replacement == other.replacement
+            && self.global == other.global
+            // doens't compare m and i setting but close enough
+            && self.regex_str == other.regex_str
+    }
+}
+
+impl Transform {
+    fn new(transform: parser::Transform) -> Option<Transform> {
+        let mut config = RegexConfig::new();
+        let mut global = false;
+        let mut invalid_config = false;
+        for c in transform.options.chars() {
+            match c {
+                'i' => {
+                    config = config.case_insensitive(true);
+                }
+                'm' => {
+                    config = config.multi_line(true);
+                }
+                'g' => {
+                    global = true;
+                }
+                // we ignore 'u' since we always want to
+                // do unicode aware matching
+                _ => invalid_config = true,
+            }
+        }
+        if invalid_config {
+            log::error!("invalid transform configuration characters {transform:?}");
+        }
+        let regex = match RegexBuilder::new().syntax(config).build(&transform.regex) {
+            Ok(regex) => regex,
+            Err(err) => {
+                log::error!("invalid transform {err} {transform:?}");
+                return None;
+            }
+        };
+        Some(Transform {
+            regex,
+            regex_str: transform.regex.as_str().into(),
+            global,
+            replacement: transform.replacement.into(),
+        })
+    }
+
+    pub fn apply(&self, mut doc: RopeSlice<'_>, range: Range) -> Tendril {
+        let mut buf = Tendril::new();
+        let it = self
+            .regex
+            .captures_iter(doc.regex_input_at(range))
+            .enumerate();
+        doc = doc.slice(range);
+        let mut last_match = 0;
+        for (_, cap) in it {
+            // unwrap on 0 is OK because captures only reports matches
+            let m = cap.get_group(0).unwrap();
+            buf.extend(doc.byte_slice(last_match..m.start).chunks());
+            last_match = m.end;
+            for fmt in &*self.replacement {
+                match *fmt {
+                    FormatItem::Text(ref text) => {
+                        buf.push_str(text);
+                    }
+                    FormatItem::Capture(i) => {
+                        if let Some(cap) = cap.get_group(i) {
+                            buf.extend(doc.byte_slice(cap.range()).chunks());
+                        }
+                    }
+                    FormatItem::CaseChange(i, change) => {
+                        if let Some(cap) = cap.get_group(i).filter(|i| !i.is_empty()) {
+                            let mut chars = doc.byte_slice(cap.range()).chars();
+                            match change {
+                                CaseChange::Upcase => to_upper_case_with(chars, &mut buf),
+                                CaseChange::Downcase => to_lower_case_with(chars, &mut buf),
+                                CaseChange::Capitalize => {
+                                    let first_char = chars.next().unwrap();
+                                    buf.extend(first_char.to_uppercase());
+                                    buf.extend(chars);
+                                }
+                                CaseChange::PascalCase => to_pascal_case_with(chars, &mut buf),
+                                CaseChange::CamelCase => to_camel_case_with(chars, &mut buf),
+                            }
+                        }
+                    }
+                    FormatItem::Conditional(i, ref if_, ref else_) => {
+                        if cap.get_group(i).map_or(true, |mat| mat.is_empty()) {
+                            buf.push_str(else_)
+                        } else {
+                            buf.push_str(if_)
+                        }
+                    }
+                }
+            }
+            if !self.global {
+                break;
+            }
+        }
+        buf.extend(doc.byte_slice(last_match..).chunks());
+        buf
+    }
+}
+
+impl TabstopIdx {
+    fn elaborate(idx: usize) -> Self {
+        TabstopIdx(idx.wrapping_sub(1))
+    }
+}
diff --git a/helix-core/src/snippets/parser.rs b/helix-core/src/snippets/parser.rs
new file mode 100644
index 000000000..74e940da8
--- /dev/null
+++ b/helix-core/src/snippets/parser.rs
@@ -0,0 +1,935 @@
+/*!
+A parser for LSP/VSCode style snippet syntax
+See <https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax>.
+
+``` text
+any         ::= tabstop | placeholder | choice | variable | text
+tabstop     ::= '$' int | '${' int '}'
+placeholder ::= '${' int ':' any '}'
+choice      ::= '${' int '|' text (',' text)* '|}'
+variable    ::= '$' var | '${' var }'
+                | '${' var ':' any '}'
+                | '${' var '/' regex '/' (format | text)+ '/' options '}'
+format      ::= '$' int | '${' int '}'
+                | '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
+                | '${' int ':+' if '}'
+                | '${' int ':?' if ':' else '}'
+                | '${' int ':-' else '}' | '${' int ':' else '}'
+regex       ::= Regular Expression value (ctor-string)
+options     ::= Regular Expression option (ctor-options)
+var         ::= [_a-zA-Z] [_a-zA-Z0-9]*
+int         ::= [0-9]+
+text        ::= .*
+if          ::= text
+else        ::= text
+```
+*/
+
+use crate::Tendril;
+use helix_parsec::*;
+
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
+pub enum CaseChange {
+    Upcase,
+    Downcase,
+    Capitalize,
+    PascalCase,
+    CamelCase,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum FormatItem {
+    Text(Tendril),
+    Capture(usize),
+    CaseChange(usize, CaseChange),
+    Conditional(usize, Tendril, Tendril),
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub struct Transform {
+    pub regex: Tendril,
+    pub replacement: Vec<FormatItem>,
+    pub options: Tendril,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum SnippetElement {
+    Tabstop {
+        tabstop: usize,
+        transform: Option<Transform>,
+    },
+    Placeholder {
+        tabstop: usize,
+        value: Vec<SnippetElement>,
+    },
+    Choice {
+        tabstop: usize,
+        choices: Vec<Tendril>,
+    },
+    Variable {
+        name: Tendril,
+        default: Option<Vec<SnippetElement>>,
+        transform: Option<Transform>,
+    },
+    Text(Tendril),
+}
+
+pub fn parse(s: &str) -> Result<Vec<SnippetElement>, &str> {
+    snippet().parse(s).and_then(|(remainder, snippet)| {
+        if remainder.is_empty() {
+            Ok(snippet)
+        } else {
+            Err(remainder)
+        }
+    })
+}
+
+fn var<'a>() -> impl Parser<'a, Output = &'a str> {
+    // var = [_a-zA-Z][_a-zA-Z0-9]*
+    move |input: &'a str| {
+        input
+            .char_indices()
+            .take_while(|(p, c)| {
+                *c == '_'
+                    || if *p == 0 {
+                        c.is_ascii_alphabetic()
+                    } else {
+                        c.is_ascii_alphanumeric()
+                    }
+            })
+            .last()
+            .map(|(index, c)| {
+                let index = index + c.len_utf8();
+                (&input[index..], &input[0..index])
+            })
+            .ok_or(input)
+    }
+}
+
+const TEXT_ESCAPE_CHARS: &[char] = &['\\', '}', '$'];
+const CHOICE_TEXT_ESCAPE_CHARS: &[char] = &['\\', '|', ','];
+
+fn text<'a>(
+    escape_chars: &'static [char],
+    term_chars: &'static [char],
+) -> impl Parser<'a, Output = Tendril> {
+    move |input: &'a str| {
+        let mut chars = input.char_indices().peekable();
+        let mut res = Tendril::new();
+        while let Some((i, c)) = chars.next() {
+            match c {
+                '\\' => {
+                    if let Some(&(_, c)) = chars.peek() {
+                        if escape_chars.contains(&c) {
+                            chars.next();
+                            res.push(c);
+                            continue;
+                        }
+                    }
+                    res.push('\\');
+                }
+                c if term_chars.contains(&c) => return Ok((&input[i..], res)),
+                c => res.push(c),
+            }
+        }
+
+        Ok(("", res))
+    }
+}
+
+fn digit<'a>() -> impl Parser<'a, Output = usize> {
+    filter_map(take_while(|c| c.is_ascii_digit()), |s| s.parse().ok())
+}
+
+fn case_change<'a>() -> impl Parser<'a, Output = CaseChange> {
+    use CaseChange::*;
+
+    choice!(
+        map("upcase", |_| Upcase),
+        map("downcase", |_| Downcase),
+        map("capitalize", |_| Capitalize),
+        map("pascalcase", |_| PascalCase),
+        map("camelcase", |_| CamelCase),
+    )
+}
+
+fn format<'a>() -> impl Parser<'a, Output = FormatItem> {
+    use FormatItem::*;
+
+    choice!(
+        // '$' int
+        map(right("$", digit()), Capture),
+        // '${' int '}'
+        map(seq!("${", digit(), "}"), |seq| Capture(seq.1)),
+        // '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
+        map(seq!("${", digit(), ":/", case_change(), "}"), |seq| {
+            CaseChange(seq.1, seq.3)
+        }),
+        // '${' int ':+' if '}'
+        map(
+            seq!("${", digit(), ":+", text(TEXT_ESCAPE_CHARS, &['}']), "}"),
+            |seq| { Conditional(seq.1, seq.3, Tendril::new()) }
+        ),
+        // '${' int ':?' if ':' else '}'
+        map(
+            seq!(
+                "${",
+                digit(),
+                ":?",
+                text(TEXT_ESCAPE_CHARS, &[':']),
+                ":",
+                text(TEXT_ESCAPE_CHARS, &['}']),
+                "}"
+            ),
+            |seq| { Conditional(seq.1, seq.3, seq.5) }
+        ),
+        // '${' int ':-' else '}' | '${' int ':' else '}'
+        map(
+            seq!(
+                "${",
+                digit(),
+                ":",
+                optional("-"),
+                text(TEXT_ESCAPE_CHARS, &['}']),
+                "}"
+            ),
+            |seq| { Conditional(seq.1, Tendril::new(), seq.4) }
+        ),
+    )
+}
+
+fn regex<'a>() -> impl Parser<'a, Output = Transform> {
+    map(
+        seq!(
+            "/",
+            // TODO parse as ECMAScript and convert to rust regex
+            text(&['/'], &['/']),
+            "/",
+            zero_or_more(choice!(
+                format(),
+                // text doesn't parse $, if format fails we just accept the $ as text
+                map("$", |_| FormatItem::Text("$".into())),
+                map(text(&['\\', '/'], &['/', '$']), FormatItem::Text),
+            )),
+            "/",
+            // vscode really doesn't allow escaping } here
+            // so it's impossible to write a regex escape containing a }
+            // we can consider deviating here and allowing the escape
+            text(&[], &['}']),
+        ),
+        |(_, value, _, replacement, _, options)| Transform {
+            regex: value,
+            replacement,
+            options,
+        },
+    )
+}
+
+fn tabstop<'a>() -> impl Parser<'a, Output = SnippetElement> {
+    map(
+        or(
+            map(right("$", digit()), |i| (i, None)),
+            map(
+                seq!("${", digit(), optional(regex()), "}"),
+                |(_, i, transform, _)| (i, transform),
+            ),
+        ),
+        |(tabstop, transform)| SnippetElement::Tabstop { tabstop, transform },
+    )
+}
+
+fn placeholder<'a>() -> impl Parser<'a, Output = SnippetElement> {
+    map(
+        seq!(
+            "${",
+            digit(),
+            ":",
+            // according to the grammar there is just a single anything here.
+            // However in the prose it is explained that placeholders can be nested.
+            // The example there contains both a placeholder text and a nested placeholder
+            // which indicates a list. Looking at the VSCode sourcecode, the placeholder
+            // is indeed parsed as zero_or_more so the grammar is simply incorrect here
+            zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
+            "}"
+        ),
+        |seq| SnippetElement::Placeholder {
+            tabstop: seq.1,
+            value: seq.3,
+        },
+    )
+}
+
+fn choice<'a>() -> impl Parser<'a, Output = SnippetElement> {
+    map(
+        seq!(
+            "${",
+            digit(),
+            "|",
+            sep(text(CHOICE_TEXT_ESCAPE_CHARS, &['|', ',']), ","),
+            "|}",
+        ),
+        |seq| SnippetElement::Choice {
+            tabstop: seq.1,
+            choices: seq.3,
+        },
+    )
+}
+
+fn variable<'a>() -> impl Parser<'a, Output = SnippetElement> {
+    choice!(
+        // $var
+        map(right("$", var()), |name| SnippetElement::Variable {
+            name: name.into(),
+            default: None,
+            transform: None,
+        }),
+        // ${var}
+        map(seq!("${", var(), "}",), |values| SnippetElement::Variable {
+            name: values.1.into(),
+            default: None,
+            transform: None,
+        }),
+        // ${var:default}
+        map(
+            seq!(
+                "${",
+                var(),
+                ":",
+                zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
+                "}",
+            ),
+            |values| SnippetElement::Variable {
+                name: values.1.into(),
+                default: Some(values.3),
+                transform: None,
+            }
+        ),
+        // ${var/value/format/options}
+        map(seq!("${", var(), regex(), "}"), |values| {
+            SnippetElement::Variable {
+                name: values.1.into(),
+                default: None,
+                transform: Some(values.2),
+            }
+        }),
+    )
+}
+
+fn anything<'a>(
+    escape_chars: &'static [char],
+    end_at_brace: bool,
+) -> impl Parser<'a, Output = SnippetElement> {
+    let term_chars: &[_] = if end_at_brace { &['$', '}'] } else { &['$'] };
+    move |input: &'a str| {
+        let parser = choice!(
+            tabstop(),
+            placeholder(),
+            choice(),
+            variable(),
+            map("$", |_| SnippetElement::Text("$".into())),
+            map(text(escape_chars, term_chars), SnippetElement::Text),
+        );
+        parser.parse(input)
+    }
+}
+
+fn snippet<'a>() -> impl Parser<'a, Output = Vec<SnippetElement>> {
+    one_or_more(anything(TEXT_ESCAPE_CHARS, false))
+}
+
+#[cfg(test)]
+mod test {
+    use crate::snippets::{Snippet, SnippetRenderCtx};
+
+    use super::SnippetElement::*;
+    use super::*;
+
+    #[test]
+    fn empty_string_is_error() {
+        assert_eq!(Err(""), parse(""));
+    }
+
+    #[test]
+    fn parse_placeholders_in_function_call() {
+        assert_eq!(
+            Ok(vec![
+                Text("match(".into()),
+                Placeholder {
+                    tabstop: 1,
+                    value: vec![Text("Arg1".into())],
+                },
+                Text(")".into()),
+            ]),
+            parse("match(${1:Arg1})")
+        );
+        // The `$0` tabstop should not have placeholder text. The parser should handle this case
+        // normally and then the placeholder text should be discarded during elaboration.
+        assert_eq!(
+            Ok(vec![
+                Text("sizeof(".into()),
+                Placeholder {
+                    tabstop: 0,
+                    value: vec![Text("expression-or-type".into())],
+                },
+                Text(")".into()),
+            ]),
+            parse("sizeof(${0:expression-or-type})")
+        );
+    }
+
+    #[test]
+    fn unterminated_placeholder() {
+        assert_eq!(
+            Ok(vec![
+                Text("match(".into()),
+                Text("$".into()),
+                Text("{1:)".into())
+            ]),
+            parse("match(${1:)")
+        )
+    }
+
+    #[test]
+    fn parse_empty_placeholder() {
+        assert_eq!(
+            Ok(vec![
+                Text("match(".into()),
+                Placeholder {
+                    tabstop: 1,
+                    value: vec![],
+                },
+                Text(")".into()),
+            ]),
+            parse("match(${1:})")
+        )
+    }
+
+    #[test]
+    fn parse_placeholders_in_statement() {
+        assert_eq!(
+            Ok(vec![
+                Text("local ".into()),
+                Placeholder {
+                    tabstop: 1,
+                    value: vec![Text("var".into())],
+                },
+                Text(" = ".into()),
+                Placeholder {
+                    tabstop: 1,
+                    value: vec![Text("value".into())],
+                },
+            ]),
+            parse("local ${1:var} = ${1:value}")
+        )
+    }
+
+    #[test]
+    fn parse_tabstop_nested_in_placeholder() {
+        assert_eq!(
+            Ok(vec![Placeholder {
+                tabstop: 1,
+                value: vec![
+                    Text("var, ".into()),
+                    Tabstop {
+                        tabstop: 2,
+                        transform: None
+                    }
+                ],
+            }]),
+            parse("${1:var, $2}")
+        )
+    }
+
+    #[test]
+    fn parse_placeholder_nested_in_placeholder() {
+        assert_eq!(
+            Ok({
+                vec![Placeholder {
+                    tabstop: 1,
+                    value: vec![
+                        Text("foo ".into()),
+                        Placeholder {
+                            tabstop: 2,
+                            value: vec![Text("bar".into())],
+                        },
+                    ],
+                }]
+            }),
+            parse("${1:foo ${2:bar}}")
+        )
+    }
+
+    #[test]
+    fn parse_all() {
+        assert_eq!(
+            Ok(vec![
+                Text("hello ".into()),
+                Tabstop {
+                    tabstop: 1,
+                    transform: None
+                },
+                Tabstop {
+                    tabstop: 2,
+                    transform: None
+                },
+                Text(" ".into()),
+                Choice {
+                    tabstop: 1,
+                    choices: vec!["one".into(), "two".into(), "three".into()],
+                },
+                Text(" ".into()),
+                Variable {
+                    name: "name".into(),
+                    default: Some(vec![Text("foo".into())]),
+                    transform: None,
+                },
+                Text(" ".into()),
+                Variable {
+                    name: "var".into(),
+                    default: None,
+                    transform: None,
+                },
+                Text(" ".into()),
+                Variable {
+                    name: "TM".into(),
+                    default: None,
+                    transform: None,
+                },
+            ]),
+            parse("hello $1${2} ${1|one,two,three|} ${name:foo} $var $TM")
+        );
+    }
+
+    #[test]
+    fn regex_capture_replace() {
+        assert_eq!(
+            Ok({
+                vec![Variable {
+                    name: "TM_FILENAME".into(),
+                    default: None,
+                    transform: Some(Transform {
+                        regex: "(.*).+$".into(),
+                        replacement: vec![FormatItem::Capture(1), FormatItem::Text("$".into())],
+                        options: Tendril::new(),
+                    }),
+                }]
+            }),
+            parse("${TM_FILENAME/(.*).+$/$1$/}")
+        );
+    }
+
+    #[test]
+    fn rust_macro() {
+        assert_eq!(
+            Ok({
+                vec![
+                    Text("macro_rules! ".into()),
+                    Tabstop {
+                        tabstop: 1,
+                        transform: None,
+                    },
+                    Text(" {\n    (".into()),
+                    Tabstop {
+                        tabstop: 2,
+                        transform: None,
+                    },
+                    Text(") => {\n        ".into()),
+                    Tabstop {
+                        tabstop: 0,
+                        transform: None,
+                    },
+                    Text("\n    };\n}".into()),
+                ]
+            }),
+            parse("macro_rules! $1 {\n    ($2) => {\n        $0\n    };\n}")
+        );
+    }
+
+    fn assert_text(snippet: &str, parsed_text: &str) {
+        let snippet = Snippet::parse(snippet).unwrap();
+        let mut rendered_snippet = snippet.prepare_render();
+        let rendered_text = snippet
+            .render_at(
+                &mut rendered_snippet,
+                "".into(),
+                false,
+                &mut SnippetRenderCtx::test_ctx(),
+                0,
+            )
+            .0;
+        assert_eq!(rendered_text, parsed_text)
+    }
+
+    #[test]
+    fn robust_parsing() {
+        assert_text("$", "$");
+        assert_text("\\\\$", "\\$");
+        assert_text("{", "{");
+        assert_text("\\}", "}");
+        assert_text("\\abc", "\\abc");
+        assert_text("foo${f:\\}}bar", "foo}bar");
+        assert_text("\\{", "\\{");
+        assert_text("I need \\\\\\$", "I need \\$");
+        assert_text("\\", "\\");
+        assert_text("\\{{", "\\{{");
+        assert_text("{{", "{{");
+        assert_text("{{dd", "{{dd");
+        assert_text("}}", "}}");
+        assert_text("ff}}", "ff}}");
+        assert_text("farboo", "farboo");
+        assert_text("far{{}}boo", "far{{}}boo");
+        assert_text("far{{123}}boo", "far{{123}}boo");
+        assert_text("far\\{{123}}boo", "far\\{{123}}boo");
+        assert_text("far{{id:bern}}boo", "far{{id:bern}}boo");
+        assert_text("far{{id:bern {{basel}}}}boo", "far{{id:bern {{basel}}}}boo");
+        assert_text(
+            "far{{id:bern {{id:basel}}}}boo",
+            "far{{id:bern {{id:basel}}}}boo",
+        );
+        assert_text(
+            "far{{id:bern {{id2:basel}}}}boo",
+            "far{{id:bern {{id2:basel}}}}boo",
+        );
+        assert_text("${}$\\a\\$\\}\\\\", "${}$\\a$}\\");
+        assert_text("farboo", "farboo");
+        assert_text("far{{}}boo", "far{{}}boo");
+        assert_text("far{{123}}boo", "far{{123}}boo");
+        assert_text("far\\{{123}}boo", "far\\{{123}}boo");
+        assert_text("far`123`boo", "far`123`boo");
+        assert_text("far\\`123\\`boo", "far\\`123\\`boo");
+        assert_text("\\$far-boo", "$far-boo");
+    }
+
+    fn assert_snippet(snippet: &str, expect: &[SnippetElement]) {
+        let elements = parse(snippet).unwrap();
+        assert_eq!(elements, expect.to_owned())
+    }
+
+    #[test]
+    fn parse_variable() {
+        use SnippetElement::*;
+        assert_snippet(
+            "$far-boo",
+            &[
+                Variable {
+                    name: "far".into(),
+                    default: None,
+                    transform: None,
+                },
+                Text("-boo".into()),
+            ],
+        );
+        assert_snippet(
+            "far$farboo",
+            &[
+                Text("far".into()),
+                Variable {
+                    name: "farboo".into(),
+                    transform: None,
+                    default: None,
+                },
+            ],
+        );
+        assert_snippet(
+            "far${farboo}",
+            &[
+                Text("far".into()),
+                Variable {
+                    name: "farboo".into(),
+                    transform: None,
+                    default: None,
+                },
+            ],
+        );
+        assert_snippet(
+            "$123",
+            &[Tabstop {
+                tabstop: 123,
+                transform: None,
+            }],
+        );
+        assert_snippet(
+            "$farboo",
+            &[Variable {
+                name: "farboo".into(),
+                transform: None,
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "$far12boo",
+            &[Variable {
+                name: "far12boo".into(),
+                transform: None,
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "000_${far}_000",
+            &[
+                Text("000_".into()),
+                Variable {
+                    name: "far".into(),
+                    transform: None,
+                    default: None,
+                },
+                Text("_000".into()),
+            ],
+        );
+    }
+
+    #[test]
+    fn parse_variable_transform() {
+        assert_snippet(
+            "${foo///}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: Tendril::new(),
+                    replacement: Vec::new(),
+                    options: Tendril::new(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/regex/format/gmi}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: "regex".into(),
+                    replacement: vec![FormatItem::Text("format".into())],
+                    options: "gmi".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/([A-Z][a-z])/format/}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: "([A-Z][a-z])".into(),
+                    replacement: vec![FormatItem::Text("format".into())],
+                    options: Tendril::new(),
+                }),
+                default: None,
+            }],
+        );
+
+        // invalid regex TODO: reneable tests once we actually parse this regex flavor
+        // assert_text(
+        //     "${foo/([A-Z][a-z])/format/GMI}",
+        //     "${foo/([A-Z][a-z])/format/GMI}",
+        // );
+        // assert_text(
+        //     "${foo/([A-Z][a-z])/format/funky}",
+        //     "${foo/([A-Z][a-z])/format/funky}",
+        // );
+        // assert_text("${foo/([A-Z][a-z]/format/}", "${foo/([A-Z][a-z]/format/}");
+        assert_text(
+            "${foo/regex\\/format/options}",
+            "${foo/regex\\/format/options}",
+        );
+
+        // tricky regex
+        assert_snippet(
+            "${foo/m\\/atch/$1/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: "m/atch".into(),
+                    replacement: vec![FormatItem::Capture(1)],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+
+        // incomplete
+        assert_text("${foo///", "${foo///");
+        assert_text("${foo/regex/format/options", "${foo/regex/format/options");
+
+        // format string
+        assert_snippet(
+            "${foo/.*/${0:fooo}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![FormatItem::Conditional(0, Tendril::new(), "fooo".into())],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/${1}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![FormatItem::Capture(1)],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/$1/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![FormatItem::Capture(1)],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/This-$1-encloses/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("This-".into()),
+                        FormatItem::Capture(1),
+                        FormatItem::Text("-encloses".into()),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/complex${1:else}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("complex".into()),
+                        FormatItem::Conditional(1, Tendril::new(), "else".into()),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/complex${1:-else}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("complex".into()),
+                        FormatItem::Conditional(1, Tendril::new(), "else".into()),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/complex${1:+if}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("complex".into()),
+                        FormatItem::Conditional(1, "if".into(), Tendril::new()),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/complex${1:?if:else}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("complex".into()),
+                        FormatItem::Conditional(1, "if".into(), "else".into()),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${foo/.*/complex${1:/upcase}/i}",
+            &[Variable {
+                name: "foo".into(),
+                transform: Some(Transform {
+                    regex: ".*".into(),
+                    replacement: vec![
+                        FormatItem::Text("complex".into()),
+                        FormatItem::CaseChange(1, CaseChange::Upcase),
+                    ],
+                    options: "i".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${TM_DIRECTORY/src\\//$1/}",
+            &[Variable {
+                name: "TM_DIRECTORY".into(),
+                transform: Some(Transform {
+                    regex: "src/".into(),
+                    replacement: vec![FormatItem::Capture(1)],
+                    options: Tendril::new(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${TM_SELECTED_TEXT/a/\\/$1/g}",
+            &[Variable {
+                name: "TM_SELECTED_TEXT".into(),
+                transform: Some(Transform {
+                    regex: "a".into(),
+                    replacement: vec![FormatItem::Text("/".into()), FormatItem::Capture(1)],
+                    options: "g".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${TM_SELECTED_TEXT/a/in\\/$1ner/g}",
+            &[Variable {
+                name: "TM_SELECTED_TEXT".into(),
+                transform: Some(Transform {
+                    regex: "a".into(),
+                    replacement: vec![
+                        FormatItem::Text("in/".into()),
+                        FormatItem::Capture(1),
+                        FormatItem::Text("ner".into()),
+                    ],
+                    options: "g".into(),
+                }),
+                default: None,
+            }],
+        );
+        assert_snippet(
+            "${TM_SELECTED_TEXT/a/end\\//g}",
+            &[Variable {
+                name: "TM_SELECTED_TEXT".into(),
+                transform: Some(Transform {
+                    regex: "a".into(),
+                    replacement: vec![FormatItem::Text("end/".into())],
+                    options: "g".into(),
+                }),
+                default: None,
+            }],
+        );
+    }
+    // TODO port more tests from https://github.com/microsoft/vscode/blob/dce493cb6e36346ef2714e82c42ce14fc461b15c/src/vs/editor/contrib/snippet/test/browser/snippetParser.test.ts
+}
diff --git a/helix-core/src/snippets/render.rs b/helix-core/src/snippets/render.rs
new file mode 100644
index 000000000..e5a7d9bb7
--- /dev/null
+++ b/helix-core/src/snippets/render.rs
@@ -0,0 +1,355 @@
+use std::borrow::Cow;
+use std::ops::{Index, IndexMut};
+use std::sync::Arc;
+
+use helix_stdx::Range;
+use ropey::{Rope, RopeSlice};
+use smallvec::SmallVec;
+
+use crate::indent::{normalize_indentation, IndentStyle};
+use crate::movement::Direction;
+use crate::snippets::elaborate;
+use crate::snippets::TabstopIdx;
+use crate::snippets::{Snippet, SnippetElement, Transform};
+use crate::{selection, Selection, Tendril, Transaction};
+
+#[derive(Debug, Clone, PartialEq)]
+pub enum TabstopKind {
+    Choice { choices: Arc<[Tendril]> },
+    Placeholder,
+    Empty,
+    Transform(Arc<Transform>),
+}
+
+#[derive(Debug, PartialEq)]
+pub struct Tabstop {
+    pub ranges: SmallVec<[Range; 1]>,
+    pub parent: Option<TabstopIdx>,
+    pub kind: TabstopKind,
+}
+
+impl Tabstop {
+    pub fn has_placeholder(&self) -> bool {
+        matches!(
+            self.kind,
+            TabstopKind::Choice { .. } | TabstopKind::Placeholder
+        )
+    }
+
+    pub fn selection(
+        &self,
+        direction: Direction,
+        primary_idx: usize,
+        snippet_ranges: usize,
+    ) -> Selection {
+        Selection::new(
+            self.ranges
+                .iter()
+                .map(|&range| {
+                    let mut range = selection::Range::new(range.start, range.end);
+                    if direction == Direction::Backward {
+                        range = range.flip()
+                    }
+                    range
+                })
+                .collect(),
+            primary_idx * (self.ranges.len() / snippet_ranges),
+        )
+    }
+}
+
+#[derive(Debug, Default, PartialEq)]
+pub struct RenderedSnippet {
+    pub tabstops: Vec<Tabstop>,
+    pub ranges: Vec<Range>,
+}
+
+impl RenderedSnippet {
+    pub fn first_selection(&self, direction: Direction, primary_idx: usize) -> Selection {
+        self.tabstops[0].selection(direction, primary_idx, self.ranges.len())
+    }
+}
+
+impl Index<TabstopIdx> for RenderedSnippet {
+    type Output = Tabstop;
+    fn index(&self, index: TabstopIdx) -> &Tabstop {
+        &self.tabstops[index.0]
+    }
+}
+
+impl IndexMut<TabstopIdx> for RenderedSnippet {
+    fn index_mut(&mut self, index: TabstopIdx) -> &mut Tabstop {
+        &mut self.tabstops[index.0]
+    }
+}
+
+impl Snippet {
+    pub fn prepare_render(&self) -> RenderedSnippet {
+        let tabstops =
+            self.tabstops()
+                .map(|tabstop| Tabstop {
+                    ranges: SmallVec::new(),
+                    parent: tabstop.parent,
+                    kind: match &tabstop.kind {
+                        elaborate::TabstopKind::Choice { choices } => TabstopKind::Choice {
+                            choices: choices.clone(),
+                        },
+                        // start out as empty: the first non-empty placeholder will change this to
+                        // a placeholder automatically
+                        elaborate::TabstopKind::Empty
+                        | elaborate::TabstopKind::Placeholder { .. } => TabstopKind::Empty,
+                        elaborate::TabstopKind::Transform(transform) => {
+                            TabstopKind::Transform(transform.clone())
+                        }
+                    },
+                })
+                .collect();
+        RenderedSnippet {
+            tabstops,
+            ranges: Vec::new(),
+        }
+    }
+
+    pub fn render_at(
+        &self,
+        snippet: &mut RenderedSnippet,
+        indent: RopeSlice<'_>,
+        at_newline: bool,
+        ctx: &mut SnippetRenderCtx,
+        pos: usize,
+    ) -> (Tendril, usize) {
+        let mut ctx = SnippetRender {
+            dst: snippet,
+            src: self,
+            indent,
+            text: Tendril::new(),
+            off: pos,
+            ctx,
+            at_newline,
+        };
+        ctx.render_elements(self.elements());
+        let end = ctx.off;
+        let text = ctx.text;
+        snippet.ranges.push(Range { start: pos, end });
+        (text, end - pos)
+    }
+
+    pub fn render(
+        &self,
+        doc: &Rope,
+        selection: &Selection,
+        change_range: impl FnMut(&selection::Range) -> (usize, usize),
+        ctx: &mut SnippetRenderCtx,
+    ) -> (Transaction, Selection, RenderedSnippet) {
+        let mut snippet = self.prepare_render();
+        let mut off = 0;
+        let (transaction, selection) = Transaction::change_by_selection_ignore_overlapping(
+            doc,
+            selection,
+            change_range,
+            |replacement_start, replacement_end| {
+                let line_idx = doc.char_to_line(replacement_start);
+                let line_start = doc.line_to_char(line_idx);
+                let prefix = doc.slice(line_start..replacement_start);
+                let indent_len = prefix.chars().take_while(|c| c.is_whitespace()).count();
+                let indent = prefix.slice(..indent_len);
+                let at_newline = indent_len == replacement_start - line_start;
+
+                let (replacement, replacement_len) = self.render_at(
+                    &mut snippet,
+                    indent,
+                    at_newline,
+                    ctx,
+                    (replacement_start as i128 + off) as usize,
+                );
+                off +=
+                    replacement_start as i128 - replacement_end as i128 + replacement_len as i128;
+
+                Some(replacement)
+            },
+        );
+        (transaction, selection, snippet)
+    }
+}
+
+pub type VariableResolver = dyn FnMut(&str) -> Option<Cow<str>>;
+pub struct SnippetRenderCtx {
+    pub resolve_var: Box<VariableResolver>,
+    pub tab_width: usize,
+    pub indent_style: IndentStyle,
+    pub line_ending: &'static str,
+}
+
+impl SnippetRenderCtx {
+    #[cfg(test)]
+    pub(super) fn test_ctx() -> SnippetRenderCtx {
+        SnippetRenderCtx {
+            resolve_var: Box::new(|_| None),
+            tab_width: 4,
+            indent_style: IndentStyle::Spaces(4),
+            line_ending: "\n",
+        }
+    }
+}
+
+struct SnippetRender<'a> {
+    ctx: &'a mut SnippetRenderCtx,
+    dst: &'a mut RenderedSnippet,
+    src: &'a Snippet,
+    indent: RopeSlice<'a>,
+    text: Tendril,
+    off: usize,
+    at_newline: bool,
+}
+
+impl SnippetRender<'_> {
+    fn render_elements(&mut self, elements: &[SnippetElement]) {
+        for element in elements {
+            self.render_element(element)
+        }
+    }
+
+    fn render_element(&mut self, element: &SnippetElement) {
+        match *element {
+            SnippetElement::Tabstop { idx } => self.render_tabstop(idx),
+            SnippetElement::Variable {
+                ref name,
+                ref default,
+                ref transform,
+            } => {
+                // TODO: allow resolve_var access to the doc and make it return rope slice
+                // so we can access selections and other document content without allocating
+                if let Some(val) = (self.ctx.resolve_var)(name) {
+                    if let Some(transform) = transform {
+                        self.push_multiline_str(&transform.apply(
+                            (&*val).into(),
+                            Range {
+                                start: 0,
+                                end: val.chars().count(),
+                            },
+                        ));
+                    } else {
+                        self.push_multiline_str(&val)
+                    }
+                } else if let Some(default) = default {
+                    self.render_elements(default)
+                }
+            }
+            SnippetElement::Text(ref text) => self.push_multiline_str(text),
+        }
+    }
+
+    fn push_multiline_str(&mut self, text: &str) {
+        let mut lines = text
+            .split('\n')
+            .map(|line| line.strip_suffix('\r').unwrap_or(line));
+        let first_line = lines.next().unwrap();
+        self.push_str(first_line, self.at_newline);
+        for line in lines {
+            self.push_newline();
+            self.push_str(line, true);
+        }
+    }
+
+    fn push_str(&mut self, mut text: &str, at_newline: bool) {
+        if at_newline {
+            let old_len = self.text.len();
+            let old_indent_len = normalize_indentation(
+                self.indent,
+                text.into(),
+                &mut self.text,
+                self.ctx.indent_style,
+                self.ctx.tab_width,
+            );
+            // this is ok because indentation can only be ascii chars (' ' and '\t')
+            self.off += self.text.len() - old_len;
+            text = &text[old_indent_len..];
+            if text.is_empty() {
+                self.at_newline = true;
+                return;
+            }
+        }
+        self.text.push_str(text);
+        self.off += text.chars().count();
+    }
+
+    fn push_newline(&mut self) {
+        self.off += self.ctx.line_ending.chars().count() + self.indent.len_chars();
+        self.text.push_str(self.ctx.line_ending);
+        self.text.extend(self.indent.chunks());
+    }
+
+    fn render_tabstop(&mut self, tabstop: TabstopIdx) {
+        let start = self.off;
+        let end = match &self.src[tabstop].kind {
+            elaborate::TabstopKind::Placeholder { default } if !default.is_empty() => {
+                self.render_elements(default);
+                self.dst[tabstop].kind = TabstopKind::Placeholder;
+                self.off
+            }
+            _ => start,
+        };
+        self.dst[tabstop].ranges.push(Range { start, end });
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use helix_stdx::Range;
+
+    use crate::snippets::render::Tabstop;
+    use crate::snippets::{Snippet, SnippetRenderCtx};
+
+    use super::TabstopKind;
+
+    fn assert_snippet(snippet: &str, expect: &str, tabstops: &[Tabstop]) {
+        let snippet = Snippet::parse(snippet).unwrap();
+        let mut rendered_snippet = snippet.prepare_render();
+        let rendered_text = snippet
+            .render_at(
+                &mut rendered_snippet,
+                "\t".into(),
+                false,
+                &mut SnippetRenderCtx::test_ctx(),
+                0,
+            )
+            .0;
+        assert_eq!(rendered_text, expect);
+        assert_eq!(&rendered_snippet.tabstops, tabstops);
+        assert_eq!(
+            rendered_snippet.ranges.last().unwrap().end,
+            rendered_text.chars().count()
+        );
+        assert_eq!(rendered_snippet.ranges.last().unwrap().start, 0)
+    }
+
+    #[test]
+    fn rust_macro() {
+        assert_snippet(
+            "macro_rules! ${1:name} {\n\t($3) => {\n\t\t$2\n\t};\n}",
+            "macro_rules! name {\n\t    () => {\n\t        \n\t    };\n\t}",
+            &[
+                Tabstop {
+                    ranges: vec![Range { start: 13, end: 17 }].into(),
+                    parent: None,
+                    kind: TabstopKind::Placeholder,
+                },
+                Tabstop {
+                    ranges: vec![Range { start: 42, end: 42 }].into(),
+                    parent: None,
+                    kind: TabstopKind::Empty,
+                },
+                Tabstop {
+                    ranges: vec![Range { start: 26, end: 26 }].into(),
+                    parent: None,
+                    kind: TabstopKind::Empty,
+                },
+                Tabstop {
+                    ranges: vec![Range { start: 53, end: 53 }].into(),
+                    parent: None,
+                    kind: TabstopKind::Empty,
+                },
+            ],
+        );
+    }
+}
diff --git a/helix-core/src/syntax.rs b/helix-core/src/syntax.rs
index 7be512f52..7c50a5797 100644
--- a/helix-core/src/syntax.rs
+++ b/helix-core/src/syntax.rs
@@ -36,12 +36,12 @@
 
 pub use tree_cursor::TreeCursor;
 
-fn deserialize_regex<'de, D>(deserializer: D) -> Result<Option<Regex>, D::Error>
+fn deserialize_regex<'de, D>(deserializer: D) -> Result<Option<rope::Regex>, D::Error>
 where
     D: serde::Deserializer<'de>,
 {
     Option::<String>::deserialize(deserializer)?
-        .map(|buf| Regex::new(&buf).map_err(serde::de::Error::custom))
+        .map(|buf| rope::Regex::new(&buf).map_err(serde::de::Error::custom))
         .transpose()
 }
 
@@ -125,6 +125,9 @@ pub struct LanguageConfiguration {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub formatter: Option<FormatterConfiguration>,
 
+    /// If set, overrides `editor.path-completion`.
+    pub path_completion: Option<bool>,
+
     #[serde(default)]
     pub diagnostic_severity: Severity,
 
@@ -132,7 +135,7 @@ pub struct LanguageConfiguration {
 
     // content_regex
     #[serde(default, skip_serializing, deserialize_with = "deserialize_regex")]
-    pub injection_regex: Option<Regex>,
+    pub injection_regex: Option<rope::Regex>,
     // first_line_regex
     //
     #[serde(skip)]
@@ -616,7 +619,7 @@ pub enum CapturedNode<'a> {
     Grouped(Vec<Node<'a>>),
 }
 
-impl<'a> CapturedNode<'a> {
+impl CapturedNode<'_> {
     pub fn start_byte(&self) -> usize {
         match self {
             Self::Single(n) => n.start_byte(),
@@ -753,7 +756,7 @@ fn initialize_highlight(&self, scopes: &[String]) -> Option<Arc<HighlightConfigu
             let language = get_language(self.grammar.as_deref().unwrap_or(&self.language_id))
                 .map_err(|err| {
                     log::error!(
-                        "Failed to load tree-sitter parser for language {:?}: {}",
+                        "Failed to load tree-sitter parser for language {:?}: {:#}",
                         self.language_id,
                         err
                     )
@@ -991,21 +994,32 @@ pub fn language_config_for_scope(&self, scope: &str) -> Option<Arc<LanguageConfi
             .cloned()
     }
 
-    pub fn language_config_for_language_id(&self, id: &str) -> Option<Arc<LanguageConfiguration>> {
+    pub fn language_config_for_language_id(
+        &self,
+        id: impl PartialEq<String>,
+    ) -> Option<Arc<LanguageConfiguration>> {
         self.language_configs
             .iter()
-            .find(|config| config.language_id == id)
+            .find(|config| id.eq(&config.language_id))
             .cloned()
     }
 
-    /// Unlike language_config_for_language_id, which only returns Some for an exact id, this
+    /// Unlike `language_config_for_language_id`, which only returns Some for an exact id, this
     /// function will perform a regex match on the given string to find the closest language match.
-    pub fn language_config_for_name(&self, name: &str) -> Option<Arc<LanguageConfiguration>> {
+    pub fn language_config_for_name(&self, slice: RopeSlice) -> Option<Arc<LanguageConfiguration>> {
+        // PERF: If the name matches up with the id, then this saves the need to do expensive regex.
+        let shortcircuit = self.language_config_for_language_id(slice);
+        if shortcircuit.is_some() {
+            return shortcircuit;
+        }
+
+        // If the name did not match up with a known id, then match on injection regex.
+
         let mut best_match_length = 0;
         let mut best_match_position = None;
         for (i, configuration) in self.language_configs.iter().enumerate() {
             if let Some(injection_regex) = &configuration.injection_regex {
-                if let Some(mat) = injection_regex.find(name) {
+                if let Some(mat) = injection_regex.find(slice.regex_input()) {
                     let length = mat.end() - mat.start();
                     if length > best_match_length {
                         best_match_position = Some(i);
@@ -1023,12 +1037,18 @@ pub fn language_configuration_for_injection_string(
         capture: &InjectionLanguageMarker,
     ) -> Option<Arc<LanguageConfiguration>> {
         match capture {
-            InjectionLanguageMarker::Name(string) => self.language_config_for_name(string),
-            InjectionLanguageMarker::Filename(file) => self.language_config_for_file_name(file),
-            InjectionLanguageMarker::Shebang(shebang) => self
-                .language_config_ids_by_shebang
-                .get(shebang)
-                .and_then(|&id| self.language_configs.get(id).cloned()),
+            InjectionLanguageMarker::LanguageId(id) => self.language_config_for_language_id(*id),
+            InjectionLanguageMarker::Name(name) => self.language_config_for_name(*name),
+            InjectionLanguageMarker::Filename(file) => {
+                let path_str: Cow<str> = (*file).into();
+                self.language_config_for_file_name(Path::new(path_str.as_ref()))
+            }
+            InjectionLanguageMarker::Shebang(shebang) => {
+                let shebang_str: Cow<str> = (*shebang).into();
+                self.language_config_ids_by_shebang
+                    .get(shebang_str.as_ref())
+                    .and_then(|&id| self.language_configs.get(id).cloned())
+            }
         }
     }
 
@@ -1849,7 +1869,7 @@ struct HighlightIterLayer<'a> {
     depth: u32,
 }
 
-impl<'a> fmt::Debug for HighlightIterLayer<'a> {
+impl fmt::Debug for HighlightIterLayer<'_> {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         f.debug_struct("HighlightIterLayer").finish()
     }
@@ -2027,12 +2047,13 @@ fn injection_pair<'a>(
         for capture in query_match.captures {
             let index = Some(capture.index);
             if index == self.injection_language_capture_index {
-                let name = byte_range_to_str(capture.node.byte_range(), source);
-                injection_capture = Some(InjectionLanguageMarker::Name(name));
+                injection_capture = Some(InjectionLanguageMarker::Name(
+                    source.byte_slice(capture.node.byte_range()),
+                ));
             } else if index == self.injection_filename_capture_index {
-                let name = byte_range_to_str(capture.node.byte_range(), source);
-                let path = Path::new(name.as_ref()).to_path_buf();
-                injection_capture = Some(InjectionLanguageMarker::Filename(path.into()));
+                injection_capture = Some(InjectionLanguageMarker::Filename(
+                    source.byte_slice(capture.node.byte_range()),
+                ));
             } else if index == self.injection_shebang_capture_index {
                 let node_slice = source.byte_slice(capture.node.byte_range());
 
@@ -2051,7 +2072,7 @@ fn injection_pair<'a>(
                     .captures_iter(lines.regex_input())
                     .map(|cap| {
                         let cap = lines.byte_slice(cap.get_group(1).unwrap().range());
-                        InjectionLanguageMarker::Shebang(cap.into())
+                        InjectionLanguageMarker::Shebang(cap)
                     })
                     .next()
             } else if index == self.injection_content_capture_index {
@@ -2082,8 +2103,8 @@ fn injection_for_match<'a>(
                 "injection.language" if injection_capture.is_none() => {
                     injection_capture = prop
                         .value
-                        .as_ref()
-                        .map(|s| InjectionLanguageMarker::Name(s.as_ref().into()));
+                        .as_deref()
+                        .map(InjectionLanguageMarker::LanguageId);
                 }
 
                 // By default, injections do not include the *children* of an
@@ -2106,7 +2127,7 @@ fn injection_for_match<'a>(
     }
 }
 
-impl<'a> HighlightIterLayer<'a> {
+impl HighlightIterLayer<'_> {
     // First, sort scope boundaries by their byte offset in the document. At a
     // given position, emit scope endings before scope beginnings. Finally, emit
     // scope boundaries from deeper layers first.
@@ -2244,7 +2265,7 @@ fn intersect_ranges(
     result
 }
 
-impl<'a> HighlightIter<'a> {
+impl HighlightIter<'_> {
     fn emit_event(
         &mut self,
         offset: usize,
@@ -2299,7 +2320,7 @@ fn sort_layers(&mut self) {
     }
 }
 
-impl<'a> Iterator for HighlightIter<'a> {
+impl Iterator for HighlightIter<'_> {
     type Item = Result<HighlightEvent, Error>;
 
     fn next(&mut self) -> Option<Self::Item> {
@@ -2481,15 +2502,17 @@ fn next(&mut self) -> Option<Self::Item> {
                 }
             }
 
-            // Once a highlighting pattern is found for the current node, skip over
-            // any later highlighting patterns that also match this node. Captures
+            // Use the last capture found for the current node, skipping over any
+            // highlight patterns that also match this node. Captures
             // for a given node are ordered by pattern index, so these subsequent
             // captures are guaranteed to be for highlighting, not injections or
             // local variables.
             while let Some((next_match, next_capture_index)) = captures.peek() {
                 let next_capture = next_match.captures[*next_capture_index];
                 if next_capture.node == capture.node {
-                    captures.next();
+                    match_.remove();
+                    capture = next_capture;
+                    match_ = captures.next().unwrap().0;
                 } else {
                     break;
                 }
@@ -2518,9 +2541,20 @@ fn next(&mut self) -> Option<Self::Item> {
 
 #[derive(Debug, Clone)]
 pub enum InjectionLanguageMarker<'a> {
-    Name(Cow<'a, str>),
-    Filename(Cow<'a, Path>),
-    Shebang(String),
+    /// The language is specified by `LanguageConfiguration`'s `language_id` field.
+    ///
+    /// This marker is used when a pattern sets the `injection.language` property, for example
+    /// `(#set! injection.language "rust")`.
+    LanguageId(&'a str),
+    /// The language is specified in the document and captured by `@injection.language`.
+    ///
+    /// This is used for markdown code fences for example. While the `LanguageId` variant can be
+    /// looked up by finding the language config that sets an `language_id`, this variant contains
+    /// text from the document being highlighted, so the text is checked against each language's
+    /// `injection_regex`.
+    Name(RopeSlice<'a>),
+    Filename(RopeSlice<'a>),
+    Shebang(RopeSlice<'a>),
 }
 
 const SHEBANG: &str = r"#!\s*(?:\S*[/\\](?:env\s+(?:\-\S+\s+)*)?)?([^\s\.\d]+)";
@@ -2663,12 +2697,20 @@ fn node_is_visible(node: &Node) -> bool {
     node.is_missing() || (node.is_named() && node.language().node_kind_is_visible(node.kind_id()))
 }
 
+fn format_anonymous_node_kind(kind: &str) -> Cow<str> {
+    if kind.contains('"') {
+        Cow::Owned(kind.replace('"', "\\\""))
+    } else {
+        Cow::Borrowed(kind)
+    }
+}
+
 pub fn pretty_print_tree<W: fmt::Write>(fmt: &mut W, node: Node) -> fmt::Result {
     if node.child_count() == 0 {
         if node_is_visible(&node) {
             write!(fmt, "({})", node.kind())
         } else {
-            write!(fmt, "\"{}\"", node.kind())
+            write!(fmt, "\"{}\"", format_anonymous_node_kind(node.kind()))
         }
     } else {
         pretty_print_tree_impl(fmt, &mut node.walk(), 0)
@@ -2692,6 +2734,8 @@ fn pretty_print_tree_impl<W: fmt::Write>(
         }
 
         write!(fmt, "({}", node.kind())?;
+    } else {
+        write!(fmt, " \"{}\"", format_anonymous_node_kind(node.kind()))?;
     }
 
     // Handle children.
@@ -2950,7 +2994,7 @@ fn assert_pretty_print(
     #[test]
     fn test_pretty_print() {
         let source = r#"// Hello"#;
-        assert_pretty_print("rust", source, "(line_comment)", 0, source.len());
+        assert_pretty_print("rust", source, "(line_comment \"//\")", 0, source.len());
 
         // A large tree should be indented with fields:
         let source = r#"fn main() {
@@ -2960,16 +3004,16 @@ fn test_pretty_print() {
             "rust",
             source,
             concat!(
-                "(function_item\n",
+                "(function_item \"fn\"\n",
                 "  name: (identifier)\n",
-                "  parameters: (parameters)\n",
-                "  body: (block\n",
+                "  parameters: (parameters \"(\" \")\")\n",
+                "  body: (block \"{\"\n",
                 "    (expression_statement\n",
                 "      (macro_invocation\n",
-                "        macro: (identifier)\n",
-                "        (token_tree\n",
-                "          (string_literal\n",
-                "            (string_content)))))))",
+                "        macro: (identifier) \"!\"\n",
+                "        (token_tree \"(\"\n",
+                "          (string_literal \"\\\"\"\n",
+                "            (string_content) \"\\\"\") \")\")) \";\") \"}\"))",
             ),
             0,
             source.len(),
@@ -2981,7 +3025,7 @@ fn test_pretty_print() {
 
         // Error nodes are printed as errors:
         let source = r#"}{"#;
-        assert_pretty_print("rust", source, "(ERROR)", 0, source.len());
+        assert_pretty_print("rust", source, "(ERROR \"}\" \"{\")", 0, source.len());
 
         // Fields broken under unnamed nodes are determined correctly.
         // In the following source, `object` belongs to the `singleton_method`
@@ -2996,11 +3040,11 @@ fn test_pretty_print() {
             "ruby",
             source,
             concat!(
-                "(singleton_method\n",
-                "  object: (self)\n",
+                "(singleton_method \"def\"\n",
+                "  object: (self) \".\"\n",
                 "  name: (identifier)\n",
                 "  body: (body_statement\n",
-                "    (true)))"
+                "    (true)) \"end\")"
             ),
             0,
             source.len(),
diff --git a/helix-core/src/syntax/tree_cursor.rs b/helix-core/src/syntax/tree_cursor.rs
index bec4a1c6c..d82ea74db 100644
--- a/helix-core/src/syntax/tree_cursor.rs
+++ b/helix-core/src/syntax/tree_cursor.rs
@@ -217,7 +217,7 @@ pub fn reset_to_byte_range(&mut self, start: usize, end: usize) {
 
     /// Returns an iterator over the children of the node the TreeCursor is on
     /// at the time this is called.
-    pub fn children(&'a mut self) -> ChildIter {
+    pub fn children(&'a mut self) -> ChildIter<'a> {
         let parent = self.node();
 
         ChildIter {
@@ -229,7 +229,7 @@ pub fn children(&'a mut self) -> ChildIter {
 
     /// Returns an iterator over the named children of the node the TreeCursor is on
     /// at the time this is called.
-    pub fn named_children(&'a mut self) -> ChildIter {
+    pub fn named_children(&'a mut self) -> ChildIter<'a> {
         let parent = self.node();
 
         ChildIter {
diff --git a/helix-core/src/text_annotations.rs b/helix-core/src/text_annotations.rs
index ff28a8dd2..9704c3d6b 100644
--- a/helix-core/src/text_annotations.rs
+++ b/helix-core/src/text_annotations.rs
@@ -211,7 +211,7 @@ pub fn consume(&self, char_idx: usize, get_char_idx: impl Fn(&A) -> usize) -> Op
 }
 
 impl<'a, A, M> From<(&'a [A], M)> for Layer<'a, A, M> {
-    fn from((annotations, metadata): (&'a [A], M)) -> Layer<A, M> {
+    fn from((annotations, metadata): (&'a [A], M)) -> Layer<'a, A, M> {
         Layer {
             annotations,
             current_index: Cell::new(0),
diff --git a/helix-core/src/transaction.rs b/helix-core/src/transaction.rs
index c5c94b750..450b47365 100644
--- a/helix-core/src/transaction.rs
+++ b/helix-core/src/transaction.rs
@@ -769,7 +769,7 @@ fn new(changeset: &'a ChangeSet) -> Self {
     }
 }
 
-impl<'a> Iterator for ChangeIterator<'a> {
+impl Iterator for ChangeIterator<'_> {
     type Item = Change;
 
     fn next(&mut self) -> Option<Self::Item> {
diff --git a/helix-core/src/uri.rs b/helix-core/src/uri.rs
index 4e03c58b1..cbe0fadda 100644
--- a/helix-core/src/uri.rs
+++ b/helix-core/src/uri.rs
@@ -1,12 +1,18 @@
-use std::path::{Path, PathBuf};
+use std::{
+    fmt,
+    path::{Path, PathBuf},
+    sync::Arc,
+};
 
 /// A generic pointer to a file location.
 ///
 /// Currently this type only supports paths to local files.
+///
+/// Cloning this type is cheap: the internal representation uses an Arc.
 #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
 #[non_exhaustive]
 pub enum Uri {
-    File(PathBuf),
+    File(Arc<Path>),
 }
 
 impl Uri {
@@ -23,26 +29,18 @@ pub fn as_path(&self) -> Option<&Path> {
             Self::File(path) => Some(path),
         }
     }
-
-    pub fn as_path_buf(self) -> Option<PathBuf> {
-        match self {
-            Self::File(path) => Some(path),
-        }
-    }
 }
 
 impl From<PathBuf> for Uri {
     fn from(path: PathBuf) -> Self {
-        Self::File(path)
+        Self::File(path.into())
     }
 }
 
-impl TryFrom<Uri> for PathBuf {
-    type Error = ();
-
-    fn try_from(uri: Uri) -> Result<Self, Self::Error> {
-        match uri {
-            Uri::File(path) => Ok(path),
+impl fmt::Display for Uri {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            Self::File(path) => write!(f, "{}", path.display()),
         }
     }
 }
@@ -59,11 +57,16 @@ pub enum UrlConversionErrorKind {
     UnableToConvert,
 }
 
-impl std::fmt::Display for UrlConversionError {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+impl fmt::Display for UrlConversionError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
         match self.kind {
             UrlConversionErrorKind::UnsupportedScheme => {
-                write!(f, "unsupported scheme in URL: {}", self.source.scheme())
+                write!(
+                    f,
+                    "unsupported scheme '{}' in URL {}",
+                    self.source.scheme(),
+                    self.source
+                )
             }
             UrlConversionErrorKind::UnableToConvert => {
                 write!(f, "unable to convert URL to file path: {}", self.source)
@@ -77,7 +80,7 @@ impl std::error::Error for UrlConversionError {}
 fn convert_url_to_uri(url: &url::Url) -> Result<Uri, UrlConversionErrorKind> {
     if url.scheme() == "file" {
         url.to_file_path()
-            .map(|path| Uri::File(helix_stdx::path::normalize(path)))
+            .map(|path| Uri::File(helix_stdx::path::normalize(path).into()))
             .map_err(|_| UrlConversionErrorKind::UnableToConvert)
     } else {
         Err(UrlConversionErrorKind::UnsupportedScheme)
diff --git a/helix-core/src/wrap.rs b/helix-core/src/wrap.rs
index f32d6f4bc..337b389ae 100644
--- a/helix-core/src/wrap.rs
+++ b/helix-core/src/wrap.rs
@@ -4,6 +4,8 @@
 /// Given a slice of text, return the text re-wrapped to fit it
 /// within the given width.
 pub fn reflow_hard_wrap(text: &str, text_width: usize) -> SmartString<LazyCompact> {
-    let options = Options::new(text_width).word_splitter(NoHyphenation);
+    let options = Options::new(text_width)
+        .word_splitter(NoHyphenation)
+        .word_separator(textwrap::WordSeparator::AsciiSpace);
     textwrap::refill(text, options).into()
 }
diff --git a/helix-dap/Cargo.toml b/helix-dap/Cargo.toml
index c37340cc6..d67932afb 100644
--- a/helix-dap/Cargo.toml
+++ b/helix-dap/Cargo.toml
@@ -24,4 +24,4 @@ tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std
 thiserror.workspace = true
 
 [dev-dependencies]
-fern = "0.6"
+fern = "0.7"
diff --git a/helix-dap/src/client.rs b/helix-dap/src/client.rs
index ed4515fe9..6aa656e17 100644
--- a/helix-dap/src/client.rs
+++ b/helix-dap/src/client.rs
@@ -119,6 +119,7 @@ pub fn stdio(
             .args(args)
             .stdin(Stdio::piped())
             .stdout(Stdio::piped())
+            .stderr(Stdio::piped())
             // make sure the process is reaped on drop
             .kill_on_drop(true)
             .spawn();
@@ -128,16 +129,12 @@ pub fn stdio(
         // TODO: do we need bufreader/writer here? or do we use async wrappers on unblock?
         let writer = BufWriter::new(process.stdin.take().expect("Failed to open stdin"));
         let reader = BufReader::new(process.stdout.take().expect("Failed to open stdout"));
-        let errors = process.stderr.take().map(BufReader::new);
+        let stderr = BufReader::new(process.stderr.take().expect("Failed to open stderr"));
 
         Self::streams(
-            Box::new(BufReader::new(reader)),
+            Box::new(reader),
             Box::new(writer),
-            // errors.map(|errors| Box::new(BufReader::new(errors))),
-            match errors {
-                Some(errors) => Some(Box::new(BufReader::new(errors))),
-                None => None,
-            },
+            Some(Box::new(stderr)),
             id,
             Some(process),
         )
diff --git a/helix-dap/src/lib.rs b/helix-dap/src/lib.rs
index d0229249d..b0605c4f0 100644
--- a/helix-dap/src/lib.rs
+++ b/helix-dap/src/lib.rs
@@ -3,10 +3,11 @@
 mod types;
 
 pub use client::{Client, ConnectionType};
-pub use events::Event;
 pub use transport::{Payload, Response, Transport};
 pub use types::*;
 
+use serde::de::DeserializeOwned;
+
 use thiserror::Error;
 #[derive(Error, Debug)]
 pub enum Error {
@@ -18,9 +19,84 @@ pub enum Error {
     Timeout(u64),
     #[error("server closed the stream")]
     StreamClosed,
+    #[error("Unhandled")]
+    Unhandled,
     #[error(transparent)]
     ExecutableNotFound(#[from] helix_stdx::env::ExecutableNotFoundError),
     #[error(transparent)]
     Other(#[from] anyhow::Error),
 }
 pub type Result<T> = core::result::Result<T, Error>;
+
+#[derive(Debug)]
+pub enum Request {
+    RunInTerminal(<requests::RunInTerminal as types::Request>::Arguments),
+}
+
+impl Request {
+    pub fn parse(command: &str, arguments: Option<serde_json::Value>) -> Result<Self> {
+        use crate::types::Request as _;
+
+        let arguments = arguments.unwrap_or_default();
+        let request = match command {
+            requests::RunInTerminal::COMMAND => Self::RunInTerminal(parse_value(arguments)?),
+            _ => return Err(Error::Unhandled),
+        };
+
+        Ok(request)
+    }
+}
+
+#[derive(Debug)]
+pub enum Event {
+    Initialized(<events::Initialized as events::Event>::Body),
+    Stopped(<events::Stopped as events::Event>::Body),
+    Continued(<events::Continued as events::Event>::Body),
+    Exited(<events::Exited as events::Event>::Body),
+    Terminated(<events::Terminated as events::Event>::Body),
+    Thread(<events::Thread as events::Event>::Body),
+    Output(<events::Output as events::Event>::Body),
+    Breakpoint(<events::Breakpoint as events::Event>::Body),
+    Module(<events::Module as events::Event>::Body),
+    LoadedSource(<events::LoadedSource as events::Event>::Body),
+    Process(<events::Process as events::Event>::Body),
+    Capabilities(<events::Capabilities as events::Event>::Body),
+    // ProgressStart(),
+    // ProgressUpdate(),
+    // ProgressEnd(),
+    // Invalidated(),
+    Memory(<events::Memory as events::Event>::Body),
+}
+
+impl Event {
+    pub fn parse(event: &str, body: Option<serde_json::Value>) -> Result<Self> {
+        use crate::events::Event as _;
+
+        let body = body.unwrap_or_default();
+        let event = match event {
+            events::Initialized::EVENT => Self::Initialized(parse_value(body)?),
+            events::Stopped::EVENT => Self::Stopped(parse_value(body)?),
+            events::Continued::EVENT => Self::Continued(parse_value(body)?),
+            events::Exited::EVENT => Self::Exited(parse_value(body)?),
+            events::Terminated::EVENT => Self::Terminated(parse_value(body)?),
+            events::Thread::EVENT => Self::Thread(parse_value(body)?),
+            events::Output::EVENT => Self::Output(parse_value(body)?),
+            events::Breakpoint::EVENT => Self::Breakpoint(parse_value(body)?),
+            events::Module::EVENT => Self::Module(parse_value(body)?),
+            events::LoadedSource::EVENT => Self::LoadedSource(parse_value(body)?),
+            events::Process::EVENT => Self::Process(parse_value(body)?),
+            events::Capabilities::EVENT => Self::Capabilities(parse_value(body)?),
+            events::Memory::EVENT => Self::Memory(parse_value(body)?),
+            _ => return Err(Error::Unhandled),
+        };
+
+        Ok(event)
+    }
+}
+
+fn parse_value<T>(value: serde_json::Value) -> Result<T>
+where
+    T: DeserializeOwned,
+{
+    serde_json::from_value(value).map_err(|err| err.into())
+}
diff --git a/helix-dap/src/transport.rs b/helix-dap/src/transport.rs
index 0f646b6a4..c1e15b3fc 100644
--- a/helix-dap/src/transport.rs
+++ b/helix-dap/src/transport.rs
@@ -1,4 +1,4 @@
-use crate::{Error, Event, Result};
+use crate::{Error, Result};
 use anyhow::Context;
 use log::{error, info, warn};
 use serde::{Deserialize, Serialize};
@@ -32,11 +32,17 @@ pub struct Response {
     pub body: Option<Value>,
 }
 
+#[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
+pub struct Event {
+    pub event: String,
+    pub body: Option<Value>,
+}
+
 #[derive(Debug, Clone, Deserialize, Serialize)]
 #[serde(tag = "type", rename_all = "camelCase")]
 pub enum Payload {
     // type = "event"
-    Event(Box<Event>),
+    Event(Event),
     // type = "response"
     Response(Response),
     // type = "request"
@@ -230,25 +236,37 @@ async fn process_server_message(
         }
     }
 
-    async fn recv_inner(
+    async fn recv(
         transport: Arc<Self>,
         mut server_stdout: Box<dyn AsyncBufRead + Unpin + Send>,
         client_tx: UnboundedSender<Payload>,
-    ) -> Result<()> {
+    ) {
         let mut recv_buffer = String::new();
         loop {
-            let msg = Self::recv_server_message(&mut server_stdout, &mut recv_buffer).await?;
-            transport.process_server_message(&client_tx, msg).await?;
-        }
-    }
+            match Self::recv_server_message(&mut server_stdout, &mut recv_buffer).await {
+                Ok(msg) => match transport.process_server_message(&client_tx, msg).await {
+                    Ok(_) => (),
+                    Err(err) => {
+                        error!("err: <- {err:?}");
+                        break;
+                    }
+                },
+                Err(err) => {
+                    if !matches!(err, Error::StreamClosed) {
+                        error!("Exiting after unexpected error: {err:?}");
+                    }
 
-    async fn recv(
-        transport: Arc<Self>,
-        server_stdout: Box<dyn AsyncBufRead + Unpin + Send>,
-        client_tx: UnboundedSender<Payload>,
-    ) {
-        if let Err(err) = Self::recv_inner(transport, server_stdout, client_tx).await {
-            error!("err: <- {:?}", err);
+                    // Close any outstanding requests.
+                    for (id, tx) in transport.pending_requests.lock().await.drain() {
+                        match tx.send(Err(Error::StreamClosed)).await {
+                            Ok(_) => (),
+                            Err(_) => {
+                                error!("Could not close request on a closed channel (id={id})");
+                            }
+                        }
+                    }
+                }
+            }
         }
     }
 
diff --git a/helix-dap/src/types.rs b/helix-dap/src/types.rs
index 9cec05e65..67f4937f1 100644
--- a/helix-dap/src/types.rs
+++ b/helix-dap/src/types.rs
@@ -759,33 +759,30 @@ impl Request for RunInTerminal {
 pub mod events {
     use super::*;
 
-    #[derive(Debug, Clone, Serialize, Deserialize)]
-    #[serde(rename_all = "camelCase")]
-    #[serde(tag = "event", content = "body")]
-    // seq is omitted as unused and is not sent by some implementations
-    pub enum Event {
-        Initialized(Option<DebuggerCapabilities>),
-        Stopped(Stopped),
-        Continued(Continued),
-        Exited(Exited),
-        Terminated(Option<Terminated>),
-        Thread(Thread),
-        Output(Output),
-        Breakpoint(Breakpoint),
-        Module(Module),
-        LoadedSource(LoadedSource),
-        Process(Process),
-        Capabilities(Capabilities),
-        // ProgressStart(),
-        // ProgressUpdate(),
-        // ProgressEnd(),
-        // Invalidated(),
-        Memory(Memory),
+    pub trait Event {
+        type Body: serde::de::DeserializeOwned + serde::Serialize;
+        const EVENT: &'static str;
+    }
+
+    #[derive(Debug)]
+    pub enum Initialized {}
+
+    impl Event for Initialized {
+        type Body = Option<DebuggerCapabilities>;
+        const EVENT: &'static str = "initialized";
+    }
+
+    #[derive(Debug)]
+    pub enum Stopped {}
+
+    impl Event for Stopped {
+        type Body = StoppedBody;
+        const EVENT: &'static str = "stopped";
     }
 
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Stopped {
+    pub struct StoppedBody {
         pub reason: String,
         #[serde(skip_serializing_if = "Option::is_none")]
         pub description: Option<String>,
@@ -801,37 +798,77 @@ pub struct Stopped {
         pub hit_breakpoint_ids: Option<Vec<usize>>,
     }
 
+    #[derive(Debug)]
+    pub enum Continued {}
+
+    impl Event for Continued {
+        type Body = ContinuedBody;
+        const EVENT: &'static str = "continued";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Continued {
+    pub struct ContinuedBody {
         pub thread_id: ThreadId,
         #[serde(skip_serializing_if = "Option::is_none")]
         pub all_threads_continued: Option<bool>,
     }
 
+    #[derive(Debug)]
+    pub enum Exited {}
+
+    impl Event for Exited {
+        type Body = ExitedBody;
+        const EVENT: &'static str = "exited";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Exited {
+    pub struct ExitedBody {
         pub exit_code: usize,
     }
 
+    #[derive(Debug)]
+    pub enum Terminated {}
+
+    impl Event for Terminated {
+        type Body = Option<TerminatedBody>;
+        const EVENT: &'static str = "terminated";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Terminated {
+    pub struct TerminatedBody {
         #[serde(skip_serializing_if = "Option::is_none")]
         pub restart: Option<Value>,
     }
 
+    #[derive(Debug)]
+    pub enum Thread {}
+
+    impl Event for Thread {
+        type Body = ThreadBody;
+        const EVENT: &'static str = "thread";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Thread {
+    pub struct ThreadBody {
         pub reason: String,
         pub thread_id: ThreadId,
     }
 
+    #[derive(Debug)]
+    pub enum Output {}
+
+    impl Event for Output {
+        type Body = OutputBody;
+        const EVENT: &'static str = "output";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Output {
+    pub struct OutputBody {
         pub output: String,
         #[serde(skip_serializing_if = "Option::is_none")]
         pub category: Option<String>,
@@ -849,30 +886,62 @@ pub struct Output {
         pub data: Option<Value>,
     }
 
+    #[derive(Debug)]
+    pub enum Breakpoint {}
+
+    impl Event for Breakpoint {
+        type Body = BreakpointBody;
+        const EVENT: &'static str = "breakpoint";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Breakpoint {
+    pub struct BreakpointBody {
         pub reason: String,
         pub breakpoint: super::Breakpoint,
     }
 
+    #[derive(Debug)]
+    pub enum Module {}
+
+    impl Event for Module {
+        type Body = ModuleBody;
+        const EVENT: &'static str = "module";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Module {
+    pub struct ModuleBody {
         pub reason: String,
         pub module: super::Module,
     }
 
+    #[derive(Debug)]
+    pub enum LoadedSource {}
+
+    impl Event for LoadedSource {
+        type Body = LoadedSourceBody;
+        const EVENT: &'static str = "loadedSource";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct LoadedSource {
+    pub struct LoadedSourceBody {
         pub reason: String,
         pub source: super::Source,
     }
 
+    #[derive(Debug)]
+    pub enum Process {}
+
+    impl Event for Process {
+        type Body = ProcessBody;
+        const EVENT: &'static str = "process";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Process {
+    pub struct ProcessBody {
         pub name: String,
         #[serde(skip_serializing_if = "Option::is_none")]
         pub system_process_id: Option<usize>,
@@ -884,39 +953,55 @@ pub struct Process {
         pub pointer_size: Option<usize>,
     }
 
+    #[derive(Debug)]
+    pub enum Capabilities {}
+
+    impl Event for Capabilities {
+        type Body = CapabilitiesBody;
+        const EVENT: &'static str = "capabilities";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Capabilities {
+    pub struct CapabilitiesBody {
         pub capabilities: super::DebuggerCapabilities,
     }
 
     // #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     // #[serde(rename_all = "camelCase")]
-    // pub struct Invalidated {
+    // pub struct InvalidatedBody {
     // pub areas: Vec<InvalidatedArea>,
     // pub thread_id: Option<ThreadId>,
     // pub stack_frame_id: Option<usize>,
     // }
 
+    #[derive(Debug)]
+    pub enum Memory {}
+
+    impl Event for Memory {
+        type Body = MemoryBody;
+        const EVENT: &'static str = "memory";
+    }
+
     #[derive(Debug, PartialEq, Eq, Clone, Deserialize, Serialize)]
     #[serde(rename_all = "camelCase")]
-    pub struct Memory {
+    pub struct MemoryBody {
         pub memory_reference: String,
         pub offset: usize,
         pub count: usize,
     }
+}
 
-    #[test]
-    fn test_deserialize_module_id_from_number() {
-        let raw = r#"{"id": 0, "name": "Name"}"#;
-        let module: super::Module = serde_json::from_str(raw).expect("Error!");
-        assert_eq!(module.id, "0");
-    }
+#[test]
+fn test_deserialize_module_id_from_number() {
+    let raw = r#"{"id": 0, "name": "Name"}"#;
+    let module: Module = serde_json::from_str(raw).expect("Error!");
+    assert_eq!(module.id, "0");
+}
 
-    #[test]
-    fn test_deserialize_module_id_from_string() {
-        let raw = r#"{"id": "0", "name": "Name"}"#;
-        let module: super::Module = serde_json::from_str(raw).expect("Error!");
-        assert_eq!(module.id, "0");
-    }
+#[test]
+fn test_deserialize_module_id_from_string() {
+    let raw = r#"{"id": "0", "name": "Name"}"#;
+    let module: Module = serde_json::from_str(raw).expect("Error!");
+    assert_eq!(module.id, "0");
 }
diff --git a/helix-event/Cargo.toml b/helix-event/Cargo.toml
index e7c877355..ee4038e69 100644
--- a/helix-event/Cargo.toml
+++ b/helix-event/Cargo.toml
@@ -19,11 +19,11 @@ tokio = { version = "1", features = ["rt", "rt-multi-thread", "time", "sync", "p
 # setup new events on initialization, hardware-lock-elision hugely benefits this case
 # as it essentially makes the lock entirely free as long as there is no writes 
 parking_lot = { version = "0.12", features = ["hardware-lock-elision"] }
-once_cell = "1.18"
+once_cell = "1.20"
 
 anyhow = "1"
 log = "0.4"
-futures-executor = "0.3.28"
+futures-executor = "0.3.31"
 
 [features]
 integration_test = []
diff --git a/helix-event/src/cancel.rs b/helix-event/src/cancel.rs
index f027be80e..2029c9456 100644
--- a/helix-event/src/cancel.rs
+++ b/helix-event/src/cancel.rs
@@ -1,15 +1,18 @@
+use std::borrow::Borrow;
 use std::future::Future;
+use std::sync::atomic::AtomicU64;
+use std::sync::atomic::Ordering::Relaxed;
+use std::sync::Arc;
 
-pub use oneshot::channel as cancelation;
-use tokio::sync::oneshot;
+use tokio::sync::Notify;
 
-pub type CancelTx = oneshot::Sender<()>;
-pub type CancelRx = oneshot::Receiver<()>;
-
-pub async fn cancelable_future<T>(future: impl Future<Output = T>, cancel: CancelRx) -> Option<T> {
+pub async fn cancelable_future<T>(
+    future: impl Future<Output = T>,
+    cancel: impl Borrow<TaskHandle>,
+) -> Option<T> {
     tokio::select! {
         biased;
-        _ = cancel => {
+        _ = cancel.borrow().canceled() => {
             None
         }
         res = future => {
@@ -17,3 +20,268 @@ pub async fn cancelable_future<T>(future: impl Future<Output = T>, cancel: Cance
         }
     }
 }
+
+#[derive(Default, Debug)]
+struct Shared {
+    state: AtomicU64,
+    // `Notify` has some features that we don't really need here because it
+    // supports waking single tasks (`notify_one`) and does its own (more
+    // complicated) state tracking, we could reimplement the waiter linked list
+    // with modest effort and reduce memory consumption by one word/8 bytes and
+    // reduce code complexity/number of atomic operations.
+    //
+    // I don't think that's worth the complexity (unsafe code).
+    //
+    // if we only cared about async code then we could also only use a notify
+    // (without the generation count), this would be equivalent (or maybe more
+    // correct if we want to allow cloning the TX) but it would be extremly slow
+    // to frequently check for cancelation from sync code
+    notify: Notify,
+}
+
+impl Shared {
+    fn generation(&self) -> u32 {
+        self.state.load(Relaxed) as u32
+    }
+
+    fn num_running(&self) -> u32 {
+        (self.state.load(Relaxed) >> 32) as u32
+    }
+
+    /// Increments the generation count and sets `num_running`
+    /// to the provided value, this operation is not with
+    /// regard to the generation counter (doesn't use `fetch_add`)
+    /// so the calling code must ensure it cannot execute concurrently
+    /// to maintain correctness (but not safety)
+    fn inc_generation(&self, num_running: u32) -> (u32, u32) {
+        let state = self.state.load(Relaxed);
+        let generation = state as u32;
+        let prev_running = (state >> 32) as u32;
+        // no need to create a new generation if the refcount is zero (fastpath)
+        if prev_running == 0 && num_running == 0 {
+            return (generation, 0);
+        }
+        let new_generation = generation.saturating_add(1);
+        self.state.store(
+            new_generation as u64 | ((num_running as u64) << 32),
+            Relaxed,
+        );
+        self.notify.notify_waiters();
+        (new_generation, prev_running)
+    }
+
+    fn inc_running(&self, generation: u32) {
+        let mut state = self.state.load(Relaxed);
+        loop {
+            let current_generation = state as u32;
+            if current_generation != generation {
+                break;
+            }
+            let off = 1 << 32;
+            let res = self.state.compare_exchange_weak(
+                state,
+                state.saturating_add(off),
+                Relaxed,
+                Relaxed,
+            );
+            match res {
+                Ok(_) => break,
+                Err(new_state) => state = new_state,
+            }
+        }
+    }
+
+    fn dec_running(&self, generation: u32) {
+        let mut state = self.state.load(Relaxed);
+        loop {
+            let current_generation = state as u32;
+            if current_generation != generation {
+                break;
+            }
+            let num_running = (state >> 32) as u32;
+            // running can't be zero here, that would mean we miscounted somewhere
+            assert_ne!(num_running, 0);
+            let off = 1 << 32;
+            let res = self
+                .state
+                .compare_exchange_weak(state, state - off, Relaxed, Relaxed);
+            match res {
+                Ok(_) => break,
+                Err(new_state) => state = new_state,
+            }
+        }
+    }
+}
+
+// This intentionally doesn't implement `Clone` and requires a mutable reference
+// for cancelation to avoid races (in inc_generation).
+
+/// A task controller allows managing a single subtask enabling the controller
+/// to cancel the subtask and to check whether it is still running.
+///
+/// For efficiency reasons the controller can be reused/restarted,
+/// in that case the previous task is automatically canceled.
+///
+/// If the controller is dropped, the subtasks are automatically canceled.
+#[derive(Default, Debug)]
+pub struct TaskController {
+    shared: Arc<Shared>,
+}
+
+impl TaskController {
+    pub fn new() -> Self {
+        TaskController::default()
+    }
+    /// Cancels the active task (handle).
+    ///
+    /// Returns whether any tasks were still running before the cancelation.
+    pub fn cancel(&mut self) -> bool {
+        self.shared.inc_generation(0).1 != 0
+    }
+
+    /// Checks whether there are any task handles
+    /// that haven't been dropped (or canceled) yet.
+    pub fn is_running(&self) -> bool {
+        self.shared.num_running() != 0
+    }
+
+    /// Starts a new task and cancels the previous task (handles).
+    pub fn restart(&mut self) -> TaskHandle {
+        TaskHandle {
+            generation: self.shared.inc_generation(1).0,
+            shared: self.shared.clone(),
+        }
+    }
+}
+
+impl Drop for TaskController {
+    fn drop(&mut self) {
+        self.cancel();
+    }
+}
+
+/// A handle that is used to link a task with a task controller.
+///
+/// It can be used to cancel async futures very efficiently but can also be checked for
+/// cancelation very quickly (single atomic read) in blocking code.
+/// The handle can be cheaply cloned (reference counted).
+///
+/// The TaskController can check whether a task is "running" by inspecting the
+/// refcount of the (current) tasks handles. Therefore, if that information
+/// is important, ensure that the handle is not dropped until the task fully
+/// completes.
+pub struct TaskHandle {
+    shared: Arc<Shared>,
+    generation: u32,
+}
+
+impl Clone for TaskHandle {
+    fn clone(&self) -> Self {
+        self.shared.inc_running(self.generation);
+        TaskHandle {
+            shared: self.shared.clone(),
+            generation: self.generation,
+        }
+    }
+}
+
+impl Drop for TaskHandle {
+    fn drop(&mut self) {
+        self.shared.dec_running(self.generation);
+    }
+}
+
+impl TaskHandle {
+    /// Waits until [`TaskController::cancel`] is called for the corresponding
+    /// [`TaskController`]. Immediately returns if `cancel` was already called since
+    pub async fn canceled(&self) {
+        let notified = self.shared.notify.notified();
+        if !self.is_canceled() {
+            notified.await
+        }
+    }
+
+    pub fn is_canceled(&self) -> bool {
+        self.generation != self.shared.generation()
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use std::future::poll_fn;
+
+    use futures_executor::block_on;
+    use tokio::task::yield_now;
+
+    use crate::{cancelable_future, TaskController};
+
+    #[test]
+    fn immediate_cancel() {
+        let mut controller = TaskController::new();
+        let handle = controller.restart();
+        controller.cancel();
+        assert!(handle.is_canceled());
+        controller.restart();
+        assert!(handle.is_canceled());
+
+        let res = block_on(cancelable_future(
+            poll_fn(|_cx| std::task::Poll::Ready(())),
+            handle,
+        ));
+        assert!(res.is_none());
+    }
+
+    #[test]
+    fn running_count() {
+        let mut controller = TaskController::new();
+        let handle = controller.restart();
+        assert!(controller.is_running());
+        assert!(!handle.is_canceled());
+        drop(handle);
+        assert!(!controller.is_running());
+        assert!(!controller.cancel());
+        let handle = controller.restart();
+        assert!(!handle.is_canceled());
+        assert!(controller.is_running());
+        let handle2 = handle.clone();
+        assert!(!handle.is_canceled());
+        assert!(controller.is_running());
+        drop(handle2);
+        assert!(!handle.is_canceled());
+        assert!(controller.is_running());
+        assert!(controller.cancel());
+        assert!(handle.is_canceled());
+        assert!(!controller.is_running());
+    }
+
+    #[test]
+    fn no_cancel() {
+        let mut controller = TaskController::new();
+        let handle = controller.restart();
+        assert!(!handle.is_canceled());
+
+        let res = block_on(cancelable_future(
+            poll_fn(|_cx| std::task::Poll::Ready(())),
+            handle,
+        ));
+        assert!(res.is_some());
+    }
+
+    #[test]
+    fn delayed_cancel() {
+        let mut controller = TaskController::new();
+        let handle = controller.restart();
+
+        let mut hit = false;
+        let res = block_on(cancelable_future(
+            async {
+                controller.cancel();
+                hit = true;
+                yield_now().await;
+            },
+            handle,
+        ));
+        assert!(res.is_none());
+        assert!(hit);
+    }
+}
diff --git a/helix-event/src/lib.rs b/helix-event/src/lib.rs
index de018a79d..8aa6b52fa 100644
--- a/helix-event/src/lib.rs
+++ b/helix-event/src/lib.rs
@@ -32,7 +32,7 @@
 //! to helix-view in the future if we manage to detach the compositor from its rendering backend.
 
 use anyhow::Result;
-pub use cancel::{cancelable_future, cancelation, CancelRx, CancelTx};
+pub use cancel::{cancelable_future, TaskController, TaskHandle};
 pub use debounce::{send_blocking, AsyncHook};
 pub use redraw::{
     lock_frame, redraw_requested, request_redraw, start_frame, RenderLockGuard, RequestRedrawOnDrop,
diff --git a/helix-loader/Cargo.toml b/helix-loader/Cargo.toml
index f74829f30..d97bf9d1a 100644
--- a/helix-loader/Cargo.toml
+++ b/helix-loader/Cargo.toml
@@ -22,7 +22,7 @@ serde = { version = "1.0", features = ["derive"] }
 toml = "0.8"
 etcetera = "0.8"
 tree-sitter.workspace = true
-once_cell = "1.19"
+once_cell = "1.20"
 log = "0.4"
 
 # TODO: these two should be on !wasm32 only
@@ -30,7 +30,7 @@ log = "0.4"
 # cloning/compiling tree-sitter grammars
 cc = { version = "1" }
 threadpool = { version = "1.0" }
-tempfile = "3.12.0"
+tempfile.workspace = true
 dunce = "1.0.5"
 
 [target.'cfg(not(target_arch = "wasm32"))'.dependencies]
diff --git a/helix-loader/build.rs b/helix-loader/build.rs
index ea0689839..22f2fa8f3 100644
--- a/helix-loader/build.rs
+++ b/helix-loader/build.rs
@@ -6,23 +6,26 @@
 const MINOR: &str = env!("CARGO_PKG_VERSION_MINOR");
 const PATCH: &str = env!("CARGO_PKG_VERSION_PATCH");
 
-fn get_calver() -> String {
-    if PATCH == "0" {
-        format!("{MAJOR}.{MINOR}")
-    } else {
-        format!("{MAJOR}.{MINOR}.{PATCH}")
-    }
-}
-
 fn main() {
     let git_hash = Command::new("git")
         .args(["rev-parse", "HEAD"])
         .output()
         .ok()
         .filter(|output| output.status.success())
-        .and_then(|x| String::from_utf8(x.stdout).ok());
+        .and_then(|x| String::from_utf8(x.stdout).ok())
+        .or_else(|| option_env!("HELIX_NIX_BUILD_REV").map(|s| s.to_string()));
 
-    let calver = get_calver();
+    let minor = if MINOR.len() == 1 {
+        // Print single-digit months in '0M' format
+        format!("0{MINOR}")
+    } else {
+        MINOR.to_string()
+    };
+    let calver = if PATCH == "0" {
+        format!("{MAJOR}.{minor}")
+    } else {
+        format!("{MAJOR}.{minor}.{PATCH}")
+    };
     let version: Cow<_> = match &git_hash {
         Some(git_hash) => format!("{} ({})", calver, &git_hash[..8]).into(),
         None => calver.into(),
diff --git a/helix-loader/src/grammar.rs b/helix-loader/src/grammar.rs
index 99e911544..7e4fc2b58 100644
--- a/helix-loader/src/grammar.rs
+++ b/helix-loader/src/grammar.rs
@@ -273,12 +273,12 @@ fn fetch_grammar(grammar: GrammarConfiguration) -> Result<FetchStatus> {
         }
 
         // ensure the remote matches the configured remote
-        if get_remote_url(&grammar_dir).map_or(true, |s| s != remote) {
+        if get_remote_url(&grammar_dir).as_ref() != Some(&remote) {
             set_remote(&grammar_dir, &remote)?;
         }
 
         // ensure the revision matches the configured revision
-        if get_revision(&grammar_dir).map_or(true, |s| s != revision) {
+        if get_revision(&grammar_dir).as_ref() != Some(&revision) {
             // Fetch the exact revision from the remote.
             // Supported by server-side git since v2.5.0 (July 2015),
             // enabled by default on major git hosts.
diff --git a/helix-loader/src/lib.rs b/helix-loader/src/lib.rs
index f36c76c4f..0e7c134d0 100644
--- a/helix-loader/src/lib.rs
+++ b/helix-loader/src/lib.rs
@@ -225,7 +225,7 @@ fn get_name(v: &Value) -> Option<&str> {
 /// Used as a ceiling dir for LSP root resolution, the filepicker and potentially as a future filewatching root
 ///
 /// This function starts searching the FS upward from the CWD
-/// and returns the first directory that contains either `.git`, `.svn` or `.helix`.
+/// and returns the first directory that contains either `.git`, `.svn`, `.jj` or `.helix`.
 /// If no workspace was found returns (CWD, true).
 /// Otherwise (workspace, false) is returned
 pub fn find_workspace() -> (PathBuf, bool) {
@@ -233,6 +233,7 @@ pub fn find_workspace() -> (PathBuf, bool) {
     for ancestor in current_dir.ancestors() {
         if ancestor.join(".git").exists()
             || ancestor.join(".svn").exists()
+            || ancestor.join(".jj").exists()
             || ancestor.join(".helix").exists()
         {
             return (ancestor.to_owned(), false);
diff --git a/helix-lsp-types/Cargo.lock b/helix-lsp-types/Cargo.lock
deleted file mode 100644
index 11ac87521..000000000
--- a/helix-lsp-types/Cargo.lock
+++ /dev/null
@@ -1,176 +0,0 @@
-# This file is automatically @generated by Cargo.
-# It is not intended for manual editing.
-version = 3
-
-[[package]]
-name = "bitflags"
-version = "1.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
-
-[[package]]
-name = "form_urlencoded"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9c384f161156f5260c24a097c56119f9be8c798586aecc13afbcbe7b7e26bf8"
-dependencies = [
- "percent-encoding",
-]
-
-[[package]]
-name = "idna"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6"
-dependencies = [
- "unicode-bidi",
- "unicode-normalization",
-]
-
-[[package]]
-name = "itoa"
-version = "1.0.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc"
-
-[[package]]
-name = "lsp-types"
-version = "0.95.1"
-dependencies = [
- "bitflags",
- "serde",
- "serde_json",
- "serde_repr",
- "url",
-]
-
-[[package]]
-name = "percent-encoding"
-version = "2.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "478c572c3d73181ff3c2539045f6eb99e5491218eae919370993b890cdbdd98e"
-
-[[package]]
-name = "proc-macro2"
-version = "1.0.47"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725"
-dependencies = [
- "unicode-ident",
-]
-
-[[package]]
-name = "quote"
-version = "1.0.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179"
-dependencies = [
- "proc-macro2",
-]
-
-[[package]]
-name = "ryu"
-version = "1.0.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09"
-
-[[package]]
-name = "serde"
-version = "1.0.145"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "728eb6351430bccb993660dfffc5a72f91ccc1295abaa8ce19b27ebe4f75568b"
-dependencies = [
- "serde_derive",
-]
-
-[[package]]
-name = "serde_derive"
-version = "1.0.145"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "81fa1584d3d1bcacd84c277a0dfe21f5b0f6accf4a23d04d4c6d61f1af522b4c"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "serde_json"
-version = "1.0.86"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "41feea4228a6f1cd09ec7a3593a682276702cd67b5273544757dae23c096f074"
-dependencies = [
- "itoa",
- "ryu",
- "serde",
-]
-
-[[package]]
-name = "serde_repr"
-version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1fe39d9fbb0ebf5eb2c7cb7e2a47e4f462fad1379f1166b8ae49ad9eae89a7ca"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "syn"
-version = "1.0.102"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1"
-dependencies = [
- "proc-macro2",
- "quote",
- "unicode-ident",
-]
-
-[[package]]
-name = "tinyvec"
-version = "1.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
-dependencies = [
- "tinyvec_macros",
-]
-
-[[package]]
-name = "tinyvec_macros"
-version = "0.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c"
-
-[[package]]
-name = "unicode-bidi"
-version = "0.3.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992"
-
-[[package]]
-name = "unicode-ident"
-version = "1.0.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3"
-
-[[package]]
-name = "unicode-normalization"
-version = "0.1.22"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
-dependencies = [
- "tinyvec",
-]
-
-[[package]]
-name = "url"
-version = "2.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d68c799ae75762b8c3fe375feb6600ef5602c883c5d21eb51c09f22b83c4643"
-dependencies = [
- "form_urlencoded",
- "idna",
- "percent-encoding",
- "serde",
-]
diff --git a/helix-lsp-types/Cargo.toml b/helix-lsp-types/Cargo.toml
index 655b36f2f..57eb331af 100644
--- a/helix-lsp-types/Cargo.toml
+++ b/helix-lsp-types/Cargo.toml
@@ -21,11 +21,11 @@ keywords = ["language", "server", "lsp", "vscode", "lsif"]
 license = "MIT"
 
 [dependencies]
-bitflags = "2.6.0"
-serde = { version = "1.0.208", features = ["derive"] }
-serde_json = "1.0.125"
+bitflags.workspace = true
+serde = { version = "1.0.217", features = ["derive"] }
+serde_json = "1.0.138"
 serde_repr = "0.1"
-url = {version = "2.0.0", features = ["serde"]}
+url = {version = "2.5.4", features = ["serde"]}
 
 [features]
 default = []
diff --git a/helix-lsp-types/src/call_hierarchy.rs b/helix-lsp-types/src/call_hierarchy.rs
index dea78803f..2669e08ee 100644
--- a/helix-lsp-types/src/call_hierarchy.rs
+++ b/helix-lsp-types/src/call_hierarchy.rs
@@ -1,10 +1,9 @@
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
-use url::Url;
 
 use crate::{
     DynamicRegistrationClientCapabilities, PartialResultParams, Range, SymbolKind, SymbolTag,
-    TextDocumentPositionParams, WorkDoneProgressOptions, WorkDoneProgressParams,
+    TextDocumentPositionParams, Url, WorkDoneProgressOptions, WorkDoneProgressParams,
 };
 
 pub type CallHierarchyClientCapabilities = DynamicRegistrationClientCapabilities;
diff --git a/helix-lsp-types/src/completion.rs b/helix-lsp-types/src/completion.rs
index 2555228a7..7c006bdb6 100644
--- a/helix-lsp-types/src/completion.rs
+++ b/helix-lsp-types/src/completion.rs
@@ -497,7 +497,6 @@ pub struct CompletionItem {
     /// insertText is ignored.
     ///
     /// Most editors support two different operation when accepting a completion item. One is to insert a
-
     /// completion text and the other is to replace an existing text with a completion text. Since this can
     /// usually not predetermined by a server it can report both ranges. Clients need to signal support for
     /// `InsertReplaceEdits` via the `textDocument.completion.insertReplaceSupport` client capability
diff --git a/helix-lsp-types/src/document_diagnostic.rs b/helix-lsp-types/src/document_diagnostic.rs
index a2b5c41fa..5a1c6b35a 100644
--- a/helix-lsp-types/src/document_diagnostic.rs
+++ b/helix-lsp-types/src/document_diagnostic.rs
@@ -1,11 +1,10 @@
 use std::collections::HashMap;
 
 use serde::{Deserialize, Serialize};
-use url::Url;
 
 use crate::{
     Diagnostic, PartialResultParams, StaticRegistrationOptions, TextDocumentIdentifier,
-    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+    TextDocumentRegistrationOptions, Url, WorkDoneProgressOptions, WorkDoneProgressParams,
 };
 
 /// Client capabilities specific to diagnostic pull requests.
diff --git a/helix-lsp-types/src/document_link.rs b/helix-lsp-types/src/document_link.rs
index 1400dd96b..dde0e2011 100644
--- a/helix-lsp-types/src/document_link.rs
+++ b/helix-lsp-types/src/document_link.rs
@@ -1,10 +1,9 @@
 use crate::{
-    PartialResultParams, Range, TextDocumentIdentifier, WorkDoneProgressOptions,
+    PartialResultParams, Range, TextDocumentIdentifier, Url, WorkDoneProgressOptions,
     WorkDoneProgressParams,
 };
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
-use url::Url;
 
 #[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
 #[serde(rename_all = "camelCase")]
diff --git a/helix-lsp-types/src/inline_value.rs b/helix-lsp-types/src/inline_value.rs
index dd29fbbf9..73e98d45f 100644
--- a/helix-lsp-types/src/inline_value.rs
+++ b/helix-lsp-types/src/inline_value.rs
@@ -132,6 +132,7 @@ pub struct InlineValueEvaluatableExpression {
 /// - directly as a text value (class InlineValueText).
 /// - as a name to use for a variable lookup (class InlineValueVariableLookup)
 /// - as an evaluatable expression (class InlineValueEvaluatableExpression)
+///
 /// The InlineValue types combines all inline value types into one type.
 ///
 /// @since 3.17.0
diff --git a/helix-lsp-types/src/lib.rs b/helix-lsp-types/src/lib.rs
index 3ea1c0cd0..41c483f42 100644
--- a/helix-lsp-types/src/lib.rs
+++ b/helix-lsp-types/src/lib.rs
@@ -16,8 +16,8 @@
 */
 #![allow(non_upper_case_globals)]
 #![forbid(unsafe_code)]
-#[macro_use]
-extern crate bitflags;
+
+use bitflags::bitflags;
 
 use std::{collections::HashMap, fmt::Debug};
 
diff --git a/helix-lsp-types/src/window.rs b/helix-lsp-types/src/window.rs
index ac45e6083..0cfffa0ce 100644
--- a/helix-lsp-types/src/window.rs
+++ b/helix-lsp-types/src/window.rs
@@ -4,9 +4,7 @@
 
 use serde_json::Value;
 
-use url::Url;
-
-use crate::Range;
+use crate::{Range, Url};
 
 #[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
 #[serde(transparent)]
diff --git a/helix-lsp-types/src/workspace_diagnostic.rs b/helix-lsp-types/src/workspace_diagnostic.rs
index e8a7646b0..485dcc2bb 100644
--- a/helix-lsp-types/src/workspace_diagnostic.rs
+++ b/helix-lsp-types/src/workspace_diagnostic.rs
@@ -1,8 +1,7 @@
 use serde::{Deserialize, Serialize};
-use url::Url;
 
 use crate::{
-    FullDocumentDiagnosticReport, PartialResultParams, UnchangedDocumentDiagnosticReport,
+    FullDocumentDiagnosticReport, PartialResultParams, UnchangedDocumentDiagnosticReport, Url,
     WorkDoneProgressParams,
 };
 
diff --git a/helix-lsp-types/src/workspace_folders.rs b/helix-lsp-types/src/workspace_folders.rs
index aeca89ffe..2169cade0 100644
--- a/helix-lsp-types/src/workspace_folders.rs
+++ b/helix-lsp-types/src/workspace_folders.rs
@@ -1,7 +1,6 @@
 use serde::{Deserialize, Serialize};
-use url::Url;
 
-use crate::OneOf;
+use crate::{OneOf, Url};
 
 #[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
 #[serde(rename_all = "camelCase")]
diff --git a/helix-lsp/Cargo.toml b/helix-lsp/Cargo.toml
index c4260be6d..12da18e9b 100644
--- a/helix-lsp/Cargo.toml
+++ b/helix-lsp/Cargo.toml
@@ -22,12 +22,12 @@ helix-lsp-types = { path = "../helix-lsp-types" }
 anyhow = "1.0"
 futures-executor = "0.3"
 futures-util = { version = "0.3", features = ["std", "async-await"], default-features = false }
-globset = "0.4.14"
+globset = "0.4.15"
 log = "0.4"
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
-tokio = { version = "1.39", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot", "sync"] }
-tokio-stream = "0.1.15"
+tokio = { version = "1.43", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot", "sync"] }
+tokio-stream = "0.1.17"
 parking_lot = "0.12.3"
 arc-swap = "1"
 slotmap.workspace = true
diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index cc1c4ce8f..3a50f20aa 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -85,7 +85,7 @@ pub fn try_add_doc(
             .and_then(|root| lsp::Url::from_file_path(root).ok());
 
         if self.root_path == root.unwrap_or(workspace)
-            || root_uri.as_ref().map_or(false, |root_uri| {
+            || root_uri.as_ref().is_some_and(|root_uri| {
                 self.workspace_folders
                     .lock()
                     .iter()
@@ -170,7 +170,7 @@ fn add_workspace_folder(
             // and that we can therefore reuse the client (but are done now)
             return;
         }
-        tokio::spawn(self.did_change_workspace(vec![workspace_for_uri(root_uri)], Vec::new()));
+        self.did_change_workspace(vec![workspace_for_uri(root_uri)], Vec::new())
     }
 
     #[allow(clippy::type_complexity, clippy::too_many_arguments)]
@@ -426,29 +426,32 @@ fn call_with_timeout<R: lsp::request::Request>(
         let server_tx = self.server_tx.clone();
         let id = self.next_request_id();
 
-        let params = serde_json::to_value(params);
+        // It's important that this is not part of the future so that it gets executed right away
+        // and the request order stays consistent.
+        let rx = serde_json::to_value(params)
+            .map_err(Error::from)
+            .and_then(|params| {
+                let request = jsonrpc::MethodCall {
+                    jsonrpc: Some(jsonrpc::Version::V2),
+                    id: id.clone(),
+                    method: R::METHOD.to_string(),
+                    params: Self::value_into_params(params),
+                };
+                let (tx, rx) = channel::<Result<Value>>(1);
+                server_tx
+                    .send(Payload::Request {
+                        chan: tx,
+                        value: request,
+                    })
+                    .map_err(|e| Error::Other(e.into()))?;
+                Ok(rx)
+            });
+
         async move {
             use std::time::Duration;
             use tokio::time::timeout;
-
-            let request = jsonrpc::MethodCall {
-                jsonrpc: Some(jsonrpc::Version::V2),
-                id: id.clone(),
-                method: R::METHOD.to_string(),
-                params: Self::value_into_params(params?),
-            };
-
-            let (tx, mut rx) = channel::<Result<Value>>(1);
-
-            server_tx
-                .send(Payload::Request {
-                    chan: tx,
-                    value: request,
-                })
-                .map_err(|e| Error::Other(e.into()))?;
-
             // TODO: delay other calls until initialize success
-            timeout(Duration::from_secs(timeout_secs), rx.recv())
+            timeout(Duration::from_secs(timeout_secs), rx?.recv())
                 .await
                 .map_err(|_| Error::Timeout(id))? // return Timeout
                 .ok_or(Error::StreamClosed)?
@@ -456,29 +459,36 @@ fn call_with_timeout<R: lsp::request::Request>(
     }
 
     /// Send a RPC notification to the language server.
-    pub fn notify<R: lsp::notification::Notification>(
-        &self,
-        params: R::Params,
-    ) -> impl Future<Output = Result<()>>
+    pub fn notify<R: lsp::notification::Notification>(&self, params: R::Params)
     where
         R::Params: serde::Serialize,
     {
         let server_tx = self.server_tx.clone();
 
-        async move {
-            let params = serde_json::to_value(params)?;
-
-            let notification = jsonrpc::Notification {
-                jsonrpc: Some(jsonrpc::Version::V2),
-                method: R::METHOD.to_string(),
-                params: Self::value_into_params(params),
-            };
+        let params = match serde_json::to_value(params) {
+            Ok(params) => params,
+            Err(err) => {
+                log::error!(
+                    "Failed to serialize params for notification '{}' for server '{}': {err}",
+                    R::METHOD,
+                    self.name,
+                );
+                return;
+            }
+        };
 
-            server_tx
-                .send(Payload::Notification(notification))
-                .map_err(|e| Error::Other(e.into()))?;
+        let notification = jsonrpc::Notification {
+            jsonrpc: Some(jsonrpc::Version::V2),
+            method: R::METHOD.to_string(),
+            params: Self::value_into_params(params),
+        };
 
-            Ok(())
+        if let Err(err) = server_tx.send(Payload::Notification(notification)) {
+            log::error!(
+                "Failed to send notification '{}' to server '{}': {err}",
+                R::METHOD,
+                self.name
+            );
         }
     }
 
@@ -487,31 +497,29 @@ pub fn reply(
         &self,
         id: jsonrpc::Id,
         result: core::result::Result<Value, jsonrpc::Error>,
-    ) -> impl Future<Output = Result<()>> {
+    ) -> Result<()> {
         use jsonrpc::{Failure, Output, Success, Version};
 
         let server_tx = self.server_tx.clone();
 
-        async move {
-            let output = match result {
-                Ok(result) => Output::Success(Success {
-                    jsonrpc: Some(Version::V2),
-                    id,
-                    result: serde_json::to_value(result)?,
-                }),
-                Err(error) => Output::Failure(Failure {
-                    jsonrpc: Some(Version::V2),
-                    id,
-                    error,
-                }),
-            };
+        let output = match result {
+            Ok(result) => Output::Success(Success {
+                jsonrpc: Some(Version::V2),
+                id,
+                result,
+            }),
+            Err(error) => Output::Failure(Failure {
+                jsonrpc: Some(Version::V2),
+                id,
+                error,
+            }),
+        };
 
-            server_tx
-                .send(Payload::Response(output))
-                .map_err(|e| Error::Other(e.into()))?;
+        server_tx
+            .send(Payload::Response(output))
+            .map_err(|e| Error::Other(e.into()))?;
 
-            Ok(())
-        }
+        Ok(())
     }
 
     // -------------------------------------------------------------------------------------------
@@ -693,7 +701,7 @@ pub async fn shutdown(&self) -> Result<()> {
         self.request::<lsp::request::Shutdown>(()).await
     }
 
-    pub fn exit(&self) -> impl Future<Output = Result<()>> {
+    pub fn exit(&self) {
         self.notify::<lsp::notification::Exit>(())
     }
 
@@ -701,7 +709,8 @@ pub fn exit(&self) -> impl Future<Output = Result<()>> {
     /// early if server responds with an error.
     pub async fn shutdown_and_exit(&self) -> Result<()> {
         self.shutdown().await?;
-        self.exit().await
+        self.exit();
+        Ok(())
     }
 
     /// Forcefully shuts down the language server ignoring any errors.
@@ -709,24 +718,21 @@ pub async fn force_shutdown(&self) -> Result<()> {
         if let Err(e) = self.shutdown().await {
             log::warn!("language server failed to terminate gracefully - {}", e);
         }
-        self.exit().await
+        self.exit();
+        Ok(())
     }
 
     // -------------------------------------------------------------------------------------------
     // Workspace
     // -------------------------------------------------------------------------------------------
 
-    pub fn did_change_configuration(&self, settings: Value) -> impl Future<Output = Result<()>> {
+    pub fn did_change_configuration(&self, settings: Value) {
         self.notify::<lsp::notification::DidChangeConfiguration>(
             lsp::DidChangeConfigurationParams { settings },
         )
     }
 
-    pub fn did_change_workspace(
-        &self,
-        added: Vec<WorkspaceFolder>,
-        removed: Vec<WorkspaceFolder>,
-    ) -> impl Future<Output = Result<()>> {
+    pub fn did_change_workspace(&self, added: Vec<WorkspaceFolder>, removed: Vec<WorkspaceFolder>) {
         self.notify::<DidChangeWorkspaceFolders>(DidChangeWorkspaceFoldersParams {
             event: WorkspaceFoldersChangeEvent { added, removed },
         })
@@ -766,12 +772,7 @@ pub fn will_rename(
         })
     }
 
-    pub fn did_rename(
-        &self,
-        old_path: &Path,
-        new_path: &Path,
-        is_dir: bool,
-    ) -> Option<impl Future<Output = std::result::Result<(), Error>>> {
+    pub fn did_rename(&self, old_path: &Path, new_path: &Path, is_dir: bool) -> Option<()> {
         let capabilities = self.file_operations_intests();
         if !capabilities.did_rename.has_interest(new_path, is_dir) {
             return None;
@@ -789,7 +790,8 @@ pub fn did_rename(
             old_uri: url_from_path(old_path)?,
             new_uri: url_from_path(new_path)?,
         }];
-        Some(self.notify::<lsp::notification::DidRenameFiles>(lsp::RenameFilesParams { files }))
+        self.notify::<lsp::notification::DidRenameFiles>(lsp::RenameFilesParams { files });
+        Some(())
     }
 
     // -------------------------------------------------------------------------------------------
@@ -802,7 +804,7 @@ pub fn text_document_did_open(
         version: i32,
         doc: &Rope,
         language_id: String,
-    ) -> impl Future<Output = Result<()>> {
+    ) {
         self.notify::<lsp::notification::DidOpenTextDocument>(lsp::DidOpenTextDocumentParams {
             text_document: lsp::TextDocumentItem {
                 uri,
@@ -929,7 +931,7 @@ pub fn text_document_did_change(
         old_text: &Rope,
         new_text: &Rope,
         changes: &ChangeSet,
-    ) -> Option<impl Future<Output = Result<()>>> {
+    ) -> Option<()> {
         let capabilities = self.capabilities.get().unwrap();
 
         // Return early if the server does not support document sync.
@@ -961,18 +963,14 @@ pub fn text_document_did_change(
             kind => unimplemented!("{:?}", kind),
         };
 
-        Some(self.notify::<lsp::notification::DidChangeTextDocument>(
-            lsp::DidChangeTextDocumentParams {
-                text_document,
-                content_changes: changes,
-            },
-        ))
+        self.notify::<lsp::notification::DidChangeTextDocument>(lsp::DidChangeTextDocumentParams {
+            text_document,
+            content_changes: changes,
+        });
+        Some(())
     }
 
-    pub fn text_document_did_close(
-        &self,
-        text_document: lsp::TextDocumentIdentifier,
-    ) -> impl Future<Output = Result<()>> {
+    pub fn text_document_did_close(&self, text_document: lsp::TextDocumentIdentifier) {
         self.notify::<lsp::notification::DidCloseTextDocument>(lsp::DidCloseTextDocumentParams {
             text_document,
         })
@@ -984,7 +982,7 @@ pub fn text_document_did_save(
         &self,
         text_document: lsp::TextDocumentIdentifier,
         text: &Rope,
-    ) -> Option<impl Future<Output = Result<()>>> {
+    ) -> Option<()> {
         let capabilities = self.capabilities.get().unwrap();
 
         let include_text = match &capabilities.text_document_sync.as_ref()? {
@@ -1002,12 +1000,11 @@ pub fn text_document_did_save(
             lsp::TextDocumentSyncCapability::Kind(..) => false,
         };
 
-        Some(self.notify::<lsp::notification::DidSaveTextDocument>(
-            lsp::DidSaveTextDocumentParams {
-                text_document,
-                text: include_text.then_some(text.into()),
-            },
-        ))
+        self.notify::<lsp::notification::DidSaveTextDocument>(lsp::DidSaveTextDocumentParams {
+            text_document,
+            text: include_text.then_some(text.into()),
+        });
+        Some(())
     }
 
     pub fn completion(
@@ -1540,10 +1537,7 @@ pub fn command(&self, command: lsp::Command) -> Option<impl Future<Output = Resu
         Some(self.call::<lsp::request::ExecuteCommand>(params))
     }
 
-    pub fn did_change_watched_files(
-        &self,
-        changes: Vec<lsp::FileEvent>,
-    ) -> impl Future<Output = std::result::Result<(), Error>> {
+    pub fn did_change_watched_files(&self, changes: Vec<lsp::FileEvent>) {
         self.notify::<lsp::notification::DidChangeWatchedFiles>(lsp::DidChangeWatchedFilesParams {
             changes,
         })
diff --git a/helix-lsp/src/file_event.rs b/helix-lsp/src/file_event.rs
index c7297d67f..5e7f8ca60 100644
--- a/helix-lsp/src/file_event.rs
+++ b/helix-lsp/src/file_event.rs
@@ -113,17 +113,13 @@ async fn run(mut rx: mpsc::UnboundedReceiver<Event>) {
                             "Sending didChangeWatchedFiles notification to client '{}'",
                             client.name()
                         );
-                        if let Err(err) = crate::block_on(client
-                            .did_change_watched_files(vec![lsp::FileEvent {
-                                uri,
-                                // We currently always send the CHANGED state
-                                // since we don't actually have more context at
-                                // the moment.
-                                typ: lsp::FileChangeType::CHANGED,
-                            }]))
-                        {
-                            log::warn!("Failed to send didChangeWatchedFiles notification to client: {err}");
-                        }
+                        client.did_change_watched_files(vec![lsp::FileEvent {
+                            uri,
+                            // We currently always send the CHANGED state
+                            // since we don't actually have more context at
+                            // the moment.
+                            typ: lsp::FileChangeType::CHANGED,
+                        }]);
                         true
                     });
                 }
diff --git a/helix-lsp/src/jsonrpc.rs b/helix-lsp/src/jsonrpc.rs
index f415dde0b..0a5b2b4c3 100644
--- a/helix-lsp/src/jsonrpc.rs
+++ b/helix-lsp/src/jsonrpc.rs
@@ -104,10 +104,37 @@ impl std::error::Error for Error {}
 #[serde(untagged)]
 pub enum Id {
     Null,
-    Num(u64),
+    Num(#[serde(deserialize_with = "deserialize_jsonrpc_id_num")] u64),
     Str(String),
 }
 
+fn deserialize_jsonrpc_id_num<'de, D>(deserializer: D) -> Result<u64, D::Error>
+where
+    D: serde::Deserializer<'de>,
+{
+    let num = serde_json::Number::deserialize(deserializer)?;
+
+    if let Some(val) = num.as_u64() {
+        return Ok(val);
+    };
+
+    // Accept floats as long as they represent positive whole numbers.
+    // The JSONRPC spec says "Numbers SHOULD NOT contain fractional parts" so we should try to
+    // accept them if possible. The JavaScript type system lumps integers and floats together so
+    // some languages may serialize integer IDs as floats with a zeroed fractional part.
+    // See <https://github.com/helix-editor/helix/issues/12367>.
+    if let Some(val) = num
+        .as_f64()
+        .filter(|f| f.is_sign_positive() && f.fract() == 0.0)
+    {
+        return Ok(val as u64);
+    }
+
+    Err(de::Error::custom(
+        "number must be integer or float representing a whole number in valid u64 range",
+    ))
+}
+
 impl std::fmt::Display for Id {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
@@ -137,7 +164,7 @@ fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
 
 struct VersionVisitor;
 
-impl<'v> Visitor<'v> for VersionVisitor {
+impl Visitor<'_> for VersionVisitor {
     type Value = Version;
 
     fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
@@ -375,6 +402,22 @@ fn serialize_skip_none_params() {
     assert_eq!(serialized, r#"{"jsonrpc":"2.0","method":"exit"}"#);
 }
 
+#[test]
+fn id_deserialize() {
+    use serde_json;
+
+    let id = r#"8"#;
+    let deserialized: Id = serde_json::from_str(id).unwrap();
+    assert_eq!(deserialized, Id::Num(8));
+
+    let id = r#"4.0"#;
+    let deserialized: Id = serde_json::from_str(id).unwrap();
+    assert_eq!(deserialized, Id::Num(4));
+
+    let id = r#"0.01"#;
+    assert!(serde_json::from_str::<Id>(id).is_err());
+}
+
 #[test]
 fn success_output_deserialize() {
     use serde_json;
diff --git a/helix-lsp/src/lib.rs b/helix-lsp/src/lib.rs
index 47f38bcf2..5eeea81c2 100644
--- a/helix-lsp/src/lib.rs
+++ b/helix-lsp/src/lib.rs
@@ -2,7 +2,6 @@
 pub mod file_event;
 mod file_operations;
 pub mod jsonrpc;
-pub mod snippet;
 mod transport;
 
 use arc_swap::ArcSwap;
@@ -67,7 +66,8 @@ pub enum OffsetEncoding {
 pub mod util {
     use super::*;
     use helix_core::line_ending::{line_end_byte_index, line_end_char_index};
-    use helix_core::{chars, RopeSlice, SmallVec};
+    use helix_core::snippets::{RenderedSnippet, Snippet, SnippetRenderCtx};
+    use helix_core::{chars, RopeSlice};
     use helix_core::{diagnostic::NumberOrString, Range, Rope, Selection, Tendril, Transaction};
 
     /// Converts a diagnostic in the document to [`lsp::Diagnostic`].
@@ -355,25 +355,17 @@ pub fn generate_transaction_from_completion_edit(
         transaction.with_selection(selection)
     }
 
-    /// Creates a [Transaction] from the [snippet::Snippet] in a completion response.
+    /// Creates a [Transaction] from the [Snippet] in a completion response.
     /// The transaction applies the edit to all cursors.
-    #[allow(clippy::too_many_arguments)]
     pub fn generate_transaction_from_snippet(
         doc: &Rope,
         selection: &Selection,
         edit_offset: Option<(i128, i128)>,
         replace_mode: bool,
-        snippet: snippet::Snippet,
-        line_ending: &str,
-        include_placeholder: bool,
-        tab_width: usize,
-        indent_width: usize,
-    ) -> Transaction {
+        snippet: Snippet,
+        cx: &mut SnippetRenderCtx,
+    ) -> (Transaction, RenderedSnippet) {
         let text = doc.slice(..);
-
-        let mut off = 0i128;
-        let mut mapped_doc = doc.clone();
-        let mut selection_tabstops: SmallVec<[_; 1]> = SmallVec::new();
         let (removed_start, removed_end) = completion_range(
             text,
             edit_offset,
@@ -382,8 +374,7 @@ pub fn generate_transaction_from_snippet(
         )
         .expect("transaction must be valid for primary selection");
         let removed_text = text.slice(removed_start..removed_end);
-
-        let (transaction, mut selection) = Transaction::change_by_selection_ignore_overlapping(
+        let (transaction, mapped_selection, snippet) = snippet.render(
             doc,
             selection,
             |range| {
@@ -392,108 +383,15 @@ pub fn generate_transaction_from_snippet(
                     .filter(|(start, end)| text.slice(start..end) == removed_text)
                     .unwrap_or_else(|| find_completion_range(text, replace_mode, cursor))
             },
-            |replacement_start, replacement_end| {
-                let mapped_replacement_start = (replacement_start as i128 + off) as usize;
-                let mapped_replacement_end = (replacement_end as i128 + off) as usize;
-
-                let line_idx = mapped_doc.char_to_line(mapped_replacement_start);
-                let indent_level = helix_core::indent::indent_level_for_line(
-                    mapped_doc.line(line_idx),
-                    tab_width,
-                    indent_width,
-                ) * indent_width;
-
-                let newline_with_offset = format!(
-                    "{line_ending}{blank:indent_level$}",
-                    line_ending = line_ending,
-                    blank = ""
-                );
-
-                let (replacement, tabstops) =
-                    snippet::render(&snippet, &newline_with_offset, include_placeholder);
-                selection_tabstops.push((mapped_replacement_start, tabstops));
-                mapped_doc.remove(mapped_replacement_start..mapped_replacement_end);
-                mapped_doc.insert(mapped_replacement_start, &replacement);
-                off +=
-                    replacement_start as i128 - replacement_end as i128 + replacement.len() as i128;
-
-                Some(replacement)
-            },
+            cx,
         );
-
-        let changes = transaction.changes();
-        if changes.is_empty() {
-            return transaction;
-        }
-
-        // Don't normalize to avoid merging/reording selections which would
-        // break the association between tabstops and selections. Most ranges
-        // will be replaced by tabstops anyways and the final selection will be
-        // normalized anyways
-        selection = selection.map_no_normalize(changes);
-        let mut mapped_selection = SmallVec::with_capacity(selection.len());
-        let mut mapped_primary_idx = 0;
-        let primary_range = selection.primary();
-        for (range, (tabstop_anchor, tabstops)) in selection.into_iter().zip(selection_tabstops) {
-            if range == primary_range {
-                mapped_primary_idx = mapped_selection.len()
-            }
-
-            let tabstops = tabstops.first().filter(|tabstops| !tabstops.is_empty());
-            let Some(tabstops) = tabstops else {
-                // no tabstop normal mapping
-                mapped_selection.push(range);
-                continue;
-            };
-
-            // expand the selection to cover the tabstop to retain the helix selection semantic
-            // the tabstop closest to the range simply replaces `head` while anchor remains in place
-            // the remaining tabstops receive their own single-width cursor
-            if range.head < range.anchor {
-                let last_idx = tabstops.len() - 1;
-                let last_tabstop = tabstop_anchor + tabstops[last_idx].0;
-
-                // if selection is forward but was moved to the right it is
-                // contained entirely in the replacement text, just do a point
-                // selection (fallback below)
-                if range.anchor > last_tabstop {
-                    let range = Range::new(range.anchor, last_tabstop);
-                    mapped_selection.push(range);
-                    let rem_tabstops = tabstops[..last_idx]
-                        .iter()
-                        .map(|tabstop| Range::point(tabstop_anchor + tabstop.0));
-                    mapped_selection.extend(rem_tabstops);
-                    continue;
-                }
-            } else {
-                let first_tabstop = tabstop_anchor + tabstops[0].0;
-
-                // if selection is forward but was moved to the right it is
-                // contained entirely in the replacement text, just do a point
-                // selection (fallback below)
-                if range.anchor < first_tabstop {
-                    // we can't properly compute the the next grapheme
-                    // here because the transaction hasn't been applied yet
-                    // that is not a problem because the range gets grapheme aligned anyway
-                    // tough so just adding one will always cause head to be grapheme
-                    // aligned correctly when applied to the document
-                    let range = Range::new(range.anchor, first_tabstop + 1);
-                    mapped_selection.push(range);
-                    let rem_tabstops = tabstops[1..]
-                        .iter()
-                        .map(|tabstop| Range::point(tabstop_anchor + tabstop.0));
-                    mapped_selection.extend(rem_tabstops);
-                    continue;
-                }
-            };
-
-            let tabstops = tabstops
-                .iter()
-                .map(|tabstop| Range::point(tabstop_anchor + tabstop.0));
-            mapped_selection.extend(tabstops);
-        }
-
-        transaction.with_selection(Selection::new(mapped_selection, mapped_primary_idx))
+        let transaction = transaction.with_selection(snippet.first_selection(
+            // we keep the direction of the old primary selection in case it changed during mapping
+            // but use the primary idx from the mapped selection in case ranges had to be merged
+            selection.primary().direction(),
+            mapped_selection.primary_index(),
+        ));
+        (transaction, snippet)
     }
 
     pub fn generate_transaction_from_edits(
@@ -720,51 +618,45 @@ fn start_client(
         Ok(self.inner[id].clone())
     }
 
-    /// If this method is called, all documents that have a reference to language servers used by the language config have to refresh their language servers,
-    /// as it could be that language servers of these documents were stopped by this method.
+    /// If this method is called, all documents that have a reference to the language server have to refresh their language servers,
     /// See helix_view::editor::Editor::refresh_language_servers
-    pub fn restart(
+    pub fn restart_server(
         &mut self,
+        name: &str,
         language_config: &LanguageConfiguration,
         doc_path: Option<&std::path::PathBuf>,
         root_dirs: &[PathBuf],
         enable_snippets: bool,
-    ) -> Result<Vec<Arc<Client>>> {
-        language_config
-            .language_servers
-            .iter()
-            .filter_map(|LanguageServerFeatures { name, .. }| {
-                if let Some(old_clients) = self.inner_by_name.remove(name) {
-                    if old_clients.is_empty() {
-                        log::info!("restarting client for '{name}' which was manually stopped");
-                    } else {
-                        log::info!("stopping existing clients for '{name}'");
-                    }
-                    for old_client in old_clients {
-                        self.file_event_handler.remove_client(old_client.id());
-                        self.inner.remove(old_client.id());
-                        tokio::spawn(async move {
-                            let _ = old_client.force_shutdown().await;
-                        });
-                    }
-                }
-                let client = match self.start_client(
-                    name.clone(),
-                    language_config,
-                    doc_path,
-                    root_dirs,
-                    enable_snippets,
-                ) {
-                    Ok(client) => client,
-                    Err(StartupError::NoRequiredRootFound) => return None,
-                    Err(StartupError::Error(err)) => return Some(Err(err)),
-                };
-                self.inner_by_name
-                    .insert(name.to_owned(), vec![client.clone()]);
+    ) -> Option<Result<Arc<Client>>> {
+        if let Some(old_clients) = self.inner_by_name.remove(name) {
+            if old_clients.is_empty() {
+                log::info!("restarting client for '{name}' which was manually stopped");
+            } else {
+                log::info!("stopping existing clients for '{name}'");
+            }
+            for old_client in old_clients {
+                self.file_event_handler.remove_client(old_client.id());
+                self.inner.remove(old_client.id());
+                tokio::spawn(async move {
+                    let _ = old_client.force_shutdown().await;
+                });
+            }
+        }
+        let client = match self.start_client(
+            name.to_string(),
+            language_config,
+            doc_path,
+            root_dirs,
+            enable_snippets,
+        ) {
+            Ok(client) => client,
+            Err(StartupError::NoRequiredRootFound) => return None,
+            Err(StartupError::Error(err)) => return Some(Err(err)),
+        };
+        self.inner_by_name
+            .insert(name.to_owned(), vec![client.clone()]);
 
-                Some(Ok(client))
-            })
-            .collect()
+        Some(Ok(client))
     }
 
     pub fn stop(&mut self, name: &str) {
@@ -803,7 +695,11 @@ pub fn get<'a>(
                     }
 
                     if let Some((_, client)) = clients.iter().enumerate().find(|(i, client)| {
-                        client.try_add_doc(&language_config.roots, root_dirs, doc_path, *i == 0)
+                        let manual_roots = language_config
+                            .workspace_lsp_roots
+                            .as_deref()
+                            .unwrap_or(root_dirs);
+                        client.try_add_doc(&language_config.roots, manual_roots, doc_path, *i == 0)
                     }) {
                         return Some((name.to_owned(), Ok(client.clone())));
                     }
@@ -1004,17 +900,7 @@ fn start_client(
         }
 
         // next up, notify<initialized>
-        let notification_result = _client
-            .notify::<lsp::notification::Initialized>(lsp::InitializedParams {})
-            .await;
-
-        if let Err(e) = notification_result {
-            log::error!(
-                "failed to notify language server of its initialization: {}",
-                e
-            );
-            return;
-        }
+        _client.notify::<lsp::notification::Initialized>(lsp::InitializedParams {});
 
         initialize_notify.notify_one();
     });
diff --git a/helix-lsp/src/snippet.rs b/helix-lsp/src/snippet.rs
deleted file mode 100644
index ebf3da240..000000000
--- a/helix-lsp/src/snippet.rs
+++ /dev/null
@@ -1,1010 +0,0 @@
-use std::borrow::Cow;
-
-use anyhow::{anyhow, Result};
-use helix_core::{smallvec, SmallVec, Tendril};
-
-#[derive(Debug, PartialEq, Eq)]
-pub enum CaseChange {
-    Upcase,
-    Downcase,
-    Capitalize,
-}
-
-#[derive(Debug, PartialEq, Eq)]
-pub enum FormatItem {
-    Text(Tendril),
-    Capture(usize),
-    CaseChange(usize, CaseChange),
-    Conditional(usize, Option<Tendril>, Option<Tendril>),
-}
-
-#[derive(Debug, PartialEq, Eq)]
-pub struct Regex {
-    value: Tendril,
-    replacement: Vec<FormatItem>,
-    options: Tendril,
-}
-
-#[derive(Debug, PartialEq, Eq)]
-pub enum SnippetElement<'a> {
-    Tabstop {
-        tabstop: usize,
-    },
-    Placeholder {
-        tabstop: usize,
-        value: Vec<SnippetElement<'a>>,
-    },
-    Choice {
-        tabstop: usize,
-        choices: Vec<Tendril>,
-    },
-    Variable {
-        name: &'a str,
-        default: Option<Vec<SnippetElement<'a>>>,
-        regex: Option<Regex>,
-    },
-    Text(Tendril),
-}
-
-#[derive(Debug, PartialEq, Eq)]
-pub struct Snippet<'a> {
-    elements: Vec<SnippetElement<'a>>,
-}
-
-pub fn parse(s: &str) -> Result<Snippet<'_>> {
-    parser::parse(s).map_err(|rest| anyhow!("Failed to parse snippet. Remaining input: {}", rest))
-}
-
-fn render_elements(
-    snippet_elements: &[SnippetElement<'_>],
-    insert: &mut Tendril,
-    offset: &mut usize,
-    tabstops: &mut Vec<(usize, (usize, usize))>,
-    newline_with_offset: &str,
-    include_placeholder: bool,
-) {
-    use SnippetElement::*;
-
-    for element in snippet_elements {
-        match element {
-            Text(text) => {
-                // small optimization to avoid calling replace when it's unnecessary
-                let text = if text.contains('\n') {
-                    Cow::Owned(text.replace('\n', newline_with_offset))
-                } else {
-                    Cow::Borrowed(text.as_str())
-                };
-                *offset += text.chars().count();
-                insert.push_str(&text);
-            }
-            Variable {
-                name: _,
-                regex: _,
-                r#default,
-            } => {
-                // TODO: variables. For now, fall back to the default, which defaults to "".
-                render_elements(
-                    r#default.as_deref().unwrap_or_default(),
-                    insert,
-                    offset,
-                    tabstops,
-                    newline_with_offset,
-                    include_placeholder,
-                );
-            }
-            &Tabstop { tabstop } => {
-                tabstops.push((tabstop, (*offset, *offset)));
-            }
-            Placeholder {
-                tabstop,
-                value: inner_snippet_elements,
-            } => {
-                let start_offset = *offset;
-                if include_placeholder {
-                    render_elements(
-                        inner_snippet_elements,
-                        insert,
-                        offset,
-                        tabstops,
-                        newline_with_offset,
-                        include_placeholder,
-                    );
-                }
-                tabstops.push((*tabstop, (start_offset, *offset)));
-            }
-            &Choice {
-                tabstop,
-                choices: _,
-            } => {
-                // TODO: choices
-                tabstops.push((tabstop, (*offset, *offset)));
-            }
-        }
-    }
-}
-
-#[allow(clippy::type_complexity)] // only used one time
-pub fn render(
-    snippet: &Snippet<'_>,
-    newline_with_offset: &str,
-    include_placeholder: bool,
-) -> (Tendril, Vec<SmallVec<[(usize, usize); 1]>>) {
-    let mut insert = Tendril::new();
-    let mut tabstops = Vec::new();
-    let mut offset = 0;
-
-    render_elements(
-        &snippet.elements,
-        &mut insert,
-        &mut offset,
-        &mut tabstops,
-        newline_with_offset,
-        include_placeholder,
-    );
-
-    // sort in ascending order (except for 0, which should always be the last one (per lsp doc))
-    tabstops.sort_unstable_by_key(|(n, _)| if *n == 0 { usize::MAX } else { *n });
-
-    // merge tabstops with the same index (we take advantage of the fact that we just sorted them
-    // above to simply look backwards)
-    let mut ntabstops = Vec::<SmallVec<[(usize, usize); 1]>>::new();
-    {
-        let mut prev = None;
-        for (tabstop, r) in tabstops {
-            if prev == Some(tabstop) {
-                let len_1 = ntabstops.len() - 1;
-                ntabstops[len_1].push(r);
-            } else {
-                prev = Some(tabstop);
-                ntabstops.push(smallvec![r]);
-            }
-        }
-    }
-
-    (insert, ntabstops)
-}
-
-mod parser {
-    use helix_core::Tendril;
-    use helix_parsec::*;
-
-    use super::{CaseChange, FormatItem, Regex, Snippet, SnippetElement};
-
-    /*
-    https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax
-
-        any         ::= tabstop | placeholder | choice | variable | text
-        tabstop     ::= '$' int | '${' int '}'
-        placeholder ::= '${' int ':' any '}'
-        choice      ::= '${' int '|' text (',' text)* '|}'
-        variable    ::= '$' var | '${' var }'
-                        | '${' var ':' any '}'
-                        | '${' var '/' regex '/' (format | text)+ '/' options '}'
-        format      ::= '$' int | '${' int '}'
-                        | '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
-                        | '${' int ':+' if '}'
-                        | '${' int ':?' if ':' else '}'
-                        | '${' int ':-' else '}' | '${' int ':' else '}'
-        regex       ::= Regular Expression value (ctor-string)
-        options     ::= Regular Expression option (ctor-options)
-        var         ::= [_a-zA-Z] [_a-zA-Z0-9]*
-        int         ::= [0-9]+
-        text        ::= .*
-        if          ::= text
-        else        ::= text
-    */
-
-    fn var<'a>() -> impl Parser<'a, Output = &'a str> {
-        // var = [_a-zA-Z][_a-zA-Z0-9]*
-        move |input: &'a str| {
-            input
-                .char_indices()
-                .take_while(|(p, c)| {
-                    *c == '_'
-                        || if *p == 0 {
-                            c.is_ascii_alphabetic()
-                        } else {
-                            c.is_ascii_alphanumeric()
-                        }
-                })
-                .last()
-                .map(|(index, c)| {
-                    let index = index + c.len_utf8();
-                    (&input[index..], &input[0..index])
-                })
-                .ok_or(input)
-        }
-    }
-
-    const TEXT_ESCAPE_CHARS: &[char] = &['\\', '}', '$'];
-    const CHOICE_TEXT_ESCAPE_CHARS: &[char] = &['\\', '|', ','];
-
-    fn text<'a>(
-        escape_chars: &'static [char],
-        term_chars: &'static [char],
-    ) -> impl Parser<'a, Output = Tendril> {
-        move |input: &'a str| {
-            let mut chars = input.char_indices().peekable();
-            let mut res = Tendril::new();
-            while let Some((i, c)) = chars.next() {
-                match c {
-                    '\\' => {
-                        if let Some(&(_, c)) = chars.peek() {
-                            if escape_chars.contains(&c) {
-                                chars.next();
-                                res.push(c);
-                                continue;
-                            }
-                        }
-                        res.push('\\');
-                    }
-                    c if term_chars.contains(&c) => return Ok((&input[i..], res)),
-                    c => res.push(c),
-                }
-            }
-
-            Ok(("", res))
-        }
-    }
-
-    fn digit<'a>() -> impl Parser<'a, Output = usize> {
-        filter_map(take_while(|c| c.is_ascii_digit()), |s| s.parse().ok())
-    }
-
-    fn case_change<'a>() -> impl Parser<'a, Output = CaseChange> {
-        use CaseChange::*;
-
-        choice!(
-            map("upcase", |_| Upcase),
-            map("downcase", |_| Downcase),
-            map("capitalize", |_| Capitalize),
-        )
-    }
-
-    fn format<'a>() -> impl Parser<'a, Output = FormatItem> {
-        use FormatItem::*;
-
-        choice!(
-            // '$' int
-            map(right("$", digit()), Capture),
-            // '${' int '}'
-            map(seq!("${", digit(), "}"), |seq| Capture(seq.1)),
-            // '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
-            map(seq!("${", digit(), ":/", case_change(), "}"), |seq| {
-                CaseChange(seq.1, seq.3)
-            }),
-            // '${' int ':+' if '}'
-            map(
-                seq!("${", digit(), ":+", text(TEXT_ESCAPE_CHARS, &['}']), "}"),
-                |seq| { Conditional(seq.1, Some(seq.3), None) }
-            ),
-            // '${' int ':?' if ':' else '}'
-            map(
-                seq!(
-                    "${",
-                    digit(),
-                    ":?",
-                    text(TEXT_ESCAPE_CHARS, &[':']),
-                    ":",
-                    text(TEXT_ESCAPE_CHARS, &['}']),
-                    "}"
-                ),
-                |seq| { Conditional(seq.1, Some(seq.3), Some(seq.5)) }
-            ),
-            // '${' int ':-' else '}' | '${' int ':' else '}'
-            map(
-                seq!(
-                    "${",
-                    digit(),
-                    ":",
-                    optional("-"),
-                    text(TEXT_ESCAPE_CHARS, &['}']),
-                    "}"
-                ),
-                |seq| { Conditional(seq.1, None, Some(seq.4)) }
-            ),
-        )
-    }
-
-    fn regex<'a>() -> impl Parser<'a, Output = Regex> {
-        map(
-            seq!(
-                "/",
-                // TODO parse as ECMAScript and convert to rust regex
-                text(&['/'], &['/']),
-                "/",
-                zero_or_more(choice!(
-                    format(),
-                    // text doesn't parse $, if format fails we just accept the $ as text
-                    map("$", |_| FormatItem::Text("$".into())),
-                    map(text(&['\\', '/'], &['/', '$']), FormatItem::Text),
-                )),
-                "/",
-                // vscode really doesn't allow escaping } here
-                // so it's impossible to write a regex escape containing a }
-                // we can consider deviating here and allowing the escape
-                text(&[], &['}']),
-            ),
-            |(_, value, _, replacement, _, options)| Regex {
-                value,
-                replacement,
-                options,
-            },
-        )
-    }
-
-    fn tabstop<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
-        map(
-            or(
-                right("$", digit()),
-                map(seq!("${", digit(), "}"), |values| values.1),
-            ),
-            |digit| SnippetElement::Tabstop { tabstop: digit },
-        )
-    }
-
-    fn placeholder<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
-        map(
-            seq!(
-                "${",
-                digit(),
-                ":",
-                // according to the grammar there is just a single anything here.
-                // However in the prose it is explained that placeholders can be nested.
-                // The example there contains both a placeholder text and a nested placeholder
-                // which indicates a list. Looking at the VSCode sourcecode, the placeholder
-                // is indeed parsed as zero_or_more so the grammar is simply incorrect here
-                zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
-                "}"
-            ),
-            |seq| SnippetElement::Placeholder {
-                tabstop: seq.1,
-                value: seq.3,
-            },
-        )
-    }
-
-    fn choice<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
-        map(
-            seq!(
-                "${",
-                digit(),
-                "|",
-                sep(text(CHOICE_TEXT_ESCAPE_CHARS, &['|', ',']), ","),
-                "|}",
-            ),
-            |seq| SnippetElement::Choice {
-                tabstop: seq.1,
-                choices: seq.3,
-            },
-        )
-    }
-
-    fn variable<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
-        choice!(
-            // $var
-            map(right("$", var()), |name| SnippetElement::Variable {
-                name,
-                default: None,
-                regex: None,
-            }),
-            // ${var}
-            map(seq!("${", var(), "}",), |values| SnippetElement::Variable {
-                name: values.1,
-                default: None,
-                regex: None,
-            }),
-            // ${var:default}
-            map(
-                seq!(
-                    "${",
-                    var(),
-                    ":",
-                    zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
-                    "}",
-                ),
-                |values| SnippetElement::Variable {
-                    name: values.1,
-                    default: Some(values.3),
-                    regex: None,
-                }
-            ),
-            // ${var/value/format/options}
-            map(seq!("${", var(), regex(), "}"), |values| {
-                SnippetElement::Variable {
-                    name: values.1,
-                    default: None,
-                    regex: Some(values.2),
-                }
-            }),
-        )
-    }
-
-    fn anything<'a>(
-        escape_chars: &'static [char],
-        end_at_brace: bool,
-    ) -> impl Parser<'a, Output = SnippetElement<'a>> {
-        let term_chars: &[_] = if end_at_brace { &['$', '}'] } else { &['$'] };
-        move |input: &'a str| {
-            let parser = choice!(
-                tabstop(),
-                placeholder(),
-                choice(),
-                variable(),
-                map("$", |_| SnippetElement::Text("$".into())),
-                map(text(escape_chars, term_chars), SnippetElement::Text),
-            );
-            parser.parse(input)
-        }
-    }
-
-    fn snippet<'a>() -> impl Parser<'a, Output = Snippet<'a>> {
-        map(one_or_more(anything(TEXT_ESCAPE_CHARS, false)), |parts| {
-            Snippet { elements: parts }
-        })
-    }
-
-    pub fn parse(s: &str) -> Result<Snippet, &str> {
-        snippet().parse(s).and_then(|(remainder, snippet)| {
-            if remainder.is_empty() {
-                Ok(snippet)
-            } else {
-                Err(remainder)
-            }
-        })
-    }
-
-    #[cfg(test)]
-    mod test {
-        use super::SnippetElement::*;
-        use super::*;
-
-        #[test]
-        fn empty_string_is_error() {
-            assert_eq!(Err(""), parse(""));
-        }
-
-        #[test]
-        fn parse_placeholders_in_function_call() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![
-                        Text("match(".into()),
-                        Placeholder {
-                            tabstop: 1,
-                            value: vec!(Text("Arg1".into())),
-                        },
-                        Text(")".into())
-                    ]
-                }),
-                parse("match(${1:Arg1})")
-            )
-        }
-
-        #[test]
-        fn unterminated_placeholder() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![Text("match(".into()), Text("$".into()), Text("{1:)".into())]
-                }),
-                parse("match(${1:)")
-            )
-        }
-
-        #[test]
-        fn parse_empty_placeholder() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![
-                        Text("match(".into()),
-                        Placeholder {
-                            tabstop: 1,
-                            value: vec![],
-                        },
-                        Text(")".into())
-                    ]
-                }),
-                parse("match(${1:})")
-            )
-        }
-
-        #[test]
-        fn parse_placeholders_in_statement() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![
-                        Text("local ".into()),
-                        Placeholder {
-                            tabstop: 1,
-                            value: vec!(Text("var".into())),
-                        },
-                        Text(" = ".into()),
-                        Placeholder {
-                            tabstop: 1,
-                            value: vec!(Text("value".into())),
-                        },
-                    ]
-                }),
-                parse("local ${1:var} = ${1:value}")
-            )
-        }
-
-        #[test]
-        fn parse_tabstop_nested_in_placeholder() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![Placeholder {
-                        tabstop: 1,
-                        value: vec!(Text("var, ".into()), Tabstop { tabstop: 2 },),
-                    },]
-                }),
-                parse("${1:var, $2}")
-            )
-        }
-
-        #[test]
-        fn parse_placeholder_nested_in_placeholder() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![Placeholder {
-                        tabstop: 1,
-                        value: vec!(
-                            Text("foo ".into()),
-                            Placeholder {
-                                tabstop: 2,
-                                value: vec!(Text("bar".into())),
-                            },
-                        ),
-                    },]
-                }),
-                parse("${1:foo ${2:bar}}")
-            )
-        }
-
-        #[test]
-        fn parse_all() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![
-                        Text("hello ".into()),
-                        Tabstop { tabstop: 1 },
-                        Tabstop { tabstop: 2 },
-                        Text(" ".into()),
-                        Choice {
-                            tabstop: 1,
-                            choices: vec!["one".into(), "two".into(), "three".into()]
-                        },
-                        Text(" ".into()),
-                        Variable {
-                            name: "name",
-                            default: Some(vec![Text("foo".into())]),
-                            regex: None
-                        },
-                        Text(" ".into()),
-                        Variable {
-                            name: "var",
-                            default: None,
-                            regex: None
-                        },
-                        Text(" ".into()),
-                        Variable {
-                            name: "TM",
-                            default: None,
-                            regex: None
-                        },
-                    ]
-                }),
-                parse("hello $1${2} ${1|one,two,three|} ${name:foo} $var $TM")
-            );
-        }
-
-        #[test]
-        fn regex_capture_replace() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![Variable {
-                        name: "TM_FILENAME",
-                        default: None,
-                        regex: Some(Regex {
-                            value: "(.*).+$".into(),
-                            replacement: vec![FormatItem::Capture(1), FormatItem::Text("$".into())],
-                            options: Tendril::new(),
-                        }),
-                    }]
-                }),
-                parse("${TM_FILENAME/(.*).+$/$1$/}")
-            );
-        }
-
-        #[test]
-        fn rust_macro() {
-            assert_eq!(
-                Ok(Snippet {
-                    elements: vec![
-                        Text("macro_rules! ".into()),
-                        Tabstop { tabstop: 1 },
-                        Text(" {\n    (".into()),
-                        Tabstop { tabstop: 2 },
-                        Text(") => {\n        ".into()),
-                        Tabstop { tabstop: 0 },
-                        Text("\n    };\n}".into())
-                    ]
-                }),
-                parse("macro_rules! $1 {\n    ($2) => {\n        $0\n    };\n}")
-            );
-        }
-
-        fn assert_text(snippet: &str, parsed_text: &str) {
-            let res = parse(snippet).unwrap();
-            let text = crate::snippet::render(&res, "\n", true).0;
-            assert_eq!(text, parsed_text)
-        }
-
-        #[test]
-        fn robust_parsing() {
-            assert_text("$", "$");
-            assert_text("\\\\$", "\\$");
-            assert_text("{", "{");
-            assert_text("\\}", "}");
-            assert_text("\\abc", "\\abc");
-            assert_text("foo${f:\\}}bar", "foo}bar");
-            assert_text("\\{", "\\{");
-            assert_text("I need \\\\\\$", "I need \\$");
-            assert_text("\\", "\\");
-            assert_text("\\{{", "\\{{");
-            assert_text("{{", "{{");
-            assert_text("{{dd", "{{dd");
-            assert_text("}}", "}}");
-            assert_text("ff}}", "ff}}");
-            assert_text("farboo", "farboo");
-            assert_text("far{{}}boo", "far{{}}boo");
-            assert_text("far{{123}}boo", "far{{123}}boo");
-            assert_text("far\\{{123}}boo", "far\\{{123}}boo");
-            assert_text("far{{id:bern}}boo", "far{{id:bern}}boo");
-            assert_text("far{{id:bern {{basel}}}}boo", "far{{id:bern {{basel}}}}boo");
-            assert_text(
-                "far{{id:bern {{id:basel}}}}boo",
-                "far{{id:bern {{id:basel}}}}boo",
-            );
-            assert_text(
-                "far{{id:bern {{id2:basel}}}}boo",
-                "far{{id:bern {{id2:basel}}}}boo",
-            );
-            assert_text("${}$\\a\\$\\}\\\\", "${}$\\a$}\\");
-            assert_text("farboo", "farboo");
-            assert_text("far{{}}boo", "far{{}}boo");
-            assert_text("far{{123}}boo", "far{{123}}boo");
-            assert_text("far\\{{123}}boo", "far\\{{123}}boo");
-            assert_text("far`123`boo", "far`123`boo");
-            assert_text("far\\`123\\`boo", "far\\`123\\`boo");
-            assert_text("\\$far-boo", "$far-boo");
-        }
-
-        fn assert_snippet(snippet: &str, expect: &[SnippetElement]) {
-            let parsed_snippet = parse(snippet).unwrap();
-            assert_eq!(parsed_snippet.elements, expect.to_owned())
-        }
-
-        #[test]
-        fn parse_variable() {
-            use SnippetElement::*;
-            assert_snippet(
-                "$far-boo",
-                &[
-                    Variable {
-                        name: "far",
-                        default: None,
-                        regex: None,
-                    },
-                    Text("-boo".into()),
-                ],
-            );
-            assert_snippet(
-                "far$farboo",
-                &[
-                    Text("far".into()),
-                    Variable {
-                        name: "farboo",
-                        regex: None,
-                        default: None,
-                    },
-                ],
-            );
-            assert_snippet(
-                "far${farboo}",
-                &[
-                    Text("far".into()),
-                    Variable {
-                        name: "farboo",
-                        regex: None,
-                        default: None,
-                    },
-                ],
-            );
-            assert_snippet("$123", &[Tabstop { tabstop: 123 }]);
-            assert_snippet(
-                "$farboo",
-                &[Variable {
-                    name: "farboo",
-                    regex: None,
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "$far12boo",
-                &[Variable {
-                    name: "far12boo",
-                    regex: None,
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "000_${far}_000",
-                &[
-                    Text("000_".into()),
-                    Variable {
-                        name: "far",
-                        regex: None,
-                        default: None,
-                    },
-                    Text("_000".into()),
-                ],
-            );
-        }
-
-        #[test]
-        fn parse_variable_transform() {
-            assert_snippet(
-                "${foo///}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: Tendril::new(),
-                        replacement: Vec::new(),
-                        options: Tendril::new(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/regex/format/gmi}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: "regex".into(),
-                        replacement: vec![FormatItem::Text("format".into())],
-                        options: "gmi".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/([A-Z][a-z])/format/}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: "([A-Z][a-z])".into(),
-                        replacement: vec![FormatItem::Text("format".into())],
-                        options: Tendril::new(),
-                    }),
-                    default: None,
-                }],
-            );
-
-            // invalid regex TODO: reneable tests once we actually parse this regex flavour
-            // assert_text(
-            //     "${foo/([A-Z][a-z])/format/GMI}",
-            //     "${foo/([A-Z][a-z])/format/GMI}",
-            // );
-            // assert_text(
-            //     "${foo/([A-Z][a-z])/format/funky}",
-            //     "${foo/([A-Z][a-z])/format/funky}",
-            // );
-            // assert_text("${foo/([A-Z][a-z]/format/}", "${foo/([A-Z][a-z]/format/}");
-            assert_text(
-                "${foo/regex\\/format/options}",
-                "${foo/regex\\/format/options}",
-            );
-
-            // tricky regex
-            assert_snippet(
-                "${foo/m\\/atch/$1/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: "m/atch".into(),
-                        replacement: vec![FormatItem::Capture(1)],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-
-            // incomplete
-            assert_text("${foo///", "${foo///");
-            assert_text("${foo/regex/format/options", "${foo/regex/format/options");
-
-            // format string
-            assert_snippet(
-                "${foo/.*/${0:fooo}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![FormatItem::Conditional(0, None, Some("fooo".into()))],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/${1}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![FormatItem::Capture(1)],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/$1/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![FormatItem::Capture(1)],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/This-$1-encloses/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("This-".into()),
-                            FormatItem::Capture(1),
-                            FormatItem::Text("-encloses".into()),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/complex${1:else}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("complex".into()),
-                            FormatItem::Conditional(1, None, Some("else".into())),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/complex${1:-else}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("complex".into()),
-                            FormatItem::Conditional(1, None, Some("else".into())),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/complex${1:+if}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("complex".into()),
-                            FormatItem::Conditional(1, Some("if".into()), None),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/complex${1:?if:else}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("complex".into()),
-                            FormatItem::Conditional(1, Some("if".into()), Some("else".into())),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${foo/.*/complex${1:/upcase}/i}",
-                &[Variable {
-                    name: "foo",
-                    regex: Some(Regex {
-                        value: ".*".into(),
-                        replacement: vec![
-                            FormatItem::Text("complex".into()),
-                            FormatItem::CaseChange(1, CaseChange::Upcase),
-                        ],
-                        options: "i".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${TM_DIRECTORY/src\\//$1/}",
-                &[Variable {
-                    name: "TM_DIRECTORY",
-                    regex: Some(Regex {
-                        value: "src/".into(),
-                        replacement: vec![FormatItem::Capture(1)],
-                        options: Tendril::new(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${TM_SELECTED_TEXT/a/\\/$1/g}",
-                &[Variable {
-                    name: "TM_SELECTED_TEXT",
-                    regex: Some(Regex {
-                        value: "a".into(),
-                        replacement: vec![FormatItem::Text("/".into()), FormatItem::Capture(1)],
-                        options: "g".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${TM_SELECTED_TEXT/a/in\\/$1ner/g}",
-                &[Variable {
-                    name: "TM_SELECTED_TEXT",
-                    regex: Some(Regex {
-                        value: "a".into(),
-                        replacement: vec![
-                            FormatItem::Text("in/".into()),
-                            FormatItem::Capture(1),
-                            FormatItem::Text("ner".into()),
-                        ],
-                        options: "g".into(),
-                    }),
-                    default: None,
-                }],
-            );
-            assert_snippet(
-                "${TM_SELECTED_TEXT/a/end\\//g}",
-                &[Variable {
-                    name: "TM_SELECTED_TEXT",
-                    regex: Some(Regex {
-                        value: "a".into(),
-                        replacement: vec![FormatItem::Text("end/".into())],
-                        options: "g".into(),
-                    }),
-                    default: None,
-                }],
-            );
-        }
-        // TODO port more tests from https://github.com/microsoft/vscode/blob/dce493cb6e36346ef2714e82c42ce14fc461b15c/src/vs/editor/contrib/snippet/test/browser/snippetParser.test.ts
-    }
-}
diff --git a/helix-parsec/src/lib.rs b/helix-parsec/src/lib.rs
index 846d02d61..0ec44436f 100644
--- a/helix-parsec/src/lib.rs
+++ b/helix-parsec/src/lib.rs
@@ -43,7 +43,7 @@ pub trait Parser<'a> {
 #[doc(hidden)]
 impl<'a, F, T> Parser<'a> for F
 where
-    F: Fn(&'a str) -> ParseResult<T>,
+    F: Fn(&'a str) -> ParseResult<'a, T>,
 {
     type Output = T;
 
diff --git a/helix-stdx/Cargo.toml b/helix-stdx/Cargo.toml
index 1c0d06ab1..e56f9f206 100644
--- a/helix-stdx/Cargo.toml
+++ b/helix-stdx/Cargo.toml
@@ -14,10 +14,13 @@ homepage.workspace = true
 [dependencies]
 dunce = "1.0"
 etcetera = "0.8"
-ropey = { version = "1.6.1", default-features = false }
-which = "6.0"
+ropey.workspace = true
+which = "7.0"
 regex-cursor = "0.1.4"
-bitflags = "2.6"
+bitflags.workspace = true
+once_cell = "1.19"
+regex-automata = "0.4.9"
+unicode-segmentation.workspace = true
 
 [target.'cfg(windows)'.dependencies]
 windows-sys = { version = "0.59", features = ["Win32_Foundation", "Win32_Security", "Win32_Security_Authorization", "Win32_Storage_FileSystem", "Win32_System_Threading"] }
@@ -26,4 +29,4 @@ windows-sys = { version = "0.59", features = ["Win32_Foundation", "Win32_Securit
 rustix = { version = "0.38", features = ["fs"] }
 
 [dev-dependencies]
-tempfile = "3.12"
+tempfile.workspace = true
diff --git a/helix-stdx/src/env.rs b/helix-stdx/src/env.rs
index 51450d225..b3f46c25f 100644
--- a/helix-stdx/src/env.rs
+++ b/helix-stdx/src/env.rs
@@ -1,9 +1,13 @@
 use std::{
-    ffi::OsStr,
+    borrow::Cow,
+    ffi::{OsStr, OsString},
     path::{Path, PathBuf},
     sync::RwLock,
 };
 
+use once_cell::sync::Lazy;
+
+// We keep the CWD as a static so that we can access it in places where we don't have access to the Editor
 static CWD: RwLock<Option<PathBuf>> = RwLock::new(None);
 
 // Get the current working directory.
@@ -33,12 +37,12 @@ pub fn current_working_dir() -> PathBuf {
     cwd
 }
 
-pub fn set_current_working_dir(path: impl AsRef<Path>) -> std::io::Result<()> {
+pub fn set_current_working_dir(path: impl AsRef<Path>) -> std::io::Result<Option<PathBuf>> {
     let path = crate::path::canonicalize(path);
     std::env::set_current_dir(&path)?;
     let mut cwd = CWD.write().unwrap();
-    *cwd = Some(path);
-    Ok(())
+
+    Ok(cwd.replace(path))
 }
 
 pub fn env_var_is_set(env_var_name: &str) -> bool {
@@ -59,6 +63,99 @@ pub fn which<T: AsRef<OsStr>>(
     })
 }
 
+fn find_brace_end(src: &[u8]) -> Option<usize> {
+    use regex_automata::meta::Regex;
+
+    static REGEX: Lazy<Regex> = Lazy::new(|| Regex::builder().build("[{}]").unwrap());
+    let mut depth = 0;
+    for mat in REGEX.find_iter(src) {
+        let pos = mat.start();
+        match src[pos] {
+            b'{' => depth += 1,
+            b'}' if depth == 0 => return Some(pos),
+            b'}' => depth -= 1,
+            _ => unreachable!(),
+        }
+    }
+    None
+}
+
+fn expand_impl(src: &OsStr, mut resolve: impl FnMut(&OsStr) -> Option<OsString>) -> Cow<OsStr> {
+    use regex_automata::meta::Regex;
+
+    static REGEX: Lazy<Regex> = Lazy::new(|| {
+        Regex::builder()
+            .build_many(&[
+                r"\$\{([^\}:]+):-",
+                r"\$\{([^\}:]+):=",
+                r"\$\{([^\}-]+)-",
+                r"\$\{([^\}=]+)=",
+                r"\$\{([^\}]+)",
+                r"\$(\w+)",
+            ])
+            .unwrap()
+    });
+
+    let bytes = src.as_encoded_bytes();
+    let mut res = Vec::with_capacity(bytes.len());
+    let mut pos = 0;
+    for captures in REGEX.captures_iter(bytes) {
+        let mat = captures.get_match().unwrap();
+        let pattern_id = mat.pattern().as_usize();
+        let mut range = mat.range();
+        // A pattern may match multiple times on a single variable, for example `${HOME:-$HOME}`:
+        // `${HOME:-` matches and also the default value (`$HOME`). Skip past any variables which
+        // have already been expanded.
+        if range.start < pos {
+            continue;
+        }
+        let var = &bytes[captures.get_group(1).unwrap().range()];
+        let default = if pattern_id != 5 {
+            let Some(bracket_pos) = find_brace_end(&bytes[range.end..]) else {
+                break;
+            };
+            let default = &bytes[range.end..range.end + bracket_pos];
+            range.end += bracket_pos + 1;
+            default
+        } else {
+            &[]
+        };
+        // safety: this is a codepoint aligned substring of an osstr (always valid)
+        let var = unsafe { OsStr::from_encoded_bytes_unchecked(var) };
+        let expansion = resolve(var);
+        let expansion = match &expansion {
+            Some(val) => {
+                if val.is_empty() && pattern_id < 2 {
+                    default
+                } else {
+                    val.as_encoded_bytes()
+                }
+            }
+            None => default,
+        };
+        res.extend_from_slice(&bytes[pos..range.start]);
+        pos = range.end;
+        res.extend_from_slice(expansion);
+    }
+    if pos == 0 {
+        src.into()
+    } else {
+        res.extend_from_slice(&bytes[pos..]);
+        // safety: this is a composition of valid osstr (and codepoint aligned slices which are also valid)
+        unsafe { OsString::from_encoded_bytes_unchecked(res) }.into()
+    }
+}
+
+/// performs substitution of enviorment variables. Supports the following (POSIX) syntax:
+///
+/// * `$<var>`, `${<var>}`
+/// * `${<var>:-<default>}`, `${<var>-<default>}`
+/// * `${<var>:=<default>}`, `${<var>=default}`
+///
+pub fn expand<S: AsRef<OsStr> + ?Sized>(src: &S) -> Cow<OsStr> {
+    expand_impl(src.as_ref(), |var| std::env::var_os(var))
+}
+
 #[derive(Debug)]
 pub struct ExecutableNotFoundError {
     command: String,
@@ -75,7 +172,9 @@ impl std::error::Error for ExecutableNotFoundError {}
 
 #[cfg(test)]
 mod tests {
-    use super::{current_working_dir, set_current_working_dir};
+    use std::ffi::{OsStr, OsString};
+
+    use super::{current_working_dir, expand_impl, set_current_working_dir};
 
     #[test]
     fn current_dir_is_set() {
@@ -88,4 +187,35 @@ fn current_dir_is_set() {
         let cwd = current_working_dir();
         assert_eq!(cwd, new_path);
     }
+
+    macro_rules! assert_env_expand {
+        ($env: expr, $lhs: expr, $rhs: expr) => {
+            assert_eq!(&*expand_impl($lhs.as_ref(), $env), OsStr::new($rhs));
+        };
+    }
+
+    /// paths that should work on all platforms
+    #[test]
+    fn test_env_expand() {
+        let env = |var: &OsStr| -> Option<OsString> {
+            match var.to_str().unwrap() {
+                "FOO" => Some("foo".into()),
+                "EMPTY" => Some("".into()),
+                _ => None,
+            }
+        };
+        assert_env_expand!(env, "pass_trough", "pass_trough");
+        assert_env_expand!(env, "$FOO", "foo");
+        assert_env_expand!(env, "bar/$FOO/baz", "bar/foo/baz");
+        assert_env_expand!(env, "bar/${FOO}/baz", "bar/foo/baz");
+        assert_env_expand!(env, "baz/${BAR:-bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${FOO:-$FOO}/foo", "baz/foo/foo");
+        assert_env_expand!(env, "baz/${BAR:=bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${BAR-bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${BAR=bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${EMPTY:-bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${EMPTY:=bar}/foo", "baz/bar/foo");
+        assert_env_expand!(env, "baz/${EMPTY-bar}/foo", "baz//foo");
+        assert_env_expand!(env, "baz/${EMPTY=bar}/foo", "baz//foo");
+    }
 }
diff --git a/helix-stdx/src/lib.rs b/helix-stdx/src/lib.rs
index 19602c205..d09df587a 100644
--- a/helix-stdx/src/lib.rs
+++ b/helix-stdx/src/lib.rs
@@ -1,4 +1,7 @@
 pub mod env;
 pub mod faccess;
 pub mod path;
+pub mod range;
 pub mod rope;
+
+pub use range::Range;
diff --git a/helix-stdx/src/path.rs b/helix-stdx/src/path.rs
index 968596a70..53081b0f0 100644
--- a/helix-stdx/src/path.rs
+++ b/helix-stdx/src/path.rs
@@ -1,8 +1,12 @@
 pub use etcetera::home_dir;
+use once_cell::sync::Lazy;
+use regex_cursor::{engines::meta::Regex, Input};
+use ropey::RopeSlice;
 
 use std::{
     borrow::Cow,
     ffi::OsString,
+    ops::Range,
     path::{Component, Path, PathBuf, MAIN_SEPARATOR_STR},
 };
 
@@ -29,7 +33,9 @@ pub fn fold_home_dir<'a, P>(path: P) -> Cow<'a, Path>
 }
 
 /// Expands tilde `~` into users home directory if available, otherwise returns the path
-/// unchanged. The tilde will only be expanded when present as the first component of the path
+/// unchanged.
+///
+/// The tilde will only be expanded when present as the first component of the path
 /// and only slash follows it.
 pub fn expand_tilde<'a, P>(path: P) -> Cow<'a, Path>
 where
@@ -50,11 +56,11 @@ pub fn expand_tilde<'a, P>(path: P) -> Cow<'a, Path>
 }
 
 /// Normalize a path without resolving symlinks.
-// Strategy: start from the first component and move up. Cannonicalize previous path,
-// join component, cannonicalize new path, strip prefix and join to the final result.
+// Strategy: start from the first component and move up. Canonicalize previous path,
+// join component, canonicalize new path, strip prefix and join to the final result.
 pub fn normalize(path: impl AsRef<Path>) -> PathBuf {
     let mut components = path.as_ref().components().peekable();
-    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {
+    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().copied() {
         components.next();
         PathBuf::from(c.as_os_str())
     } else {
@@ -201,6 +207,96 @@ pub fn get_truncated_path(path: impl AsRef<Path>) -> PathBuf {
     ret
 }
 
+fn path_component_regex(windows: bool) -> String {
+    // TODO: support backslash path escape on windows (when using git bash for example)
+    let space_escape = if windows { r"[\^`]\s" } else { r"[\\]\s" };
+    // partially baesd on what's allowed in an url but with some care to avoid
+    // false positives (like any kind of brackets or quotes)
+    r"[\w@.\-+#$%?!,;~&]|".to_owned() + space_escape
+}
+
+/// Regex for delimited environment captures like `${HOME}`.
+fn braced_env_regex(windows: bool) -> String {
+    r"\$\{(?:".to_owned() + &path_component_regex(windows) + r"|[/:=])+\}"
+}
+
+fn compile_path_regex(
+    prefix: &str,
+    postfix: &str,
+    match_single_file: bool,
+    windows: bool,
+) -> Regex {
+    let first_component = format!(
+        "(?:{}|(?:{}))",
+        braced_env_regex(windows),
+        path_component_regex(windows)
+    );
+    // For all components except the first we allow an equals so that `foo=/
+    // bar/baz` does not include foo. This is primarily intended for url queries
+    // (where an equals is never in the first component)
+    let component = format!("(?:{first_component}|=)");
+    let sep = if windows { r"[/\\]" } else { "/" };
+    let url_prefix = r"[\w+\-.]+://??";
+    let path_prefix = if windows {
+        // single slash handles most windows prefixes (like\\server\...) but `\
+        // \?\C:\..` (and C:\) needs special handling, since we don't allow : in path
+        // components (so that colon separated paths and <path>:<line> work)
+        r"\\\\\?\\\w:|\w:|\\|"
+    } else {
+        ""
+    };
+    let path_start = format!("(?:{first_component}+|~|{path_prefix}{url_prefix})");
+    let optional = if match_single_file {
+        format!("|{path_start}")
+    } else {
+        String::new()
+    };
+    let path_regex = format!(
+        "{prefix}(?:{path_start}?(?:(?:{sep}{component}+)+{sep}?|{sep}){optional}){postfix}"
+    );
+    Regex::new(&path_regex).unwrap()
+}
+
+/// If `src` ends with a path then this function returns the part of the slice.
+pub fn get_path_suffix(src: RopeSlice<'_>, match_single_file: bool) -> Option<RopeSlice<'_>> {
+    let regex = if match_single_file {
+        static REGEX: Lazy<Regex> = Lazy::new(|| compile_path_regex("", "$", true, cfg!(windows)));
+        &*REGEX
+    } else {
+        static REGEX: Lazy<Regex> = Lazy::new(|| compile_path_regex("", "$", false, cfg!(windows)));
+        &*REGEX
+    };
+
+    regex
+        .find(Input::new(src))
+        .map(|mat| src.byte_slice(mat.range()))
+}
+
+/// Returns an iterator of the **byte** ranges in src that contain a path.
+pub fn find_paths(
+    src: RopeSlice<'_>,
+    match_single_file: bool,
+) -> impl Iterator<Item = Range<usize>> + '_ {
+    let regex = if match_single_file {
+        static REGEX: Lazy<Regex> = Lazy::new(|| compile_path_regex("", "", true, cfg!(windows)));
+        &*REGEX
+    } else {
+        static REGEX: Lazy<Regex> = Lazy::new(|| compile_path_regex("", "", false, cfg!(windows)));
+        &*REGEX
+    };
+    regex.find_iter(Input::new(src)).map(|mat| mat.range())
+}
+
+/// Performs substitution of `~` and environment variables, see [`env::expand`](crate::env::expand) and [`expand_tilde`]
+pub fn expand<T: AsRef<Path> + ?Sized>(path: &T) -> Cow<'_, Path> {
+    let path = path.as_ref();
+    let path = expand_tilde(path);
+    match crate::env::expand(&*path) {
+        Cow::Borrowed(_) => path,
+        Cow::Owned(path) => PathBuf::from(path).into(),
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use std::{
@@ -208,7 +304,10 @@ mod tests {
         path::{Component, Path},
     };
 
-    use crate::path;
+    use regex_cursor::Input;
+    use ropey::RopeSlice;
+
+    use crate::path::{self, compile_path_regex};
 
     #[test]
     fn expand_tilde() {
@@ -228,4 +327,127 @@ fn expand_tilde() {
             assert_ne!(component_count, 0);
         }
     }
+
+    macro_rules! assert_match {
+        ($regex: expr, $haystack: expr) => {
+            let haystack = Input::new(RopeSlice::from($haystack));
+            assert!(
+                $regex.is_match(haystack),
+                "regex should match {}",
+                $haystack
+            );
+        };
+    }
+    macro_rules! assert_no_match {
+        ($regex: expr, $haystack: expr) => {
+            let haystack = Input::new(RopeSlice::from($haystack));
+            assert!(
+                !$regex.is_match(haystack),
+                "regex should not match {}",
+                $haystack
+            );
+        };
+    }
+
+    macro_rules! assert_matches {
+        ($regex: expr, $haystack: expr, [$($matches: expr),*]) => {
+            let src = $haystack;
+            let matches: Vec<_> = $regex
+                .find_iter(Input::new(RopeSlice::from(src)))
+                .map(|it| &src[it.range()])
+                .collect();
+            assert_eq!(matches, vec![$($matches),*]);
+        };
+    }
+
+    /// Linux-only path
+    #[test]
+    fn path_regex_unix() {
+        // due to ambiguity with the `\` path separator we can't support space escapes `\ ` on windows
+        let regex = compile_path_regex("^", "$", false, false);
+        assert_match!(regex, "${FOO}/hello\\ world");
+        assert_match!(regex, "${FOO}/\\ ");
+    }
+
+    /// Windows-only paths
+    #[test]
+    fn path_regex_windows() {
+        let regex = compile_path_regex("^", "$", false, true);
+        assert_match!(regex, "${FOO}/hello^ world");
+        assert_match!(regex, "${FOO}/hello` world");
+        assert_match!(regex, "${FOO}/^ ");
+        assert_match!(regex, "${FOO}/` ");
+        assert_match!(regex, r"foo\bar");
+        assert_match!(regex, r"foo\bar");
+        assert_match!(regex, r"..\bar");
+        assert_match!(regex, r"..\");
+        assert_match!(regex, r"C:\");
+        assert_match!(regex, r"\\?\C:\foo");
+        assert_match!(regex, r"\\server\foo");
+    }
+
+    /// Paths that should work on all platforms
+    #[test]
+    fn path_regex() {
+        for windows in [false, true] {
+            let regex = compile_path_regex("^", "$", false, windows);
+            assert_no_match!(regex, "foo");
+            assert_no_match!(regex, "");
+            assert_match!(regex, "https://github.com/notifications/query=foo");
+            assert_match!(regex, "file:///foo/bar");
+            assert_match!(regex, "foo/bar");
+            assert_match!(regex, "$HOME/foo");
+            assert_match!(regex, "${FOO:-bar}/baz");
+            assert_match!(regex, "foo/bar_");
+            assert_match!(regex, "/home/bar");
+            assert_match!(regex, "foo/");
+            assert_match!(regex, "./");
+            assert_match!(regex, "../");
+            assert_match!(regex, "../..");
+            assert_match!(regex, "./foo");
+            assert_match!(regex, "./foo.rs");
+            assert_match!(regex, "/");
+            assert_match!(regex, "~/");
+            assert_match!(regex, "~/foo");
+            assert_match!(regex, "~/foo");
+            assert_match!(regex, "~/foo/../baz");
+            assert_match!(regex, "${HOME}/foo");
+            assert_match!(regex, "$HOME/foo");
+            assert_match!(regex, "/$FOO");
+            assert_match!(regex, "/${FOO}");
+            assert_match!(regex, "/${FOO}/${BAR}");
+            assert_match!(regex, "/${FOO}/${BAR}/foo");
+            assert_match!(regex, "/${FOO}/${BAR}");
+            assert_match!(regex, "${FOO}/hello_$WORLD");
+            assert_match!(regex, "${FOO}/hello_${WORLD}");
+            let regex = compile_path_regex("", "", false, windows);
+            assert_no_match!(regex, "");
+            assert_matches!(
+                regex,
+                r#"${FOO}/hello_${WORLD}  ${FOO}/hello_${WORLD} foo("./bar", "/home/foo")""#,
+                [
+                    "${FOO}/hello_${WORLD}",
+                    "${FOO}/hello_${WORLD}",
+                    "./bar",
+                    "/home/foo"
+                ]
+            );
+            assert_matches!(
+                regex,
+                r#"--> helix-stdx/src/path.rs:427:13"#,
+                ["helix-stdx/src/path.rs"]
+            );
+            assert_matches!(
+                regex,
+                r#"PATH=/foo/bar:/bar/baz:${foo:-/foo}/bar:${PATH}"#,
+                ["/foo/bar", "/bar/baz", "${foo:-/foo}/bar"]
+            );
+            let regex = compile_path_regex("^", "$", true, windows);
+            assert_no_match!(regex, "");
+            assert_match!(regex, "foo");
+            assert_match!(regex, "foo/");
+            assert_match!(regex, "$FOO");
+            assert_match!(regex, "${BAR}");
+        }
+    }
 }
diff --git a/helix-stdx/src/range.rs b/helix-stdx/src/range.rs
new file mode 100644
index 000000000..0b2411998
--- /dev/null
+++ b/helix-stdx/src/range.rs
@@ -0,0 +1,103 @@
+use std::ops::{self, RangeBounds};
+
+/// A range of `char`s within the text.
+#[derive(Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq)]
+pub struct Range<T = usize> {
+    pub start: T,
+    pub end: T,
+}
+
+impl<T: PartialOrd> Range<T> {
+    pub fn contains(&self, other: Self) -> bool {
+        self.start <= other.start && other.end <= self.end
+    }
+    pub fn is_empty(&self) -> bool {
+        self.end <= self.start
+    }
+}
+
+impl<T> RangeBounds<T> for Range<T> {
+    fn start_bound(&self) -> ops::Bound<&T> {
+        ops::Bound::Included(&self.start)
+    }
+
+    fn end_bound(&self) -> ops::Bound<&T> {
+        ops::Bound::Excluded(&self.end)
+    }
+}
+
+/// Returns true if all ranges yielded by `sub_set` are contained by
+/// `super_set`. This is essentially an optimized implementation of
+/// `sub_set.all(|rb| super_set.any(|ra| ra.contains(rb)))` that runs in O(m+n)
+/// instead of O(mn) (and in many cases faster).
+///
+/// Both iterators must uphold a the following invariants:
+/// * ranges must not overlap (but they can be adjacent)
+/// * ranges must be sorted
+pub fn is_subset<const ALLOW_EMPTY: bool>(
+    mut super_set: impl Iterator<Item = Range>,
+    mut sub_set: impl Iterator<Item = Range>,
+) -> bool {
+    let (mut super_range, mut sub_range) = (super_set.next(), sub_set.next());
+    loop {
+        match (super_range, sub_range) {
+            // skip over irrelevant ranges
+            (Some(ra), Some(rb))
+                if ra.end <= rb.start && (ra.start != rb.start || !ALLOW_EMPTY) =>
+            {
+                super_range = super_set.next();
+            }
+            (Some(ra), Some(rb)) => {
+                if ra.contains(rb) {
+                    sub_range = sub_set.next();
+                } else {
+                    return false;
+                }
+            }
+            (None, Some(_)) => {
+                // exhausted `super_set`, we can't match the reminder of `sub_set`
+                return false;
+            }
+            (_, None) => {
+                // no elements from `sub_sut` left to match, `super_set` contains `sub_set`
+                return true;
+            }
+        }
+    }
+}
+
+pub fn is_exact_subset(
+    mut super_set: impl Iterator<Item = Range>,
+    mut sub_set: impl Iterator<Item = Range>,
+) -> bool {
+    let (mut super_range, mut sub_range) = (super_set.next(), sub_set.next());
+    let mut super_range_matched = true;
+    loop {
+        match (super_range, sub_range) {
+            // skip over irrelevant ranges
+            (Some(ra), Some(rb)) if ra.end <= rb.start && ra.start < rb.start => {
+                if !super_range_matched {
+                    return false;
+                }
+                super_range_matched = false;
+                super_range = super_set.next();
+            }
+            (Some(ra), Some(rb)) => {
+                if ra.contains(rb) {
+                    super_range_matched = true;
+                    sub_range = sub_set.next();
+                } else {
+                    return false;
+                }
+            }
+            (None, Some(_)) => {
+                // exhausted `super_set`, we can't match the reminder of `sub_set`
+                return false;
+            }
+            (_, None) => {
+                // no elements from `sub_sut` left to match, `super_set` contains `sub_set`
+                return super_set.next().is_none();
+            }
+        }
+    }
+}
diff --git a/helix-stdx/src/rope.rs b/helix-stdx/src/rope.rs
index 2695555e3..9fc348f58 100644
--- a/helix-stdx/src/rope.rs
+++ b/helix-stdx/src/rope.rs
@@ -1,10 +1,12 @@
+use std::fmt;
 use std::ops::{Bound, RangeBounds};
 
 pub use regex_cursor::engines::meta::{Builder as RegexBuilder, Regex};
 pub use regex_cursor::regex_automata::util::syntax::Config;
 use regex_cursor::{Input as RegexInput, RopeyCursor};
-use ropey::str_utils::byte_to_char_idx;
+use ropey::iter::Chunks;
 use ropey::RopeSlice;
+use unicode_segmentation::{GraphemeCursor, GraphemeIncomplete};
 
 pub trait RopeSliceExt<'a>: Sized {
     fn ends_with(self, text: &str) -> bool;
@@ -17,23 +19,138 @@ fn regex_input_at_bytes<R: RangeBounds<usize>>(
     fn regex_input_at<R: RangeBounds<usize>>(self, char_range: R) -> RegexInput<RopeyCursor<'a>>;
     fn first_non_whitespace_char(self) -> Option<usize>;
     fn last_non_whitespace_char(self) -> Option<usize>;
-    /// returns the char idx of `byte_idx`, if `byte_idx` is a char boundary
-    /// this function behaves the same as `byte_to_char` but if `byte_idx` is
-    /// not a valid char boundary (so within a char) this will return the next
-    /// char index.
+    /// Finds the closest byte index not exceeding `byte_idx` which lies on a character boundary.
+    ///
+    /// If `byte_idx` already lies on a character boundary then it is returned as-is. When
+    /// `byte_idx` lies between two character boundaries, this function returns the byte index of
+    /// the lesser / earlier / left-hand-side boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from(""); // three bytes: e2 8c 9a
+    /// assert_eq!(text.floor_char_boundary(0), 0);
+    /// assert_eq!(text.floor_char_boundary(1), 0);
+    /// assert_eq!(text.floor_char_boundary(2), 0);
+    /// assert_eq!(text.floor_char_boundary(3), 3);
+    /// ```
+    fn floor_char_boundary(self, byte_idx: usize) -> usize;
+    /// Finds the closest byte index not below `byte_idx` which lies on a character boundary.
+    ///
+    /// If `byte_idx` already lies on a character boundary then it is returned as-is. When
+    /// `byte_idx` lies between two character boundaries, this function returns the byte index of
+    /// the greater / later / right-hand-side boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from(""); // three bytes: e2 8c 9a
+    /// assert_eq!(text.ceil_char_boundary(0), 0);
+    /// assert_eq!(text.ceil_char_boundary(1), 3);
+    /// assert_eq!(text.ceil_char_boundary(2), 3);
+    /// assert_eq!(text.ceil_char_boundary(3), 3);
+    /// ```
+    fn ceil_char_boundary(self, byte_idx: usize) -> usize;
+    /// Checks whether the given `byte_idx` lies on a character boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from(""); // three bytes: e2 8c 9a
+    /// assert!(text.is_char_boundary(0));
+    /// assert!(!text.is_char_boundary(1));
+    /// assert!(!text.is_char_boundary(2));
+    /// assert!(text.is_char_boundary(3));
+    /// ```
+    #[allow(clippy::wrong_self_convention)]
+    fn is_char_boundary(self, byte_idx: usize) -> bool;
+    /// Finds the closest byte index not exceeding `byte_idx` which lies on a grapheme cluster
+    /// boundary.
+    ///
+    /// If `byte_idx` already lies on a grapheme cluster boundary then it is returned as-is. When
+    /// `byte_idx` lies between two grapheme cluster boundaries, this function returns the byte
+    /// index of the lesser / earlier / left-hand-side boundary.
+    ///
+    /// `byte_idx` does not need to be aligned to a character boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from("\r\n"); // U+000D U+000A, hex: 0d 0a
+    /// assert_eq!(text.floor_grapheme_boundary(0), 0);
+    /// assert_eq!(text.floor_grapheme_boundary(1), 0);
+    /// assert_eq!(text.floor_grapheme_boundary(2), 2);
+    /// ```
+    fn floor_grapheme_boundary(self, byte_idx: usize) -> usize;
+    /// Finds the closest byte index not exceeding `byte_idx` which lies on a grapheme cluster
+    /// boundary.
+    ///
+    /// If `byte_idx` already lies on a grapheme cluster boundary then it is returned as-is. When
+    /// `byte_idx` lies between two grapheme cluster boundaries, this function returns the byte
+    /// index of the greater / later / right-hand-side boundary.
+    ///
+    /// `byte_idx` does not need to be aligned to a character boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from("\r\n"); // U+000D U+000A, hex: 0d 0a
+    /// assert_eq!(text.ceil_grapheme_boundary(0), 0);
+    /// assert_eq!(text.ceil_grapheme_boundary(1), 2);
+    /// assert_eq!(text.ceil_grapheme_boundary(2), 2);
+    /// ```
+    fn ceil_grapheme_boundary(self, byte_idx: usize) -> usize;
+    /// Checks whether the `byte_idx` lies on a grapheme cluster boundary.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from("\r\n"); // U+000D U+000A, hex: 0d 0a
+    /// assert!(text.is_grapheme_boundary(0));
+    /// assert!(!text.is_grapheme_boundary(1));
+    /// assert!(text.is_grapheme_boundary(2));
+    /// ```
+    #[allow(clippy::wrong_self_convention)]
+    fn is_grapheme_boundary(self, byte_idx: usize) -> bool;
+    /// Returns an iterator over the grapheme clusters in the slice.
     ///
     /// # Example
     ///
     /// ```
     /// # use ropey::RopeSlice;
     /// # use helix_stdx::rope::RopeSliceExt;
-    /// let text = RopeSlice::from("");
-    /// for i in 1..text.len_bytes() {
-    ///     assert_eq!(text.byte_to_char(i), 0);
-    ///     assert_eq!(text.byte_to_next_char(i), 1);
-    /// }
+    /// let text = RopeSlice::from("");
+    /// let graphemes: Vec<_> = text.graphemes().collect();
+    /// assert_eq!(graphemes.as_slice(), &["", "", ""]);
     /// ```
-    fn byte_to_next_char(self, byte_idx: usize) -> usize;
+    fn graphemes(self) -> RopeGraphemes<'a>;
+    /// Returns an iterator over the grapheme clusters in the slice, reversed.
+    ///
+    /// The returned iterator starts at the end of the slice and ends at the beginning of the
+    /// slice.
+    ///
+    /// # Example
+    ///
+    /// ```
+    /// # use ropey::RopeSlice;
+    /// # use helix_stdx::rope::RopeSliceExt;
+    /// let text = RopeSlice::from("");
+    /// let graphemes: Vec<_> = text.graphemes_rev().collect();
+    /// assert_eq!(graphemes.as_slice(), &["", "", ""]);
+    /// ```
+    fn graphemes_rev(self) -> RevRopeGraphemes<'a>;
 }
 
 impl<'a> RopeSliceExt<'a> for RopeSlice<'a> {
@@ -43,7 +160,7 @@ fn ends_with(self, text: &str) -> bool {
             return false;
         }
         self.get_byte_slice(len - text.len()..)
-            .map_or(false, |end| end == text)
+            .is_some_and(|end| end == text)
     }
 
     fn starts_with(self, text: &str) -> bool {
@@ -51,8 +168,8 @@ fn starts_with(self, text: &str) -> bool {
         if len < text.len() {
             return false;
         }
-        self.get_byte_slice(..len - text.len())
-            .map_or(false, |start| start == text)
+        self.get_byte_slice(..text.len())
+            .is_some_and(|start| start == text)
     }
 
     fn regex_input(self) -> RegexInput<RopeyCursor<'a>> {
@@ -94,14 +211,154 @@ fn last_non_whitespace_char(self) -> Option<usize> {
             .map(|pos| self.len_chars() - pos - 1)
     }
 
-    /// returns the char idx of `byte_idx`, if `byte_idx` is
-    /// a char boundary this function behaves the same as `byte_to_char`
-    fn byte_to_next_char(self, mut byte_idx: usize) -> usize {
-        let (chunk, chunk_byte_off, chunk_char_off, _) = self.chunk_at_byte(byte_idx);
-        byte_idx -= chunk_byte_off;
-        let is_char_boundary =
-            is_utf8_char_boundary(chunk.as_bytes().get(byte_idx).copied().unwrap_or(0));
-        chunk_char_off + byte_to_char_idx(chunk, byte_idx) + !is_char_boundary as usize
+    // These three are adapted from std:
+
+    fn floor_char_boundary(self, byte_idx: usize) -> usize {
+        if byte_idx >= self.len_bytes() {
+            self.len_bytes()
+        } else {
+            let offset = self
+                .bytes_at(byte_idx + 1)
+                .reversed()
+                .take(4)
+                .position(is_utf8_char_boundary)
+                // A char can only be four bytes long so we are guaranteed to find a boundary.
+                .unwrap();
+
+            byte_idx - offset
+        }
+    }
+
+    fn ceil_char_boundary(self, byte_idx: usize) -> usize {
+        if byte_idx > self.len_bytes() {
+            self.len_bytes()
+        } else {
+            let upper_bound = self.len_bytes().min(byte_idx + 4);
+            self.bytes_at(byte_idx)
+                .position(is_utf8_char_boundary)
+                .map_or(upper_bound, |pos| pos + byte_idx)
+        }
+    }
+
+    fn is_char_boundary(self, byte_idx: usize) -> bool {
+        if byte_idx == 0 {
+            return true;
+        }
+
+        if byte_idx >= self.len_bytes() {
+            byte_idx == self.len_bytes()
+        } else {
+            is_utf8_char_boundary(self.bytes_at(byte_idx).next().unwrap())
+        }
+    }
+
+    fn floor_grapheme_boundary(self, mut byte_idx: usize) -> usize {
+        if byte_idx >= self.len_bytes() {
+            return self.len_bytes();
+        }
+
+        byte_idx = self.ceil_char_boundary(byte_idx + 1);
+
+        let (mut chunk, mut chunk_byte_idx, _, _) = self.chunk_at_byte(byte_idx);
+
+        let mut cursor = GraphemeCursor::new(byte_idx, self.len_bytes(), true);
+
+        loop {
+            match cursor.prev_boundary(chunk, chunk_byte_idx) {
+                Ok(None) => return 0,
+                Ok(Some(boundary)) => return boundary,
+                Err(GraphemeIncomplete::PrevChunk) => {
+                    let (ch, ch_byte_idx, _, _) = self.chunk_at_byte(chunk_byte_idx - 1);
+                    chunk = ch;
+                    chunk_byte_idx = ch_byte_idx;
+                }
+                Err(GraphemeIncomplete::PreContext(n)) => {
+                    let ctx_chunk = self.chunk_at_byte(n - 1).0;
+                    cursor.provide_context(ctx_chunk, n - ctx_chunk.len());
+                }
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    fn ceil_grapheme_boundary(self, mut byte_idx: usize) -> usize {
+        if byte_idx >= self.len_bytes() {
+            return self.len_bytes();
+        }
+
+        if byte_idx == 0 {
+            return 0;
+        }
+
+        byte_idx = self.floor_char_boundary(byte_idx - 1);
+
+        let (mut chunk, mut chunk_byte_idx, _, _) = self.chunk_at_byte(byte_idx);
+
+        let mut cursor = GraphemeCursor::new(byte_idx, self.len_bytes(), true);
+
+        loop {
+            match cursor.next_boundary(chunk, chunk_byte_idx) {
+                Ok(None) => return self.len_bytes(),
+                Ok(Some(boundary)) => return boundary,
+                Err(GraphemeIncomplete::NextChunk) => {
+                    chunk_byte_idx += chunk.len();
+                    chunk = self.chunk_at_byte(chunk_byte_idx).0;
+                }
+                Err(GraphemeIncomplete::PreContext(n)) => {
+                    let ctx_chunk = self.chunk_at_byte(n - 1).0;
+                    cursor.provide_context(ctx_chunk, n - ctx_chunk.len());
+                }
+                _ => unreachable!(),
+            }
+        }
+    }
+
+    fn is_grapheme_boundary(self, byte_idx: usize) -> bool {
+        // The byte must lie on a character boundary to lie on a grapheme cluster boundary.
+        if !self.is_char_boundary(byte_idx) {
+            return false;
+        }
+
+        let (chunk, chunk_byte_idx, _, _) = self.chunk_at_byte(byte_idx);
+
+        let mut cursor = GraphemeCursor::new(byte_idx, self.len_bytes(), true);
+
+        loop {
+            match cursor.is_boundary(chunk, chunk_byte_idx) {
+                Ok(n) => return n,
+                Err(GraphemeIncomplete::PreContext(n)) => {
+                    let (ctx_chunk, ctx_byte_start, _, _) = self.chunk_at_byte(n - 1);
+                    cursor.provide_context(ctx_chunk, ctx_byte_start);
+                }
+                Err(_) => unreachable!(),
+            }
+        }
+    }
+
+    fn graphemes(self) -> RopeGraphemes<'a> {
+        let mut chunks = self.chunks();
+        let first_chunk = chunks.next().unwrap_or("");
+        RopeGraphemes {
+            text: self,
+            chunks,
+            cur_chunk: first_chunk,
+            cur_chunk_start: 0,
+            cursor: GraphemeCursor::new(0, self.len_bytes(), true),
+        }
+    }
+
+    fn graphemes_rev(self) -> RevRopeGraphemes<'a> {
+        let (mut chunks, mut cur_chunk_start, _, _) = self.chunks_at_byte(self.len_bytes());
+        chunks.reverse();
+        let first_chunk = chunks.next().unwrap_or("");
+        cur_chunk_start -= first_chunk.len();
+        RevRopeGraphemes {
+            text: self,
+            chunks,
+            cur_chunk: first_chunk,
+            cur_chunk_start,
+            cursor: GraphemeCursor::new(self.len_bytes(), self.len_bytes(), true),
+        }
     }
 }
 
@@ -112,6 +369,130 @@ const fn is_utf8_char_boundary(b: u8) -> bool {
     (b as i8) >= -0x40
 }
 
+/// An iterator over the graphemes of a `RopeSlice`.
+#[derive(Clone)]
+pub struct RopeGraphemes<'a> {
+    text: RopeSlice<'a>,
+    chunks: Chunks<'a>,
+    cur_chunk: &'a str,
+    cur_chunk_start: usize,
+    cursor: GraphemeCursor,
+}
+
+impl fmt::Debug for RopeGraphemes<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("RopeGraphemes")
+            .field("text", &self.text)
+            .field("chunks", &self.chunks)
+            .field("cur_chunk", &self.cur_chunk)
+            .field("cur_chunk_start", &self.cur_chunk_start)
+            // .field("cursor", &self.cursor)
+            .finish()
+    }
+}
+
+impl<'a> Iterator for RopeGraphemes<'a> {
+    type Item = RopeSlice<'a>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        let a = self.cursor.cur_cursor();
+        let b;
+        loop {
+            match self
+                .cursor
+                .next_boundary(self.cur_chunk, self.cur_chunk_start)
+            {
+                Ok(None) => {
+                    return None;
+                }
+                Ok(Some(n)) => {
+                    b = n;
+                    break;
+                }
+                Err(GraphemeIncomplete::NextChunk) => {
+                    self.cur_chunk_start += self.cur_chunk.len();
+                    self.cur_chunk = self.chunks.next().unwrap_or("");
+                }
+                Err(GraphemeIncomplete::PreContext(idx)) => {
+                    let (chunk, byte_idx, _, _) = self.text.chunk_at_byte(idx.saturating_sub(1));
+                    self.cursor.provide_context(chunk, byte_idx);
+                }
+                _ => unreachable!(),
+            }
+        }
+
+        if a < self.cur_chunk_start {
+            Some(self.text.byte_slice(a..b))
+        } else {
+            let a2 = a - self.cur_chunk_start;
+            let b2 = b - self.cur_chunk_start;
+            Some((&self.cur_chunk[a2..b2]).into())
+        }
+    }
+}
+
+/// An iterator over the graphemes of a `RopeSlice` in reverse.
+#[derive(Clone)]
+pub struct RevRopeGraphemes<'a> {
+    text: RopeSlice<'a>,
+    chunks: Chunks<'a>,
+    cur_chunk: &'a str,
+    cur_chunk_start: usize,
+    cursor: GraphemeCursor,
+}
+
+impl fmt::Debug for RevRopeGraphemes<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("RevRopeGraphemes")
+            .field("text", &self.text)
+            .field("chunks", &self.chunks)
+            .field("cur_chunk", &self.cur_chunk)
+            .field("cur_chunk_start", &self.cur_chunk_start)
+            // .field("cursor", &self.cursor)
+            .finish()
+    }
+}
+
+impl<'a> Iterator for RevRopeGraphemes<'a> {
+    type Item = RopeSlice<'a>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        let a = self.cursor.cur_cursor();
+        let b;
+        loop {
+            match self
+                .cursor
+                .prev_boundary(self.cur_chunk, self.cur_chunk_start)
+            {
+                Ok(None) => {
+                    return None;
+                }
+                Ok(Some(n)) => {
+                    b = n;
+                    break;
+                }
+                Err(GraphemeIncomplete::PrevChunk) => {
+                    self.cur_chunk = self.chunks.next().unwrap_or("");
+                    self.cur_chunk_start -= self.cur_chunk.len();
+                }
+                Err(GraphemeIncomplete::PreContext(idx)) => {
+                    let (chunk, byte_idx, _, _) = self.text.chunk_at_byte(idx.saturating_sub(1));
+                    self.cursor.provide_context(chunk, byte_idx);
+                }
+                _ => unreachable!(),
+            }
+        }
+
+        if a >= self.cur_chunk_start + self.cur_chunk.len() {
+            Some(self.text.byte_slice(b..a))
+        } else {
+            let a2 = a - self.cur_chunk_start;
+            let b2 = b - self.cur_chunk_start;
+            Some((&self.cur_chunk[b2..a2]).into())
+        }
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use ropey::RopeSlice;
@@ -119,22 +500,87 @@ mod tests {
     use crate::rope::RopeSliceExt;
 
     #[test]
-    fn next_char_at_byte() {
+    fn starts_with() {
+        assert!(RopeSlice::from("asdf").starts_with("a"));
+    }
+
+    #[test]
+    fn ends_with() {
+        assert!(RopeSlice::from("asdf").ends_with("f"));
+    }
+
+    #[test]
+    fn char_boundaries() {
+        let ascii = RopeSlice::from("ascii");
+        // When the given index lies on a character boundary, the index should not change.
+        for byte_idx in 0..=ascii.len_bytes() {
+            assert_eq!(ascii.floor_char_boundary(byte_idx), byte_idx);
+            assert_eq!(ascii.ceil_char_boundary(byte_idx), byte_idx);
+            assert!(ascii.is_char_boundary(byte_idx));
+        }
+
+        // This is a polyfill of a method of this trait which was replaced by ceil_char_boundary.
+        // It returns the _character index_ of the given byte index, rounding up if it does not
+        // already lie on a character boundary.
+        fn byte_to_next_char(slice: RopeSlice, byte_idx: usize) -> usize {
+            slice.byte_to_char(slice.ceil_char_boundary(byte_idx))
+        }
+
         for i in 0..=6 {
-            assert_eq!(RopeSlice::from("foobar").byte_to_next_char(i), i);
+            assert_eq!(byte_to_next_char(RopeSlice::from("foobar"), i), i);
         }
         for char_idx in 0..10 {
             let len = "".len();
             assert_eq!(
-                RopeSlice::from("").byte_to_next_char(char_idx * len),
+                byte_to_next_char(RopeSlice::from(""), char_idx * len),
                 char_idx
             );
             for i in 1..=len {
                 assert_eq!(
-                    RopeSlice::from("").byte_to_next_char(char_idx * len + i),
+                    byte_to_next_char(RopeSlice::from(""), char_idx * len + i),
                     char_idx + 1
                 );
             }
         }
     }
+
+    #[test]
+    fn grapheme_boundaries() {
+        let ascii = RopeSlice::from("ascii");
+        // When the given index lies on a grapheme boundary, the index should not change.
+        for byte_idx in 0..=ascii.len_bytes() {
+            assert_eq!(ascii.floor_char_boundary(byte_idx), byte_idx);
+            assert_eq!(ascii.ceil_char_boundary(byte_idx), byte_idx);
+            assert!(ascii.is_grapheme_boundary(byte_idx));
+        }
+
+        // : U+1F3F4 U+200D U+2620 U+FE0F
+        // 13 bytes, hex: f0 9f 8f b4 + e2 80 8d + e2 98 a0 + ef b8 8f
+        let g = RopeSlice::from("\r\n");
+        let emoji_len = "".len();
+        let end = g.len_bytes();
+
+        for byte_idx in 0..emoji_len {
+            assert_eq!(g.floor_grapheme_boundary(byte_idx), 0);
+        }
+        for byte_idx in emoji_len..end {
+            assert_eq!(g.floor_grapheme_boundary(byte_idx), emoji_len);
+        }
+        assert_eq!(g.floor_grapheme_boundary(end), end);
+
+        assert_eq!(g.ceil_grapheme_boundary(0), 0);
+        for byte_idx in 1..=emoji_len {
+            assert_eq!(g.ceil_grapheme_boundary(byte_idx), emoji_len);
+        }
+        for byte_idx in emoji_len + 1..=end {
+            assert_eq!(g.ceil_grapheme_boundary(byte_idx), end);
+        }
+
+        assert!(g.is_grapheme_boundary(0));
+        assert!(g.is_grapheme_boundary(emoji_len));
+        assert!(g.is_grapheme_boundary(end));
+        for byte_idx in (1..emoji_len).chain(emoji_len + 1..end) {
+            assert!(!g.is_grapheme_boundary(byte_idx));
+        }
+    }
 }
diff --git a/helix-term/Cargo.toml b/helix-term/Cargo.toml
index 5f691d44a..3c27f919e 100644
--- a/helix-term/Cargo.toml
+++ b/helix-term/Cargo.toml
@@ -12,6 +12,24 @@ categories.workspace = true
 repository.workspace = true
 homepage.workspace = true
 
+[package.metadata.deb]
+# generate a .deb in target/debian/ with the command: cargo deb --no-build
+name = "helix"
+assets = [
+  { source = "target/release/hx", dest = "/usr/lib/helix/", mode = "755" },
+  { source = "../contrib/hx_launcher.sh", dest = "/usr/bin/hx", mode = "755" },
+  { source = "../runtime/*", dest = "/usr/lib/helix/runtime/", mode = "644" },
+  { source = "../runtime/grammars/*", dest = "/usr/lib/helix/runtime/grammars/", mode = "644" }, # to avoid sources/
+  { source = "../runtime/queries/**/*", dest = "/usr/lib/helix/runtime/queries/", mode = "644" },
+  { source = "../runtime/themes/**/*", dest = "/usr/lib/helix/runtime/themes/", mode = "644" },
+  { source = "../README.md", dest = "/usr/share/doc/helix/", mode = "644" },
+  { source = "../contrib/completion/hx.bash", dest = "/usr/share/bash-completion/completions/hx", mode = "644" },
+  { source = "../contrib/completion/hx.fish", dest = "/usr/share/fish/vendor_completions.d/hx.fish", mode = "644" },
+  { source = "../contrib/completion/hx.zsh", dest = "/usr/share/zsh/vendor-completions/_hx", mode = "644" },
+  { source = "../contrib/Helix.desktop", dest = "/usr/share/applications/Helix.desktop", mode = "644" },
+  { source = "../contrib/helix.png", dest = "/usr/share/icons/hicolor/256x256/apps/helix.png", mode = "644" },
+]
+
 [features]
 default = ["git"]
 unicode-lines = ["helix-core/unicode-lines", "helix-view/unicode-lines"]
@@ -33,7 +51,7 @@ helix-vcs = { path = "../helix-vcs" }
 helix-loader = { path = "../helix-loader" }
 
 anyhow = "1"
-once_cell = "1.19"
+once_cell = "1.20"
 
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot"] }
 tui = { path = "../helix-tui", package = "helix-tui", default-features = false, features = ["crossterm"] }
@@ -43,9 +61,10 @@ tokio-stream = "0.1"
 futures-util = { version = "0.3", features = ["std", "async-await"], default-features = false }
 arc-swap = { version = "1.7.1" }
 termini = "1"
+indexmap = "2.7"
 
 # Logging
-fern = "0.6"
+fern = "0.7"
 chrono = { version = "0.4", default-features = false, features = ["clock"] }
 log = "0.4"
 
@@ -56,11 +75,11 @@ ignore = "0.4"
 pulldown-cmark = { version = "0.12", default-features = false }
 # file type detection
 content_inspector = "0.2.4"
-thiserror = "1.0"
+thiserror.workspace = true
 
 # opening URLs
-open = "5.3.0"
-url = "2.5.2"
+open = "5.3.2"
+url = "2.5.4"
 
 # config
 toml = "0.8"
@@ -69,12 +88,12 @@ serde_json = "1.0"
 serde = { version = "1.0", features = ["derive"] }
 
 # ripgrep for global search
-grep-regex = "0.1.12"
-grep-searcher = "0.1.13"
+grep-regex = "0.1.13"
+grep-searcher = "0.1.14"
 
 [target.'cfg(not(windows))'.dependencies]  # https://github.com/vorner/signal-hook/issues/100
 signal-hook-tokio = { version = "0.3", features = ["futures-v0_3"] }
-libc = "0.2.158"
+libc = "0.2.169"
 
 [target.'cfg(target_os = "macos")'.dependencies]
 crossterm = { version = "0.28", features = ["event-stream", "use-dev-tty", "libc"] }
@@ -85,5 +104,5 @@ helix-loader = { path = "../helix-loader" }
 [dev-dependencies]
 smallvec = "1.13"
 indoc = "2.0.5"
-tempfile = "3.12.0"
+tempfile.workspace = true
 same-file = "1.0.1"
diff --git a/helix-term/src/application.rs b/helix-term/src/application.rs
index bd6b5a870..242cce1b8 100644
--- a/helix-term/src/application.rs
+++ b/helix-term/src/application.rs
@@ -1,6 +1,6 @@
 use arc_swap::{access::Map, ArcSwap};
 use futures_util::Stream;
-use helix_core::{diagnostic::Severity, pos_at_coords, syntax, Selection};
+use helix_core::{diagnostic::Severity, pos_at_coords, syntax, Range, Selection};
 use helix_lsp::{
     lsp::{self, notification::Notification},
     util::lsp_range_to_range,
@@ -11,7 +11,6 @@
     align_view,
     document::{DocumentOpenError, DocumentSavedEventResult},
     editor::{ConfigEvent, EditorEvent},
-    events::DiagnosticsDidChange,
     graphics::Rect,
     theme,
     tree::Layout,
@@ -33,7 +32,7 @@
 use log::{debug, error, info, warn};
 #[cfg(not(feature = "integration"))]
 use std::io::stdout;
-use std::{collections::btree_map::Entry, io::stdin, path::Path, sync::Arc};
+use std::{io::stdin, path::Path, sync::Arc};
 
 #[cfg(not(windows))]
 use anyhow::Context;
@@ -175,7 +174,7 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
                     nr_of_files += 1;
                     if file.is_dir() {
                         return Err(anyhow::anyhow!(
-                            "expected a path to file, found a directory. (to open a directory pass it as first argument)"
+                            "expected a path to file, but found a directory: {file:?}. (to open a directory pass it as first argument)"
                         ));
                     } else {
                         // If the user passes in either `--vsplit` or
@@ -189,6 +188,7 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
                             Some(Layout::Horizontal) => Action::HorizontalSplit,
                             None => Action::Load,
                         };
+                        let old_id = editor.document_id_by_path(&file);
                         let doc_id = match editor.open(&file, action) {
                             // Ignore irregular files during application init.
                             Err(DocumentOpenError::IrregularFile) => {
@@ -196,6 +196,11 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
                                 continue;
                             }
                             Err(err) => return Err(anyhow::anyhow!(err)),
+                            // We can't open more than 1 buffer for 1 file, in this case we already have opened this file previously
+                            Ok(doc_id) if old_id == Some(doc_id) => {
+                                nr_of_files -= 1;
+                                doc_id
+                            }
                             Ok(doc_id) => doc_id,
                         };
                         // with Action::Load all documents have the same view
@@ -204,8 +209,13 @@ pub fn new(args: Args, config: Config, lang_loader: syntax::Loader) -> Result<Se
                         // opened last is focused on.
                         let view_id = editor.tree.focus;
                         let doc = doc_mut!(editor, &doc_id);
-                        let pos = Selection::point(pos_at_coords(doc.text().slice(..), pos, true));
-                        doc.set_selection(view_id, pos);
+                        let selection = pos
+                            .into_iter()
+                            .map(|coords| {
+                                Range::point(pos_at_coords(doc.text().slice(..), coords, true))
+                            })
+                            .collect();
+                        doc.set_selection(view_id, selection);
                     }
                 }
 
@@ -711,7 +721,7 @@ macro_rules! language_server {
                         // This might not be required by the spec but Neovim does this as well, so it's
                         // probably a good idea for compatibility.
                         if let Some(config) = language_server.config() {
-                            tokio::spawn(language_server.did_change_configuration(config.clone()));
+                            language_server.did_change_configuration(config.clone());
                         }
 
                         let docs = self
@@ -729,15 +739,15 @@ macro_rules! language_server {
                             let language_id =
                                 doc.language_id().map(ToOwned::to_owned).unwrap_or_default();
 
-                            tokio::spawn(language_server.text_document_did_open(
+                            language_server.text_document_did_open(
                                 url,
                                 doc.version(),
                                 doc.text(),
                                 language_id,
-                            ));
+                            );
                         }
                     }
-                    Notification::PublishDiagnostics(mut params) => {
+                    Notification::PublishDiagnostics(params) => {
                         let uri = match helix_core::Uri::try_from(params.uri) {
                             Ok(uri) => uri,
                             Err(err) => {
@@ -750,103 +760,23 @@ macro_rules! language_server {
                             log::error!("Discarding publishDiagnostic notification sent by an uninitialized server: {}", language_server.name());
                             return;
                         }
-                        // have to inline the function because of borrow checking...
-                        let doc = self.editor.documents.values_mut()
-                            .find(|doc| doc.uri().is_some_and(|u| u == uri))
-                            .filter(|doc| {
-                                if let Some(version) = params.version {
-                                    if version != doc.version() {
-                                        log::info!("Version ({version}) is out of date for {uri:?} (expected ({}), dropping PublishDiagnostic notification", doc.version());
-                                        return false;
-                                    }
-                                }
-                                true
-                            });
-
-                        let mut unchanged_diag_sources = Vec::new();
-                        if let Some(doc) = &doc {
-                            let lang_conf = doc.language.clone();
-
-                            if let Some(lang_conf) = &lang_conf {
-                                if let Some(old_diagnostics) = self.editor.diagnostics.get(&uri) {
-                                    if !lang_conf.persistent_diagnostic_sources.is_empty() {
-                                        // Sort diagnostics first by severity and then by line numbers.
-                                        // Note: The `lsp::DiagnosticSeverity` enum is already defined in decreasing order
-                                        params
-                                            .diagnostics
-                                            .sort_by_key(|d| (d.severity, d.range.start));
-                                    }
-                                    for source in &lang_conf.persistent_diagnostic_sources {
-                                        let new_diagnostics = params
-                                            .diagnostics
-                                            .iter()
-                                            .filter(|d| d.source.as_ref() == Some(source));
-                                        let old_diagnostics = old_diagnostics
-                                            .iter()
-                                            .filter(|(d, d_server)| {
-                                                *d_server == server_id
-                                                    && d.source.as_ref() == Some(source)
-                                            })
-                                            .map(|(d, _)| d);
-                                        if new_diagnostics.eq(old_diagnostics) {
-                                            unchanged_diag_sources.push(source.clone())
-                                        }
-                                    }
+                        self.editor.handle_lsp_diagnostics(
+                            language_server.id(),
+                            uri,
+                            params.version,
+                            params.diagnostics,
+                        );
+                    }
+                    Notification::ShowMessage(params) => {
+                        if self.config.load().editor.lsp.display_messages {
+                            match params.typ {
+                                lsp::MessageType::ERROR => self.editor.set_error(params.message),
+                                lsp::MessageType::WARNING => {
+                                    self.editor.set_warning(params.message)
                                 }
+                                _ => self.editor.set_status(params.message),
                             }
                         }
-
-                        let diagnostics = params.diagnostics.into_iter().map(|d| (d, server_id));
-
-                        // Insert the original lsp::Diagnostics here because we may have no open document
-                        // for diagnosic message and so we can't calculate the exact position.
-                        // When using them later in the diagnostics picker, we calculate them on-demand.
-                        let diagnostics = match self.editor.diagnostics.entry(uri) {
-                            Entry::Occupied(o) => {
-                                let current_diagnostics = o.into_mut();
-                                // there may entries of other language servers, which is why we can't overwrite the whole entry
-                                current_diagnostics.retain(|(_, lsp_id)| *lsp_id != server_id);
-                                current_diagnostics.extend(diagnostics);
-                                current_diagnostics
-                                // Sort diagnostics first by severity and then by line numbers.
-                            }
-                            Entry::Vacant(v) => v.insert(diagnostics.collect()),
-                        };
-
-                        // Sort diagnostics first by severity and then by line numbers.
-                        // Note: The `lsp::DiagnosticSeverity` enum is already defined in decreasing order
-                        diagnostics
-                            .sort_by_key(|(d, server_id)| (d.severity, d.range.start, *server_id));
-
-                        if let Some(doc) = doc {
-                            let diagnostic_of_language_server_and_not_in_unchanged_sources =
-                                |diagnostic: &lsp::Diagnostic, ls_id| {
-                                    ls_id == server_id
-                                        && diagnostic.source.as_ref().map_or(true, |source| {
-                                            !unchanged_diag_sources.contains(source)
-                                        })
-                                };
-                            let diagnostics = Editor::doc_diagnostics_with_filter(
-                                &self.editor.language_servers,
-                                &self.editor.diagnostics,
-                                doc,
-                                diagnostic_of_language_server_and_not_in_unchanged_sources,
-                            );
-                            doc.replace_diagnostics(
-                                diagnostics,
-                                &unchanged_diag_sources,
-                                Some(server_id),
-                            );
-
-                            let doc = doc.id();
-                            helix_event::dispatch(DiagnosticsDidChange {
-                                editor: &mut self.editor,
-                                doc,
-                            });
-                        }
-                    }
-                    Notification::ShowMessage(params) => {
-                        log::warn!("unhandled window/showMessage: {:?}", params);
                     }
                     Notification::LogMessage(params) => {
                         log::info!("window/logMessage: {:?}", params);
@@ -930,7 +860,7 @@ macro_rules! language_server {
                             self.lsp_progress.update(server_id, token, work);
                         }
 
-                        if self.config.load().editor.lsp.display_messages {
+                        if self.config.load().editor.lsp.display_progress_messages {
                             self.editor.set_status(status);
                         }
                     }
@@ -1112,7 +1042,13 @@ macro_rules! language_server {
                     }
                 };
 
-                tokio::spawn(language_server!().reply(id, reply));
+                let language_server = language_server!();
+                if let Err(err) = language_server.reply(id.clone(), reply) {
+                    log::error!(
+                        "Failed to send reply to server '{}' request {id}: {err}",
+                        language_server.name()
+                    );
+                }
             }
             Call::Invalid { id } => log::error!("LSP invalid method call id={:?}", id),
         }
diff --git a/helix-term/src/args.rs b/helix-term/src/args.rs
index 0b1c9cde0..9b1b4409b 100644
--- a/helix-term/src/args.rs
+++ b/helix-term/src/args.rs
@@ -1,6 +1,7 @@
 use anyhow::Result;
 use helix_core::Position;
 use helix_view::tree::Layout;
+use indexmap::IndexMap;
 use std::path::{Path, PathBuf};
 
 #[derive(Default)]
@@ -16,7 +17,7 @@ pub struct Args {
     pub verbosity: u64,
     pub log_file: Option<PathBuf>,
     pub config_file: Option<PathBuf>,
-    pub files: Vec<(PathBuf, Position)>,
+    pub files: IndexMap<PathBuf, Vec<Position>>,
     pub working_directory: Option<PathBuf>,
 }
 
@@ -26,6 +27,18 @@ pub fn parse_args() -> Result<Args> {
         let mut argv = std::env::args().peekable();
         let mut line_number = 0;
 
+        let mut insert_file_with_position = |file_with_position: &str| {
+            let (filename, position) = parse_file(file_with_position);
+
+            // Before setting the working directory, resolve all the paths in args.files
+            let filename = helix_stdx::path::canonicalize(filename);
+
+            args.files
+                .entry(filename)
+                .and_modify(|positions| positions.push(position))
+                .or_insert_with(|| vec![position]);
+        };
+
         argv.next(); // skip the program, we don't care about that
 
         while let Some(arg) = argv.next() {
@@ -92,21 +105,25 @@ pub fn parse_args() -> Result<Args> {
                 arg if arg.starts_with('+') => {
                     match arg[1..].parse::<usize>() {
                         Ok(n) => line_number = n.saturating_sub(1),
-                        _ => args.files.push(parse_file(arg)),
+                        _ => insert_file_with_position(arg),
                     };
                 }
-                arg => args.files.push(parse_file(arg)),
+                arg => insert_file_with_position(arg),
             }
         }
 
         // push the remaining args, if any to the files
         for arg in argv {
-            args.files.push(parse_file(&arg));
+            insert_file_with_position(&arg);
         }
 
-        if let Some(file) = args.files.first_mut() {
-            if line_number != 0 {
-                file.1.row = line_number;
+        if line_number != 0 {
+            if let Some(first_position) = args
+                .files
+                .first_mut()
+                .and_then(|(_, positions)| positions.first_mut())
+            {
+                first_position.row = line_number;
             }
         }
 
@@ -129,7 +146,7 @@ pub(crate) fn parse_file(s: &str) -> (PathBuf, Position) {
 ///
 /// Does not validate if file.rs is a file or directory.
 fn split_path_row_col(s: &str) -> Option<(PathBuf, Position)> {
-    let mut s = s.rsplitn(3, ':');
+    let mut s = s.trim_end_matches(':').rsplitn(3, ':');
     let col: usize = s.next()?.parse().ok()?;
     let row: usize = s.next()?.parse().ok()?;
     let path = s.next()?.into();
@@ -141,7 +158,7 @@ fn split_path_row_col(s: &str) -> Option<(PathBuf, Position)> {
 ///
 /// Does not validate if file.rs is a file or directory.
 fn split_path_row(s: &str) -> Option<(PathBuf, Position)> {
-    let (path, row) = s.rsplit_once(':')?;
+    let (path, row) = s.trim_end_matches(':').rsplit_once(':')?;
     let row: usize = row.parse().ok()?;
     let path = path.into();
     let pos = Position::new(row.saturating_sub(1), 0);
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 6e037a471..19a22601e 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -6,7 +6,7 @@
 use futures_util::FutureExt;
 use helix_event::status;
 use helix_stdx::{
-    path::expand_tilde,
+    path::{self, find_paths},
     rope::{self, RopeSliceExt},
 };
 use helix_vcs::{FileChange, Hunk};
@@ -20,10 +20,10 @@
     comment,
     doc_formatter::TextFormat,
     encoding, find_workspace,
-    graphemes::{self, next_grapheme_boundary, RevRopeGraphemes},
+    graphemes::{self, next_grapheme_boundary},
     history::UndoKind,
-    increment, indent,
-    indent::IndentStyle,
+    increment,
+    indent::{self, IndentStyle},
     line_ending::{get_line_ending_of_str, line_end_char_index},
     match_brackets,
     movement::{self, move_vertically_visual, Direction},
@@ -35,8 +35,8 @@
     text_annotations::{Overlay, TextAnnotations},
     textobject,
     unicode::width::UnicodeWidthChar,
-    visual_offset_from_block, Deletion, LineEnding, Position, Range, Rope, RopeGraphemes,
-    RopeReader, RopeSlice, Selection, SmallVec, Syntax, Tendril, Transaction,
+    visual_offset_from_block, Deletion, LineEnding, Position, Range, Rope, RopeReader, RopeSlice,
+    Selection, SmallVec, Syntax, Tendril, Transaction,
 };
 use helix_view::{
     document::{FormatterError, Mode, SCRATCH_BUFFER_NAME},
@@ -87,6 +87,11 @@
 use ignore::{DirEntry, WalkBuilder, WalkState};
 
 pub type OnKeyCallback = Box<dyn FnOnce(&mut Context, KeyEvent)>;
+#[derive(PartialEq, Eq, Clone, Copy, Debug)]
+pub enum OnKeyCallbackKind {
+    PseudoPending,
+    Fallback,
+}
 
 pub struct Context<'a> {
     pub register: Option<char>,
@@ -94,11 +99,11 @@ pub struct Context<'a> {
     pub editor: &'a mut Editor,
 
     pub callback: Vec<crate::compositor::Callback>,
-    pub on_next_key_callback: Option<OnKeyCallback>,
+    pub on_next_key_callback: Option<(OnKeyCallback, OnKeyCallbackKind)>,
     pub jobs: &'a mut Jobs,
 }
 
-impl<'a> Context<'a> {
+impl Context<'_> {
     /// Push a new component onto the compositor.
     pub fn push_layer(&mut self, component: Box<dyn Component>) {
         self.callback
@@ -120,7 +125,19 @@ pub fn on_next_key(
         &mut self,
         on_next_key_callback: impl FnOnce(&mut Context, KeyEvent) + 'static,
     ) {
-        self.on_next_key_callback = Some(Box::new(on_next_key_callback));
+        self.on_next_key_callback = Some((
+            Box::new(on_next_key_callback),
+            OnKeyCallbackKind::PseudoPending,
+        ));
+    }
+
+    #[inline]
+    pub fn on_next_key_fallback(
+        &mut self,
+        on_next_key_callback: impl FnOnce(&mut Context, KeyEvent) + 'static,
+    ) {
+        self.on_next_key_callback =
+            Some((Box::new(on_next_key_callback), OnKeyCallbackKind::Fallback));
     }
 
     #[inline]
@@ -353,6 +370,7 @@ pub fn doc(&self) -> &str {
         extend_search_next, "Add next search match to selection",
         extend_search_prev, "Add previous search match to selection",
         search_selection, "Use current selection as search pattern",
+        search_selection_detect_word_boundaries, "Use current selection as the search pattern, automatically wrapping with `\\b` on word boundaries",
         make_search_word_bounded, "Modify current search to make it word bounded",
         global_search, "Global search in workspace folder",
         extend_line, "Select current line, if already selected, extend to another line based on the anchor",
@@ -375,6 +393,9 @@ pub fn doc(&self) -> &str {
         file_picker, "Open file picker",
         file_picker_in_current_buffer_directory, "Open file picker at current buffer's directory",
         file_picker_in_current_directory, "Open file picker at current working directory",
+        file_explorer, "Open file explorer in workspace root",
+        file_explorer_in_current_buffer_directory, "Open file explorer at current buffer's directory",
+        file_explorer_in_current_directory, "Open file explorer at current working directory",
         code_action, "Perform code action",
         buffer_picker, "Open buffer picker",
         jumplist_picker, "Open jumplist picker",
@@ -511,6 +532,7 @@ pub fn doc(&self) -> &str {
         wonly, "Close windows except current",
         select_register, "Select register",
         insert_register, "Insert register",
+        copy_between_registers, "Copy between two registers",
         align_view_middle, "Align view middle",
         align_view_top, "Align view top",
         align_view_center, "Align view center",
@@ -567,6 +589,8 @@ pub fn doc(&self) -> &str {
         command_palette, "Open command palette",
         goto_word, "Jump to a two-character label",
         extend_to_word, "Extend to a two-character label",
+        goto_next_tabstop, "goto next snippet placeholder",
+        goto_prev_tabstop, "goto next snippet placeholder",
     );
 }
 
@@ -610,10 +634,17 @@ fn from_str(s: &str) -> Result<Self, Self::Err> {
                 .collect::<Vec<String>>();
             typed::TYPABLE_COMMAND_MAP
                 .get(name)
-                .map(|cmd| MappableCommand::Typable {
-                    name: cmd.name.to_owned(),
-                    doc: format!(":{} {:?}", cmd.name, args),
-                    args,
+                .map(|cmd| {
+                    let doc = if args.is_empty() {
+                        cmd.doc.to_string()
+                    } else {
+                        format!(":{} {:?}", cmd.name, args)
+                    };
+                    MappableCommand::Typable {
+                        name: cmd.name.to_owned(),
+                        doc,
+                        args,
+                    }
                 })
                 .ok_or_else(|| anyhow!("No TypableCommand named '{}'", s))
         } else if let Some(suffix) = s.strip_prefix('@') {
@@ -1263,7 +1294,7 @@ fn goto_file_vsplit(cx: &mut Context) {
 /// Goto files in selection.
 fn goto_file_impl(cx: &mut Context, action: Action) {
     let (view, doc) = current_ref!(cx.editor);
-    let text = doc.text();
+    let text = doc.text().slice(..);
     let selections = doc.selection(view.id);
     let primary = selections.primary();
     let rel_path = doc
@@ -1272,53 +1303,31 @@ fn goto_file_impl(cx: &mut Context, action: Action) {
         .unwrap_or_default();
 
     let paths: Vec<_> = if selections.len() == 1 && primary.len() == 1 {
-        // Secial case: if there is only one one-width selection, try to detect the
-        // path under the cursor.
-        let is_valid_path_char = |c: &char| {
-            #[cfg(target_os = "windows")]
-            let valid_chars = &[
-                '@', '/', '\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':', '!',
-                '~', '=',
-            ];
-            #[cfg(not(target_os = "windows"))]
-            let valid_chars = &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=', ':'];
-
-            valid_chars.contains(c) || c.is_alphabetic() || c.is_numeric()
-        };
-
-        let cursor_pos = primary.cursor(text.slice(..));
-        let pre_cursor_pos = cursor_pos.saturating_sub(1);
-        let post_cursor_pos = cursor_pos + 1;
-        let start_pos = if is_valid_path_char(&text.char(cursor_pos)) {
-            cursor_pos
-        } else if is_valid_path_char(&text.char(pre_cursor_pos)) {
-            pre_cursor_pos
-        } else {
-            post_cursor_pos
-        };
-
-        let prefix_len = text
-            .chars_at(start_pos)
-            .reversed()
-            .take_while(is_valid_path_char)
-            .count();
-
-        let postfix_len = text
-            .chars_at(start_pos)
-            .take_while(is_valid_path_char)
-            .count();
-
-        let path: String = text
-            .slice((start_pos - prefix_len)..(start_pos + postfix_len))
-            .into();
-        log::debug!("goto_file auto-detected path: {}", path);
-
-        vec![path]
+        // Cap the search at roughly 1k bytes around the cursor.
+        let lookaround = 1000;
+        let pos = text.char_to_byte(primary.cursor(text));
+        let search_start = text
+            .line_to_byte(text.byte_to_line(pos))
+            .max(text.floor_char_boundary(pos.saturating_sub(lookaround)));
+        let search_end = text
+            .line_to_byte(text.byte_to_line(pos) + 1)
+            .min(text.ceil_char_boundary(pos + lookaround));
+        let search_range = text.byte_slice(search_start..search_end);
+        // we also allow paths that are next to the cursor (can be ambiguous but
+        // rarely so in practice) so that gf on quoted/braced path works (not sure about this
+        // but apparently that is how gf has worked historically in helix)
+        let path = find_paths(search_range, true)
+            .take_while(|range| search_start + range.start <= pos + 1)
+            .find(|range| pos <= search_start + range.end)
+            .map(|range| Cow::from(search_range.byte_slice(range)));
+        log::debug!("goto_file auto-detected path: {path:?}");
+        let path = path.unwrap_or_else(|| primary.fragment(text));
+        vec![path.into_owned()]
     } else {
         // Otherwise use each selection, trimmed.
         selections
-            .fragments(text.slice(..))
-            .map(|sel| sel.trim().to_string())
+            .fragments(text)
+            .map(|sel| sel.trim().to_owned())
             .filter(|sel| !sel.is_empty())
             .collect()
     };
@@ -1329,7 +1338,7 @@ fn goto_file_impl(cx: &mut Context, action: Action) {
             continue;
         }
 
-        let path = expand_tilde(Cow::from(PathBuf::from(sel)));
+        let path = path::expand(&sel);
         let path = &rel_path.join(path);
         if path.is_dir() {
             let picker = ui::file_picker(path.into(), &cx.editor.config());
@@ -1680,10 +1689,12 @@ fn replace(cx: &mut Context) {
         if let Some(ch) = ch {
             let transaction = Transaction::change_by_selection(doc.text(), selection, |range| {
                 if !range.is_empty() {
-                    let text: Tendril =
-                        RopeGraphemes::new(doc.text().slice(range.from()..range.to()))
-                            .map(|_g| ch)
-                            .collect();
+                    let text: Tendril = doc
+                        .text()
+                        .slice(range.from()..range.to())
+                        .graphemes()
+                        .map(|_g| ch)
+                        .collect();
                     (range.from(), range.to(), Some(text))
                 } else {
                     // No change.
@@ -2186,7 +2197,7 @@ fn searcher(cx: &mut Context, direction: Direction) {
             completions
                 .iter()
                 .filter(|comp| comp.starts_with(input))
-                .map(|comp| (0.., std::borrow::Cow::Owned(comp.clone())))
+                .map(|comp| (0.., comp.clone().into()))
                 .collect()
         },
         move |cx, regex, event| {
@@ -2265,14 +2276,59 @@ fn extend_search_prev(cx: &mut Context) {
 }
 
 fn search_selection(cx: &mut Context) {
+    search_selection_impl(cx, false)
+}
+
+fn search_selection_detect_word_boundaries(cx: &mut Context) {
+    search_selection_impl(cx, true)
+}
+
+fn search_selection_impl(cx: &mut Context, detect_word_boundaries: bool) {
+    fn is_at_word_start(text: RopeSlice, index: usize) -> bool {
+        // This can happen when the cursor is at the last character in
+        // the document +1 (ge + j), in this case text.char(index) will panic as
+        // it will index out of bounds. See https://github.com/helix-editor/helix/issues/12609
+        if index == text.len_chars() {
+            return false;
+        }
+        let ch = text.char(index);
+        if index == 0 {
+            return char_is_word(ch);
+        }
+        let prev_ch = text.char(index - 1);
+
+        !char_is_word(prev_ch) && char_is_word(ch)
+    }
+
+    fn is_at_word_end(text: RopeSlice, index: usize) -> bool {
+        if index == 0 || index == text.len_chars() {
+            return false;
+        }
+        let ch = text.char(index);
+        let prev_ch = text.char(index - 1);
+
+        char_is_word(prev_ch) && !char_is_word(ch)
+    }
+
     let register = cx.register.unwrap_or('/');
     let (view, doc) = current!(cx.editor);
-    let contents = doc.text().slice(..);
+    let text = doc.text().slice(..);
 
     let regex = doc
         .selection(view.id)
         .iter()
-        .map(|selection| regex::escape(&selection.fragment(contents)))
+        .map(|selection| {
+            let add_boundary_prefix =
+                detect_word_boundaries && is_at_word_start(text, selection.from());
+            let add_boundary_suffix =
+                detect_word_boundaries && is_at_word_end(text, selection.to());
+
+            let prefix = if add_boundary_prefix { "\\b" } else { "" };
+            let suffix = if add_boundary_suffix { "\\b" } else { "" };
+
+            let word = regex::escape(&selection.fragment(text));
+            format!("{}{}{}", prefix, word, suffix)
+        })
         .collect::<HashSet<_>>() // Collect into hashset to deduplicate identical regexes
         .into_iter()
         .collect::<Vec<_>>()
@@ -2451,7 +2507,7 @@ struct GlobalSearchConfig {
                         let doc = documents.iter().find(|&(doc_path, _)| {
                             doc_path
                                 .as_ref()
-                                .map_or(false, |doc_path| doc_path == entry.path())
+                                .is_some_and(|doc_path| doc_path == entry.path())
                         });
 
                         let result = if let Some((_, doc)) = doc {
@@ -2459,7 +2515,7 @@ struct GlobalSearchConfig {
                             // search the buffer instead of the file because it's faster
                             // and captures new edits without requiring a save
                             if searcher.multi_line_with_matcher(&matcher) {
-                                // in this case a continous buffer is required
+                                // in this case a continuous buffer is required
                                 // convert the rope to a string
                                 let text = doc.to_string();
                                 searcher.search_slice(&matcher, text.as_bytes(), sink)
@@ -2735,7 +2791,9 @@ fn delete_selection_impl(cx: &mut Context, op: Operation, yank: YankAction) {
         // yank the selection
         let text = doc.text().slice(..);
         let values: Vec<String> = selection.fragments(text).map(Cow::into_owned).collect();
-        let reg_name = cx.register.unwrap_or('"');
+        let reg_name = cx
+            .register
+            .unwrap_or_else(|| cx.editor.config.load().default_yank_register);
         if let Err(err) = cx.editor.registers.write(reg_name, values) {
             cx.editor.set_error(err.to_string());
             return;
@@ -2754,7 +2812,7 @@ fn delete_selection_impl(cx: &mut Context, op: Operation, yank: YankAction) {
         }
         Operation::Change => {
             if only_whole_lines {
-                open_above(cx);
+                open(cx, Open::Above, CommentContinuation::Disabled);
             } else {
                 enter_insert_mode(cx);
             }
@@ -2948,6 +3006,58 @@ fn file_picker_in_current_directory(cx: &mut Context) {
     cx.push_layer(Box::new(overlaid(picker)));
 }
 
+fn file_explorer(cx: &mut Context) {
+    let root = find_workspace().0;
+    if !root.exists() {
+        cx.editor.set_error("Workspace directory does not exist");
+        return;
+    }
+
+    if let Ok(picker) = ui::file_explorer(root, cx.editor) {
+        cx.push_layer(Box::new(overlaid(picker)));
+    }
+}
+
+fn file_explorer_in_current_buffer_directory(cx: &mut Context) {
+    let doc_dir = doc!(cx.editor)
+        .path()
+        .and_then(|path| path.parent().map(|path| path.to_path_buf()));
+
+    let path = match doc_dir {
+        Some(path) => path,
+        None => {
+            let cwd = helix_stdx::env::current_working_dir();
+            if !cwd.exists() {
+                cx.editor.set_error(
+                    "Current buffer has no parent and current working directory does not exist",
+                );
+                return;
+            }
+            cx.editor.set_error(
+                "Current buffer has no parent, opening file explorer in current working directory",
+            );
+            cwd
+        }
+    };
+
+    if let Ok(picker) = ui::file_explorer(path, cx.editor) {
+        cx.push_layer(Box::new(overlaid(picker)));
+    }
+}
+
+fn file_explorer_in_current_directory(cx: &mut Context) {
+    let cwd = helix_stdx::env::current_working_dir();
+    if !cwd.exists() {
+        cx.editor
+            .set_error("Current working directory does not exist");
+        return;
+    }
+
+    if let Ok(picker) = ui::file_explorer(cwd, cx.editor) {
+        cx.push_layer(Box::new(overlaid(picker)));
+    }
+}
+
 fn buffer_picker(cx: &mut Context) {
     let current = view!(cx.editor).doc;
 
@@ -3006,12 +3116,11 @@ struct BufferMeta {
     })
     .with_preview(|editor, meta| {
         let doc = &editor.documents.get(&meta.id)?;
-        let &view_id = doc.selections().keys().next()?;
-        let line = doc
-            .selection(view_id)
-            .primary()
-            .cursor_line(doc.text().slice(..));
-        Some((meta.id.into(), Some((line, line))))
+        let lines = doc.selections().values().next().map(|selection| {
+            let cursor_line = selection.primary().cursor_line(doc.text().slice(..));
+            (cursor_line, cursor_line)
+        });
+        Some((meta.id.into(), lines))
     });
     cx.push_layer(Box::new(overlaid(picker)));
 }
@@ -3401,14 +3510,23 @@ async fn make_format_callback(
         let doc = doc_mut!(editor, &doc_id);
         let view = view_mut!(editor, view_id);
 
-        if let Ok(format) = format {
-            if doc.version() == doc_version {
-                doc.apply(&format, view.id);
-                doc.append_changes_to_history(view);
-                doc.detect_indent_and_line_ending();
-                view.ensure_cursor_in_view(doc, scrolloff);
-            } else {
-                log::info!("discarded formatting changes because the document changed");
+        match format {
+            Ok(format) => {
+                if doc.version() == doc_version {
+                    doc.apply(&format, view.id);
+                    doc.append_changes_to_history(view);
+                    doc.detect_indent_and_line_ending();
+                    view.ensure_cursor_in_view(doc, scrolloff);
+                } else {
+                    log::info!("discarded formatting changes because the document changed");
+                }
+            }
+            Err(err) => {
+                if write.is_none() {
+                    editor.set_error(err.to_string());
+                    return;
+                }
+                log::info!("failed to format '{}': {err}", doc.display_name());
             }
         }
 
@@ -3429,74 +3547,122 @@ pub enum Open {
     Above,
 }
 
-fn open(cx: &mut Context, open: Open) {
+#[derive(PartialEq)]
+pub enum CommentContinuation {
+    Enabled,
+    Disabled,
+}
+
+fn open(cx: &mut Context, open: Open, comment_continuation: CommentContinuation) {
     let count = cx.count();
     enter_insert_mode(cx);
+    let config = cx.editor.config();
     let (view, doc) = current!(cx.editor);
 
     let text = doc.text().slice(..);
     let contents = doc.text();
     let selection = doc.selection(view.id);
+    let mut offs = 0;
 
     let mut ranges = SmallVec::with_capacity(selection.len());
-    let mut offs = 0;
+
+    let continue_comment_tokens =
+        if comment_continuation == CommentContinuation::Enabled && config.continue_comments {
+            doc.language_config()
+                .and_then(|config| config.comment_tokens.as_ref())
+        } else {
+            None
+        };
 
     let mut transaction = Transaction::change_by_selection(contents, selection, |range| {
-        let cursor_line = text.char_to_line(match open {
+        // the line number, where the cursor is currently
+        let curr_line_num = text.char_to_line(match open {
             Open::Below => graphemes::prev_grapheme_boundary(text, range.to()),
             Open::Above => range.from(),
         });
 
-        let new_line = match open {
-            // adjust position to the end of the line (next line - 1)
-            Open::Below => cursor_line + 1,
-            // adjust position to the end of the previous line (current line - 1)
-            Open::Above => cursor_line,
+        // the next line number, where the cursor will be, after finishing the transaction
+        let next_new_line_num = match open {
+            Open::Below => curr_line_num + 1,
+            Open::Above => curr_line_num,
         };
 
-        let line_num = new_line.saturating_sub(1);
+        let above_next_new_line_num = next_new_line_num.saturating_sub(1);
+
+        let continue_comment_token = continue_comment_tokens
+            .and_then(|tokens| comment::get_comment_token(text, tokens, curr_line_num));
 
         // Index to insert newlines after, as well as the char width
         // to use to compensate for those inserted newlines.
-        let (line_end_index, line_end_offset_width) = if new_line == 0 {
+        let (above_next_line_end_index, above_next_line_end_width) = if next_new_line_num == 0 {
             (0, 0)
         } else {
             (
-                line_end_char_index(&text, line_num),
+                line_end_char_index(&text, above_next_new_line_num),
                 doc.line_ending.len_chars(),
             )
         };
 
-        let indent = indent::indent_for_newline(
-            doc.language_config(),
-            doc.syntax(),
-            &doc.config.load().indent_heuristic,
-            &doc.indent_style,
-            doc.tab_width(),
-            text,
-            line_num,
-            line_end_index,
-            cursor_line,
-        );
+        let line = text.line(curr_line_num);
+        let indent = match line.first_non_whitespace_char() {
+            Some(pos) if continue_comment_token.is_some() => line.slice(..pos).to_string(),
+            _ => indent::indent_for_newline(
+                doc.language_config(),
+                doc.syntax(),
+                &config.indent_heuristic,
+                &doc.indent_style,
+                doc.tab_width(),
+                text,
+                above_next_new_line_num,
+                above_next_line_end_index,
+                curr_line_num,
+            ),
+        };
 
         let indent_len = indent.len();
         let mut text = String::with_capacity(1 + indent_len);
-        text.push_str(doc.line_ending.as_str());
-        text.push_str(&indent);
+
+        if open == Open::Above && next_new_line_num == 0 {
+            text.push_str(&indent);
+            if let Some(token) = continue_comment_token {
+                text.push_str(token);
+                text.push(' ');
+            }
+            text.push_str(doc.line_ending.as_str());
+        } else {
+            text.push_str(doc.line_ending.as_str());
+            text.push_str(&indent);
+
+            if let Some(token) = continue_comment_token {
+                text.push_str(token);
+                text.push(' ');
+            }
+        }
+
         let text = text.repeat(count);
 
         // calculate new selection ranges
-        let pos = offs + line_end_index + line_end_offset_width;
+        let pos = offs + above_next_line_end_index + above_next_line_end_width;
+        let comment_len = continue_comment_token
+            .map(|token| token.len() + 1) // `+ 1` for the extra space added
+            .unwrap_or_default();
         for i in 0..count {
             // pos                    -> beginning of reference line,
-            // + (i * (1+indent_len)) -> beginning of i'th line from pos
-            // + indent_len ->        -> indent for i'th line
-            ranges.push(Range::point(pos + (i * (1 + indent_len)) + indent_len));
+            // + (i * (1+indent_len + comment_len)) -> beginning of i'th line from pos (possibly including comment token)
+            // + indent_len + comment_len ->        -> indent for i'th line
+            ranges.push(Range::point(
+                pos + (i * (1 + indent_len + comment_len)) + indent_len + comment_len,
+            ));
         }
 
+        // update the offset for the next range
         offs += text.chars().count();
 
-        (line_end_index, line_end_index, Some(text.into()))
+        (
+            above_next_line_end_index,
+            above_next_line_end_index,
+            Some(text.into()),
+        )
     });
 
     transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
@@ -3506,12 +3672,12 @@ fn open(cx: &mut Context, open: Open) {
 
 // o inserts a new line after each line with a selection
 fn open_below(cx: &mut Context) {
-    open(cx, Open::Below)
+    open(cx, Open::Below, CommentContinuation::Enabled)
 }
 
 // O inserts a new line before each line with a selection
 fn open_above(cx: &mut Context) {
-    open(cx, Open::Above)
+    open(cx, Open::Above, CommentContinuation::Enabled)
 }
 
 fn normal_mode(cx: &mut Context) {
@@ -3670,8 +3836,7 @@ fn goto_next_diag(cx: &mut Context) {
         let diag = doc
             .diagnostics()
             .iter()
-            .find(|diag| diag.range.start > cursor_pos)
-            .or_else(|| doc.diagnostics().first());
+            .find(|diag| diag.range.start > cursor_pos);
 
         let selection = match diag {
             Some(diag) => Selection::single(diag.range.start, diag.range.end),
@@ -3698,8 +3863,7 @@ fn goto_prev_diag(cx: &mut Context) {
             .diagnostics()
             .iter()
             .rev()
-            .find(|diag| diag.range.start < cursor_pos)
-            .or_else(|| doc.diagnostics().last());
+            .find(|diag| diag.range.start < cursor_pos);
 
         let selection = match diag {
             // NOTE: the selection is reversed because we're jumping to the
@@ -3878,7 +4042,11 @@ pub fn smart_tab(cx: &mut Context) {
             });
 
             if !cursors_after_whitespace {
-                move_parent_node_end(cx);
+                if doc.active_snippet.is_some() {
+                    goto_next_tabstop(cx);
+                } else {
+                    move_parent_node_end(cx);
+                }
                 return;
             }
         }
@@ -3901,17 +4069,29 @@ pub fn insert_tab(cx: &mut Context) {
     }
 
     pub fn insert_newline(cx: &mut Context) {
+        let config = cx.editor.config();
         let (view, doc) = current_ref!(cx.editor);
         let text = doc.text().slice(..);
+        let line_ending = doc.line_ending.as_str();
 
         let contents = doc.text();
-        let selection = doc.selection(view.id).clone();
+        let selection = doc.selection(view.id);
         let mut ranges = SmallVec::with_capacity(selection.len());
 
         // TODO: this is annoying, but we need to do it to properly calculate pos after edits
         let mut global_offs = 0;
+        let mut new_text = String::new();
 
-        let mut transaction = Transaction::change_by_selection(contents, &selection, |range| {
+        let continue_comment_tokens = if config.continue_comments {
+            doc.language_config()
+                .and_then(|config| config.comment_tokens.as_ref())
+        } else {
+            None
+        };
+
+        let mut transaction = Transaction::change_by_selection(contents, selection, |range| {
+            // Tracks the number of trailing whitespace characters deleted by this selection.
+            let mut chars_deleted = 0;
             let pos = range.cursor(text);
 
             let prev = if pos == 0 {
@@ -3922,33 +4102,31 @@ pub fn insert_newline(cx: &mut Context) {
             let curr = contents.get_char(pos).unwrap_or(' ');
 
             let current_line = text.char_to_line(pos);
-            let line_is_only_whitespace = text
-                .line(current_line)
-                .chars()
-                .all(|char| char.is_ascii_whitespace());
-
-            let mut new_text = String::new();
+            let line_start = text.line_to_char(current_line);
 
-            // If the current line is all whitespace, insert a line ending at the beginning of
-            // the current line. This makes the current line empty and the new line contain the
-            // indentation of the old line.
-            let (from, to, local_offs) = if line_is_only_whitespace {
-                let line_start = text.line_to_char(current_line);
-                new_text.push_str(doc.line_ending.as_str());
+            let continue_comment_token = continue_comment_tokens
+                .and_then(|tokens| comment::get_comment_token(text, tokens, current_line));
 
-                (line_start, line_start, new_text.chars().count())
-            } else {
-                let indent = indent::indent_for_newline(
-                    doc.language_config(),
-                    doc.syntax(),
-                    &doc.config.load().indent_heuristic,
-                    &doc.indent_style,
-                    doc.tab_width(),
-                    text,
-                    current_line,
-                    pos,
-                    current_line,
-                );
+            let (from, to, local_offs) = if let Some(idx) =
+                text.slice(line_start..pos).last_non_whitespace_char()
+            {
+                let first_trailing_whitespace_char = (line_start + idx + 1).min(pos);
+                let line = text.line(current_line);
+
+                let indent = match line.first_non_whitespace_char() {
+                    Some(pos) if continue_comment_token.is_some() => line.slice(..pos).to_string(),
+                    _ => indent::indent_for_newline(
+                        doc.language_config(),
+                        doc.syntax(),
+                        &config.indent_heuristic,
+                        &doc.indent_style,
+                        doc.tab_width(),
+                        text,
+                        current_line,
+                        pos,
+                        current_line,
+                    ),
+                };
 
                 // If we are between pairs (such as brackets), we want to
                 // insert an additional line which is indented one level
@@ -3956,38 +4134,66 @@ pub fn insert_newline(cx: &mut Context) {
                 let on_auto_pair = doc
                     .auto_pairs(cx.editor)
                     .and_then(|pairs| pairs.get(prev))
-                    .map_or(false, |pair| pair.open == prev && pair.close == curr);
+                    .is_some_and(|pair| pair.open == prev && pair.close == curr);
 
-                let local_offs = if on_auto_pair {
+                let local_offs = if let Some(token) = continue_comment_token {
+                    new_text.reserve_exact(line_ending.len() + indent.len() + token.len() + 1);
+                    new_text.push_str(line_ending);
+                    new_text.push_str(&indent);
+                    new_text.push_str(token);
+                    new_text.push(' ');
+                    new_text.chars().count()
+                } else if on_auto_pair {
+                    // line where the cursor will be
                     let inner_indent = indent.clone() + doc.indent_style.as_str();
-                    new_text.reserve_exact(2 + indent.len() + inner_indent.len());
-                    new_text.push_str(doc.line_ending.as_str());
+                    new_text
+                        .reserve_exact(line_ending.len() * 2 + indent.len() + inner_indent.len());
+                    new_text.push_str(line_ending);
                     new_text.push_str(&inner_indent);
+
+                    // line where the matching pair will be
                     let local_offs = new_text.chars().count();
-                    new_text.push_str(doc.line_ending.as_str());
+                    new_text.push_str(line_ending);
                     new_text.push_str(&indent);
+
                     local_offs
                 } else {
-                    new_text.reserve_exact(1 + indent.len());
-                    new_text.push_str(doc.line_ending.as_str());
+                    new_text.reserve_exact(line_ending.len() + indent.len());
+                    new_text.push_str(line_ending);
                     new_text.push_str(&indent);
+
                     new_text.chars().count()
                 };
 
-                (pos, pos, local_offs)
+                // Note that `first_trailing_whitespace_char` is at least `pos` so this unsigned
+                // subtraction cannot underflow.
+                chars_deleted = pos - first_trailing_whitespace_char;
+
+                (
+                    first_trailing_whitespace_char,
+                    pos,
+                    local_offs as isize - chars_deleted as isize,
+                )
+            } else {
+                // If the current line is all whitespace, insert a line ending at the beginning of
+                // the current line. This makes the current line empty and the new line contain the
+                // indentation of the old line.
+                new_text.push_str(line_ending);
+
+                (line_start, line_start, new_text.chars().count() as isize)
             };
 
             let new_range = if range.cursor(text) > range.anchor {
                 // when appending, extend the range by local_offs
                 Range::new(
-                    range.anchor + global_offs,
-                    range.head + local_offs + global_offs,
+                    (range.anchor as isize + global_offs) as usize,
+                    (range.head as isize + local_offs + global_offs) as usize,
                 )
             } else {
                 // when inserting, slide the range by local_offs
                 Range::new(
-                    range.anchor + local_offs + global_offs,
-                    range.head + local_offs + global_offs,
+                    (range.anchor as isize + local_offs + global_offs) as usize,
+                    (range.head as isize + local_offs + global_offs) as usize,
                 )
             };
 
@@ -3995,9 +4201,11 @@ pub fn insert_newline(cx: &mut Context) {
             // range.replace(|range| range.is_empty(), head); -> fn extend if cond true, new head pos
             // can be used with cx.mode to do replace or extend on most changes
             ranges.push(new_range);
-            global_offs += new_text.chars().count();
+            global_offs += new_text.chars().count() as isize - chars_deleted as isize;
+            let tendril = Tendril::from(&new_text);
+            new_text.clear();
 
-            (from, to, Some(new_text.into()))
+            (from, to, Some(tendril))
         });
 
         transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
@@ -4180,7 +4388,11 @@ fn commit_undo_checkpoint(cx: &mut Context) {
 // Yank / Paste
 
 fn yank(cx: &mut Context) {
-    yank_impl(cx.editor, cx.register.unwrap_or('"'));
+    yank_impl(
+        cx.editor,
+        cx.register
+            .unwrap_or(cx.editor.config().default_yank_register),
+    );
     exit_select_mode(cx);
 }
 
@@ -4241,7 +4453,12 @@ fn yank_joined_impl(editor: &mut Editor, separator: &str, register: char) {
 
 fn yank_joined(cx: &mut Context) {
     let separator = doc!(cx.editor).line_ending.as_str();
-    yank_joined_impl(cx.editor, separator, cx.register.unwrap_or('"'));
+    yank_joined_impl(
+        cx.editor,
+        separator,
+        cx.register
+            .unwrap_or(cx.editor.config().default_yank_register),
+    );
     exit_select_mode(cx);
 }
 
@@ -4286,6 +4503,8 @@ enum Paste {
     Cursor,
 }
 
+static LINE_ENDING_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"\r\n|\r|\n").unwrap());
+
 fn paste_impl(
     values: &[String],
     doc: &mut Document,
@@ -4298,26 +4517,30 @@ fn paste_impl(
         return;
     }
 
-    let repeat = std::iter::repeat(
-        // `values` is asserted to have at least one entry above.
-        values
-            .last()
-            .map(|value| Tendril::from(value.repeat(count)))
-            .unwrap(),
-    );
+    if mode == Mode::Insert {
+        doc.append_changes_to_history(view);
+    }
 
     // if any of values ends with a line ending, it's linewise paste
     let linewise = values
         .iter()
         .any(|value| get_line_ending_of_str(value).is_some());
 
-    // Only compiled once.
-    static REGEX: Lazy<Regex> = Lazy::new(|| Regex::new(r"\r\n|\r|\n").unwrap());
-    let mut values = values
-        .iter()
-        .map(|value| REGEX.replace_all(value, doc.line_ending.as_str()))
-        .map(|value| Tendril::from(value.as_ref().repeat(count)))
-        .chain(repeat);
+    let map_value = |value| {
+        let value = LINE_ENDING_REGEX.replace_all(value, doc.line_ending.as_str());
+        let mut out = Tendril::from(value.as_ref());
+        for _ in 1..count {
+            out.push_str(&value);
+        }
+        out
+    };
+
+    let repeat = std::iter::repeat(
+        // `values` is asserted to have at least one entry above.
+        map_value(values.last().unwrap()),
+    );
+
+    let mut values = values.iter().map(|value| map_value(value)).chain(repeat);
 
     let text = doc.text();
     let selection = doc.selection(view.id);
@@ -4397,7 +4620,12 @@ fn paste_primary_clipboard_before(cx: &mut Context) {
 }
 
 fn replace_with_yanked(cx: &mut Context) {
-    replace_with_yanked_impl(cx.editor, cx.register.unwrap_or('"'), cx.count());
+    replace_with_yanked_impl(
+        cx.editor,
+        cx.register
+            .unwrap_or(cx.editor.config().default_yank_register),
+        cx.count(),
+    );
     exit_select_mode(cx);
 }
 
@@ -4409,19 +4637,24 @@ fn replace_with_yanked_impl(editor: &mut Editor, register: char, count: usize) {
     else {
         return;
     };
-    let values: Vec<_> = values.map(|value| value.to_string()).collect();
     let scrolloff = editor.config().scrolloff;
+    let (view, doc) = current_ref!(editor);
 
-    let (view, doc) = current!(editor);
-    let repeat = std::iter::repeat(
-        values
-            .last()
-            .map(|value| Tendril::from(&value.repeat(count)))
-            .unwrap(),
-    );
-    let mut values = values
-        .iter()
-        .map(|value| Tendril::from(&value.repeat(count)))
+    let map_value = |value: &Cow<str>| {
+        let value = LINE_ENDING_REGEX.replace_all(value, doc.line_ending.as_str());
+        let mut out = Tendril::from(value.as_ref());
+        for _ in 1..count {
+            out.push_str(&value);
+        }
+        out
+    };
+    let mut values_rev = values.rev().peekable();
+    // `values` is asserted to have at least one entry above.
+    let last = values_rev.peek().unwrap();
+    let repeat = std::iter::repeat(map_value(last));
+    let mut values = values_rev
+        .rev()
+        .map(|value| map_value(&value))
         .chain(repeat);
     let selection = doc.selection(view.id);
     let transaction = Transaction::change_by_selection(doc.text(), selection, |range| {
@@ -4431,7 +4664,9 @@ fn replace_with_yanked_impl(editor: &mut Editor, register: char, count: usize) {
             (range.from(), range.to(), None)
         }
     });
+    drop(values);
 
+    let (view, doc) = current!(editor);
     doc.apply(&transaction, view.id);
     doc.append_changes_to_history(view);
     view.ensure_cursor_in_view(doc, scrolloff);
@@ -4460,7 +4695,8 @@ fn paste(editor: &mut Editor, register: char, pos: Paste, count: usize) {
 fn paste_after(cx: &mut Context) {
     paste(
         cx.editor,
-        cx.register.unwrap_or('"'),
+        cx.register
+            .unwrap_or(cx.editor.config().default_yank_register),
         Paste::After,
         cx.count(),
     );
@@ -4470,7 +4706,8 @@ fn paste_after(cx: &mut Context) {
 fn paste_before(cx: &mut Context) {
     paste(
         cx.editor,
-        cx.register.unwrap_or('"'),
+        cx.register
+            .unwrap_or(cx.editor.config().default_yank_register),
         Paste::Before,
         cx.count(),
     );
@@ -4626,6 +4863,14 @@ fn join_selections_impl(cx: &mut Context, select_space: bool) {
     let text = doc.text();
     let slice = text.slice(..);
 
+    let comment_tokens = doc
+        .language_config()
+        .and_then(|config| config.comment_tokens.as_deref())
+        .unwrap_or(&[]);
+    // Sort by length to handle Rust's /// vs //
+    let mut comment_tokens: Vec<&str> = comment_tokens.iter().map(|x| x.as_str()).collect();
+    comment_tokens.sort_unstable_by_key(|x| std::cmp::Reverse(x.len()));
+
     let mut changes = Vec::new();
 
     for selection in doc.selection(view.id) {
@@ -4637,10 +4882,31 @@ fn join_selections_impl(cx: &mut Context, select_space: bool) {
 
         changes.reserve(lines.len());
 
+        let first_line_idx = slice.line_to_char(start);
+        let first_line_idx = skip_while(slice, first_line_idx, |ch| matches!(ch, ' ' | '\t'))
+            .unwrap_or(first_line_idx);
+        let first_line = slice.slice(first_line_idx..);
+        let mut current_comment_token = comment_tokens
+            .iter()
+            .find(|token| first_line.starts_with(token));
+
         for line in lines {
             let start = line_end_char_index(&slice, line);
             let mut end = text.line_to_char(line + 1);
             end = skip_while(slice, end, |ch| matches!(ch, ' ' | '\t')).unwrap_or(end);
+            let slice_from_end = slice.slice(end..);
+            if let Some(token) = comment_tokens
+                .iter()
+                .find(|token| slice_from_end.starts_with(token))
+            {
+                if Some(token) == current_comment_token {
+                    end += token.chars().count();
+                    end = skip_while(slice, end, |ch| matches!(ch, ' ' | '\t')).unwrap_or(end);
+                } else {
+                    // update current token, but don't delete this one.
+                    current_comment_token = Some(token);
+                }
+            }
 
             let separator = if end == line_end_char_index(&slice, line + 1) {
                 // the joining line contains only space-characters => don't include a whitespace when joining
@@ -5280,8 +5546,8 @@ fn wonly(cx: &mut Context) {
 fn select_register(cx: &mut Context) {
     cx.editor.autoinfo = Some(Info::from_registers(&cx.editor.registers));
     cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
         if let Some(ch) = event.char() {
-            cx.editor.autoinfo = None;
             cx.editor.selected_register = Some(ch);
         }
     })
@@ -5290,12 +5556,13 @@ fn select_register(cx: &mut Context) {
 fn insert_register(cx: &mut Context) {
     cx.editor.autoinfo = Some(Info::from_registers(&cx.editor.registers));
     cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
         if let Some(ch) = event.char() {
-            cx.editor.autoinfo = None;
             cx.register = Some(ch);
             paste(
                 cx.editor,
-                cx.register.unwrap_or('"'),
+                cx.register
+                    .unwrap_or(cx.editor.config().default_yank_register),
                 Paste::Cursor,
                 cx.count(),
             );
@@ -5303,6 +5570,41 @@ fn insert_register(cx: &mut Context) {
     })
 }
 
+fn copy_between_registers(cx: &mut Context) {
+    cx.editor.autoinfo = Some(Info::from_registers(&cx.editor.registers));
+    cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
+
+        let Some(source) = event.char() else {
+            return;
+        };
+
+        let Some(values) = cx.editor.registers.read(source, cx.editor) else {
+            cx.editor.set_error(format!("register {source} is empty"));
+            return;
+        };
+        let values: Vec<_> = values.map(|value| value.to_string()).collect();
+
+        cx.editor.autoinfo = Some(Info::from_registers(&cx.editor.registers));
+        cx.on_next_key(move |cx, event| {
+            cx.editor.autoinfo = None;
+
+            let Some(dest) = event.char() else {
+                return;
+            };
+
+            let n_values = values.len();
+            match cx.editor.registers.write(dest, values) {
+                Ok(_) => cx.editor.set_status(format!(
+                    "yanked {n_values} value{} from register {source} to {dest}",
+                    if n_values == 1 { "" } else { "s" }
+                )),
+                Err(err) => cx.editor.set_error(err.to_string()),
+            }
+        });
+    });
+}
+
 fn align_view_top(cx: &mut Context) {
     let (view, doc) = current!(cx.editor);
     align_view(doc, view, Align::Top);
@@ -5555,8 +5857,18 @@ fn select_textobject(cx: &mut Context, objtype: textobject::TextObject) {
     cx.editor.autoinfo = Some(Info::new(title, &help_text));
 }
 
+static SURROUND_HELP_TEXT: [(&str, &str); 6] = [
+    ("m", "Nearest matching pair"),
+    ("( or )", "Parentheses"),
+    ("{ or }", "Curly braces"),
+    ("< or >", "Angled brackets"),
+    ("[ or ]", "Square brackets"),
+    (" ", "... or any character"),
+];
+
 fn surround_add(cx: &mut Context) {
     cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
         let (view, doc) = current!(cx.editor);
         // surround_len is the number of new characters being added.
         let (open, close, surround_len) = match event.char() {
@@ -5597,12 +5909,18 @@ fn surround_add(cx: &mut Context) {
             .with_selection(Selection::new(ranges, selection.primary_index()));
         doc.apply(&transaction, view.id);
         exit_select_mode(cx);
-    })
+    });
+
+    cx.editor.autoinfo = Some(Info::new(
+        "Surround selections with",
+        &SURROUND_HELP_TEXT[1..],
+    ));
 }
 
 fn surround_replace(cx: &mut Context) {
     let count = cx.count();
     cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
         let surround_ch = match event.char() {
             Some('m') => None, // m selects the closest surround pair
             Some(ch) => Some(ch),
@@ -5629,6 +5947,7 @@ fn surround_replace(cx: &mut Context) {
         );
 
         cx.on_next_key(move |cx, event| {
+            cx.editor.autoinfo = None;
             let (view, doc) = current!(cx.editor);
             let to = match event.char() {
                 Some(to) => to,
@@ -5656,12 +5975,23 @@ fn surround_replace(cx: &mut Context) {
             doc.apply(&transaction, view.id);
             exit_select_mode(cx);
         });
-    })
+
+        cx.editor.autoinfo = Some(Info::new(
+            "Replace with a pair of",
+            &SURROUND_HELP_TEXT[1..],
+        ));
+    });
+
+    cx.editor.autoinfo = Some(Info::new(
+        "Replace surrounding pair of",
+        &SURROUND_HELP_TEXT,
+    ));
 }
 
 fn surround_delete(cx: &mut Context) {
     let count = cx.count();
     cx.on_next_key(move |cx, event| {
+        cx.editor.autoinfo = None;
         let surround_ch = match event.char() {
             Some('m') => None, // m selects the closest surround pair
             Some(ch) => Some(ch),
@@ -5684,7 +6014,9 @@ fn surround_delete(cx: &mut Context) {
             Transaction::change(doc.text(), change_pos.into_iter().map(|p| (p, p + 1, None)));
         doc.apply(&transaction, view.id);
         exit_select_mode(cx);
-    })
+    });
+
+    cx.editor.autoinfo = Some(Info::new("Delete surrounding pair of", &SURROUND_HELP_TEXT));
 }
 
 #[derive(Eq, PartialEq)]
@@ -5851,7 +6183,7 @@ fn shell(cx: &mut compositor::Context, cmd: &str, behavior: &ShellBehavior) {
             let input = range.slice(text);
             match shell_impl(shell, cmd, pipe.then(|| input.into())) {
                 Ok(mut output) => {
-                    if !input.ends_with("\n") && !output.is_empty() && output.ends_with('\n') {
+                    if !input.ends_with("\n") && output.ends_with('\n') {
                         output.pop();
                         if output.ends_with('\r') {
                             output.pop();
@@ -6037,6 +6369,47 @@ fn increment_impl(cx: &mut Context, increment_direction: IncrementDirection) {
     }
 }
 
+fn goto_next_tabstop(cx: &mut Context) {
+    goto_next_tabstop_impl(cx, Direction::Forward)
+}
+
+fn goto_prev_tabstop(cx: &mut Context) {
+    goto_next_tabstop_impl(cx, Direction::Backward)
+}
+
+fn goto_next_tabstop_impl(cx: &mut Context, direction: Direction) {
+    let (view, doc) = current!(cx.editor);
+    let view_id = view.id;
+    let Some(mut snippet) = doc.active_snippet.take() else {
+        cx.editor.set_error("no snippet is currently active");
+        return;
+    };
+    let tabstop = match direction {
+        Direction::Forward => Some(snippet.next_tabstop(doc.selection(view_id))),
+        Direction::Backward => snippet
+            .prev_tabstop(doc.selection(view_id))
+            .map(|selection| (selection, false)),
+    };
+    let Some((selection, last_tabstop)) = tabstop else {
+        return;
+    };
+    doc.set_selection(view_id, selection);
+    if !last_tabstop {
+        doc.active_snippet = Some(snippet)
+    }
+    if cx.editor.mode() == Mode::Insert {
+        cx.on_next_key_fallback(|cx, key| {
+            if let Some(c) = key.char() {
+                let (view, doc) = current!(cx.editor);
+                if let Some(snippet) = &doc.active_snippet {
+                    doc.apply(&snippet.delete_placeholder(doc.text()), view.id);
+                }
+                insert_char(cx, c);
+            }
+        })
+    }
+}
+
 fn record_macro(cx: &mut Context) {
     if let Some((reg, mut keys)) = cx.editor.macro_recording.take() {
         // Remove the keypress which ends the recording
@@ -6162,6 +6535,7 @@ fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
         let alphabet = &cx.editor.config().jump_label_alphabet;
         let Some(i) = event
             .char()
+            .filter(|_| event.modifiers.is_empty())
             .and_then(|ch| alphabet.iter().position(|&it| it == ch))
         else {
             doc_mut!(cx.editor, &doc).remove_jump_labels(view);
@@ -6178,6 +6552,7 @@ fn jump_to_label(cx: &mut Context, labels: Vec<Range>, behaviour: Movement) {
             let alphabet = &cx.editor.config().jump_label_alphabet;
             let Some(inner) = event
                 .char()
+                .filter(|_| event.modifiers.is_empty())
                 .and_then(|ch| alphabet.iter().position(|&it| it == ch))
             else {
                 return;
@@ -6229,7 +6604,7 @@ fn jump_to_word(cx: &mut Context, behaviour: Movement) {
     let mut cursor_rev = Range::point(cursor);
     if text.get_char(cursor).is_some_and(|c| !c.is_whitespace()) {
         let cursor_word_end = movement::move_next_word_end(text, cursor_fwd, 1);
-        //  single grapheme words need a specical case
+        //  single grapheme words need a special case
         if cursor_word_end.anchor == cursor {
             cursor_fwd = cursor_word_end;
         }
@@ -6246,7 +6621,9 @@ fn jump_to_word(cx: &mut Context, behaviour: Movement) {
             // madeup of word characters. The latter condition is needed because
             // move_next_word_end simply treats a sequence of characters from
             // the same char class as a word so `=<` would also count as a word.
-            let add_label = RevRopeGraphemes::new(text.slice(..cursor_fwd.head))
+            let add_label = text
+                .slice(..cursor_fwd.head)
+                .graphemes_rev()
                 .take(2)
                 .take_while(|g| g.chars().all(char_is_word))
                 .count()
@@ -6272,7 +6649,9 @@ fn jump_to_word(cx: &mut Context, behaviour: Movement) {
             // madeup of word characters. The latter condition is needed because
             // move_prev_word_start simply treats a sequence of characters from
             // the same char class as a word so `=<` would also count as a word.
-            let add_label = RopeGraphemes::new(text.slice(cursor_rev.head..))
+            let add_label = text
+                .slice(cursor_rev.head..)
+                .graphemes()
                 .take(2)
                 .take_while(|g| g.chars().all(char_is_word))
                 .count()
diff --git a/helix-term/src/commands/dap.rs b/helix-term/src/commands/dap.rs
index 0b754bc21..83dd936cd 100644
--- a/helix-term/src/commands/dap.rs
+++ b/helix-term/src/commands/dap.rs
@@ -518,15 +518,16 @@ pub fn dap_variables(cx: &mut Context) {
         Some(thread_frame) => thread_frame,
         None => {
             cx.editor
-                .set_error("Failed to get stack frame for thread: {thread_id}");
+                .set_error(format!("Failed to get stack frame for thread: {thread_id}"));
             return;
         }
     };
     let stack_frame = match thread_frame.get(frame) {
         Some(stack_frame) => stack_frame,
         None => {
-            cx.editor
-                .set_error("Failed to get stack frame for thread {thread_id} and frame {frame}.");
+            cx.editor.set_error(format!(
+                "Failed to get stack frame for thread {thread_id} and frame {frame}."
+            ));
             return;
         }
     };
diff --git a/helix-term/src/commands/lsp.rs b/helix-term/src/commands/lsp.rs
index 93ac2a849..130428d4d 100644
--- a/helix-term/src/commands/lsp.rs
+++ b/helix-term/src/commands/lsp.rs
@@ -34,7 +34,7 @@
 use std::{
     cmp::Ordering,
     collections::{BTreeMap, HashSet},
-    fmt::{Display, Write},
+    fmt::Display,
     future::Future,
     path::Path,
 };
@@ -61,10 +61,36 @@ macro_rules! language_server_with_feature {
     }};
 }
 
+/// A wrapper around `lsp::Location` that swaps out the LSP URI for `helix_core::Uri` and adds
+/// the server's  offset encoding.
+#[derive(Debug, Clone, PartialEq, Eq)]
+struct Location {
+    uri: Uri,
+    range: lsp::Range,
+    offset_encoding: OffsetEncoding,
+}
+
+fn lsp_location_to_location(
+    location: lsp::Location,
+    offset_encoding: OffsetEncoding,
+) -> Option<Location> {
+    let uri = match location.uri.try_into() {
+        Ok(uri) => uri,
+        Err(err) => {
+            log::warn!("discarding invalid or unsupported URI: {err}");
+            return None;
+        }
+    };
+    Some(Location {
+        uri,
+        range: location.range,
+        offset_encoding,
+    })
+}
+
 struct SymbolInformationItem {
+    location: Location,
     symbol: lsp::SymbolInformation,
-    offset_encoding: OffsetEncoding,
-    uri: Uri,
 }
 
 struct DiagnosticStyles {
@@ -75,35 +101,35 @@ struct DiagnosticStyles {
 }
 
 struct PickerDiagnostic {
-    uri: Uri,
+    location: Location,
     diag: lsp::Diagnostic,
-    offset_encoding: OffsetEncoding,
 }
 
-fn uri_to_file_location<'a>(uri: &'a Uri, range: &lsp::Range) -> Option<FileLocation<'a>> {
-    let path = uri.as_path()?;
-    let line = Some((range.start.line as usize, range.end.line as usize));
+fn location_to_file_location(location: &Location) -> Option<FileLocation> {
+    let path = location.uri.as_path()?;
+    let line = Some((
+        location.range.start.line as usize,
+        location.range.end.line as usize,
+    ));
     Some((path.into(), line))
 }
 
-fn jump_to_location(
-    editor: &mut Editor,
-    location: &lsp::Location,
-    offset_encoding: OffsetEncoding,
-    action: Action,
-) {
+fn jump_to_location(editor: &mut Editor, location: &Location, action: Action) {
     let (view, doc) = current!(editor);
     push_jump(view, doc);
 
-    let path = match location.uri.to_file_path() {
-        Ok(path) => path,
-        Err(_) => {
-            let err = format!("unable to convert URI to filepath: {}", location.uri);
-            editor.set_error(err);
-            return;
-        }
+    let Some(path) = location.uri.as_path() else {
+        let err = format!("unable to convert URI to filepath: {:?}", location.uri);
+        editor.set_error(err);
+        return;
     };
-    jump_to_position(editor, &path, location.range, offset_encoding, action);
+    jump_to_position(
+        editor,
+        path,
+        location.range,
+        location.offset_encoding,
+        action,
+    );
 }
 
 fn jump_to_position(
@@ -196,9 +222,12 @@ fn diag_picker(
         for (diag, ls) in diags {
             if let Some(ls) = cx.editor.language_server_by_id(ls) {
                 flat_diag.push(PickerDiagnostic {
-                    uri: uri.clone(),
+                    location: Location {
+                        uri: uri.clone(),
+                        range: diag.range,
+                        offset_encoding: ls.offset_encoding(),
+                    },
                     diag,
-                    offset_encoding: ls.offset_encoding(),
                 });
             }
         }
@@ -243,7 +272,7 @@ fn diag_picker(
             // between message code and message
             2,
             ui::PickerColumn::new("path", |item: &PickerDiagnostic, _| {
-                if let Some(path) = item.uri.as_path() {
+                if let Some(path) = item.location.uri.as_path() {
                     path::get_truncated_path(path)
                         .to_string_lossy()
                         .to_string()
@@ -261,26 +290,14 @@ fn diag_picker(
         primary_column,
         flat_diag,
         styles,
-        move |cx,
-              PickerDiagnostic {
-                  uri,
-                  diag,
-                  offset_encoding,
-              },
-              action| {
-            let Some(path) = uri.as_path() else {
-                return;
-            };
-            jump_to_position(cx.editor, path, diag.range, *offset_encoding, action);
+        move |cx, diag, action| {
+            jump_to_location(cx.editor, &diag.location, action);
             let (view, doc) = current!(cx.editor);
             view.diagnostics_handler
                 .immediately_show_diagnostic(doc, view.id);
         },
     )
-    .with_preview(move |_editor, PickerDiagnostic { uri, diag, .. }| {
-        let line = Some((diag.range.start.line as usize, diag.range.end.line as usize));
-        Some((uri.as_path()?.into(), line))
-    })
+    .with_preview(move |_editor, diag| location_to_file_location(&diag.location))
     .truncate_start(false)
 }
 
@@ -302,8 +319,11 @@ fn nested_to_flat(
                 location: lsp::Location::new(file.uri.clone(), symbol.selection_range),
                 container_name: None,
             },
-            offset_encoding,
-            uri: uri.clone(),
+            location: Location {
+                uri: uri.clone(),
+                range: symbol.selection_range,
+                offset_encoding,
+            },
         });
         for child in symbol.children.into_iter().flatten() {
             nested_to_flat(list, file, uri, child, offset_encoding);
@@ -337,9 +357,12 @@ fn nested_to_flat(
                     lsp::DocumentSymbolResponse::Flat(symbols) => symbols
                         .into_iter()
                         .map(|symbol| SymbolInformationItem {
-                            uri: doc_uri.clone(),
+                            location: Location {
+                                uri: doc_uri.clone(),
+                                range: symbol.location.range,
+                                offset_encoding,
+                            },
                             symbol,
-                            offset_encoding,
                         })
                         .collect(),
                     lsp::DocumentSymbolResponse::Nested(symbols) => {
@@ -392,17 +415,10 @@ fn nested_to_flat(
                 symbols,
                 (),
                 move |cx, item, action| {
-                    jump_to_location(
-                        cx.editor,
-                        &item.symbol.location,
-                        item.offset_encoding,
-                        action,
-                    );
+                    jump_to_location(cx.editor, &item.location, action);
                 },
             )
-            .with_preview(move |_editor, item| {
-                uri_to_file_location(&item.uri, &item.symbol.location.range)
-            })
+            .with_preview(move |_editor, item| location_to_file_location(&item.location))
             .truncate_start(false);
 
             compositor.push(Box::new(overlaid(picker)))
@@ -453,9 +469,12 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
                                     }
                                 };
                                 Some(SymbolInformationItem {
+                                    location: Location {
+                                        uri,
+                                        range: symbol.location.range,
+                                        offset_encoding,
+                                    },
                                     symbol,
-                                    uri,
-                                    offset_encoding,
                                 })
                             })
                             .collect();
@@ -490,7 +509,7 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
         })
         .without_filtering(),
         ui::PickerColumn::new("path", |item: &SymbolInformationItem, _| {
-            if let Some(path) = item.uri.as_path() {
+            if let Some(path) = item.location.uri.as_path() {
                 path::get_relative_path(path)
                     .to_string_lossy()
                     .to_string()
@@ -507,15 +526,10 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
         [],
         (),
         move |cx, item, action| {
-            jump_to_location(
-                cx.editor,
-                &item.symbol.location,
-                item.offset_encoding,
-                action,
-            );
+            jump_to_location(cx.editor, &item.location, action);
         },
     )
-    .with_preview(|_editor, item| uri_to_file_location(&item.uri, &item.symbol.location.range))
+    .with_preview(|_editor, item| location_to_file_location(&item.location))
     .with_dynamic_query(get_symbols, None)
     .truncate_start(false);
 
@@ -844,124 +858,98 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 }
 
 /// Precondition: `locations` should be non-empty.
-fn goto_impl(
-    editor: &mut Editor,
-    compositor: &mut Compositor,
-    locations: Vec<lsp::Location>,
-    offset_encoding: OffsetEncoding,
-) {
+fn goto_impl(editor: &mut Editor, compositor: &mut Compositor, locations: Vec<Location>) {
     let cwdir = helix_stdx::env::current_working_dir();
 
     match locations.as_slice() {
         [location] => {
-            jump_to_location(editor, location, offset_encoding, Action::Replace);
+            jump_to_location(editor, location, Action::Replace);
         }
         [] => unreachable!("`locations` should be non-empty for `goto_impl`"),
         _locations => {
             let columns = [ui::PickerColumn::new(
                 "location",
-                |item: &lsp::Location, cwdir: &std::path::PathBuf| {
-                    // The preallocation here will overallocate a few characters since it will account for the
-                    // URL's scheme, which is not used most of the time since that scheme will be "file://".
-                    // Those extra chars will be used to avoid allocating when writing the line number (in the
-                    // common case where it has 5 digits or less, which should be enough for a cast majority
-                    // of usages).
-                    let mut res = String::with_capacity(item.uri.as_str().len());
-
-                    if item.uri.scheme() == "file" {
-                        // With the preallocation above and UTF-8 paths already, this closure will do one (1)
-                        // allocation, for `to_file_path`, else there will be two (2), with `to_string_lossy`.
-                        if let Ok(path) = item.uri.to_file_path() {
-                            // We don't convert to a `helix_core::Uri` here because we've already checked the scheme.
-                            // This path won't be normalized but it's only used for display.
-                            res.push_str(
-                                &path.strip_prefix(cwdir).unwrap_or(&path).to_string_lossy(),
-                            );
-                        }
+                |item: &Location, cwdir: &std::path::PathBuf| {
+                    let path = if let Some(path) = item.uri.as_path() {
+                        path.strip_prefix(cwdir).unwrap_or(path).to_string_lossy()
                     } else {
-                        // Never allocates since we declared the string with this capacity already.
-                        res.push_str(item.uri.as_str());
-                    }
+                        item.uri.to_string().into()
+                    };
 
-                    // Most commonly, this will not allocate, especially on Unix systems where the root prefix
-                    // is a simple `/` and not `C:\` (with whatever drive letter)
-                    write!(&mut res, ":{}", item.range.start.line + 1)
-                        .expect("Will only failed if allocating fail");
-                    res.into()
+                    format!("{path}:{}", item.range.start.line + 1).into()
                 },
             )];
 
-            let picker = Picker::new(columns, 0, locations, cwdir, move |cx, location, action| {
-                jump_to_location(cx.editor, location, offset_encoding, action)
+            let picker = Picker::new(columns, 0, locations, cwdir, |cx, location, action| {
+                jump_to_location(cx.editor, location, action)
             })
-            .with_preview(move |_editor, location| {
-                use crate::ui::picker::PathOrId;
-
-                let lines = Some((
-                    location.range.start.line as usize,
-                    location.range.end.line as usize,
-                ));
-
-                // TODO: we should avoid allocating by doing the Uri conversion ahead of time.
-                //
-                // To do this, introduce a `Location` type in `helix-core` that reuses the core
-                // `Uri` type instead of the LSP `Url` type and replaces the LSP `Range` type.
-                // Refactor the callers of `goto_impl` to pass iterators that translate the
-                // LSP location type to the custom one in core, or have them collect and pass
-                // `Vec<Location>`s. Replace the `uri_to_file_location` function with
-                // `location_to_file_location` that takes only `&helix_core::Location` as
-                // parameters.
-                //
-                // By doing this we can also eliminate the duplicated URI info in the
-                // `SymbolInformationItem` type and introduce a custom Symbol type in `helix-core`
-                // which will be reused in the future for tree-sitter based symbol pickers.
-                let path = Uri::try_from(&location.uri).ok()?.as_path_buf()?;
-                #[allow(deprecated)]
-                Some((PathOrId::from_path_buf(path), lines))
-            });
+            .with_preview(|_editor, location| location_to_file_location(location));
             compositor.push(Box::new(overlaid(picker)));
         }
     }
 }
 
-fn to_locations(definitions: Option<lsp::GotoDefinitionResponse>) -> Vec<lsp::Location> {
-    match definitions {
-        Some(lsp::GotoDefinitionResponse::Scalar(location)) => vec![location],
-        Some(lsp::GotoDefinitionResponse::Array(locations)) => locations,
-        Some(lsp::GotoDefinitionResponse::Link(locations)) => locations
-            .into_iter()
-            .map(|location_link| lsp::Location {
-                uri: location_link.target_uri,
-                range: location_link.target_range,
-            })
-            .collect(),
-        None => Vec::new(),
-    }
-}
-
 fn goto_single_impl<P, F>(cx: &mut Context, feature: LanguageServerFeature, request_provider: P)
 where
     P: Fn(&Client, lsp::Position, lsp::TextDocumentIdentifier) -> Option<F>,
     F: Future<Output = helix_lsp::Result<serde_json::Value>> + 'static + Send,
 {
-    let (view, doc) = current!(cx.editor);
-
-    let language_server = language_server_with_feature!(cx.editor, doc, feature);
-    let offset_encoding = language_server.offset_encoding();
-    let pos = doc.position(view.id, offset_encoding);
-    let future = request_provider(language_server, pos, doc.identifier()).unwrap();
+    let (view, doc) = current_ref!(cx.editor);
+    let mut futures: FuturesOrdered<_> = doc
+        .language_servers_with_feature(feature)
+        .map(|language_server| {
+            let offset_encoding = language_server.offset_encoding();
+            let pos = doc.position(view.id, offset_encoding);
+            let future = request_provider(language_server, pos, doc.identifier()).unwrap();
+            async move {
+                let json = future.await?;
+                let response: Option<lsp::GotoDefinitionResponse> = serde_json::from_value(json)?;
+                anyhow::Ok((response, offset_encoding))
+            }
+        })
+        .collect();
 
-    cx.callback(
-        future,
-        move |editor, compositor, response: Option<lsp::GotoDefinitionResponse>| {
-            let items = to_locations(response);
-            if items.is_empty() {
+    cx.jobs.callback(async move {
+        let mut locations = Vec::new();
+        while let Some((response, offset_encoding)) = futures.try_next().await? {
+            match response {
+                Some(lsp::GotoDefinitionResponse::Scalar(lsp_location)) => {
+                    locations.extend(lsp_location_to_location(lsp_location, offset_encoding));
+                }
+                Some(lsp::GotoDefinitionResponse::Array(lsp_locations)) => {
+                    locations.extend(
+                        lsp_locations.into_iter().flat_map(|location| {
+                            lsp_location_to_location(location, offset_encoding)
+                        }),
+                    );
+                }
+                Some(lsp::GotoDefinitionResponse::Link(lsp_locations)) => {
+                    locations.extend(
+                        lsp_locations
+                            .into_iter()
+                            .map(|location_link| {
+                                lsp::Location::new(
+                                    location_link.target_uri,
+                                    location_link.target_range,
+                                )
+                            })
+                            .flat_map(|location| {
+                                lsp_location_to_location(location, offset_encoding)
+                            }),
+                    );
+                }
+                None => (),
+            }
+        }
+        let call = move |editor: &mut Editor, compositor: &mut Compositor| {
+            if locations.is_empty() {
                 editor.set_error("No definition found.");
             } else {
-                goto_impl(editor, compositor, items, offset_encoding);
+                goto_impl(editor, compositor, locations);
             }
-        },
-    );
+        };
+        Ok(Callback::EditorCompositor(Box::new(call)))
+    });
 }
 
 pub fn goto_declaration(cx: &mut Context) {
@@ -998,34 +986,48 @@ pub fn goto_implementation(cx: &mut Context) {
 
 pub fn goto_reference(cx: &mut Context) {
     let config = cx.editor.config();
-    let (view, doc) = current!(cx.editor);
+    let (view, doc) = current_ref!(cx.editor);
 
-    // TODO could probably support multiple language servers,
-    // not sure if there's a real practical use case for this though
-    let language_server =
-        language_server_with_feature!(cx.editor, doc, LanguageServerFeature::GotoReference);
-    let offset_encoding = language_server.offset_encoding();
-    let pos = doc.position(view.id, offset_encoding);
-    let future = language_server
-        .goto_reference(
-            doc.identifier(),
-            pos,
-            config.lsp.goto_reference_include_declaration,
-            None,
-        )
-        .unwrap();
+    let mut futures: FuturesOrdered<_> = doc
+        .language_servers_with_feature(LanguageServerFeature::GotoReference)
+        .map(|language_server| {
+            let offset_encoding = language_server.offset_encoding();
+            let pos = doc.position(view.id, offset_encoding);
+            let future = language_server
+                .goto_reference(
+                    doc.identifier(),
+                    pos,
+                    config.lsp.goto_reference_include_declaration,
+                    None,
+                )
+                .unwrap();
+            async move {
+                let json = future.await?;
+                let locations: Option<Vec<lsp::Location>> = serde_json::from_value(json)?;
+                anyhow::Ok((locations, offset_encoding))
+            }
+        })
+        .collect();
 
-    cx.callback(
-        future,
-        move |editor, compositor, response: Option<Vec<lsp::Location>>| {
-            let items = response.unwrap_or_default();
-            if items.is_empty() {
+    cx.jobs.callback(async move {
+        let mut locations = Vec::new();
+        while let Some((lsp_locations, offset_encoding)) = futures.try_next().await? {
+            locations.extend(
+                lsp_locations
+                    .into_iter()
+                    .flatten()
+                    .flat_map(|location| lsp_location_to_location(location, offset_encoding)),
+            );
+        }
+        let call = move |editor: &mut Editor, compositor: &mut Compositor| {
+            if locations.is_empty() {
                 editor.set_error("No references found.");
             } else {
-                goto_impl(editor, compositor, items, offset_encoding);
+                goto_impl(editor, compositor, locations);
             }
-        },
-    );
+        };
+        Ok(Callback::EditorCompositor(Box::new(call)))
+    });
 }
 
 pub fn signature_help(cx: &mut Context) {
@@ -1035,54 +1037,61 @@ pub fn signature_help(cx: &mut Context) {
 }
 
 pub fn hover(cx: &mut Context) {
+    use ui::lsp::hover::Hover;
+
     let (view, doc) = current!(cx.editor);
+    if doc
+        .language_servers_with_feature(LanguageServerFeature::Hover)
+        .count()
+        == 0
+    {
+        cx.editor
+            .set_error("No configured language server supports hover");
+        return;
+    }
 
-    // TODO support multiple language servers (merge UI somehow)
-    let language_server =
-        language_server_with_feature!(cx.editor, doc, LanguageServerFeature::Hover);
-    // TODO: factor out a doc.position_identifier() that returns lsp::TextDocumentPositionIdentifier
-    let pos = doc.position(view.id, language_server.offset_encoding());
-    let future = language_server
-        .text_document_hover(doc.identifier(), pos, None)
-        .unwrap();
+    let mut seen_language_servers = HashSet::new();
+    let mut futures: FuturesOrdered<_> = doc
+        .language_servers_with_feature(LanguageServerFeature::Hover)
+        .filter(|ls| seen_language_servers.insert(ls.id()))
+        .map(|language_server| {
+            let server_name = language_server.name().to_string();
+            // TODO: factor out a doc.position_identifier() that returns lsp::TextDocumentPositionIdentifier
+            let pos = doc.position(view.id, language_server.offset_encoding());
+            let request = language_server
+                .text_document_hover(doc.identifier(), pos, None)
+                .unwrap();
 
-    cx.callback(
-        future,
-        move |editor, compositor, response: Option<lsp::Hover>| {
-            if let Some(hover) = response {
-                // hover.contents / .range <- used for visualizing
-
-                fn marked_string_to_markdown(contents: lsp::MarkedString) -> String {
-                    match contents {
-                        lsp::MarkedString::String(contents) => contents,
-                        lsp::MarkedString::LanguageString(string) => {
-                            if string.language == "markdown" {
-                                string.value
-                            } else {
-                                format!("```{}\n{}\n```", string.language, string.value)
-                            }
-                        }
-                    }
-                }
+            async move {
+                let json = request.await?;
+                let response = serde_json::from_value::<Option<lsp::Hover>>(json)?;
+                anyhow::Ok((server_name, response))
+            }
+        })
+        .collect();
 
-                let contents = match hover.contents {
-                    lsp::HoverContents::Scalar(contents) => marked_string_to_markdown(contents),
-                    lsp::HoverContents::Array(contents) => contents
-                        .into_iter()
-                        .map(marked_string_to_markdown)
-                        .collect::<Vec<_>>()
-                        .join("\n\n"),
-                    lsp::HoverContents::Markup(contents) => contents.value,
-                };
+    cx.jobs.callback(async move {
+        let mut hovers: Vec<(String, lsp::Hover)> = Vec::new();
 
-                // skip if contents empty
+        while let Some((server_name, hover)) = futures.try_next().await? {
+            if let Some(hover) = hover {
+                hovers.push((server_name, hover));
+            }
+        }
 
-                let contents = ui::Markdown::new(contents, editor.syn_loader.clone());
-                let popup = Popup::new("hover", contents).auto_close(true);
-                compositor.replace_or_push("hover", popup);
+        let call = move |editor: &mut Editor, compositor: &mut Compositor| {
+            if hovers.is_empty() {
+                editor.set_status("No hover results available.");
+                return;
             }
-        },
-    );
+
+            // create new popup
+            let contents = Hover::new(hovers, editor.syn_loader.clone());
+            let popup = Popup::new(Hover::ID, contents).auto_close(true);
+            compositor.replace_or_push(Hover::ID, popup);
+        };
+        Ok(Callback::EditorCompositor(Box::new(call)))
+    });
 }
 
 pub fn rename_symbol(cx: &mut Context) {
@@ -1314,7 +1323,7 @@ fn compute_inlay_hints_for_view(
     if !doc.inlay_hints_oudated
         && doc
             .inlay_hints(view_id)
-            .map_or(false, |dih| dih.id == new_doc_inlay_hints_id)
+            .is_some_and(|dih| dih.id == new_doc_inlay_hints_id)
     {
         return None;
     }
diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index 7ad0369fc..9c48bf723 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -9,6 +9,7 @@
 use helix_core::fuzzy::fuzzy_match;
 use helix_core::indent::MAX_INDENT;
 use helix_core::{line_ending, shellwords::Shellwords};
+use helix_stdx::path::home_dir;
 use helix_view::document::{read_to_string, DEFAULT_LANGUAGE_NAME};
 use helix_view::editor::{CloseError, ConfigEvent};
 use serde_json::Value;
@@ -186,9 +187,7 @@ fn buffer_gather_paths_impl(editor: &mut Editor, args: &[Cow<str>]) -> Vec<Docum
     for arg in args {
         let doc_id = editor.documents().find_map(|doc| {
             let arg_path = Some(Path::new(arg.as_ref()));
-            if doc.path().map(|p| p.as_path()) == arg_path
-                || doc.relative_path().as_deref() == arg_path
-            {
+            if doc.path().map(|p| p.as_path()) == arg_path || doc.relative_path() == arg_path {
                 Some(doc.id())
             } else {
                 None
@@ -456,13 +455,15 @@ fn format(
     }
 
     let (view, doc) = current!(cx.editor);
-    if let Some(format) = doc.format() {
-        let callback = make_format_callback(doc.id(), doc.version(), view.id, format, None);
-        cx.jobs.callback(callback);
-    }
+    let format = doc.format().context(
+        "A formatter isn't available, and no language server provides formatting capabilities",
+    )?;
+    let callback = make_format_callback(doc.id(), doc.version(), view.id, format, None);
+    cx.jobs.callback(callback);
 
     Ok(())
 }
+
 fn set_indent_style(
     cx: &mut compositor::Context,
     args: &[Cow<str>],
@@ -648,11 +649,12 @@ fn force_write_quit(
 /// error, otherwise returns `Ok(())`. If the current document is unmodified,
 /// and there are modified documents, switches focus to one of them.
 pub(super) fn buffers_remaining_impl(editor: &mut Editor) -> anyhow::Result<()> {
-    let (modified_ids, modified_names): (Vec<_>, Vec<_>) = editor
+    let modified_ids: Vec<_> = editor
         .documents()
         .filter(|doc| doc.is_modified())
-        .map(|doc| (doc.id(), doc.display_name()))
-        .unzip();
+        .map(|doc| doc.id())
+        .collect();
+
     if let Some(first) = modified_ids.first() {
         let current = doc!(editor);
         // If the current document is unmodified, and there are modified
@@ -660,6 +662,12 @@ pub(super) fn buffers_remaining_impl(editor: &mut Editor) -> anyhow::Result<()>
         if !modified_ids.contains(&current.id()) {
             editor.switch(*first, Action::Replace);
         }
+
+        let modified_names: Vec<_> = modified_ids
+            .iter()
+            .map(|doc_id| doc!(editor, doc_id).display_name())
+            .collect();
+
         bail!(
             "{} unsaved buffer{} remaining: {:?}",
             modified_names.len(),
@@ -1074,7 +1082,7 @@ fn show_clipboard_provider(
     }
 
     cx.editor
-        .set_status(cx.editor.registers.clipboard_provider_name().to_string());
+        .set_status(cx.editor.registers.clipboard_provider_name());
     Ok(())
 }
 
@@ -1087,18 +1095,28 @@ fn change_current_directory(
         return Ok(());
     }
 
-    let dir = args
-        .first()
-        .context("target directory not provided")?
-        .as_ref();
-    let dir = helix_stdx::path::expand_tilde(Path::new(dir));
+    let dir = match args.first().map(AsRef::as_ref) {
+        Some("-") => cx
+            .editor
+            .get_last_cwd()
+            .map(|path| Cow::Owned(path.to_path_buf()))
+            .ok_or_else(|| anyhow!("No previous working directory"))?,
+        Some(path) => helix_stdx::path::expand_tilde(Path::new(path)),
+        None => Cow::Owned(home_dir()?),
+    };
 
-    helix_stdx::env::set_current_working_dir(dir)?;
+    cx.editor.set_cwd(&dir).map_err(|err| {
+        anyhow!(
+            "Could not change working directory to '{}': {err}",
+            dir.display()
+        )
+    })?;
 
     cx.editor.set_status(format!(
         "Current working directory is now {}",
         helix_stdx::env::current_working_dir().display()
     ));
+
     Ok(())
 }
 
@@ -1458,9 +1476,34 @@ fn lsp_workspace_command(
     Ok(())
 }
 
+/// Returns all language servers used by the current document if no servers are supplied
+/// If servers are supplied, do a check to make sure that all of the servers exist
+fn valid_lang_servers(doc: &Document, servers: &[Cow<str>]) -> anyhow::Result<Vec<String>> {
+    let valid_ls_names = doc
+        .language_servers()
+        .map(|ls| ls.name().to_string())
+        .collect();
+
+    if servers.is_empty() {
+        Ok(valid_ls_names)
+    } else {
+        let (valid, invalid): (Vec<_>, Vec<_>) = servers
+            .iter()
+            .map(|m| m.to_string())
+            .partition(|ls| valid_ls_names.contains(ls));
+
+        if !invalid.is_empty() {
+            let s = if invalid.len() == 1 { "" } else { "s" };
+            bail!("Unknown language server{s}: {}", invalid.join(", "));
+        };
+
+        Ok(valid)
+    }
+}
+
 fn lsp_restart(
     cx: &mut compositor::Context,
-    _args: &[Cow<str>],
+    args: &[Cow<str>],
     event: PromptEvent,
 ) -> anyhow::Result<()> {
     if event != PromptEvent::Validate {
@@ -1468,17 +1511,25 @@ fn lsp_restart(
     }
 
     let editor_config = cx.editor.config.load();
-    let (_view, doc) = current!(cx.editor);
+    let doc = doc!(cx.editor);
     let config = doc
         .language_config()
         .context("LSP not defined for the current document")?;
 
-    cx.editor.language_servers.restart(
-        config,
-        doc.path(),
-        &editor_config.workspace_lsp_roots,
-        editor_config.lsp.snippets,
-    )?;
+    let ls_restart_names = valid_lang_servers(doc, args)?;
+
+    for server in ls_restart_names.iter() {
+        cx.editor
+            .language_servers
+            .restart_server(
+                server,
+                config,
+                doc.path(),
+                &editor_config.workspace_lsp_roots,
+                editor_config.lsp.snippets,
+            )
+            .transpose()?;
+    }
 
     // This collect is needed because refresh_language_server would need to re-borrow editor.
     let document_ids_to_refresh: Vec<DocumentId> = cx
@@ -1487,10 +1538,9 @@ fn lsp_restart(
         .filter_map(|doc| match doc.language_config() {
             Some(config)
                 if config.language_servers.iter().any(|ls| {
-                    config
-                        .language_servers
+                    ls_restart_names
                         .iter()
-                        .any(|restarted_ls| restarted_ls.name == ls.name)
+                        .any(|restarted_ls| restarted_ls == &ls.name)
                 }) =>
             {
                 Some(doc.id())
@@ -1508,17 +1558,15 @@ fn lsp_restart(
 
 fn lsp_stop(
     cx: &mut compositor::Context,
-    _args: &[Cow<str>],
+    args: &[Cow<str>],
     event: PromptEvent,
 ) -> anyhow::Result<()> {
     if event != PromptEvent::Validate {
         return Ok(());
     }
+    let doc = doc!(cx.editor);
 
-    let ls_shutdown_names = doc!(cx.editor)
-        .language_servers()
-        .map(|ls| ls.name().to_string())
-        .collect::<Vec<_>>();
+    let ls_shutdown_names = valid_lang_servers(doc, args)?;
 
     for ls_name in &ls_shutdown_names {
         cx.editor.language_servers.stop(ls_name);
@@ -2068,6 +2116,10 @@ fn sort_impl(
 
     let selection = doc.selection(view.id);
 
+    if selection.len() == 1 {
+        bail!("Sorting requires multiple selections. Hint: split selection first");
+    }
+
     let mut fragments: Vec<_> = selection
         .slices(text)
         .map(|fragment| fragment.chunks().collect())
@@ -2499,7 +2551,8 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     ensure!(args.len() == 1, "only the file name is expected");
 
     let filename = args.first().unwrap();
-    let path = PathBuf::from(filename.to_string());
+    let path = helix_stdx::path::expand_tilde(PathBuf::from(filename.to_string()));
+
     ensure!(
         path.exists() && path.is_file(),
         "path is not a file: {:?}",
@@ -2636,7 +2689,7 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     TypableCommand {
         name: "format",
         aliases: &["fmt"],
-        doc: "Format the file using the LSP formatter.",
+        doc: "Format the file using an external formatter or language server.",
         fun: format,
         signature: CommandSignature::none(),
     },
@@ -2891,16 +2944,16 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     TypableCommand {
         name: "lsp-restart",
         aliases: &[],
-        doc: "Restarts the language servers used by the current doc",
+        doc: "Restarts the given language servers, or all language servers that are used by the current file if no arguments are supplied",
         fun: lsp_restart,
-        signature: CommandSignature::none(),
+        signature: CommandSignature::all(completers::language_servers),
     },
     TypableCommand {
         name: "lsp-stop",
         aliases: &[],
-        doc: "Stops the language servers that are used by the current doc",
+        doc: "Stops the given language servers, or all language servers that are used by the current file if no arguments are supplied",
         fun: lsp_stop,
-        signature: CommandSignature::none(),
+        signature: CommandSignature::all(completers::language_servers),
     },
     TypableCommand {
         name: "tree-sitter-scopes",
@@ -3032,7 +3085,7 @@ fn read(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     TypableCommand {
         name: "tree-sitter-subtree",
         aliases: &["ts-subtree"],
-        doc: "Display tree sitter subtree under cursor, primarily for debugging queries.",
+        doc: "Display the smallest tree-sitter subtree that spans the primary selection, primarily for debugging queries.",
         fun: tree_sitter_subtree,
         signature: CommandSignature::none(),
     },
@@ -3189,8 +3242,8 @@ pub(super) fn command_mode(cx: &mut Context) {
                 {
                     completer(editor, word)
                         .into_iter()
-                        .map(|(range, file)| {
-                            let file = shellwords::escape(file);
+                        .map(|(range, mut file)| {
+                            file.content = shellwords::escape(file.content);
 
                             // offset ranges to input
                             let offset = input.len() - word_len;
diff --git a/helix-term/src/compositor.rs b/helix-term/src/compositor.rs
index 3dcb5f2bf..28c8651a2 100644
--- a/helix-term/src/compositor.rs
+++ b/helix-term/src/compositor.rs
@@ -27,7 +27,7 @@ pub struct Context<'a> {
     pub jobs: &'a mut Jobs,
 }
 
-impl<'a> Context<'a> {
+impl Context<'_> {
     /// Waits on all pending jobs, and then tries to flush all pending write
     /// operations for all documents.
     pub fn block_try_flush_writes(&mut self) -> anyhow::Result<()> {
@@ -137,9 +137,12 @@ pub fn remove(&mut self, id: &'static str) -> Option<Box<dyn Component>> {
     }
 
     pub fn handle_event(&mut self, event: &Event, cx: &mut Context) -> bool {
-        // If it is a key event and a macro is being recorded, push the key event to the recording.
+        // If it is a key event, a macro is being recorded, and a macro isn't being replayed,
+        // push the key event to the recording.
         if let (Event::Key(key), Some((_, keys))) = (event, &mut cx.editor.macro_recording) {
-            keys.push(*key);
+            if cx.editor.macro_replaying.is_empty() {
+                keys.push(*key);
+            }
         }
 
         let mut callbacks = Vec::new();
diff --git a/helix-term/src/config.rs b/helix-term/src/config.rs
index 4c2340e91..bcba8d8e1 100644
--- a/helix-term/src/config.rs
+++ b/helix-term/src/config.rs
@@ -174,129 +174,6 @@ fn parsing_keymaps_config_file() {
         );
     }
 
-    #[test]
-    fn parsing_menus() {
-        use crate::keymap;
-        use helix_core::hashmap;
-        use helix_view::document::Mode;
-
-        let sample_keymaps = r#"
-            [keys.normal]
-            f = { f = "file_picker", c = "wclose" }
-            b = { label = "buffer", b = "buffer_picker", n = "goto_next_buffer" }
-        "#;
-
-        let mut keys = keymap::default();
-        merge_keys(
-            &mut keys,
-            hashmap! {
-                Mode::Normal => keymap!({ "Normal mode"
-                    "f" => { ""
-                        "f" => file_picker,
-                        "c" => wclose,
-                    },
-                    "b" => { "buffer"
-                        "b" => buffer_picker,
-                        "n" => goto_next_buffer,
-                    },
-                }),
-            },
-        );
-
-        assert_eq!(
-            Config::load_test(sample_keymaps),
-            Config {
-                keys,
-                ..Default::default()
-            }
-        );
-    }
-
-    #[test]
-    fn parsing_typable_commands() {
-        use crate::keymap;
-        use crate::keymap::MappableCommand;
-        use helix_view::document::Mode;
-        use helix_view::input::KeyEvent;
-        use std::str::FromStr;
-
-        let sample_keymaps = r#"
-            [keys.normal]
-            o = { label = "Edit Config", command = ":open ~/.config" }
-            c = ":buffer-close" 
-            h = ["vsplit", "normal_mode", "swap_view_left"]
-            j = {command = ["hsplit", "normal_mode", "swap_view_down"], label = "split down"}
-            n = { label = "Delete word", command = "@wd" }
-        "#;
-
-        let config = Config::load_test(sample_keymaps);
-
-        let tree = config.keys.get(&Mode::Normal).unwrap();
-
-        if let keymap::KeyTrie::Node(node) = tree {
-            let open_node = node.get(&KeyEvent::from_str("o").unwrap()).unwrap();
-
-            if let keymap::KeyTrie::MappableCommand(MappableCommand::Typable { doc, .. }) =
-                open_node
-            {
-                assert_eq!(doc, "Edit Config");
-            } else {
-                panic!("Edit Config did not parse to typable command");
-            }
-
-            let close_node = node.get(&KeyEvent::from_str("c").unwrap()).unwrap();
-            if let keymap::KeyTrie::MappableCommand(MappableCommand::Typable { doc, .. }) =
-                close_node
-            {
-                assert_eq!(doc, ":buffer-close []");
-            } else {
-                panic!(":buffer-close command did not parse to typable command");
-            }
-
-            let split_left = node.get(&KeyEvent::from_str("h").unwrap()).unwrap();
-            if let keymap::KeyTrie::Sequence(label, cmds) = split_left {
-                assert_eq!(label, KeyTrie::DEFAULT_SEQUENCE_LABEL);
-                assert_eq!(
-                    *cmds,
-                    vec![
-                        MappableCommand::vsplit,
-                        MappableCommand::normal_mode,
-                        MappableCommand::swap_view_left
-                    ]
-                );
-            }
-
-            let split_down = node.get(&KeyEvent::from_str("j").unwrap()).unwrap();
-            if let keymap::KeyTrie::Sequence(label, cmds) = split_down {
-                assert_eq!(label, "split down");
-                assert_eq!(
-                    *cmds,
-                    vec![
-                        MappableCommand::hsplit,
-                        MappableCommand::normal_mode,
-                        MappableCommand::swap_view_down
-                    ]
-                );
-            }
-
-            let macro_keys = node.get(&KeyEvent::from_str("n").unwrap()).unwrap();
-            if let keymap::KeyTrie::MappableCommand(MappableCommand::Macro { name, keys }) =
-                macro_keys
-            {
-                assert_eq!(name, "Delete word");
-                assert_eq!(
-                    keys,
-                    &vec![
-                        KeyEvent::from_str("w").unwrap(),
-                        KeyEvent::from_str("d").unwrap()
-                    ]
-                );
-            }
-        } else {
-            panic!("Config did not parse to trie");
-        }
-    }
-
     #[test]
     fn keys_resolve_to_correct_defaults() {
         // From serde default
diff --git a/helix-term/src/events.rs b/helix-term/src/events.rs
index 415213c22..15d811529 100644
--- a/helix-term/src/events.rs
+++ b/helix-term/src/events.rs
@@ -1,6 +1,8 @@
 use helix_event::{events, register_event};
 use helix_view::document::Mode;
-use helix_view::events::{DiagnosticsDidChange, DocumentDidChange, SelectionDidChange};
+use helix_view::events::{
+    DiagnosticsDidChange, DocumentDidChange, DocumentFocusLost, SelectionDidChange,
+};
 
 use crate::commands;
 use crate::keymap::MappableCommand;
@@ -16,6 +18,7 @@ pub fn register() {
     register_event::<PostInsertChar>();
     register_event::<PostCommand>();
     register_event::<DocumentDidChange>();
+    register_event::<DocumentFocusLost>();
     register_event::<SelectionDidChange>();
     register_event::<DiagnosticsDidChange>();
 }
diff --git a/helix-term/src/handlers.rs b/helix-term/src/handlers.rs
index b27e34e29..b580e678b 100644
--- a/helix-term/src/handlers.rs
+++ b/helix-term/src/handlers.rs
@@ -6,26 +6,25 @@
 use crate::config::Config;
 use crate::events;
 use crate::handlers::auto_save::AutoSaveHandler;
-use crate::handlers::completion::CompletionHandler;
 use crate::handlers::signature_help::SignatureHelpHandler;
 
-pub use completion::trigger_auto_completion;
 pub use helix_view::handlers::Handlers;
 
 mod auto_save;
 pub mod completion;
 mod diagnostics;
 mod signature_help;
+mod snippet;
 
 pub fn setup(config: Arc<ArcSwap<Config>>) -> Handlers {
     events::register();
 
-    let completions = CompletionHandler::new(config).spawn();
+    let event_tx = completion::CompletionHandler::new(config).spawn();
     let signature_hints = SignatureHelpHandler::new().spawn();
     let auto_save = AutoSaveHandler::new().spawn();
 
     let handlers = Handlers {
-        completions,
+        completions: helix_view::handlers::completion::CompletionHandler::new(event_tx),
         signature_hints,
         auto_save,
     };
@@ -34,5 +33,6 @@ pub fn setup(config: Arc<ArcSwap<Config>>) -> Handlers {
     signature_help::register_hooks(&handlers);
     auto_save::register_hooks(&handlers);
     diagnostics::register_hooks(&handlers);
+    snippet::register_hooks(&handlers);
     handlers
 }
diff --git a/helix-term/src/handlers/completion.rs b/helix-term/src/handlers/completion.rs
index 68956c85f..046cfab79 100644
--- a/helix-term/src/handlers/completion.rs
+++ b/helix-term/src/handlers/completion.rs
@@ -1,302 +1,90 @@
-use std::collections::HashSet;
-use std::sync::Arc;
-use std::time::Duration;
+use std::collections::HashMap;
 
-use arc_swap::ArcSwap;
-use futures_util::stream::FuturesUnordered;
 use helix_core::chars::char_is_word;
+use helix_core::completion::CompletionProvider;
 use helix_core::syntax::LanguageServerFeature;
-use helix_event::{
-    cancelable_future, cancelation, register_hook, send_blocking, CancelRx, CancelTx,
-};
+use helix_event::{register_hook, TaskHandle};
 use helix_lsp::lsp;
-use helix_lsp::util::pos_to_lsp_pos;
 use helix_stdx::rope::RopeSliceExt;
-use helix_view::document::{Mode, SavePoint};
-use helix_view::handlers::lsp::CompletionEvent;
-use helix_view::{DocumentId, Editor, ViewId};
-use tokio::sync::mpsc::Sender;
-use tokio::time::Instant;
-use tokio_stream::StreamExt;
+use helix_view::document::Mode;
+use helix_view::handlers::completion::{CompletionEvent, ResponseContext};
+use helix_view::Editor;
+use tokio::task::JoinSet;
 
 use crate::commands;
 use crate::compositor::Compositor;
-use crate::config::Config;
 use crate::events::{OnModeSwitch, PostCommand, PostInsertChar};
-use crate::job::{dispatch, dispatch_blocking};
+use crate::handlers::completion::request::{request_incomplete_completion_list, Trigger};
+use crate::job::dispatch;
 use crate::keymap::MappableCommand;
-use crate::ui::editor::InsertEvent;
-use crate::ui::lsp::SignatureHelp;
-use crate::ui::{self, CompletionItem, Popup};
+use crate::ui::lsp::signature_help::SignatureHelp;
+use crate::ui::{self, Popup};
 
 use super::Handlers;
-pub use resolve::ResolveHandler;
-mod resolve;
 
-#[derive(Debug, PartialEq, Eq, Clone, Copy)]
-enum TriggerKind {
-    Auto,
-    TriggerChar,
-    Manual,
-}
-
-#[derive(Debug, Clone, Copy)]
-struct Trigger {
-    pos: usize,
-    view: ViewId,
-    doc: DocumentId,
-    kind: TriggerKind,
-}
+pub use item::{CompletionItem, CompletionItems, CompletionResponse, LspCompletionItem};
+pub use request::CompletionHandler;
+pub use resolve::ResolveHandler;
 
-#[derive(Debug)]
-pub(super) struct CompletionHandler {
-    /// currently active trigger which will cause a
-    /// completion request after the timeout
-    trigger: Option<Trigger>,
-    /// A handle for currently active completion request.
-    /// This can be used to determine whether the current
-    /// request is still active (and new triggers should be
-    /// ignored) and can also be used to abort the current
-    /// request (by dropping the handle)
-    request: Option<CancelTx>,
-    config: Arc<ArcSwap<Config>>,
-}
+mod item;
+mod path;
+mod request;
+mod resolve;
 
-impl CompletionHandler {
-    pub fn new(config: Arc<ArcSwap<Config>>) -> CompletionHandler {
-        Self {
-            config,
-            request: None,
-            trigger: None,
+async fn handle_response(
+    requests: &mut JoinSet<CompletionResponse>,
+    is_incomplete: bool,
+) -> Option<CompletionResponse> {
+    loop {
+        let response = requests.join_next().await?.unwrap();
+        if !is_incomplete && !response.context.is_incomplete && response.items.is_empty() {
+            continue;
         }
+        return Some(response);
     }
 }
 
-impl helix_event::AsyncHook for CompletionHandler {
-    type Event = CompletionEvent;
-
-    fn handle_event(
-        &mut self,
-        event: Self::Event,
-        _old_timeout: Option<Instant>,
-    ) -> Option<Instant> {
-        match event {
-            CompletionEvent::AutoTrigger {
-                cursor: trigger_pos,
-                doc,
-                view,
-            } => {
-                // techically it shouldn't be possible to switch views/documents in insert mode
-                // but people may create weird keymaps/use the mouse so lets be extra careful
-                if self
-                    .trigger
-                    .as_ref()
-                    .map_or(true, |trigger| trigger.doc != doc || trigger.view != view)
-                {
-                    self.trigger = Some(Trigger {
-                        pos: trigger_pos,
-                        view,
-                        doc,
-                        kind: TriggerKind::Auto,
-                    });
-                }
-            }
-            CompletionEvent::TriggerChar { cursor, doc, view } => {
-                // immediately request completions and drop all auto completion requests
-                self.request = None;
-                self.trigger = Some(Trigger {
-                    pos: cursor,
-                    view,
-                    doc,
-                    kind: TriggerKind::TriggerChar,
-                });
-            }
-            CompletionEvent::ManualTrigger { cursor, doc, view } => {
-                // immediately request completions and drop all auto completion requests
-                self.request = None;
-                self.trigger = Some(Trigger {
-                    pos: cursor,
-                    view,
-                    doc,
-                    kind: TriggerKind::Manual,
-                });
-                // stop debouncing immediately and request the completion
-                self.finish_debounce();
-                return None;
-            }
-            CompletionEvent::Cancel => {
-                self.trigger = None;
-                self.request = None;
-            }
-            CompletionEvent::DeleteText { cursor } => {
-                // if we deleted the original trigger, abort the completion
-                if matches!(self.trigger, Some(Trigger{ pos, .. }) if cursor < pos) {
-                    self.trigger = None;
-                    self.request = None;
-                }
-            }
-        }
-        self.trigger.map(|trigger| {
-            // if the current request was closed forget about it
-            // otherwise immediately restart the completion request
-            let cancel = self.request.take().map_or(false, |req| !req.is_closed());
-            let timeout = if trigger.kind == TriggerKind::Auto && !cancel {
-                self.config.load().editor.completion_timeout
-            } else {
-                // we want almost instant completions for trigger chars
-                // and restarting completion requests. The small timeout here mainly
-                // serves to better handle cases where the completion handler
-                // may fall behind (so multiple events in the channel) and macros
-                Duration::from_millis(5)
-            };
-            Instant::now() + timeout
-        })
-    }
-
-    fn finish_debounce(&mut self) {
-        let trigger = self.trigger.take().expect("debounce always has a trigger");
-        let (tx, rx) = cancelation();
-        self.request = Some(tx);
-        dispatch_blocking(move |editor, compositor| {
-            request_completion(trigger, rx, editor, compositor)
-        });
-    }
-}
-
-fn request_completion(
-    mut trigger: Trigger,
-    cancel: CancelRx,
-    editor: &mut Editor,
-    compositor: &mut Compositor,
+async fn replace_completions(
+    handle: TaskHandle,
+    mut requests: JoinSet<CompletionResponse>,
+    is_incomplete: bool,
 ) {
-    let (view, doc) = current!(editor);
-
-    if compositor
-        .find::<ui::EditorView>()
-        .unwrap()
-        .completion
-        .is_some()
-        || editor.mode != Mode::Insert
-    {
-        return;
-    }
-
-    let text = doc.text();
-    let cursor = doc.selection(view.id).primary().cursor(text.slice(..));
-    if trigger.view != view.id || trigger.doc != doc.id() || cursor < trigger.pos {
-        return;
-    }
-    // this looks odd... Why are we not using the trigger position from
-    // the `trigger` here? Won't that mean that the trigger char doesn't get
-    // send to the LS if we type fast enougn? Yes that is true but it's
-    // not actually a problem. The LSP will resolve the completion to the identifier
-    // anyway (in fact sending the later position is necessary to get the right results
-    // from LSPs that provide incomplete completion list). We rely on trigger offset
-    // and primary cursor matching for multi-cursor completions so this is definitely
-    // necessary from our side too.
-    trigger.pos = cursor;
-    let trigger_text = text.slice(..cursor);
-
-    let mut seen_language_servers = HashSet::new();
-    let mut futures: FuturesUnordered<_> = doc
-        .language_servers_with_feature(LanguageServerFeature::Completion)
-        .filter(|ls| seen_language_servers.insert(ls.id()))
-        .map(|ls| {
-            let language_server_id = ls.id();
-            let offset_encoding = ls.offset_encoding();
-            let pos = pos_to_lsp_pos(text, cursor, offset_encoding);
-            let doc_id = doc.identifier();
-            let context = if trigger.kind == TriggerKind::Manual {
-                lsp::CompletionContext {
-                    trigger_kind: lsp::CompletionTriggerKind::INVOKED,
-                    trigger_character: None,
-                }
-            } else {
-                let trigger_char =
-                    ls.capabilities()
-                        .completion_provider
-                        .as_ref()
-                        .and_then(|provider| {
-                            provider
-                                .trigger_characters
-                                .as_deref()?
-                                .iter()
-                                .find(|&trigger| trigger_text.ends_with(trigger))
-                        });
-
-                if trigger_char.is_some() {
-                    lsp::CompletionContext {
-                        trigger_kind: lsp::CompletionTriggerKind::TRIGGER_CHARACTER,
-                        trigger_character: trigger_char.cloned(),
-                    }
-                } else {
-                    lsp::CompletionContext {
-                        trigger_kind: lsp::CompletionTriggerKind::INVOKED,
-                        trigger_character: None,
-                    }
-                }
+    while let Some(mut response) = handle_response(&mut requests, is_incomplete).await {
+        let handle = handle.clone();
+        dispatch(move |editor, compositor| {
+            let editor_view = compositor.find::<ui::EditorView>().unwrap();
+            let Some(completion) = &mut editor_view.completion else {
+                return;
             };
-
-            let completion_response = ls.completion(doc_id, pos, None, context).unwrap();
-            async move {
-                let json = completion_response.await?;
-                let response: Option<lsp::CompletionResponse> = serde_json::from_value(json)?;
-                let items = match response {
-                    Some(lsp::CompletionResponse::Array(items)) => items,
-                    // TODO: do something with is_incomplete
-                    Some(lsp::CompletionResponse::List(lsp::CompletionList {
-                        is_incomplete: _is_incomplete,
-                        items,
-                    })) => items,
-                    None => Vec::new(),
-                }
-                .into_iter()
-                .map(|item| CompletionItem {
-                    item,
-                    provider: language_server_id,
-                    resolved: false,
-                })
-                .collect();
-                anyhow::Ok(items)
+            if handle.is_canceled() {
+                log::error!("dropping outdated completion response");
+                return;
             }
-        })
-        .collect();
-
-    let future = async move {
-        let mut items = Vec::new();
-        while let Some(lsp_items) = futures.next().await {
-            match lsp_items {
-                Ok(mut lsp_items) => items.append(&mut lsp_items),
-                Err(err) => {
-                    log::debug!("completion request failed: {err:?}");
-                }
-            };
-        }
-        items
-    };
 
-    let savepoint = doc.savepoint(view);
-
-    let ui = compositor.find::<ui::EditorView>().unwrap();
-    ui.last_insert.1.push(InsertEvent::RequestCompletion);
-    tokio::spawn(async move {
-        let items = cancelable_future(future, cancel).await.unwrap_or_default();
-        if items.is_empty() {
-            return;
-        }
-        dispatch(move |editor, compositor| {
-            show_completion(editor, compositor, items, trigger, savepoint)
+            completion.replace_provider_completions(&mut response, is_incomplete);
+            if completion.is_empty() {
+                editor_view.clear_completion(editor);
+                // clearing completions might mean we want to immediately re-request them (usually
+                // this occurs if typing a trigger char)
+                trigger_auto_completion(editor, false);
+            } else {
+                editor
+                    .handlers
+                    .completions
+                    .active_completions
+                    .insert(response.provider, response.context);
+            }
         })
-        .await
-    });
+        .await;
+    }
 }
 
 fn show_completion(
     editor: &mut Editor,
     compositor: &mut Compositor,
     items: Vec<CompletionItem>,
+    context: HashMap<CompletionProvider, ResponseContext>,
     trigger: Trigger,
-    savepoint: Arc<SavePoint>,
 ) {
     let (view, doc) = current_ref!(editor);
     // check if the completion request is stale.
@@ -313,8 +101,9 @@ fn show_completion(
     if ui.completion.is_some() {
         return;
     }
+    editor.handlers.completions.active_completions = context;
 
-    let completion_area = ui.set_completion(editor, savepoint, items, trigger.pos, size);
+    let completion_area = ui.set_completion(editor, items, trigger.pos, size);
     let signature_help_area = compositor
         .find_id::<Popup<SignatureHelp>>(SignatureHelp::ID)
         .map(|signature_help| signature_help.area(size, editor));
@@ -324,11 +113,7 @@ fn show_completion(
     }
 }
 
-pub fn trigger_auto_completion(
-    tx: &Sender<CompletionEvent>,
-    editor: &Editor,
-    trigger_char_only: bool,
-) {
+pub fn trigger_auto_completion(editor: &Editor, trigger_char_only: bool) {
     let config = editor.config.load();
     if !config.auto_completion {
         return;
@@ -346,15 +131,23 @@ pub fn trigger_auto_completion(
                         ..
                     }) if triggers.iter().any(|trigger| text.ends_with(trigger)))
         });
-    if is_trigger_char {
-        send_blocking(
-            tx,
-            CompletionEvent::TriggerChar {
-                cursor,
-                doc: doc.id(),
-                view: view.id,
-            },
-        );
+
+    let cursor_char = text
+        .get_bytes_at(text.len_bytes())
+        .and_then(|t| t.reversed().next());
+
+    #[cfg(windows)]
+    let is_path_completion_trigger = matches!(cursor_char, Some(b'/' | b'\\'));
+    #[cfg(not(windows))]
+    let is_path_completion_trigger = matches!(cursor_char, Some(b'/'));
+
+    let handler = &editor.handlers.completions;
+    if is_trigger_char || (is_path_completion_trigger && doc.path_completion_enabled()) {
+        handler.event(CompletionEvent::TriggerChar {
+            cursor,
+            doc: doc.id(),
+            view: view.id,
+        });
         return;
     }
 
@@ -367,29 +160,29 @@ pub fn trigger_auto_completion(
             .all(char_is_word);
 
     if is_auto_trigger {
-        send_blocking(
-            tx,
-            CompletionEvent::AutoTrigger {
-                cursor,
-                doc: doc.id(),
-                view: view.id,
-            },
-        );
+        handler.event(CompletionEvent::AutoTrigger {
+            cursor,
+            doc: doc.id(),
+            view: view.id,
+        });
     }
 }
 
-fn update_completions(cx: &mut commands::Context, c: Option<char>) {
+fn update_completion_filter(cx: &mut commands::Context, c: Option<char>) {
     cx.callback.push(Box::new(move |compositor, cx| {
         let editor_view = compositor.find::<ui::EditorView>().unwrap();
         if let Some(completion) = &mut editor_view.completion {
             completion.update_filter(c);
-            if completion.is_empty() {
+            if completion.is_empty() || c.is_some_and(|c| !char_is_word(c)) {
                 editor_view.clear_completion(cx.editor);
                 // clearing completions might mean we want to immediately rerequest them (usually
                 // this occurs if typing a trigger char)
                 if c.is_some() {
-                    trigger_auto_completion(&cx.editor.handlers.completions, cx.editor, false);
+                    trigger_auto_completion(cx.editor, false);
                 }
+            } else {
+                let handle = cx.editor.handlers.completions.request_controller.restart();
+                request_incomplete_completion_list(cx.editor, handle)
             }
         }
     }))
@@ -403,7 +196,6 @@ fn clear_completions(cx: &mut commands::Context) {
 }
 
 fn completion_post_command_hook(
-    tx: &Sender<CompletionEvent>,
     PostCommand { command, cx }: &mut PostCommand<'_, '_>,
 ) -> anyhow::Result<()> {
     if cx.editor.mode == Mode::Insert {
@@ -416,7 +208,7 @@ fn completion_post_command_hook(
                 MappableCommand::Static {
                     name: "delete_char_backward",
                     ..
-                } => update_completions(cx, None),
+                } => update_completion_filter(cx, None),
                 _ => clear_completions(cx),
             }
         } else {
@@ -442,33 +234,35 @@ fn completion_post_command_hook(
                 } => return Ok(()),
                 _ => CompletionEvent::Cancel,
             };
-            send_blocking(tx, event);
+            cx.editor.handlers.completions.event(event);
         }
     }
     Ok(())
 }
 
-pub(super) fn register_hooks(handlers: &Handlers) {
-    let tx = handlers.completions.clone();
-    register_hook!(move |event: &mut PostCommand<'_, '_>| completion_post_command_hook(&tx, event));
+pub(super) fn register_hooks(_handlers: &Handlers) {
+    register_hook!(move |event: &mut PostCommand<'_, '_>| completion_post_command_hook(event));
 
-    let tx = handlers.completions.clone();
     register_hook!(move |event: &mut OnModeSwitch<'_, '_>| {
         if event.old_mode == Mode::Insert {
-            send_blocking(&tx, CompletionEvent::Cancel);
+            event
+                .cx
+                .editor
+                .handlers
+                .completions
+                .event(CompletionEvent::Cancel);
             clear_completions(event.cx);
         } else if event.new_mode == Mode::Insert {
-            trigger_auto_completion(&tx, event.cx.editor, false)
+            trigger_auto_completion(event.cx.editor, false)
         }
         Ok(())
     });
 
-    let tx = handlers.completions.clone();
     register_hook!(move |event: &mut PostInsertChar<'_, '_>| {
         if event.cx.editor.last_completion.is_some() {
-            update_completions(event.cx, Some(event.c))
+            update_completion_filter(event.cx, Some(event.c))
         } else {
-            trigger_auto_completion(&tx, event.cx.editor, false);
+            trigger_auto_completion(event.cx.editor, false);
         }
         Ok(())
     });
diff --git a/helix-term/src/handlers/completion/item.rs b/helix-term/src/handlers/completion/item.rs
new file mode 100644
index 000000000..7a473b024
--- /dev/null
+++ b/helix-term/src/handlers/completion/item.rs
@@ -0,0 +1,126 @@
+use std::mem;
+
+use helix_core::completion::CompletionProvider;
+use helix_lsp::{lsp, LanguageServerId};
+use helix_view::handlers::completion::ResponseContext;
+
+pub struct CompletionResponse {
+    pub items: CompletionItems,
+    pub provider: CompletionProvider,
+    pub context: ResponseContext,
+}
+
+pub enum CompletionItems {
+    Lsp(Vec<lsp::CompletionItem>),
+    Other(Vec<CompletionItem>),
+}
+
+impl CompletionItems {
+    pub fn is_empty(&self) -> bool {
+        match self {
+            CompletionItems::Lsp(items) => items.is_empty(),
+            CompletionItems::Other(items) => items.is_empty(),
+        }
+    }
+}
+
+impl CompletionResponse {
+    pub fn take_items(&mut self, dst: &mut Vec<CompletionItem>) {
+        match &mut self.items {
+            CompletionItems::Lsp(items) => dst.extend(items.drain(..).map(|item| {
+                CompletionItem::Lsp(LspCompletionItem {
+                    item,
+                    provider: match self.provider {
+                        CompletionProvider::Lsp(provider) => provider,
+                        _ => unreachable!(),
+                    },
+                    resolved: false,
+                    provider_priority: self.context.priority,
+                })
+            })),
+            CompletionItems::Other(items) if dst.is_empty() => mem::swap(dst, items),
+            CompletionItems::Other(items) => dst.append(items),
+        }
+    }
+}
+
+#[derive(Debug, PartialEq, Clone)]
+pub struct LspCompletionItem {
+    pub item: lsp::CompletionItem,
+    pub provider: LanguageServerId,
+    pub resolved: bool,
+    // TODO: we should not be filtering and sorting incomplete completion list
+    // according to the spec but vscode does that anyway and most servers (
+    // including rust-analyzer) rely on that.. so we can't do that without
+    // breaking completions.
+    pub provider_priority: i8,
+}
+
+impl LspCompletionItem {
+    #[inline]
+    pub fn filter_text(&self) -> &str {
+        self.item
+            .filter_text
+            .as_ref()
+            .unwrap_or(&self.item.label)
+            .as_str()
+    }
+}
+
+#[derive(Debug, PartialEq, Clone)]
+pub enum CompletionItem {
+    Lsp(LspCompletionItem),
+    Other(helix_core::CompletionItem),
+}
+
+impl CompletionItem {
+    #[inline]
+    pub fn filter_text(&self) -> &str {
+        match self {
+            CompletionItem::Lsp(item) => item.filter_text(),
+            CompletionItem::Other(item) => &item.label,
+        }
+    }
+}
+
+impl PartialEq<CompletionItem> for LspCompletionItem {
+    fn eq(&self, other: &CompletionItem) -> bool {
+        match other {
+            CompletionItem::Lsp(other) => self == other,
+            _ => false,
+        }
+    }
+}
+
+impl PartialEq<CompletionItem> for helix_core::CompletionItem {
+    fn eq(&self, other: &CompletionItem) -> bool {
+        match other {
+            CompletionItem::Other(other) => self == other,
+            _ => false,
+        }
+    }
+}
+
+impl CompletionItem {
+    pub fn provider_priority(&self) -> i8 {
+        match self {
+            CompletionItem::Lsp(item) => item.provider_priority,
+            // sorting path completions after LSP for now
+            CompletionItem::Other(_) => 1,
+        }
+    }
+
+    pub fn provider(&self) -> CompletionProvider {
+        match self {
+            CompletionItem::Lsp(item) => CompletionProvider::Lsp(item.provider),
+            CompletionItem::Other(item) => item.provider,
+        }
+    }
+
+    pub fn preselect(&self) -> bool {
+        match self {
+            CompletionItem::Lsp(LspCompletionItem { item, .. }) => item.preselect.unwrap_or(false),
+            CompletionItem::Other(_) => false,
+        }
+    }
+}
diff --git a/helix-term/src/handlers/completion/path.rs b/helix-term/src/handlers/completion/path.rs
new file mode 100644
index 000000000..c2ffa5efa
--- /dev/null
+++ b/helix-term/src/handlers/completion/path.rs
@@ -0,0 +1,210 @@
+use std::{
+    borrow::Cow,
+    fs,
+    path::{Path, PathBuf},
+    str::FromStr as _,
+    sync::Arc,
+};
+
+use helix_core::{self as core, completion::CompletionProvider, Selection, Transaction};
+use helix_event::TaskHandle;
+use helix_stdx::path::{self, canonicalize, fold_home_dir, get_path_suffix};
+use helix_view::{document::SavePoint, handlers::completion::ResponseContext, Document};
+use url::Url;
+
+use crate::handlers::completion::{item::CompletionResponse, CompletionItem, CompletionItems};
+
+pub(crate) fn path_completion(
+    selection: Selection,
+    doc: &Document,
+    handle: TaskHandle,
+    savepoint: Arc<SavePoint>,
+) -> Option<impl FnOnce() -> CompletionResponse> {
+    if !doc.path_completion_enabled() {
+        return None;
+    }
+
+    let text = doc.text().clone();
+    let cursor = selection.primary().cursor(text.slice(..));
+    let cur_line = text.char_to_line(cursor);
+    let start = text.line_to_char(cur_line).max(cursor.saturating_sub(1000));
+    let line_until_cursor = text.slice(start..cursor);
+
+    let (dir_path, typed_file_name) =
+        get_path_suffix(line_until_cursor, false).and_then(|matched_path| {
+            let matched_path = Cow::from(matched_path);
+            let path: Cow<_> = if matched_path.starts_with("file://") {
+                Url::from_str(&matched_path)
+                    .ok()
+                    .and_then(|url| url.to_file_path().ok())?
+                    .into()
+            } else {
+                Path::new(&*matched_path).into()
+            };
+            let path = path::expand(&path);
+            let parent_dir = doc.path().and_then(|dp| dp.parent());
+            let path = match parent_dir {
+                Some(parent_dir) if path.is_relative() => parent_dir.join(&path),
+                _ => path.into_owned(),
+            };
+            #[cfg(windows)]
+            let ends_with_slash = matches!(matched_path.as_bytes().last(), Some(b'/' | b'\\'));
+            #[cfg(not(windows))]
+            let ends_with_slash = matches!(matched_path.as_bytes().last(), Some(b'/'));
+
+            if ends_with_slash {
+                Some((PathBuf::from(path.as_path()), None))
+            } else {
+                path.parent().map(|parent_path| {
+                    (
+                        PathBuf::from(parent_path),
+                        path.file_name().and_then(|f| f.to_str().map(String::from)),
+                    )
+                })
+            }
+        })?;
+
+    if handle.is_canceled() {
+        return None;
+    }
+
+    // TODO: handle properly in the future
+    const PRIORITY: i8 = 1;
+    let future = move || {
+        let Ok(read_dir) = std::fs::read_dir(&dir_path) else {
+            return CompletionResponse {
+                items: CompletionItems::Other(Vec::new()),
+                provider: CompletionProvider::Path,
+                context: ResponseContext {
+                    is_incomplete: false,
+                    priority: PRIORITY,
+                    savepoint,
+                },
+            };
+        };
+
+        let edit_diff = typed_file_name
+            .as_ref()
+            .map(|s| s.chars().count())
+            .unwrap_or_default();
+
+        let res: Vec<_> = read_dir
+            .filter_map(Result::ok)
+            .filter_map(|dir_entry| {
+                dir_entry
+                    .metadata()
+                    .ok()
+                    .and_then(|md| Some((dir_entry.file_name().into_string().ok()?, md)))
+            })
+            .map_while(|(file_name, md)| {
+                if handle.is_canceled() {
+                    return None;
+                }
+
+                let kind = path_kind(&md);
+                let documentation = path_documentation(&md, &dir_path.join(&file_name), kind);
+
+                let transaction = Transaction::change_by_selection(&text, &selection, |range| {
+                    let cursor = range.cursor(text.slice(..));
+                    (cursor - edit_diff, cursor, Some((&file_name).into()))
+                });
+
+                Some(CompletionItem::Other(core::CompletionItem {
+                    kind: Cow::Borrowed(kind),
+                    label: file_name.into(),
+                    transaction,
+                    documentation: Some(documentation),
+                    provider: CompletionProvider::Path,
+                }))
+            })
+            .collect();
+        CompletionResponse {
+            items: CompletionItems::Other(res),
+            provider: CompletionProvider::Path,
+            context: ResponseContext {
+                is_incomplete: false,
+                priority: PRIORITY,
+                savepoint,
+            },
+        }
+    };
+
+    Some(future)
+}
+
+#[cfg(unix)]
+fn path_documentation(md: &fs::Metadata, full_path: &Path, kind: &str) -> String {
+    let full_path = fold_home_dir(canonicalize(full_path));
+    let full_path_name = full_path.to_string_lossy();
+
+    use std::os::unix::prelude::PermissionsExt;
+    let mode = md.permissions().mode();
+
+    let perms = [
+        (libc::S_IRUSR, 'r'),
+        (libc::S_IWUSR, 'w'),
+        (libc::S_IXUSR, 'x'),
+        (libc::S_IRGRP, 'r'),
+        (libc::S_IWGRP, 'w'),
+        (libc::S_IXGRP, 'x'),
+        (libc::S_IROTH, 'r'),
+        (libc::S_IWOTH, 'w'),
+        (libc::S_IXOTH, 'x'),
+    ]
+    .into_iter()
+    .fold(String::with_capacity(9), |mut acc, (p, s)| {
+        // This cast is necessary on some platforms such as macos as `mode_t` is u16 there
+        #[allow(clippy::unnecessary_cast)]
+        acc.push(if mode & (p as u32) > 0 { s } else { '-' });
+        acc
+    });
+
+    // TODO it would be great to be able to individually color the documentation,
+    // but this will likely require a custom doc implementation (i.e. not `lsp::Documentation`)
+    // and/or different rendering in completion.rs
+    format!(
+        "type: `{kind}`\n\
+         permissions: `[{perms}]`\n\
+         full path: `{full_path_name}`",
+    )
+}
+
+#[cfg(not(unix))]
+fn path_documentation(_md: &fs::Metadata, full_path: &Path, kind: &str) -> String {
+    let full_path = fold_home_dir(canonicalize(full_path));
+    let full_path_name = full_path.to_string_lossy();
+    format!("type: `{kind}`\nfull path: `{full_path_name}`",)
+}
+
+#[cfg(unix)]
+fn path_kind(md: &fs::Metadata) -> &'static str {
+    if md.is_symlink() {
+        "link"
+    } else if md.is_dir() {
+        "folder"
+    } else {
+        use std::os::unix::fs::FileTypeExt;
+        if md.file_type().is_block_device() {
+            "block"
+        } else if md.file_type().is_socket() {
+            "socket"
+        } else if md.file_type().is_char_device() {
+            "char_device"
+        } else if md.file_type().is_fifo() {
+            "fifo"
+        } else {
+            "file"
+        }
+    }
+}
+
+#[cfg(not(unix))]
+fn path_kind(md: &fs::Metadata) -> &'static str {
+    if md.is_symlink() {
+        "link"
+    } else if md.is_dir() {
+        "folder"
+    } else {
+        "file"
+    }
+}
diff --git a/helix-term/src/handlers/completion/request.rs b/helix-term/src/handlers/completion/request.rs
new file mode 100644
index 000000000..3d2a158ea
--- /dev/null
+++ b/helix-term/src/handlers/completion/request.rs
@@ -0,0 +1,368 @@
+use std::collections::{HashMap, HashSet};
+use std::sync::Arc;
+use std::time::Duration;
+
+use arc_swap::ArcSwap;
+use futures_util::Future;
+use helix_core::completion::CompletionProvider;
+use helix_core::syntax::LanguageServerFeature;
+use helix_event::{cancelable_future, TaskController, TaskHandle};
+use helix_lsp::lsp;
+use helix_lsp::lsp::{CompletionContext, CompletionTriggerKind};
+use helix_lsp::util::pos_to_lsp_pos;
+use helix_stdx::rope::RopeSliceExt;
+use helix_view::document::{Mode, SavePoint};
+use helix_view::handlers::completion::{CompletionEvent, ResponseContext};
+use helix_view::{Document, DocumentId, Editor, ViewId};
+use tokio::task::JoinSet;
+use tokio::time::{timeout_at, Instant};
+
+use crate::compositor::Compositor;
+use crate::config::Config;
+use crate::handlers::completion::item::CompletionResponse;
+use crate::handlers::completion::path::path_completion;
+use crate::handlers::completion::{
+    handle_response, replace_completions, show_completion, CompletionItems,
+};
+use crate::job::{dispatch, dispatch_blocking};
+use crate::ui;
+use crate::ui::editor::InsertEvent;
+
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
+pub(super) enum TriggerKind {
+    Auto,
+    TriggerChar,
+    Manual,
+}
+
+#[derive(Debug, Clone, Copy)]
+pub(super) struct Trigger {
+    pub(super) pos: usize,
+    pub(super) view: ViewId,
+    pub(super) doc: DocumentId,
+    pub(super) kind: TriggerKind,
+}
+
+#[derive(Debug)]
+pub struct CompletionHandler {
+    /// The currently active trigger which will cause a completion request after the timeout.
+    trigger: Option<Trigger>,
+    in_flight: Option<Trigger>,
+    task_controller: TaskController,
+    config: Arc<ArcSwap<Config>>,
+}
+
+impl CompletionHandler {
+    pub fn new(config: Arc<ArcSwap<Config>>) -> CompletionHandler {
+        Self {
+            config,
+            task_controller: TaskController::new(),
+            trigger: None,
+            in_flight: None,
+        }
+    }
+}
+
+impl helix_event::AsyncHook for CompletionHandler {
+    type Event = CompletionEvent;
+
+    fn handle_event(
+        &mut self,
+        event: Self::Event,
+        _old_timeout: Option<Instant>,
+    ) -> Option<Instant> {
+        if self.in_flight.is_some() && !self.task_controller.is_running() {
+            self.in_flight = None;
+        }
+        match event {
+            CompletionEvent::AutoTrigger {
+                cursor: trigger_pos,
+                doc,
+                view,
+            } => {
+                // Technically it shouldn't be possible to switch views/documents in insert mode
+                // but people may create weird keymaps/use the mouse so let's be extra careful.
+                if self
+                    .trigger
+                    .or(self.in_flight)
+                    .map_or(true, |trigger| trigger.doc != doc || trigger.view != view)
+                {
+                    self.trigger = Some(Trigger {
+                        pos: trigger_pos,
+                        view,
+                        doc,
+                        kind: TriggerKind::Auto,
+                    });
+                }
+            }
+            CompletionEvent::TriggerChar { cursor, doc, view } => {
+                // immediately request completions and drop all auto completion requests
+                self.task_controller.cancel();
+                self.trigger = Some(Trigger {
+                    pos: cursor,
+                    view,
+                    doc,
+                    kind: TriggerKind::TriggerChar,
+                });
+            }
+            CompletionEvent::ManualTrigger { cursor, doc, view } => {
+                // immediately request completions and drop all auto completion requests
+                self.trigger = Some(Trigger {
+                    pos: cursor,
+                    view,
+                    doc,
+                    kind: TriggerKind::Manual,
+                });
+                // stop debouncing immediately and request the completion
+                self.finish_debounce();
+                return None;
+            }
+            CompletionEvent::Cancel => {
+                self.trigger = None;
+                self.task_controller.cancel();
+            }
+            CompletionEvent::DeleteText { cursor } => {
+                // if we deleted the original trigger, abort the completion
+                if matches!(self.trigger.or(self.in_flight), Some(Trigger{ pos, .. }) if cursor < pos)
+                {
+                    self.trigger = None;
+                    self.task_controller.cancel();
+                }
+            }
+        }
+        self.trigger.map(|trigger| {
+            // if the current request was closed forget about it
+            // otherwise immediately restart the completion request
+            let timeout = if trigger.kind == TriggerKind::Auto {
+                self.config.load().editor.completion_timeout
+            } else {
+                // we want almost instant completions for trigger chars
+                // and restarting completion requests. The small timeout here mainly
+                // serves to better handle cases where the completion handler
+                // may fall behind (so multiple events in the channel) and macros
+                Duration::from_millis(5)
+            };
+            Instant::now() + timeout
+        })
+    }
+
+    fn finish_debounce(&mut self) {
+        let trigger = self.trigger.take().expect("debounce always has a trigger");
+        self.in_flight = Some(trigger);
+        let handle = self.task_controller.restart();
+        dispatch_blocking(move |editor, compositor| {
+            request_completions(trigger, handle, editor, compositor)
+        });
+    }
+}
+
+fn request_completions(
+    mut trigger: Trigger,
+    handle: TaskHandle,
+    editor: &mut Editor,
+    compositor: &mut Compositor,
+) {
+    let (view, doc) = current_ref!(editor);
+
+    if compositor
+        .find::<ui::EditorView>()
+        .unwrap()
+        .completion
+        .is_some()
+        || editor.mode != Mode::Insert
+    {
+        return;
+    }
+
+    let text = doc.text();
+    let cursor = doc.selection(view.id).primary().cursor(text.slice(..));
+    if trigger.view != view.id || trigger.doc != doc.id() || cursor < trigger.pos {
+        return;
+    }
+    // This looks odd... Why are we not using the trigger position from the `trigger` here? Won't
+    // that mean that the trigger char doesn't get send to the language server if we type fast
+    // enough? Yes that is true but it's not actually a problem. The language server will resolve
+    // the completion to the identifier anyway (in fact sending the later position is necessary to
+    // get the right results from language servers that provide incomplete completion list). We
+    // rely on the trigger offset and primary cursor matching for multi-cursor completions so this
+    // is definitely necessary from our side too.
+    trigger.pos = cursor;
+    let doc = doc_mut!(editor, &doc.id());
+    let savepoint = doc.savepoint(view);
+    let text = doc.text();
+    let trigger_text = text.slice(..cursor);
+
+    let mut seen_language_servers = HashSet::new();
+    let language_servers: Vec<_> = doc
+        .language_servers_with_feature(LanguageServerFeature::Completion)
+        .filter(|ls| seen_language_servers.insert(ls.id()))
+        .collect();
+    let mut requests = JoinSet::new();
+    for (priority, ls) in language_servers.iter().enumerate() {
+        let context = if trigger.kind == TriggerKind::Manual {
+            lsp::CompletionContext {
+                trigger_kind: lsp::CompletionTriggerKind::INVOKED,
+                trigger_character: None,
+            }
+        } else {
+            let trigger_char =
+                ls.capabilities()
+                    .completion_provider
+                    .as_ref()
+                    .and_then(|provider| {
+                        provider
+                            .trigger_characters
+                            .as_deref()?
+                            .iter()
+                            .find(|&trigger| trigger_text.ends_with(trigger))
+                    });
+
+            if trigger_char.is_some() {
+                lsp::CompletionContext {
+                    trigger_kind: lsp::CompletionTriggerKind::TRIGGER_CHARACTER,
+                    trigger_character: trigger_char.cloned(),
+                }
+            } else {
+                lsp::CompletionContext {
+                    trigger_kind: lsp::CompletionTriggerKind::INVOKED,
+                    trigger_character: None,
+                }
+            }
+        };
+        requests.spawn(request_completions_from_language_server(
+            ls,
+            doc,
+            view.id,
+            context,
+            -(priority as i8),
+            savepoint.clone(),
+        ));
+    }
+    if let Some(path_completion_request) = path_completion(
+        doc.selection(view.id).clone(),
+        doc,
+        handle.clone(),
+        savepoint,
+    ) {
+        requests.spawn_blocking(path_completion_request);
+    }
+
+    let ui = compositor.find::<ui::EditorView>().unwrap();
+    ui.last_insert.1.push(InsertEvent::RequestCompletion);
+    let handle_ = handle.clone();
+    let request_completions = async move {
+        let mut context = HashMap::new();
+        let Some(mut response) = handle_response(&mut requests, false).await else {
+            return;
+        };
+
+        let mut items: Vec<_> = Vec::new();
+        response.take_items(&mut items);
+        context.insert(response.provider, response.context);
+        let deadline = Instant::now() + Duration::from_millis(100);
+        loop {
+            let Some(mut response) = timeout_at(deadline, handle_response(&mut requests, false))
+                .await
+                .ok()
+                .flatten()
+            else {
+                break;
+            };
+            response.take_items(&mut items);
+            context.insert(response.provider, response.context);
+        }
+        dispatch(move |editor, compositor| {
+            show_completion(editor, compositor, items, context, trigger)
+        })
+        .await;
+        if !requests.is_empty() {
+            replace_completions(handle_, requests, false).await;
+        }
+    };
+    tokio::spawn(cancelable_future(request_completions, handle));
+}
+
+fn request_completions_from_language_server(
+    ls: &helix_lsp::Client,
+    doc: &Document,
+    view: ViewId,
+    context: lsp::CompletionContext,
+    priority: i8,
+    savepoint: Arc<SavePoint>,
+) -> impl Future<Output = CompletionResponse> {
+    let provider = ls.id();
+    let offset_encoding = ls.offset_encoding();
+    let text = doc.text();
+    let cursor = doc.selection(view).primary().cursor(text.slice(..));
+    let pos = pos_to_lsp_pos(text, cursor, offset_encoding);
+    let doc_id = doc.identifier();
+
+    // it's important that this is before the async block (and that this is not an async function)
+    // to ensure the request is dispatched right away before any new edit notifications
+    let completion_response = ls.completion(doc_id, pos, None, context).unwrap();
+    async move {
+        let response: Option<lsp::CompletionResponse> = completion_response
+            .await
+            .and_then(|json| serde_json::from_value(json).map_err(helix_lsp::Error::Parse))
+            .inspect_err(|err| log::error!("completion request failed: {err}"))
+            .ok()
+            .flatten();
+        let (mut items, is_incomplete) = match response {
+            Some(lsp::CompletionResponse::Array(items)) => (items, false),
+            Some(lsp::CompletionResponse::List(lsp::CompletionList {
+                is_incomplete,
+                items,
+            })) => (items, is_incomplete),
+            None => (Vec::new(), false),
+        };
+        items.sort_by(|item1, item2| {
+            let sort_text1 = item1.sort_text.as_deref().unwrap_or(&item1.label);
+            let sort_text2 = item2.sort_text.as_deref().unwrap_or(&item2.label);
+            sort_text1.cmp(sort_text2)
+        });
+        CompletionResponse {
+            items: CompletionItems::Lsp(items),
+            context: ResponseContext {
+                is_incomplete,
+                priority,
+                savepoint,
+            },
+            provider: CompletionProvider::Lsp(provider),
+        }
+    }
+}
+
+pub fn request_incomplete_completion_list(editor: &mut Editor, handle: TaskHandle) {
+    let handler = &mut editor.handlers.completions;
+    let mut requests = JoinSet::new();
+    let mut savepoint = None;
+    for (&provider, context) in &handler.active_completions {
+        if !context.is_incomplete {
+            continue;
+        }
+        let CompletionProvider::Lsp(ls_id) = provider else {
+            log::error!("non-lsp incomplete completion lists");
+            continue;
+        };
+        let Some(ls) = editor.language_servers.get_by_id(ls_id) else {
+            continue;
+        };
+        let (view, doc) = current!(editor);
+        let savepoint = savepoint.get_or_insert_with(|| doc.savepoint(view)).clone();
+        let request = request_completions_from_language_server(
+            ls,
+            doc,
+            view.id,
+            CompletionContext {
+                trigger_kind: CompletionTriggerKind::TRIGGER_FOR_INCOMPLETE_COMPLETIONS,
+                trigger_character: None,
+            },
+            context.priority,
+            savepoint,
+        );
+        requests.spawn(request);
+    }
+    if !requests.is_empty() {
+        tokio::spawn(replace_completions(handle, requests, true));
+    }
+}
diff --git a/helix-term/src/handlers/completion/resolve.rs b/helix-term/src/handlers/completion/resolve.rs
index 0b2c90672..802d6f51d 100644
--- a/helix-term/src/handlers/completion/resolve.rs
+++ b/helix-term/src/handlers/completion/resolve.rs
@@ -4,9 +4,10 @@
 use tokio::sync::mpsc::Sender;
 use tokio::time::{Duration, Instant};
 
-use helix_event::{send_blocking, AsyncHook, CancelRx};
+use helix_event::{send_blocking, AsyncHook, TaskController, TaskHandle};
 use helix_view::Editor;
 
+use super::LspCompletionItem;
 use crate::handlers::completion::CompletionItem;
 use crate::job;
 
@@ -22,7 +23,7 @@
 /// > 'completionItem/resolve' request is sent with the selected completion item as a parameter.
 /// > The returned completion item should have the documentation property filled in.
 pub struct ResolveHandler {
-    last_request: Option<Arc<CompletionItem>>,
+    last_request: Option<Arc<LspCompletionItem>>,
     resolver: Sender<ResolveRequest>,
 }
 
@@ -30,15 +31,11 @@ impl ResolveHandler {
     pub fn new() -> ResolveHandler {
         ResolveHandler {
             last_request: None,
-            resolver: ResolveTimeout {
-                next_request: None,
-                in_flight: None,
-            }
-            .spawn(),
+            resolver: ResolveTimeout::default().spawn(),
         }
     }
 
-    pub fn ensure_item_resolved(&mut self, editor: &mut Editor, item: &mut CompletionItem) {
+    pub fn ensure_item_resolved(&mut self, editor: &mut Editor, item: &mut LspCompletionItem) {
         if item.resolved {
             return;
         }
@@ -93,14 +90,15 @@ pub fn ensure_item_resolved(&mut self, editor: &mut Editor, item: &mut Completio
 }
 
 struct ResolveRequest {
-    item: Arc<CompletionItem>,
+    item: Arc<LspCompletionItem>,
     ls: Arc<helix_lsp::Client>,
 }
 
 #[derive(Default)]
 struct ResolveTimeout {
     next_request: Option<ResolveRequest>,
-    in_flight: Option<(helix_event::CancelTx, Arc<CompletionItem>)>,
+    in_flight: Option<Arc<LspCompletionItem>>,
+    task_controller: TaskController,
 }
 
 impl AsyncHook for ResolveTimeout {
@@ -120,7 +118,7 @@ fn handle_event(
         } else if self
             .in_flight
             .as_ref()
-            .is_some_and(|(_, old_request)| old_request.item == request.item.item)
+            .is_some_and(|old_request| old_request.item == request.item.item)
         {
             self.next_request = None;
             None
@@ -134,14 +132,14 @@ fn finish_debounce(&mut self) {
         let Some(request) = self.next_request.take() else {
             return;
         };
-        let (tx, rx) = helix_event::cancelation();
-        self.in_flight = Some((tx, request.item.clone()));
-        tokio::spawn(request.execute(rx));
+        let token = self.task_controller.restart();
+        self.in_flight = Some(request.item.clone());
+        tokio::spawn(request.execute(token));
     }
 }
 
 impl ResolveRequest {
-    async fn execute(self, cancel: CancelRx) {
+    async fn execute(self, cancel: TaskHandle) {
         let future = self.ls.resolve_completion_item(&self.item.item);
         let Some(resolved_item) = helix_event::cancelable_future(future, cancel).await else {
             return;
@@ -152,8 +150,8 @@ async fn execute(self, cancel: CancelRx) {
                 .unwrap()
                 .completion
             {
-                let resolved_item = match resolved_item {
-                    Ok(item) => CompletionItem {
+                let resolved_item = CompletionItem::Lsp(match resolved_item {
+                    Ok(item) => LspCompletionItem {
                         item,
                         resolved: true,
                         ..*self.item
@@ -166,8 +164,8 @@ async fn execute(self, cancel: CancelRx) {
                         item.resolved = true;
                         item
                     }
-                };
-                completion.replace_item(&self.item, resolved_item);
+                });
+                completion.replace_item(&*self.item, resolved_item);
             };
         })
         .await
diff --git a/helix-term/src/handlers/signature_help.rs b/helix-term/src/handlers/signature_help.rs
index aaa97b9a0..33c9e16ce 100644
--- a/helix-term/src/handlers/signature_help.rs
+++ b/helix-term/src/handlers/signature_help.rs
@@ -2,9 +2,7 @@
 use std::time::Duration;
 
 use helix_core::syntax::LanguageServerFeature;
-use helix_event::{
-    cancelable_future, cancelation, register_hook, send_blocking, CancelRx, CancelTx,
-};
+use helix_event::{cancelable_future, register_hook, send_blocking, TaskController, TaskHandle};
 use helix_lsp::lsp::{self, SignatureInformation};
 use helix_stdx::rope::RopeSliceExt;
 use helix_view::document::Mode;
@@ -18,15 +16,15 @@
 use crate::compositor::Compositor;
 use crate::events::{OnModeSwitch, PostInsertChar};
 use crate::handlers::Handlers;
-use crate::ui::lsp::{Signature, SignatureHelp};
+use crate::ui::lsp::signature_help::{Signature, SignatureHelp};
 use crate::ui::Popup;
 use crate::{job, ui};
 
-#[derive(Debug)]
+#[derive(Debug, PartialEq, Eq)]
 enum State {
     Open,
     Closed,
-    Pending { request: CancelTx },
+    Pending,
 }
 
 /// debounce timeout in ms, value taken from VSCode
@@ -37,6 +35,7 @@ enum State {
 pub(super) struct SignatureHelpHandler {
     trigger: Option<SignatureHelpInvoked>,
     state: State,
+    task_controller: TaskController,
 }
 
 impl SignatureHelpHandler {
@@ -44,6 +43,7 @@ pub fn new() -> SignatureHelpHandler {
         SignatureHelpHandler {
             trigger: None,
             state: State::Closed,
+            task_controller: TaskController::new(),
         }
     }
 }
@@ -76,12 +76,11 @@ fn handle_event(
             }
             SignatureHelpEvent::RequestComplete { open } => {
                 // don't cancel rerequest that was already triggered
-                if let State::Pending { request } = &self.state {
-                    if !request.is_closed() {
-                        return timeout;
-                    }
+                if self.state == State::Pending && self.task_controller.is_running() {
+                    return timeout;
                 }
                 self.state = if open { State::Open } else { State::Closed };
+                self.task_controller.cancel();
 
                 return timeout;
             }
@@ -94,16 +93,16 @@ fn handle_event(
 
     fn finish_debounce(&mut self) {
         let invocation = self.trigger.take().unwrap();
-        let (tx, rx) = cancelation();
-        self.state = State::Pending { request: tx };
-        job::dispatch_blocking(move |editor, _| request_signature_help(editor, invocation, rx))
+        self.state = State::Pending;
+        let handle = self.task_controller.restart();
+        job::dispatch_blocking(move |editor, _| request_signature_help(editor, invocation, handle))
     }
 }
 
 pub fn request_signature_help(
     editor: &mut Editor,
     invoked: SignatureHelpInvoked,
-    cancel: CancelRx,
+    cancel: TaskHandle,
 ) {
     let (view, doc) = current!(editor);
 
@@ -354,7 +353,7 @@ pub(super) fn register_hooks(handlers: &Handlers) {
 
     let tx = handlers.signature_hints.clone();
     register_hook!(move |event: &mut DocumentDidChange<'_>| {
-        if event.doc.config.load().lsp.auto_signature_help {
+        if event.doc.config.load().lsp.auto_signature_help && !event.ghost_transaction {
             send_blocking(&tx, SignatureHelpEvent::ReTrigger);
         }
         Ok(())
diff --git a/helix-term/src/handlers/snippet.rs b/helix-term/src/handlers/snippet.rs
new file mode 100644
index 000000000..3860d3f72
--- /dev/null
+++ b/helix-term/src/handlers/snippet.rs
@@ -0,0 +1,28 @@
+use helix_event::register_hook;
+use helix_view::events::{DocumentDidChange, DocumentFocusLost, SelectionDidChange};
+use helix_view::handlers::Handlers;
+
+pub(super) fn register_hooks(_handlers: &Handlers) {
+    register_hook!(move |event: &mut SelectionDidChange<'_>| {
+        if let Some(snippet) = &event.doc.active_snippet {
+            if !snippet.is_valid(event.doc.selection(event.view)) {
+                event.doc.active_snippet = None;
+            }
+        }
+        Ok(())
+    });
+    register_hook!(move |event: &mut DocumentDidChange<'_>| {
+        if let Some(snippet) = &mut event.doc.active_snippet {
+            let invalid = snippet.map(event.changes);
+            if invalid {
+                event.doc.active_snippet = None;
+            }
+        }
+        Ok(())
+    });
+    register_hook!(move |event: &mut DocumentFocusLost<'_>| {
+        let editor = &mut event.editor;
+        doc_mut!(editor).active_snippet = None;
+        Ok(())
+    });
+}
diff --git a/helix-term/src/health.rs b/helix-term/src/health.rs
index 0bbb5735c..faf632d87 100644
--- a/helix-term/src/health.rs
+++ b/helix-term/src/health.rs
@@ -1,10 +1,10 @@
+use crate::config::{Config, ConfigLoadError};
 use crossterm::{
-    style::{Color, Print, Stylize},
+    style::{Color, StyledContent, Stylize},
     tty::IsTty,
 };
 use helix_core::config::{default_lang_config, user_lang_config};
 use helix_loader::grammar::load_runtime_file;
-use helix_view::clipboard::get_clipboard_provider;
 use std::io::Write;
 
 #[derive(Copy, Clone)]
@@ -53,7 +53,6 @@ pub fn general() -> std::io::Result<()> {
     let lang_file = helix_loader::lang_config_file();
     let log_file = helix_loader::log_file();
     let rt_dirs = helix_loader::runtime_dirs();
-    let clipboard_provider = get_clipboard_provider();
 
     if config_file.exists() {
         writeln!(stdout, "Config file: {}", config_file.display())?;
@@ -92,7 +91,6 @@ pub fn general() -> std::io::Result<()> {
             writeln!(stdout, "{}", msg.yellow())?;
         }
     }
-    writeln!(stdout, "Clipboard provider: {}", clipboard_provider.name())?;
 
     Ok(())
 }
@@ -101,8 +99,19 @@ pub fn clipboard() -> std::io::Result<()> {
     let stdout = std::io::stdout();
     let mut stdout = stdout.lock();
 
-    let board = get_clipboard_provider();
-    match board.name().as_ref() {
+    let config = match Config::load_default() {
+        Ok(config) => config,
+        Err(ConfigLoadError::Error(err)) if err.kind() == std::io::ErrorKind::NotFound => {
+            Config::default()
+        }
+        Err(err) => {
+            writeln!(stdout, "{}", "Configuration file malformed".red())?;
+            writeln!(stdout, "{}", err)?;
+            return Ok(());
+        }
+    };
+
+    match config.editor.clipboard_provider.name().as_ref() {
         "none" => {
             writeln!(
                 stdout,
@@ -145,7 +154,7 @@ pub fn languages_all() -> std::io::Result<()> {
         }
     };
 
-    let mut headings = vec!["Language", "LSP", "DAP", "Formatter"];
+    let mut headings = vec!["Language", "Language servers", "Debug adapter", "Formatter"];
 
     for feat in TsFeature::all() {
         headings.push(feat.short_title())
@@ -155,25 +164,20 @@ pub fn languages_all() -> std::io::Result<()> {
     let column_width = terminal_cols as usize / headings.len();
     let is_terminal = std::io::stdout().is_tty();
 
-    let column = |item: &str, color: Color| {
-        let mut data = format!(
-            "{:width$}",
-            item.get(..column_width - 2)
+    let fit = |s: &str| -> StyledContent<String> {
+        format!(
+            "{:column_width$}",
+            s.get(..column_width - 2)
                 .map(|s| format!("{}", s))
-                .unwrap_or_else(|| item.to_string()),
-            width = column_width,
-        );
-        if is_terminal {
-            data = data.stylize().with(color).to_string();
-        }
-
-        // We can't directly use println!() because of
-        // https://github.com/crossterm-rs/crossterm/issues/589
-        let _ = crossterm::execute!(std::io::stdout(), Print(data));
+                .unwrap_or_else(|| s.to_string())
+        )
+        .stylize()
     };
+    let color = |s: StyledContent<String>, c: Color| if is_terminal { s.with(c) } else { s };
+    let bold = |s: StyledContent<String>| if is_terminal { s.bold() } else { s };
 
     for heading in headings {
-        column(heading, Color::White);
+        write!(stdout, "{}", bold(fit(heading)))?;
     }
     writeln!(stdout)?;
 
@@ -183,14 +187,14 @@ pub fn languages_all() -> std::io::Result<()> {
 
     let check_binary = |cmd: Option<&str>| match cmd {
         Some(cmd) => match helix_stdx::env::which(cmd) {
-            Ok(_) => column(&format!(" {}", cmd), Color::Green),
-            Err(_) => column(&format!(" {}", cmd), Color::Red),
+            Ok(_) => color(fit(&format!(" {}", cmd)), Color::Green),
+            Err(_) => color(fit(&format!(" {}", cmd)), Color::Red),
         },
-        None => column("None", Color::Yellow),
+        None => color(fit("None"), Color::Yellow),
     };
 
     for lang in &syn_loader_conf.language {
-        column(&lang.language_id, Color::Reset);
+        write!(stdout, "{}", fit(&lang.language_id))?;
 
         let mut cmds = lang.language_servers.iter().filter_map(|ls| {
             syn_loader_conf
@@ -198,28 +202,28 @@ pub fn languages_all() -> std::io::Result<()> {
                 .get(&ls.name)
                 .map(|config| config.command.as_str())
         });
-        check_binary(cmds.next());
+        write!(stdout, "{}", check_binary(cmds.next()))?;
 
         let dap = lang.debugger.as_ref().map(|dap| dap.command.as_str());
-        check_binary(dap);
+        write!(stdout, "{}", check_binary(dap))?;
 
         let formatter = lang
             .formatter
             .as_ref()
             .map(|formatter| formatter.command.as_str());
-        check_binary(formatter);
+        write!(stdout, "{}", check_binary(formatter))?;
 
         for ts_feat in TsFeature::all() {
             match load_runtime_file(&lang.language_id, ts_feat.runtime_filename()).is_ok() {
-                true => column("", Color::Green),
-                false => column("", Color::Red),
+                true => write!(stdout, "{}", color(fit(""), Color::Green))?,
+                false => write!(stdout, "{}", color(fit(""), Color::Red))?,
             }
         }
 
         writeln!(stdout)?;
 
         for cmd in cmds {
-            column("", Color::Reset);
+            write!(stdout, "{}", fit(""))?;
             check_binary(Some(cmd));
             writeln!(stdout)?;
         }
@@ -298,6 +302,8 @@ pub fn language(lang_str: String) -> std::io::Result<()> {
             .map(|formatter| formatter.command.to_string()),
     )?;
 
+    probe_parser(lang.grammar.as_ref().unwrap_or(&lang.language_id))?;
+
     for ts_feat in TsFeature::all() {
         probe_treesitter_feature(&lang_str, *ts_feat)?
     }
@@ -305,6 +311,18 @@ pub fn language(lang_str: String) -> std::io::Result<()> {
     Ok(())
 }
 
+fn probe_parser(grammar_name: &str) -> std::io::Result<()> {
+    let stdout = std::io::stdout();
+    let mut stdout = stdout.lock();
+
+    write!(stdout, "Tree-sitter parser: ")?;
+
+    match helix_loader::grammar::get_language(grammar_name) {
+        Ok(_) => writeln!(stdout, "{}", "".green()),
+        Err(_) => writeln!(stdout, "{}", "None".yellow()),
+    }
+}
+
 /// Display diagnostics about multiple LSPs and DAPs.
 fn probe_protocols<'a, I: Iterator<Item = &'a str> + 'a>(
     protocol_name: &str,
diff --git a/helix-term/src/keymap.rs b/helix-term/src/keymap.rs
index a01a05f86..020ecaf40 100644
--- a/helix-term/src/keymap.rs
+++ b/helix-term/src/keymap.rs
@@ -12,7 +12,6 @@
     borrow::Cow,
     collections::{BTreeSet, HashMap},
     ops::{Deref, DerefMut},
-    str::FromStr,
     sync::Arc,
 };
 
@@ -84,7 +83,7 @@ pub fn infobox(&self) -> Info {
                     cmd.doc()
                 }
                 KeyTrie::Node(n) => &n.name,
-                KeyTrie::Sequence(l, ..) => l,
+                KeyTrie::Sequence(_) => "[Multiple commands]",
             };
             match body.iter().position(|(_, d)| d == &desc) {
                 Some(pos) => {
@@ -134,18 +133,10 @@ fn deref_mut(&mut self) -> &mut Self::Target {
 #[derive(Debug, Clone, PartialEq)]
 pub enum KeyTrie {
     MappableCommand(MappableCommand),
-    Sequence(String, Vec<MappableCommand>),
+    Sequence(Vec<MappableCommand>),
     Node(KeyTrieNode),
 }
 
-impl KeyTrie {
-    pub const DEFAULT_SEQUENCE_LABEL: &'static str = "[Multiple commands]";
-
-    pub fn sequence(commands: Vec<MappableCommand>) -> Self {
-        Self::Sequence(Self::DEFAULT_SEQUENCE_LABEL.to_string(), commands)
-    }
-}
-
 impl<'de> Deserialize<'de> for KeyTrie {
     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
     where
@@ -199,99 +190,20 @@ fn visit_seq<S>(self, mut seq: S) -> Result<Self::Value, S::Error>
             ));
         }
 
-        Ok(KeyTrie::Sequence(
-            KeyTrie::DEFAULT_SEQUENCE_LABEL.to_string(),
-            commands,
-        ))
+        Ok(KeyTrie::Sequence(commands))
     }
 
     fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>
     where
         M: serde::de::MapAccess<'de>,
     {
-        let mut label = String::from("");
-        let mut command = None;
         let mut mapping = HashMap::new();
         let mut order = Vec::new();
-
-        while let Some(key) = map.next_key::<String>()? {
-            match &key as &str {
-                "label" => label = map.next_value::<String>()?,
-                "command" => {
-                    command = Some(match map.next_value::<toml::Value>()? {
-                        toml::Value::String(s) => {
-                            vec![MappableCommand::from_str(&s).map_err(serde::de::Error::custom)?]
-                        }
-                        toml::Value::Array(arr) => {
-                            let mut vec = Vec::with_capacity(arr.len());
-                            for value in arr {
-                                let toml::Value::String(s) = value else {
-                                    return Err(serde::de::Error::invalid_type(
-                                        serde::de::Unexpected::Other(value.type_str()),
-                                        &"string",
-                                    ));
-                                };
-                                vec.push(
-                                    MappableCommand::from_str(&s)
-                                        .map_err(serde::de::Error::custom)?,
-                                );
-                            }
-                            vec
-                        }
-                        value => {
-                            return Err(serde::de::Error::invalid_type(
-                                serde::de::Unexpected::Other(value.type_str()),
-                                &"string or array",
-                            ))
-                        }
-                    });
-                }
-                _ => {
-                    let key_event = key.parse::<KeyEvent>().map_err(serde::de::Error::custom)?;
-                    let key_trie = map.next_value::<KeyTrie>()?;
-                    mapping.insert(key_event, key_trie);
-                    order.push(key_event);
-                }
-            }
-        }
-
-        match command {
-            None => Ok(KeyTrie::Node(KeyTrieNode::new(label.as_str(), mapping, order))),
-            Some(_command) if !order.is_empty() => {
-                Err(serde::de::Error::custom("ambiguous mapping: 'command' is only valid with 'label', but I found other keys"))
-            }
-            Some(mut commands) if commands.len() == 1 => match commands.pop() {
-                None => Err(serde::de::Error::custom("UNREACHABLE!, vec is empty after checking len == 1")),
-                Some(MappableCommand::Static { .. }) if !label.is_empty() => {
-                    Err(serde::de::Error::custom("custom labels are only available for typable commands (the ones starting with ':')"))
-                }
-                Some(MappableCommand::Typable { name, args, .. }) if !label.is_empty() => {
-                    Ok(KeyTrie::MappableCommand(MappableCommand::Typable {
-                        name,
-                        args,
-                        doc: label,
-                    }))
-                }
-
-                // To label/name macro commands from config
-                Some(MappableCommand::Macro { keys, .. }) if !label.is_empty() => {
-                    Ok(KeyTrie::MappableCommand(MappableCommand::Macro {
-                        keys,
-                        name: label
-                    }))
-                }
-
-                Some(command) => Ok(KeyTrie::MappableCommand(command)),
-            }
-            Some(commands) => {
-                let label = if label.is_empty() {
-                    KeyTrie::DEFAULT_SEQUENCE_LABEL.to_string()
-                } else {
-                    label
-                };
-                Ok(KeyTrie::Sequence(label, commands))
-            },
+        while let Some((key, value)) = map.next_entry::<KeyEvent, KeyTrie>()? {
+            mapping.insert(key, value);
+            order.push(key);
         }
+        Ok(KeyTrie::Node(KeyTrieNode::new("", mapping, order)))
     }
 }
 
@@ -314,7 +226,7 @@ fn map_node(cmd_map: &mut ReverseKeymap, node: &KeyTrie, keys: &mut Vec<KeyEvent
                         keys.pop();
                     }
                 }
-                KeyTrie::Sequence(..) => {}
+                KeyTrie::Sequence(_) => {}
             };
         }
 
@@ -326,14 +238,14 @@ fn map_node(cmd_map: &mut ReverseKeymap, node: &KeyTrie, keys: &mut Vec<KeyEvent
     pub fn node(&self) -> Option<&KeyTrieNode> {
         match *self {
             KeyTrie::Node(ref node) => Some(node),
-            KeyTrie::MappableCommand(_) | KeyTrie::Sequence(..) => None,
+            KeyTrie::MappableCommand(_) | KeyTrie::Sequence(_) => None,
         }
     }
 
     pub fn node_mut(&mut self) -> Option<&mut KeyTrieNode> {
         match *self {
             KeyTrie::Node(ref mut node) => Some(node),
-            KeyTrie::MappableCommand(_) | KeyTrie::Sequence(..) => None,
+            KeyTrie::MappableCommand(_) | KeyTrie::Sequence(_) => None,
         }
     }
 
@@ -350,7 +262,7 @@ pub fn search(&self, keys: &[KeyEvent]) -> Option<&KeyTrie> {
             trie = match trie {
                 KeyTrie::Node(map) => map.get(key),
                 // leaf encountered while keys left to process
-                KeyTrie::MappableCommand(_) | KeyTrie::Sequence(..) => None,
+                KeyTrie::MappableCommand(_) | KeyTrie::Sequence(_) => None,
             }?
         }
         Some(trie)
@@ -440,7 +352,7 @@ pub fn get(&mut self, mode: Mode, key: KeyEvent) -> KeymapResult {
             Some(KeyTrie::MappableCommand(ref cmd)) => {
                 return KeymapResult::Matched(cmd.clone());
             }
-            Some(KeyTrie::Sequence(_, ref cmds)) => {
+            Some(KeyTrie::Sequence(ref cmds)) => {
                 return KeymapResult::MatchedSequence(cmds.clone());
             }
             None => return KeymapResult::NotFound,
@@ -460,7 +372,7 @@ pub fn get(&mut self, mode: Mode, key: KeyEvent) -> KeymapResult {
                 self.state.clear();
                 KeymapResult::Matched(cmd.clone())
             }
-            Some(KeyTrie::Sequence(_, cmds)) => {
+            Some(KeyTrie::Sequence(cmds)) => {
                 self.state.clear();
                 KeymapResult::MatchedSequence(cmds.clone())
             }
@@ -685,7 +597,7 @@ fn escaped_keymap() {
         let expectation = KeyTrie::Node(KeyTrieNode::new(
             "",
             hashmap! {
-                key => KeyTrie::sequence(vec!{
+                key => KeyTrie::Sequence(vec!{
                     MappableCommand::select_all,
                     MappableCommand::Typable {
                         name: "pipe".to_string(),
diff --git a/helix-term/src/keymap/default.rs b/helix-term/src/keymap/default.rs
index 5a3e8eed4..e160b2246 100644
--- a/helix-term/src/keymap/default.rs
+++ b/helix-term/src/keymap/default.rs
@@ -140,7 +140,8 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "?" => rsearch,
         "n" => search_next,
         "N" => search_prev,
-        "*" => search_selection,
+        "*" => search_selection_detect_word_boundaries,
+        "A-*" => search_selection,
 
         "u" => undo,
         "U" => redo,
@@ -221,6 +222,8 @@ pub fn default() -> HashMap<Mode, KeyTrie> {
         "space" => { "Space"
             "f" => file_picker,
             "F" => file_picker_in_current_directory,
+            "e" => file_explorer,
+            "E" => file_explorer_in_current_buffer_directory,
             "b" => buffer_picker,
             "j" => jumplist_picker,
             "s" => symbol_picker,
diff --git a/helix-term/src/lib.rs b/helix-term/src/lib.rs
index cf4fbd9fa..a371dd1cf 100644
--- a/helix-term/src/lib.rs
+++ b/helix-term/src/lib.rs
@@ -63,7 +63,7 @@ fn filter_picker_entry(entry: &DirEntry, root: &Path, dedup_symlinks: bool) -> b
             .path()
             .canonicalize()
             .ok()
-            .map_or(false, |path| !path.starts_with(root));
+            .is_some_and(|path| !path.starts_with(root));
     }
 
     true
diff --git a/helix-term/src/main.rs b/helix-term/src/main.rs
index a3a27a076..31ab85cff 100644
--- a/helix-term/src/main.rs
+++ b/helix-term/src/main.rs
@@ -40,8 +40,15 @@ fn main() -> Result<()> {
 
 #[tokio::main]
 async fn main_impl() -> Result<i32> {
-    let help = format!(
-        "\
+    let args = Args::parse_args().context("could not parse arguments")?;
+
+    helix_loader::initialize_config_file(args.config_file.clone());
+    helix_loader::initialize_log_file(args.log_file.clone());
+
+    // Help has a higher priority and should be handled separately.
+    if args.display_help {
+        print!(
+            "\
 {} {}
 {}
 {}
@@ -69,21 +76,12 @@ async fn main_impl() -> Result<i32> {
     -w, --working-dir <path>       Specify an initial working directory
     +N                             Open the first given file at line number N
 ",
-        env!("CARGO_PKG_NAME"),
-        VERSION_AND_GIT_HASH,
-        env!("CARGO_PKG_AUTHORS"),
-        env!("CARGO_PKG_DESCRIPTION"),
-        helix_loader::default_log_file().display(),
-    );
-
-    let mut args = Args::parse_args().context("could not parse arguments")?;
-
-    helix_loader::initialize_config_file(args.config_file.clone());
-    helix_loader::initialize_log_file(args.log_file.clone());
-
-    // Help has a higher priority and should be handled separately.
-    if args.display_help {
-        print!("{}", help);
+            env!("CARGO_PKG_NAME"),
+            VERSION_AND_GIT_HASH,
+            env!("CARGO_PKG_AUTHORS"),
+            env!("CARGO_PKG_DESCRIPTION"),
+            helix_loader::default_log_file().display(),
+        );
         std::process::exit(0);
     }
 
@@ -116,10 +114,6 @@ async fn main_impl() -> Result<i32> {
 
     setup_logging(args.verbosity).context("failed to initialize logging")?;
 
-    // Before setting the working directory, resolve all the paths in args.files
-    for (path, _) in &mut args.files {
-        *path = helix_stdx::path::canonicalize(&*path);
-    }
     // NOTE: Set the working directory early so the correct configuration is loaded. Be aware that
     // Application::new() depends on this logic so it must be updated if this changes.
     if let Some(path) = &args.working_directory {
@@ -154,8 +148,7 @@ async fn main_impl() -> Result<i32> {
     });
 
     // TODO: use the thread local executor to spawn the application task separately from the work pool
-    let mut app =
-        Application::new(args, config, lang_loader).context("unable to create new application")?;
+    let mut app = Application::new(args, config, lang_loader).context("unable to start Helix")?;
 
     let exit_code = app.run(&mut EventStream::new()).await?;
 
diff --git a/helix-term/src/ui/completion.rs b/helix-term/src/ui/completion.rs
index 14397bb5c..e17762bfc 100644
--- a/helix-term/src/ui/completion.rs
+++ b/helix-term/src/ui/completion.rs
@@ -1,97 +1,119 @@
+use crate::ui::{menu, Markdown, Menu, Popup, PromptEvent};
 use crate::{
     compositor::{Component, Context, Event, EventResult},
-    handlers::{completion::ResolveHandler, trigger_auto_completion},
+    handlers::completion::{
+        trigger_auto_completion, CompletionItem, CompletionResponse, LspCompletionItem,
+        ResolveHandler,
+    },
 };
+use helix_core::snippets::{ActiveSnippet, RenderedSnippet, Snippet};
+use helix_core::{self as core, chars, fuzzy::MATCHER, Change, Transaction};
+use helix_lsp::{lsp, util, OffsetEncoding};
 use helix_view::{
-    document::SavePoint,
     editor::CompleteAction,
     handlers::lsp::SignatureHelpInvoked,
-    theme::{Modifier, Style},
+    theme::{Color, Modifier, Style},
     ViewId,
 };
-use tui::{buffer::Buffer as Surface, text::Span};
-
-use std::{borrow::Cow, sync::Arc};
-
-use helix_core::{chars, Change, Transaction};
 use helix_view::{graphics::Rect, Document, Editor};
+use nucleo::{
+    pattern::{Atom, AtomKind, CaseMatching, Normalization},
+    Config, Utf32Str,
+};
+use tui::text::Spans;
+use tui::{buffer::Buffer as Surface, text::Span};
 
-use crate::ui::{menu, Markdown, Menu, Popup, PromptEvent};
-
-use helix_lsp::{lsp, util, LanguageServerId, OffsetEncoding};
+use std::cmp::Reverse;
 
 impl menu::Item for CompletionItem {
-    type Data = ();
-    fn sort_text(&self, data: &Self::Data) -> Cow<str> {
-        self.filter_text(data)
-    }
+    type Data = Style;
+
+    fn format(&self, dir_style: &Self::Data) -> menu::Row {
+        let deprecated = match self {
+            CompletionItem::Lsp(LspCompletionItem { item, .. }) => {
+                item.deprecated.unwrap_or_default()
+                    || item
+                        .tags
+                        .as_ref()
+                        .is_some_and(|tags| tags.contains(&lsp::CompletionItemTag::DEPRECATED))
+            }
+            CompletionItem::Other(_) => false,
+        };
 
-    #[inline]
-    fn filter_text(&self, _data: &Self::Data) -> Cow<str> {
-        self.item
-            .filter_text
-            .as_ref()
-            .unwrap_or(&self.item.label)
-            .as_str()
-            .into()
-    }
+        let label = match self {
+            CompletionItem::Lsp(LspCompletionItem { item, .. }) => item.label.as_str(),
+            CompletionItem::Other(core::CompletionItem { label, .. }) => label,
+        };
 
-    fn format(&self, _data: &Self::Data) -> menu::Row {
-        let deprecated = self.item.deprecated.unwrap_or_default()
-            || self.item.tags.as_ref().map_or(false, |tags| {
-                tags.contains(&lsp::CompletionItemTag::DEPRECATED)
-            });
-
-        menu::Row::new(vec![
-            menu::Cell::from(Span::styled(
-                self.item.label.as_str(),
-                if deprecated {
-                    Style::default().add_modifier(Modifier::CROSSED_OUT)
-                } else {
-                    Style::default()
-                },
-            )),
-            menu::Cell::from(match self.item.kind {
-                Some(lsp::CompletionItemKind::TEXT) => "text",
-                Some(lsp::CompletionItemKind::METHOD) => "method",
-                Some(lsp::CompletionItemKind::FUNCTION) => "function",
-                Some(lsp::CompletionItemKind::CONSTRUCTOR) => "constructor",
-                Some(lsp::CompletionItemKind::FIELD) => "field",
-                Some(lsp::CompletionItemKind::VARIABLE) => "variable",
-                Some(lsp::CompletionItemKind::CLASS) => "class",
-                Some(lsp::CompletionItemKind::INTERFACE) => "interface",
-                Some(lsp::CompletionItemKind::MODULE) => "module",
-                Some(lsp::CompletionItemKind::PROPERTY) => "property",
-                Some(lsp::CompletionItemKind::UNIT) => "unit",
-                Some(lsp::CompletionItemKind::VALUE) => "value",
-                Some(lsp::CompletionItemKind::ENUM) => "enum",
-                Some(lsp::CompletionItemKind::KEYWORD) => "keyword",
-                Some(lsp::CompletionItemKind::SNIPPET) => "snippet",
-                Some(lsp::CompletionItemKind::COLOR) => "color",
-                Some(lsp::CompletionItemKind::FILE) => "file",
-                Some(lsp::CompletionItemKind::REFERENCE) => "reference",
-                Some(lsp::CompletionItemKind::FOLDER) => "folder",
-                Some(lsp::CompletionItemKind::ENUM_MEMBER) => "enum_member",
-                Some(lsp::CompletionItemKind::CONSTANT) => "constant",
-                Some(lsp::CompletionItemKind::STRUCT) => "struct",
-                Some(lsp::CompletionItemKind::EVENT) => "event",
-                Some(lsp::CompletionItemKind::OPERATOR) => "operator",
-                Some(lsp::CompletionItemKind::TYPE_PARAMETER) => "type_param",
+        let kind = match self {
+            CompletionItem::Lsp(LspCompletionItem { item, .. }) => match item.kind {
+                Some(lsp::CompletionItemKind::TEXT) => "text".into(),
+                Some(lsp::CompletionItemKind::METHOD) => "method".into(),
+                Some(lsp::CompletionItemKind::FUNCTION) => "function".into(),
+                Some(lsp::CompletionItemKind::CONSTRUCTOR) => "constructor".into(),
+                Some(lsp::CompletionItemKind::FIELD) => "field".into(),
+                Some(lsp::CompletionItemKind::VARIABLE) => "variable".into(),
+                Some(lsp::CompletionItemKind::CLASS) => "class".into(),
+                Some(lsp::CompletionItemKind::INTERFACE) => "interface".into(),
+                Some(lsp::CompletionItemKind::MODULE) => "module".into(),
+                Some(lsp::CompletionItemKind::PROPERTY) => "property".into(),
+                Some(lsp::CompletionItemKind::UNIT) => "unit".into(),
+                Some(lsp::CompletionItemKind::VALUE) => "value".into(),
+                Some(lsp::CompletionItemKind::ENUM) => "enum".into(),
+                Some(lsp::CompletionItemKind::KEYWORD) => "keyword".into(),
+                Some(lsp::CompletionItemKind::SNIPPET) => "snippet".into(),
+                Some(lsp::CompletionItemKind::COLOR) => item
+                    .documentation
+                    .as_ref()
+                    .and_then(|docs| {
+                        let text = match docs {
+                            lsp::Documentation::String(text) => text,
+                            lsp::Documentation::MarkupContent(lsp::MarkupContent {
+                                value, ..
+                            }) => value,
+                        };
+                        // Language servers which send Color completion items tend to include a 6
+                        // digit hex code at the end for the color. The extra 1 digit is for the '#'
+                        text.get(text.len().checked_sub(7)?..)
+                    })
+                    .and_then(Color::from_hex)
+                    .map_or("color".into(), |color| {
+                        Spans::from(vec![
+                            Span::raw("color "),
+                            Span::styled("", Style::default().fg(color)),
+                        ])
+                    }),
+                Some(lsp::CompletionItemKind::FILE) => "file".into(),
+                Some(lsp::CompletionItemKind::REFERENCE) => "reference".into(),
+                Some(lsp::CompletionItemKind::FOLDER) => "folder".into(),
+                Some(lsp::CompletionItemKind::ENUM_MEMBER) => "enum_member".into(),
+                Some(lsp::CompletionItemKind::CONSTANT) => "constant".into(),
+                Some(lsp::CompletionItemKind::STRUCT) => "struct".into(),
+                Some(lsp::CompletionItemKind::EVENT) => "event".into(),
+                Some(lsp::CompletionItemKind::OPERATOR) => "operator".into(),
+                Some(lsp::CompletionItemKind::TYPE_PARAMETER) => "type_param".into(),
                 Some(kind) => {
                     log::error!("Received unknown completion item kind: {:?}", kind);
-                    ""
+                    "".into()
                 }
-                None => "",
-            }),
-        ])
-    }
-}
+                None => "".into(),
+            },
+            CompletionItem::Other(core::CompletionItem { kind, .. }) => kind.as_ref().into(),
+        };
+
+        let label = Span::styled(
+            label,
+            if deprecated {
+                Style::default().add_modifier(Modifier::CROSSED_OUT)
+            } else if kind.0[0].content == "folder" {
+                *dir_style
+            } else {
+                Style::default()
+            },
+        );
 
-#[derive(Debug, PartialEq, Default, Clone)]
-pub struct CompletionItem {
-    pub item: lsp::CompletionItem,
-    pub provider: LanguageServerId,
-    pub resolved: bool,
+        menu::Row::new([menu::Cell::from(label), menu::Cell::from(kind)])
+    }
 }
 
 /// Wraps a Menu.
@@ -100,120 +122,21 @@ pub struct Completion {
     #[allow(dead_code)]
     trigger_offset: usize,
     filter: String,
+    // TODO: move to helix-view/central handler struct in the future
     resolve_handler: ResolveHandler,
 }
 
 impl Completion {
     pub const ID: &'static str = "completion";
 
-    pub fn new(
-        editor: &Editor,
-        savepoint: Arc<SavePoint>,
-        mut items: Vec<CompletionItem>,
-        trigger_offset: usize,
-    ) -> Self {
+    pub fn new(editor: &Editor, items: Vec<CompletionItem>, trigger_offset: usize) -> Self {
         let preview_completion_insert = editor.config().preview_completion_insert;
         let replace_mode = editor.config().completion_replace;
-        // Sort completion items according to their preselect status (given by the LSP server)
-        items.sort_by_key(|item| !item.item.preselect.unwrap_or(false));
 
-        // Then create the menu
-        let menu = Menu::new(items, (), move |editor: &mut Editor, item, event| {
-            fn item_to_transaction(
-                doc: &Document,
-                view_id: ViewId,
-                item: &lsp::CompletionItem,
-                offset_encoding: OffsetEncoding,
-                trigger_offset: usize,
-                include_placeholder: bool,
-                replace_mode: bool,
-            ) -> Transaction {
-                use helix_lsp::snippet;
-                let selection = doc.selection(view_id);
-                let text = doc.text().slice(..);
-                let primary_cursor = selection.primary().cursor(text);
-
-                let (edit_offset, new_text) = if let Some(edit) = &item.text_edit {
-                    let edit = match edit {
-                        lsp::CompletionTextEdit::Edit(edit) => edit.clone(),
-                        lsp::CompletionTextEdit::InsertAndReplace(item) => {
-                            let range = if replace_mode {
-                                item.replace
-                            } else {
-                                item.insert
-                            };
-                            lsp::TextEdit::new(range, item.new_text.clone())
-                        }
-                    };
-
-                    let Some(range) =
-                        util::lsp_range_to_range(doc.text(), edit.range, offset_encoding)
-                    else {
-                        return Transaction::new(doc.text());
-                    };
-
-                    let start_offset = range.anchor as i128 - primary_cursor as i128;
-                    let end_offset = range.head as i128 - primary_cursor as i128;
-
-                    (Some((start_offset, end_offset)), edit.new_text)
-                } else {
-                    let new_text = item
-                        .insert_text
-                        .clone()
-                        .unwrap_or_else(|| item.label.clone());
-                    // check that we are still at the correct savepoint
-                    // we can still generate a transaction regardless but if the
-                    // document changed (and not just the selection) then we will
-                    // likely delete the wrong text (same if we applied an edit sent by the LS)
-                    debug_assert!(primary_cursor == trigger_offset);
-                    (None, new_text)
-                };
-
-                if matches!(item.kind, Some(lsp::CompletionItemKind::SNIPPET))
-                    || matches!(
-                        item.insert_text_format,
-                        Some(lsp::InsertTextFormat::SNIPPET)
-                    )
-                {
-                    match snippet::parse(&new_text) {
-                        Ok(snippet) => util::generate_transaction_from_snippet(
-                            doc.text(),
-                            selection,
-                            edit_offset,
-                            replace_mode,
-                            snippet,
-                            doc.line_ending.as_str(),
-                            include_placeholder,
-                            doc.tab_width(),
-                            doc.indent_width(),
-                        ),
-                        Err(err) => {
-                            log::error!(
-                                "Failed to parse snippet: {:?}, remaining output: {}",
-                                &new_text,
-                                err
-                            );
-                            Transaction::new(doc.text())
-                        }
-                    }
-                } else {
-                    util::generate_transaction_from_completion_edit(
-                        doc.text(),
-                        selection,
-                        edit_offset,
-                        replace_mode,
-                        new_text,
-                    )
-                }
-            }
-
-            fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<Change> {
-                transaction
-                    .changes_iter()
-                    .filter(|(start, end, _)| (*start..=*end).contains(&trigger_offset))
-                    .collect()
-            }
+        let dir_style = editor.theme.get("ui.text.directory");
 
+        // Then create the menu
+        let menu = Menu::new(items, dir_style, move |editor: &mut Editor, item, event| {
             let (view, doc) = current!(editor);
 
             macro_rules! language_server {
@@ -252,21 +175,28 @@ macro_rules! language_server {
                             savepoint: doc.savepoint(view),
                         })
                     }
+                    let item = item.unwrap();
+                    let context = &editor.handlers.completions.active_completions[&item.provider()];
                     // if more text was entered, remove it
-                    doc.restore(view, &savepoint, false);
+                    doc.restore(view, &context.savepoint, false);
                     // always present here
-                    let item = item.unwrap();
 
-                    let transaction = item_to_transaction(
-                        doc,
-                        view.id,
-                        &item.item,
-                        language_server!(item).offset_encoding(),
-                        trigger_offset,
-                        true,
-                        replace_mode,
-                    );
-                    doc.apply_temporary(&transaction, view.id);
+                    match item {
+                        CompletionItem::Lsp(item) => {
+                            let (transaction, _) = lsp_item_to_transaction(
+                                doc,
+                                view.id,
+                                &item.item,
+                                language_server!(item).offset_encoding(),
+                                trigger_offset,
+                                replace_mode,
+                            );
+                            doc.apply_temporary(&transaction, view.id)
+                        }
+                        CompletionItem::Other(core::CompletionItem { transaction, .. }) => {
+                            doc.apply_temporary(transaction, view.id)
+                        }
+                    };
                 }
                 PromptEvent::Update => {}
                 PromptEvent::Validate => {
@@ -275,41 +205,68 @@ macro_rules! language_server {
                     {
                         doc.restore(view, &savepoint, false);
                     }
-                    // always present here
-                    let mut item = item.unwrap().clone();
-
-                    let language_server = language_server!(item);
-                    let offset_encoding = language_server.offset_encoding();
 
-                    if !item.resolved {
-                        if let Some(resolved) =
-                            Self::resolve_completion_item(language_server, item.item.clone())
-                        {
-                            item.item = resolved;
-                        }
-                    };
+                    let item = item.unwrap();
+                    let context = &editor.handlers.completions.active_completions[&item.provider()];
                     // if more text was entered, remove it
-                    doc.restore(view, &savepoint, true);
+                    doc.restore(view, &context.savepoint, true);
                     // save an undo checkpoint before the completion
                     doc.append_changes_to_history(view);
-                    let transaction = item_to_transaction(
-                        doc,
-                        view.id,
-                        &item.item,
-                        offset_encoding,
-                        trigger_offset,
-                        false,
-                        replace_mode,
-                    );
+
+                    // item always present here
+                    let (transaction, additional_edits, snippet) = match item.clone() {
+                        CompletionItem::Lsp(mut item) => {
+                            let language_server = language_server!(item);
+
+                            // resolve item if not yet resolved
+                            if !item.resolved {
+                                if let Some(resolved_item) = Self::resolve_completion_item(
+                                    language_server,
+                                    item.item.clone(),
+                                ) {
+                                    item.item = resolved_item;
+                                }
+                            };
+
+                            let encoding = language_server.offset_encoding();
+                            let (transaction, snippet) = lsp_item_to_transaction(
+                                doc,
+                                view.id,
+                                &item.item,
+                                encoding,
+                                trigger_offset,
+                                replace_mode,
+                            );
+                            let add_edits = item.item.additional_text_edits;
+
+                            (
+                                transaction,
+                                add_edits.map(|edits| (edits, encoding)),
+                                snippet,
+                            )
+                        }
+                        CompletionItem::Other(core::CompletionItem { transaction, .. }) => {
+                            (transaction, None, None)
+                        }
+                    };
+
                     doc.apply(&transaction, view.id);
+                    let placeholder = snippet.is_some();
+                    if let Some(snippet) = snippet {
+                        doc.active_snippet = match doc.active_snippet.take() {
+                            Some(active) => active.insert_subsnippet(snippet),
+                            None => ActiveSnippet::new(snippet),
+                        };
+                    }
 
                     editor.last_completion = Some(CompleteAction::Applied {
                         trigger_offset,
                         changes: completion_changes(&transaction, trigger_offset),
+                        placeholder,
                     });
 
                     // TODO: add additional _edits to completion_changes?
-                    if let Some(additional_edits) = item.item.additional_text_edits {
+                    if let Some((additional_edits, offset_encoding)) = additional_edits {
                         if !additional_edits.is_empty() {
                             let transaction = util::generate_transaction_from_edits(
                                 doc.text(),
@@ -321,7 +278,7 @@ macro_rules! language_server {
                     }
                     // we could have just inserted a trigger char (like a `crate::` completion for rust
                     // so we want to retrigger immediately when accepting a completion.
-                    trigger_auto_completion(&editor.handlers.completions, editor, true);
+                    trigger_auto_completion(editor, true);
                 }
             };
 
@@ -358,14 +315,70 @@ macro_rules! language_server {
         };
 
         // need to recompute immediately in case start_offset != trigger_offset
-        completion
-            .popup
-            .contents_mut()
-            .score(&completion.filter, false);
+        completion.score(false);
 
         completion
     }
 
+    fn score(&mut self, incremental: bool) {
+        let pattern = &self.filter;
+        let mut matcher = MATCHER.lock();
+        matcher.config = Config::DEFAULT;
+        // slight preference towards prefix matches
+        matcher.config.prefer_prefix = true;
+        let pattern = Atom::new(
+            pattern,
+            CaseMatching::Ignore,
+            Normalization::Smart,
+            AtomKind::Fuzzy,
+            false,
+        );
+        let mut buf = Vec::new();
+        let (matches, options) = self.popup.contents_mut().update_options();
+        if incremental {
+            matches.retain_mut(|(index, score)| {
+                let option = &options[*index as usize];
+                let text = option.filter_text();
+                let new_score = pattern.score(Utf32Str::new(text, &mut buf), &mut matcher);
+                match new_score {
+                    Some(new_score) => {
+                        *score = new_score as u32 / 2;
+                        true
+                    }
+                    None => false,
+                }
+            })
+        } else {
+            matches.clear();
+            matches.extend(options.iter().enumerate().filter_map(|(i, option)| {
+                let text = option.filter_text();
+                pattern
+                    .score(Utf32Str::new(text, &mut buf), &mut matcher)
+                    .map(|score| (i as u32, score as u32 / 3))
+            }));
+        }
+        // Nucleo is meant as an FZF-like fuzzy matcher and only hides matches that are truly
+        // impossible - as in the sequence of characters just doesn't appear. That doesn't work
+        // well for completions with multiple language servers where all completions of the next
+        // server are below the current one (so you would get good suggestions from the second
+        // server below those of the first). Setting a reasonable cutoff below which to move bad
+        // completions out of the way helps with that.
+        //
+        // The score computation is a heuristic derived from Nucleo internal constants that may
+        // move upstream in the future. I want to test this out here to settle on a good number.
+        let min_score = (7 + pattern.needle_text().len() as u32 * 14) / 3;
+        matches.sort_unstable_by_key(|&(i, score)| {
+            let option = &options[i as usize];
+            (
+                score <= min_score,
+                Reverse(option.preselect()),
+                option.provider_priority(),
+                Reverse(score),
+                i,
+            )
+        });
+    }
+
     /// Synchronously resolve the given completion item. This is used when
     /// accepting a completion.
     fn resolve_completion_item(
@@ -407,14 +420,35 @@ pub fn update_filter(&mut self, c: Option<char>) {
                 }
             }
         }
-        menu.score(&self.filter, c.is_some());
+        self.score(c.is_some());
+        self.popup.contents_mut().reset_cursor();
+    }
+
+    pub fn replace_provider_completions(
+        &mut self,
+        response: &mut CompletionResponse,
+        is_incomplete: bool,
+    ) {
+        let menu = self.popup.contents_mut();
+        let (_, options) = menu.update_options();
+        if is_incomplete {
+            options.retain(|item| item.provider() != response.provider)
+        }
+        response.take_items(options);
+        self.score(false);
+        let menu = self.popup.contents_mut();
+        menu.ensure_cursor_in_bounds();
     }
 
     pub fn is_empty(&self) -> bool {
         self.popup.contents().is_empty()
     }
 
-    pub fn replace_item(&mut self, old_item: &CompletionItem, new_item: CompletionItem) {
+    pub fn replace_item(
+        &mut self,
+        old_item: &impl PartialEq<CompletionItem>,
+        new_item: CompletionItem,
+    ) {
         self.popup.contents_mut().replace_option(old_item, new_item);
     }
 
@@ -440,7 +474,7 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
             Some(option) => option,
             None => return,
         };
-        if !option.resolved {
+        if let CompletionItem::Lsp(option) = option {
             self.resolve_handler.ensure_item_resolved(cx.editor, option);
         }
         // need to render:
@@ -465,27 +499,35 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
             Markdown::new(md, cx.editor.syn_loader.clone())
         };
 
-        let mut markdown_doc = match &option.item.documentation {
-            Some(lsp::Documentation::String(contents))
-            | Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
-                kind: lsp::MarkupKind::PlainText,
-                value: contents,
-            })) => {
-                // TODO: convert to wrapped text
-                markdowned(language, option.item.detail.as_deref(), Some(contents))
-            }
-            Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
-                kind: lsp::MarkupKind::Markdown,
-                value: contents,
-            })) => {
-                // TODO: set language based on doc scope
-                markdowned(language, option.item.detail.as_deref(), Some(contents))
-            }
-            None if option.item.detail.is_some() => {
-                // TODO: set language based on doc scope
-                markdowned(language, option.item.detail.as_deref(), None)
+        let mut markdown_doc = match option {
+            CompletionItem::Lsp(option) => match &option.item.documentation {
+                Some(lsp::Documentation::String(contents))
+                | Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
+                    kind: lsp::MarkupKind::PlainText,
+                    value: contents,
+                })) => {
+                    // TODO: convert to wrapped text
+                    markdowned(language, option.item.detail.as_deref(), Some(contents))
+                }
+                Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
+                    kind: lsp::MarkupKind::Markdown,
+                    value: contents,
+                })) => {
+                    // TODO: set language based on doc scope
+                    markdowned(language, option.item.detail.as_deref(), Some(contents))
+                }
+                None if option.item.detail.is_some() => {
+                    // TODO: set language based on doc scope
+                    markdowned(language, option.item.detail.as_deref(), None)
+                }
+                None => return,
+            },
+            CompletionItem::Other(option) => {
+                let Some(doc) = option.documentation.as_deref() else {
+                    return;
+                };
+                markdowned(language, None, Some(doc))
             }
-            None => return,
         };
 
         let popup_area = self.popup.area(area, cx.editor);
@@ -537,3 +579,86 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         markdown_doc.render(doc_area, surface, cx);
     }
 }
+fn lsp_item_to_transaction(
+    doc: &Document,
+    view_id: ViewId,
+    item: &lsp::CompletionItem,
+    offset_encoding: OffsetEncoding,
+    trigger_offset: usize,
+    replace_mode: bool,
+) -> (Transaction, Option<RenderedSnippet>) {
+    let selection = doc.selection(view_id);
+    let text = doc.text().slice(..);
+    let primary_cursor = selection.primary().cursor(text);
+
+    let (edit_offset, new_text) = if let Some(edit) = &item.text_edit {
+        let edit = match edit {
+            lsp::CompletionTextEdit::Edit(edit) => edit.clone(),
+            lsp::CompletionTextEdit::InsertAndReplace(item) => {
+                let range = if replace_mode {
+                    item.replace
+                } else {
+                    item.insert
+                };
+                lsp::TextEdit::new(range, item.new_text.clone())
+            }
+        };
+
+        let Some(range) = util::lsp_range_to_range(doc.text(), edit.range, offset_encoding) else {
+            return (Transaction::new(doc.text()), None);
+        };
+
+        let start_offset = range.anchor as i128 - primary_cursor as i128;
+        let end_offset = range.head as i128 - primary_cursor as i128;
+
+        (Some((start_offset, end_offset)), edit.new_text)
+    } else {
+        let new_text = item
+            .insert_text
+            .clone()
+            .unwrap_or_else(|| item.label.clone());
+        // check that we are still at the correct savepoint
+        // we can still generate a transaction regardless but if the
+        // document changed (and not just the selection) then we will
+        // likely delete the wrong text (same if we applied an edit sent by the LS)
+        debug_assert!(primary_cursor == trigger_offset);
+        (None, new_text)
+    };
+
+    if matches!(item.kind, Some(lsp::CompletionItemKind::SNIPPET))
+        || matches!(
+            item.insert_text_format,
+            Some(lsp::InsertTextFormat::SNIPPET)
+        )
+    {
+        let Ok(snippet) = Snippet::parse(&new_text) else {
+            log::error!("Failed to parse snippet: {new_text:?}",);
+            return (Transaction::new(doc.text()), None);
+        };
+        let (transaction, snippet) = util::generate_transaction_from_snippet(
+            doc.text(),
+            selection,
+            edit_offset,
+            replace_mode,
+            snippet,
+            &mut doc.snippet_ctx(),
+        );
+        (transaction, Some(snippet))
+    } else {
+        let transaction = util::generate_transaction_from_completion_edit(
+            doc.text(),
+            selection,
+            edit_offset,
+            replace_mode,
+            new_text,
+        );
+        (transaction, None)
+    }
+}
+
+fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<Change> {
+    transaction
+        .changes_iter()
+        .filter(|(start, end, _)| (*start..=*end).contains(&trigger_offset))
+        .collect()
+}
diff --git a/helix-term/src/ui/document.rs b/helix-term/src/ui/document.rs
index 79145ba04..8423ae8e4 100644
--- a/helix-term/src/ui/document.rs
+++ b/helix-term/src/ui/document.rs
@@ -60,7 +60,9 @@ fn next(&mut self) -> Option<(Style, usize)> {
                             acc.patch(self.theme.highlight(span.0))
                         });
                     if self.kind == StyleIterKind::BaseHighlights {
-                        end = self.text.byte_to_next_char(end);
+                        // Move the end byte index to the nearest character boundary (rounding up)
+                        // and convert it to a character index.
+                        end = self.text.byte_to_char(self.text.ceil_char_boundary(end));
                     }
                     return Some((style, end));
                 }
@@ -433,7 +435,7 @@ pub fn draw_grapheme(
             Grapheme::Newline => &self.newline,
         };
 
-        let in_bounds = self.column_in_bounds(position.col + width - 1);
+        let in_bounds = self.column_in_bounds(position.col, width);
 
         if in_bounds {
             self.surface.set_string(
@@ -452,7 +454,6 @@ pub fn draw_grapheme(
             );
             self.surface.set_style(rect, style);
         }
-
         if *is_in_indent_area && !is_whitespace {
             *last_indent_level = position.col;
             *is_in_indent_area = false;
@@ -461,8 +462,8 @@ pub fn draw_grapheme(
         width
     }
 
-    pub fn column_in_bounds(&self, colum: usize) -> bool {
-        self.offset.col <= colum && colum < self.viewport.width as usize + self.offset.col
+    pub fn column_in_bounds(&self, colum: usize, width: usize) -> bool {
+        self.offset.col <= colum && colum + width <= self.offset.col + self.viewport.width as usize
     }
 
     /// Overlay indentation guides ontop of a rendered line
@@ -523,8 +524,6 @@ pub fn set_style(&mut self, mut area: Rect, style: Style) {
         self.surface.set_style(area, style);
     }
 
-    /// Sets the style of an area **within the text viewport* this accounts
-    /// both for the renderers vertical offset and its viewport
     #[allow(clippy::too_many_arguments)]
     pub fn set_string_truncated(
         &mut self,
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index f7541fe25..6fecd512b 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -1,14 +1,15 @@
 use crate::{
-    commands::{self, OnKeyCallback},
+    commands::{self, OnKeyCallback, OnKeyCallbackKind},
     compositor::{Component, Context, Event, EventResult},
     events::{OnModeSwitch, PostCommand},
+    handlers::completion::CompletionItem,
     key,
     keymap::{KeymapResult, Keymaps},
     ui::{
         document::{render_document, LinePos, TextRenderer},
         statusline,
         text_decorations::{self, Decoration, DecorationManager, InlineDiagnostics},
-        Completion, CompletionItem, ProgressSpinners,
+        Completion, ProgressSpinners,
     },
 };
 
@@ -23,20 +24,20 @@
 };
 use helix_view::{
     annotations::diagnostics::DiagnosticFilter,
-    document::{Mode, SavePoint, SCRATCH_BUFFER_NAME},
+    document::{Mode, SCRATCH_BUFFER_NAME},
     editor::{CompleteAction, CursorShapeConfig},
     graphics::{Color, CursorKind, Modifier, Rect, Style},
     input::{KeyEvent, MouseButton, MouseEvent, MouseEventKind},
     keyboard::{KeyCode, KeyModifiers},
     Document, Editor, Theme, View,
 };
-use std::{mem::take, num::NonZeroUsize, path::PathBuf, rc::Rc, sync::Arc};
+use std::{mem::take, num::NonZeroUsize, path::PathBuf, rc::Rc};
 
 use tui::{buffer::Buffer as Surface, text::Span};
 
 pub struct EditorView {
     pub keymaps: Keymaps,
-    on_next_key: Option<OnKeyCallback>,
+    on_next_key: Option<(OnKeyCallback, OnKeyCallbackKind)>,
     pseudo_pending: Vec<KeyEvent>,
     pub(crate) last_insert: (commands::MappableCommand, Vec<InsertEvent>),
     pub(crate) completion: Option<Completion>,
@@ -56,12 +57,6 @@ pub enum InsertEvent {
     RequestCompletion,
 }
 
-impl Default for EditorView {
-    fn default() -> Self {
-        Self::new(Keymaps::default())
-    }
-}
-
 impl EditorView {
     pub fn new(keymaps: Keymaps) -> Self {
         Self {
@@ -146,6 +141,9 @@ pub fn render_view(
         }
 
         if is_focused {
+            if let Some(tabstops) = Self::tabstop_highlights(doc, theme) {
+                overlay_highlights = Box::new(syntax::merge(overlay_highlights, tabstops));
+            }
             let highlights = syntax::merge(
                 overlay_highlights,
                 Self::doc_selection_highlights(
@@ -591,6 +589,24 @@ pub fn highlight_focused_view_elements(
         Vec::new()
     }
 
+    pub fn tabstop_highlights(
+        doc: &Document,
+        theme: &Theme,
+    ) -> Option<Vec<(usize, std::ops::Range<usize>)>> {
+        let snippet = doc.active_snippet.as_ref()?;
+        let highlight = theme.find_scope_index_exact("tabstop")?;
+        let mut highlights = Vec::new();
+        for tabstop in snippet.tabstops() {
+            highlights.extend(
+                tabstop
+                    .ranges
+                    .iter()
+                    .map(|range| (highlight, range.start..range.end)),
+            );
+        }
+        (!highlights.is_empty()).then_some(highlights)
+    }
+
     /// Render bufferline at the top
     pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface) {
         let scratch = PathBuf::from(SCRATCH_BUFFER_NAME); // default filename to use for scratch buffer
@@ -917,8 +933,10 @@ fn insert_mode(&mut self, cx: &mut commands::Context, event: KeyEvent) {
         if let Some(keyresult) = self.handle_keymap_event(Mode::Insert, cx, event) {
             match keyresult {
                 KeymapResult::NotFound => {
-                    if let Some(ch) = event.char() {
-                        commands::insert::insert_char(cx, ch)
+                    if !self.on_next_key(OnKeyCallbackKind::Fallback, cx, event) {
+                        if let Some(ch) = event.char() {
+                            commands::insert::insert_char(cx, ch)
+                        }
                     }
                 }
                 KeymapResult::Cancelled(pending) => {
@@ -1014,7 +1032,10 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
                 // set the register
                 cxt.register = cxt.editor.selected_register.take();
 
-                self.handle_keymap_event(mode, cxt, event);
+                let res = self.handle_keymap_event(mode, cxt, event);
+                if matches!(&res, Some(KeymapResult::NotFound)) {
+                    self.on_next_key(OnKeyCallbackKind::Fallback, cxt, event);
+                }
                 if self.keymaps.pending().is_empty() {
                     cxt.editor.count = None
                 } else {
@@ -1028,12 +1049,11 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
     pub fn set_completion(
         &mut self,
         editor: &mut Editor,
-        savepoint: Arc<SavePoint>,
         items: Vec<CompletionItem>,
         trigger_offset: usize,
         size: Rect,
     ) -> Option<Rect> {
-        let mut completion = Completion::new(editor, savepoint, items, trigger_offset);
+        let mut completion = Completion::new(editor, items, trigger_offset);
 
         if completion.is_empty() {
             // skip if we got no completion results
@@ -1049,24 +1069,40 @@ pub fn set_completion(
         Some(area)
     }
 
-    pub fn clear_completion(&mut self, editor: &mut Editor) {
+    pub fn clear_completion(&mut self, editor: &mut Editor) -> Option<OnKeyCallback> {
         self.completion = None;
+        let mut on_next_key: Option<OnKeyCallback> = None;
+        editor.handlers.completions.request_controller.restart();
+        editor.handlers.completions.active_completions.clear();
         if let Some(last_completion) = editor.last_completion.take() {
             match last_completion {
                 CompleteAction::Triggered => (),
                 CompleteAction::Applied {
                     trigger_offset,
                     changes,
-                } => self.last_insert.1.push(InsertEvent::CompletionApply {
-                    trigger_offset,
-                    changes,
-                }),
+                    placeholder,
+                } => {
+                    self.last_insert.1.push(InsertEvent::CompletionApply {
+                        trigger_offset,
+                        changes,
+                    });
+                    on_next_key = placeholder.then_some(Box::new(|cx, key| {
+                        if let Some(c) = key.char() {
+                            let (view, doc) = current!(cx.editor);
+                            if let Some(snippet) = &doc.active_snippet {
+                                doc.apply(&snippet.delete_placeholder(doc.text()), view.id);
+                            }
+                            commands::insert::insert_char(cx, c);
+                        }
+                    }))
+                }
                 CompleteAction::Selected { savepoint } => {
                     let (view, doc) = current!(editor);
                     doc.restore(view, &savepoint, false);
                 }
             }
         }
+        on_next_key
     }
 
     pub fn handle_idle_timeout(&mut self, cx: &mut commands::Context) -> EventResult {
@@ -1090,7 +1126,7 @@ fn handle_non_key_input(&mut self, cxt: &mut commands::Context) {
             modifiers: KeyModifiers::empty(),
         };
         // dismiss any pending keys
-        if let Some(on_next_key) = self.on_next_key.take() {
+        if let Some((on_next_key, _)) = self.on_next_key.take() {
             on_next_key(cxt, null_key_event);
         }
         self.handle_keymap_event(cxt.editor.mode, cxt, null_key_event);
@@ -1313,6 +1349,24 @@ fn handle_mouse_event(
             _ => EventResult::Ignored(None),
         }
     }
+    fn on_next_key(
+        &mut self,
+        kind: OnKeyCallbackKind,
+        ctx: &mut commands::Context,
+        event: KeyEvent,
+    ) -> bool {
+        if let Some((on_next_key, kind_)) = self.on_next_key.take() {
+            if kind == kind_ {
+                on_next_key(ctx, event);
+                true
+            } else {
+                self.on_next_key = Some((on_next_key, kind_));
+                false
+            }
+        } else {
+            false
+        }
+    }
 }
 
 impl Component for EditorView {
@@ -1364,10 +1418,7 @@ fn handle_event(
 
                 let mode = cx.editor.mode();
 
-                if let Some(on_next_key) = self.on_next_key.take() {
-                    // if there's a command waiting input, do that first
-                    on_next_key(&mut cx, key);
-                } else {
+                if !self.on_next_key(OnKeyCallbackKind::PseudoPending, &mut cx, key) {
                     match mode {
                         Mode::Insert => {
                             // let completion swallow the event if necessary
@@ -1398,7 +1449,15 @@ fn handle_event(
                                 if let Some(callback) = res {
                                     if callback.is_some() {
                                         // assume close_fn
-                                        self.clear_completion(cx.editor);
+                                        if let Some(cb) = self.clear_completion(cx.editor) {
+                                            if consumed {
+                                                cx.on_next_key_callback =
+                                                    Some((cb, OnKeyCallbackKind::Fallback))
+                                            } else {
+                                                self.on_next_key =
+                                                    Some((cb, OnKeyCallbackKind::Fallback));
+                                            }
+                                        }
                                     }
                                 }
                             }
@@ -1417,8 +1476,8 @@ fn handle_event(
 
                 self.on_next_key = cx.on_next_key_callback.take();
                 match self.on_next_key {
-                    Some(_) => self.pseudo_pending.push(key),
-                    None => self.pseudo_pending.clear(),
+                    Some((_, OnKeyCallbackKind::PseudoPending)) => self.pseudo_pending.push(key),
+                    _ => self.pseudo_pending.clear(),
                 }
 
                 // appease borrowck
diff --git a/helix-term/src/ui/lsp.rs b/helix-term/src/ui/lsp.rs
index b6491085b..e71cf095d 100644
--- a/helix-term/src/ui/lsp.rs
+++ b/helix-term/src/ui/lsp.rs
@@ -1,199 +1,2 @@
-use std::sync::Arc;
-
-use arc_swap::ArcSwap;
-use helix_core::syntax;
-use helix_view::graphics::{Margin, Rect, Style};
-use helix_view::input::Event;
-use tui::buffer::Buffer;
-use tui::layout::Alignment;
-use tui::text::Text;
-use tui::widgets::{BorderType, Paragraph, Widget, Wrap};
-
-use crate::compositor::{Component, Compositor, Context, EventResult};
-
-use crate::alt;
-use crate::ui::Markdown;
-
-use super::Popup;
-
-pub struct Signature {
-    pub signature: String,
-    pub signature_doc: Option<String>,
-    /// Part of signature text
-    pub active_param_range: Option<(usize, usize)>,
-}
-
-pub struct SignatureHelp {
-    language: String,
-    config_loader: Arc<ArcSwap<syntax::Loader>>,
-    active_signature: usize,
-    lsp_signature: Option<usize>,
-    signatures: Vec<Signature>,
-}
-
-impl SignatureHelp {
-    pub const ID: &'static str = "signature-help";
-
-    pub fn new(
-        language: String,
-        config_loader: Arc<ArcSwap<syntax::Loader>>,
-        active_signature: usize,
-        lsp_signature: Option<usize>,
-        signatures: Vec<Signature>,
-    ) -> Self {
-        Self {
-            language,
-            config_loader,
-            active_signature,
-            lsp_signature,
-            signatures,
-        }
-    }
-
-    pub fn active_signature(&self) -> usize {
-        self.active_signature
-    }
-
-    pub fn lsp_signature(&self) -> Option<usize> {
-        self.lsp_signature
-    }
-
-    pub fn visible_popup(compositor: &mut Compositor) -> Option<&mut Popup<Self>> {
-        compositor.find_id::<Popup<Self>>(Self::ID)
-    }
-
-    fn signature_index(&self) -> String {
-        format!("({}/{})", self.active_signature + 1, self.signatures.len())
-    }
-}
-
-impl Component for SignatureHelp {
-    fn handle_event(&mut self, event: &Event, _cx: &mut Context) -> EventResult {
-        let Event::Key(event) = event else {
-            return EventResult::Ignored(None);
-        };
-
-        if self.signatures.len() <= 1 {
-            return EventResult::Ignored(None);
-        }
-
-        match event {
-            alt!('p') => {
-                self.active_signature = self
-                    .active_signature
-                    .checked_sub(1)
-                    .unwrap_or(self.signatures.len() - 1);
-                EventResult::Consumed(None)
-            }
-            alt!('n') => {
-                self.active_signature = (self.active_signature + 1) % self.signatures.len();
-                EventResult::Consumed(None)
-            }
-            _ => EventResult::Ignored(None),
-        }
-    }
-
-    fn render(&mut self, area: Rect, surface: &mut Buffer, cx: &mut Context) {
-        let margin = Margin::horizontal(1);
-
-        let signature = &self.signatures[self.active_signature];
-
-        let active_param_span = signature.active_param_range.map(|(start, end)| {
-            vec![(
-                cx.editor
-                    .theme
-                    .find_scope_index_exact("ui.selection")
-                    .unwrap(),
-                start..end,
-            )]
-        });
-
-        let sig = &self.signatures[self.active_signature];
-        let sig_text = crate::ui::markdown::highlighted_code_block(
-            sig.signature.as_str(),
-            &self.language,
-            Some(&cx.editor.theme),
-            Arc::clone(&self.config_loader),
-            active_param_span,
-        );
-
-        if self.signatures.len() > 1 {
-            let signature_index = self.signature_index();
-            let text = Text::from(signature_index);
-            let paragraph = Paragraph::new(&text).alignment(Alignment::Right);
-            paragraph.render(area.clip_top(1).with_height(1).clip_right(1), surface);
-        }
-
-        let (_, sig_text_height) = crate::ui::text::required_size(&sig_text, area.width);
-        let sig_text_area = area.clip_top(1).with_height(sig_text_height);
-        let sig_text_area = sig_text_area.inner(margin).intersection(surface.area);
-        let sig_text_para = Paragraph::new(&sig_text).wrap(Wrap { trim: false });
-        sig_text_para.render(sig_text_area, surface);
-
-        if sig.signature_doc.is_none() {
-            return;
-        }
-
-        let sep_style = Style::default();
-        let borders = BorderType::line_symbols(BorderType::Plain);
-        for x in sig_text_area.left()..sig_text_area.right() {
-            if let Some(cell) = surface.get_mut(x, sig_text_area.bottom()) {
-                cell.set_symbol(borders.horizontal).set_style(sep_style);
-            }
-        }
-
-        let sig_doc = match &sig.signature_doc {
-            None => return,
-            Some(doc) => Markdown::new(doc.clone(), Arc::clone(&self.config_loader)),
-        };
-        let sig_doc = sig_doc.parse(Some(&cx.editor.theme));
-        let sig_doc_area = area
-            .clip_top(sig_text_area.height + 2)
-            .clip_bottom(u16::from(cx.editor.popup_border()));
-        let sig_doc_para = Paragraph::new(&sig_doc)
-            .wrap(Wrap { trim: false })
-            .scroll((cx.scroll.unwrap_or_default() as u16, 0));
-        sig_doc_para.render(sig_doc_area.inner(margin), surface);
-    }
-
-    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
-        const PADDING: u16 = 2;
-        const SEPARATOR_HEIGHT: u16 = 1;
-
-        let sig = &self.signatures[self.active_signature];
-
-        let max_text_width = viewport.0.saturating_sub(PADDING).clamp(10, 120);
-
-        let signature_text = crate::ui::markdown::highlighted_code_block(
-            sig.signature.as_str(),
-            &self.language,
-            None,
-            Arc::clone(&self.config_loader),
-            None,
-        );
-        let (sig_width, sig_height) =
-            crate::ui::text::required_size(&signature_text, max_text_width);
-
-        let (width, height) = match sig.signature_doc {
-            Some(ref doc) => {
-                let doc_md = Markdown::new(doc.clone(), Arc::clone(&self.config_loader));
-                let doc_text = doc_md.parse(None);
-                let (doc_width, doc_height) =
-                    crate::ui::text::required_size(&doc_text, max_text_width);
-                (
-                    sig_width.max(doc_width),
-                    sig_height + SEPARATOR_HEIGHT + doc_height,
-                )
-            }
-            None => (sig_width, sig_height),
-        };
-
-        let sig_index_width = if self.signatures.len() > 1 {
-            self.signature_index().len() + 1
-        } else {
-            0
-        };
-
-        Some((width + PADDING + sig_index_width as u16, height + PADDING))
-    }
-}
+pub mod hover;
+pub mod signature_help;
diff --git a/helix-term/src/ui/lsp/hover.rs b/helix-term/src/ui/lsp/hover.rs
new file mode 100644
index 000000000..3617dbe6d
--- /dev/null
+++ b/helix-term/src/ui/lsp/hover.rs
@@ -0,0 +1,183 @@
+use std::sync::Arc;
+
+use arc_swap::ArcSwap;
+use helix_core::syntax;
+use helix_lsp::lsp;
+use helix_view::graphics::{Margin, Rect, Style};
+use helix_view::input::Event;
+use tui::buffer::Buffer;
+use tui::widgets::{BorderType, Paragraph, Widget, Wrap};
+
+use crate::compositor::{Component, Context, EventResult};
+
+use crate::alt;
+use crate::ui::Markdown;
+
+pub struct Hover {
+    active_index: usize,
+    contents: Vec<(Option<Markdown>, Markdown)>,
+}
+
+impl Hover {
+    pub const ID: &'static str = "hover";
+
+    pub fn new(
+        hovers: Vec<(String, lsp::Hover)>,
+        config_loader: Arc<ArcSwap<syntax::Loader>>,
+    ) -> Self {
+        let n_hovers = hovers.len();
+        let contents = hovers
+            .into_iter()
+            .enumerate()
+            .map(|(idx, (server_name, hover))| {
+                let header = (n_hovers > 1).then(|| {
+                    Markdown::new(
+                        format!("**[{}/{}] {}**", idx + 1, n_hovers, server_name),
+                        config_loader.clone(),
+                    )
+                });
+                let body = Markdown::new(
+                    hover_contents_to_string(hover.contents),
+                    config_loader.clone(),
+                );
+                (header, body)
+            })
+            .collect();
+
+        Self {
+            active_index: usize::default(),
+            contents,
+        }
+    }
+
+    fn has_header(&self) -> bool {
+        self.contents.len() > 1
+    }
+
+    fn content(&self) -> &(Option<Markdown>, Markdown) {
+        &self.contents[self.active_index]
+    }
+
+    fn set_index(&mut self, index: usize) {
+        assert!((0..self.contents.len()).contains(&index));
+        self.active_index = index;
+    }
+}
+
+const PADDING_HORIZONTAL: u16 = 2;
+const PADDING_TOP: u16 = 1;
+const PADDING_BOTTOM: u16 = 1;
+const HEADER_HEIGHT: u16 = 1;
+const SEPARATOR_HEIGHT: u16 = 1;
+
+impl Component for Hover {
+    fn render(&mut self, area: Rect, surface: &mut Buffer, cx: &mut Context) {
+        let margin = Margin::all(1);
+        let area = area.inner(margin);
+
+        let (header, contents) = self.content();
+
+        // show header and border only when more than one results
+        if let Some(header) = header {
+            // header LSP Name
+            let header = header.parse(Some(&cx.editor.theme));
+            let header = Paragraph::new(&header);
+            header.render(area.with_height(HEADER_HEIGHT), surface);
+
+            // border
+            let sep_style = Style::default();
+            let borders = BorderType::line_symbols(BorderType::Plain);
+            for x in area.left()..area.right() {
+                if let Some(cell) = surface.get_mut(x, area.top() + HEADER_HEIGHT) {
+                    cell.set_symbol(borders.horizontal).set_style(sep_style);
+                }
+            }
+        }
+
+        // hover content
+        let contents = contents.parse(Some(&cx.editor.theme));
+        let contents_area = area.clip_top(if self.has_header() {
+            HEADER_HEIGHT + SEPARATOR_HEIGHT
+        } else {
+            0
+        });
+        let contents_para = Paragraph::new(&contents)
+            .wrap(Wrap { trim: false })
+            .scroll((cx.scroll.unwrap_or_default() as u16, 0));
+        contents_para.render(contents_area, surface);
+    }
+
+    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
+        let max_text_width = viewport.0.saturating_sub(PADDING_HORIZONTAL).clamp(10, 120);
+
+        let (header, contents) = self.content();
+
+        let header_width = header
+            .as_ref()
+            .map(|header| {
+                let header = header.parse(None);
+                let (width, _height) = crate::ui::text::required_size(&header, max_text_width);
+                width
+            })
+            .unwrap_or_default();
+
+        let contents = contents.parse(None);
+        let (content_width, content_height) =
+            crate::ui::text::required_size(&contents, max_text_width);
+
+        let width = PADDING_HORIZONTAL + header_width.max(content_width);
+        let height = if self.has_header() {
+            PADDING_TOP + HEADER_HEIGHT + SEPARATOR_HEIGHT + content_height + PADDING_BOTTOM
+        } else {
+            PADDING_TOP + content_height + PADDING_BOTTOM
+        };
+
+        Some((width, height))
+    }
+
+    fn handle_event(&mut self, event: &Event, _ctx: &mut Context) -> EventResult {
+        let Event::Key(event) = event else {
+            return EventResult::Ignored(None);
+        };
+
+        match event {
+            alt!('p') => {
+                let index = self
+                    .active_index
+                    .checked_sub(1)
+                    .unwrap_or(self.contents.len() - 1);
+                self.set_index(index);
+                EventResult::Consumed(None)
+            }
+            alt!('n') => {
+                self.set_index((self.active_index + 1) % self.contents.len());
+                EventResult::Consumed(None)
+            }
+            _ => EventResult::Ignored(None),
+        }
+    }
+}
+
+fn hover_contents_to_string(contents: lsp::HoverContents) -> String {
+    fn marked_string_to_markdown(contents: lsp::MarkedString) -> String {
+        match contents {
+            lsp::MarkedString::String(contents) => contents,
+            lsp::MarkedString::LanguageString(string) => {
+                if string.language == "markdown" {
+                    string.value
+                } else {
+                    format!("```{}\n{}\n```", string.language, string.value)
+                }
+            }
+        }
+    }
+    match contents {
+        lsp::HoverContents::Scalar(contents) => marked_string_to_markdown(contents),
+        lsp::HoverContents::Array(contents) => contents
+            .into_iter()
+            .map(marked_string_to_markdown)
+            .collect::<Vec<_>>()
+            .join("\n\n"),
+        lsp::HoverContents::Markup(contents) => contents.value,
+    }
+}
diff --git a/helix-term/src/ui/lsp/signature_help.rs b/helix-term/src/ui/lsp/signature_help.rs
new file mode 100644
index 000000000..2dee81241
--- /dev/null
+++ b/helix-term/src/ui/lsp/signature_help.rs
@@ -0,0 +1,209 @@
+use std::sync::Arc;
+
+use arc_swap::ArcSwap;
+use helix_core::syntax;
+use helix_view::graphics::{Margin, Rect, Style};
+use helix_view::input::Event;
+use tui::buffer::Buffer;
+use tui::layout::Alignment;
+use tui::text::Text;
+use tui::widgets::{BorderType, Paragraph, Widget, Wrap};
+
+use crate::compositor::{Component, Compositor, Context, EventResult};
+
+use crate::alt;
+use crate::ui::Markdown;
+
+use crate::ui::Popup;
+
+pub struct Signature {
+    pub signature: String,
+    pub signature_doc: Option<String>,
+    /// Part of signature text
+    pub active_param_range: Option<(usize, usize)>,
+}
+
+pub struct SignatureHelp {
+    language: String,
+    config_loader: Arc<ArcSwap<syntax::Loader>>,
+    active_signature: usize,
+    lsp_signature: Option<usize>,
+    signatures: Vec<Signature>,
+}
+
+impl SignatureHelp {
+    pub const ID: &'static str = "signature-help";
+
+    pub fn new(
+        language: String,
+        config_loader: Arc<ArcSwap<syntax::Loader>>,
+        active_signature: usize,
+        lsp_signature: Option<usize>,
+        signatures: Vec<Signature>,
+    ) -> Self {
+        Self {
+            language,
+            config_loader,
+            active_signature,
+            lsp_signature,
+            signatures,
+        }
+    }
+
+    pub fn active_signature(&self) -> usize {
+        self.active_signature
+    }
+
+    pub fn lsp_signature(&self) -> Option<usize> {
+        self.lsp_signature
+    }
+
+    pub fn visible_popup(compositor: &mut Compositor) -> Option<&mut Popup<Self>> {
+        compositor.find_id::<Popup<Self>>(Self::ID)
+    }
+
+    fn signature_index(&self) -> String {
+        format!("({}/{})", self.active_signature + 1, self.signatures.len())
+    }
+}
+
+impl Component for SignatureHelp {
+    fn handle_event(&mut self, event: &Event, _cx: &mut Context) -> EventResult {
+        let Event::Key(event) = event else {
+            return EventResult::Ignored(None);
+        };
+
+        if self.signatures.len() <= 1 {
+            return EventResult::Ignored(None);
+        }
+
+        match event {
+            alt!('p') => {
+                self.active_signature = self
+                    .active_signature
+                    .checked_sub(1)
+                    .unwrap_or(self.signatures.len() - 1);
+                EventResult::Consumed(None)
+            }
+            alt!('n') => {
+                self.active_signature = (self.active_signature + 1) % self.signatures.len();
+                EventResult::Consumed(None)
+            }
+            _ => EventResult::Ignored(None),
+        }
+    }
+
+    fn render(&mut self, area: Rect, surface: &mut Buffer, cx: &mut Context) {
+        let margin = Margin::horizontal(1);
+
+        let signature = self
+            .signatures
+            .get(self.active_signature)
+            .unwrap_or_else(|| &self.signatures[0]);
+
+        let active_param_span = signature.active_param_range.map(|(start, end)| {
+            vec![(
+                cx.editor
+                    .theme
+                    .find_scope_index_exact("ui.selection")
+                    .unwrap(),
+                start..end,
+            )]
+        });
+
+        let signature = self
+            .signatures
+            .get(self.active_signature)
+            .unwrap_or_else(|| &self.signatures[0]);
+
+        let sig_text = crate::ui::markdown::highlighted_code_block(
+            signature.signature.as_str(),
+            &self.language,
+            Some(&cx.editor.theme),
+            Arc::clone(&self.config_loader),
+            active_param_span,
+        );
+
+        if self.signatures.len() > 1 {
+            let signature_index = self.signature_index();
+            let text = Text::from(signature_index);
+            let paragraph = Paragraph::new(&text).alignment(Alignment::Right);
+            paragraph.render(area.clip_top(1).with_height(1).clip_right(1), surface);
+        }
+
+        let (_, sig_text_height) = crate::ui::text::required_size(&sig_text, area.width);
+        let sig_text_area = area.clip_top(1).with_height(sig_text_height);
+        let sig_text_area = sig_text_area.inner(margin).intersection(surface.area);
+        let sig_text_para = Paragraph::new(&sig_text).wrap(Wrap { trim: false });
+        sig_text_para.render(sig_text_area, surface);
+
+        if signature.signature_doc.is_none() {
+            return;
+        }
+
+        let sep_style = Style::default();
+        let borders = BorderType::line_symbols(BorderType::Plain);
+        for x in sig_text_area.left()..sig_text_area.right() {
+            if let Some(cell) = surface.get_mut(x, sig_text_area.bottom()) {
+                cell.set_symbol(borders.horizontal).set_style(sep_style);
+            }
+        }
+
+        let sig_doc = match &signature.signature_doc {
+            None => return,
+            Some(doc) => Markdown::new(doc.clone(), Arc::clone(&self.config_loader)),
+        };
+        let sig_doc = sig_doc.parse(Some(&cx.editor.theme));
+        let sig_doc_area = area
+            .clip_top(sig_text_area.height + 2)
+            .clip_bottom(u16::from(cx.editor.popup_border()));
+        let sig_doc_para = Paragraph::new(&sig_doc)
+            .wrap(Wrap { trim: false })
+            .scroll((cx.scroll.unwrap_or_default() as u16, 0));
+        sig_doc_para.render(sig_doc_area.inner(margin), surface);
+    }
+
+    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
+        const PADDING: u16 = 2;
+        const SEPARATOR_HEIGHT: u16 = 1;
+
+        let signature = self
+            .signatures
+            .get(self.active_signature)
+            .unwrap_or_else(|| &self.signatures[0]);
+
+        let max_text_width = viewport.0.saturating_sub(PADDING).clamp(10, 120);
+
+        let signature_text = crate::ui::markdown::highlighted_code_block(
+            signature.signature.as_str(),
+            &self.language,
+            None,
+            Arc::clone(&self.config_loader),
+            None,
+        );
+        let (sig_width, sig_height) =
+            crate::ui::text::required_size(&signature_text, max_text_width);
+
+        let (width, height) = match signature.signature_doc {
+            Some(ref doc) => {
+                let doc_md = Markdown::new(doc.clone(), Arc::clone(&self.config_loader));
+                let doc_text = doc_md.parse(None);
+                let (doc_width, doc_height) =
+                    crate::ui::text::required_size(&doc_text, max_text_width);
+                (
+                    sig_width.max(doc_width),
+                    sig_height + SEPARATOR_HEIGHT + doc_height,
+                )
+            }
+            None => (sig_width, sig_height),
+        };
+
+        let sig_index_width = if self.signatures.len() > 1 {
+            self.signature_index().len() + 1
+        } else {
+            0
+        };
+
+        Some((width + PADDING + sig_index_width as u16, height + PADDING))
+    }
+}
diff --git a/helix-term/src/ui/markdown.rs b/helix-term/src/ui/markdown.rs
index 96614443f..fe581b5ad 100644
--- a/helix-term/src/ui/markdown.rs
+++ b/helix-term/src/ui/markdown.rs
@@ -132,6 +132,9 @@ pub struct Markdown {
 impl Markdown {
     const TEXT_STYLE: &'static str = "ui.text";
     const BLOCK_STYLE: &'static str = "markup.raw.inline";
+    const RULE_STYLE: &'static str = "punctuation.special";
+    const UNNUMBERED_LIST_STYLE: &'static str = "markup.list.unnumbered";
+    const NUMBERED_LIST_STYLE: &'static str = "markup.list.numbered";
     const HEADING_STYLES: [&'static str; 6] = [
         "markup.heading.1",
         "markup.heading.2",
@@ -178,6 +181,9 @@ fn push_line<'a>(spans: &mut Vec<Span<'a>>, lines: &mut Vec<Spans<'a>>) {
         let get_theme = |key: &str| -> Style { theme.map(|t| t.get(key)).unwrap_or_default() };
         let text_style = get_theme(Self::TEXT_STYLE);
         let code_style = get_theme(Self::BLOCK_STYLE);
+        let numbered_list_style = get_theme(Self::NUMBERED_LIST_STYLE);
+        let unnumbered_list_style = get_theme(Self::UNNUMBERED_LIST_STYLE);
+        let rule_style = get_theme(Self::RULE_STYLE);
         let heading_styles: Vec<Style> = Self::HEADING_STYLES
             .iter()
             .map(|key| get_theme(key))
@@ -227,10 +233,12 @@ fn push_line<'a>(spans: &mut Vec<Span<'a>>, lines: &mut Vec<Spans<'a>>) {
                     tags.push(Tag::Item);
 
                     // get the appropriate bullet for the current list
-                    let bullet = list_stack
+                    let (bullet, bullet_style) = list_stack
                         .last()
                         .unwrap_or(&None) // use the '- ' bullet in case the list stack would be empty
-                        .map_or(String::from("- "), |number| format!("{}. ", number));
+                        .map_or((String::from(" "), unnumbered_list_style), |number| {
+                            (format!("{}. ", number), numbered_list_style)
+                        });
 
                     // increment the current list number if there is one
                     if let Some(v) = list_stack.last_mut().unwrap_or(&mut None).as_mut() {
@@ -238,7 +246,7 @@ fn push_line<'a>(spans: &mut Vec<Span<'a>>, lines: &mut Vec<Spans<'a>>) {
                     }
 
                     let prefix = get_indent(list_stack.len()) + bullet.as_str();
-                    spans.push(Span::from(prefix));
+                    spans.push(Span::styled(prefix, bullet_style));
                 }
                 Event::Start(tag) => {
                     tags.push(tag);
@@ -314,7 +322,7 @@ fn push_line<'a>(spans: &mut Vec<Span<'a>>, lines: &mut Vec<Spans<'a>>) {
                     }
                 }
                 Event::Rule => {
-                    lines.push(Spans::from(Span::styled("---", code_style)));
+                    lines.push(Spans::from(Span::styled("", rule_style)));
                     lines.push(Spans::default());
                 }
                 // TaskListMarker(bool) true if checked
diff --git a/helix-term/src/ui/menu.rs b/helix-term/src/ui/menu.rs
index c120d0b25..76e50229a 100644
--- a/helix-term/src/ui/menu.rs
+++ b/helix-term/src/ui/menu.rs
@@ -1,12 +1,7 @@
-use std::{borrow::Cow, cmp::Reverse};
-
 use crate::{
     compositor::{Callback, Component, Compositor, Context, Event, EventResult},
     ctrl, key, shift,
 };
-use helix_core::fuzzy::MATCHER;
-use nucleo::pattern::{Atom, AtomKind, CaseMatching, Normalization};
-use nucleo::{Config, Utf32Str};
 use tui::{buffer::Buffer as Surface, widgets::Table};
 
 pub use tui::widgets::{Cell, Row};
@@ -19,16 +14,6 @@ pub trait Item: Sync + Send + 'static {
     type Data: Sync + Send + 'static;
 
     fn format(&self, data: &Self::Data) -> Row;
-
-    fn sort_text(&self, data: &Self::Data) -> Cow<str> {
-        let label: String = self.format(data).cell_text().collect();
-        label.into()
-    }
-
-    fn filter_text(&self, data: &Self::Data) -> Cow<str> {
-        let label: String = self.format(data).cell_text().collect();
-        label.into()
-    }
 }
 
 pub type MenuCallback<T> = Box<dyn Fn(&mut Editor, Option<&T>, MenuEvent)>;
@@ -77,49 +62,30 @@ pub fn new(
         }
     }
 
-    pub fn score(&mut self, pattern: &str, incremental: bool) {
-        let mut matcher = MATCHER.lock();
-        matcher.config = Config::DEFAULT;
-        let pattern = Atom::new(
-            pattern,
-            CaseMatching::Ignore,
-            Normalization::Smart,
-            AtomKind::Fuzzy,
-            false,
-        );
-        let mut buf = Vec::new();
-        if incremental {
-            self.matches.retain_mut(|(index, score)| {
-                let option = &self.options[*index as usize];
-                let text = option.filter_text(&self.editor_data);
-                let new_score = pattern.score(Utf32Str::new(&text, &mut buf), &mut matcher);
-                match new_score {
-                    Some(new_score) => {
-                        *score = new_score as u32;
-                        true
-                    }
-                    None => false,
-                }
-            })
-        } else {
-            self.matches.clear();
-            let matches = self.options.iter().enumerate().filter_map(|(i, option)| {
-                let text = option.filter_text(&self.editor_data);
-                pattern
-                    .score(Utf32Str::new(&text, &mut buf), &mut matcher)
-                    .map(|score| (i as u32, score as u32))
-            });
-            self.matches.extend(matches);
-        }
-        self.matches
-            .sort_unstable_by_key(|&(i, score)| (Reverse(score), i));
-
-        // reset cursor position
+    pub fn reset_cursor(&mut self) {
         self.cursor = None;
         self.scroll = 0;
         self.recalculate = true;
     }
 
+    pub fn update_options(&mut self) -> (&mut Vec<(u32, u32)>, &mut Vec<T>) {
+        self.recalculate = true;
+        (&mut self.matches, &mut self.options)
+    }
+
+    pub fn ensure_cursor_in_bounds(&mut self) {
+        if self.matches.is_empty() {
+            self.cursor = None;
+            self.scroll = 0;
+        } else {
+            self.scroll = 0;
+            self.recalculate = true;
+            if let Some(cursor) = &mut self.cursor {
+                *cursor = (*cursor).min(self.matches.len() - 1)
+            }
+        }
+    }
+
     pub fn clear(&mut self) {
         self.matches.clear();
 
@@ -228,7 +194,7 @@ pub fn len(&self) -> usize {
 }
 
 impl<T: Item + PartialEq> Menu<T> {
-    pub fn replace_option(&mut self, old_option: &T, new_option: T) {
+    pub fn replace_option(&mut self, old_option: &impl PartialEq<T>, new_option: T) {
         for option in &mut self.options {
             if old_option == option {
                 *option = new_option;
@@ -346,10 +312,6 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
 
         let win_height = area.height as usize;
 
-        const fn div_ceil(a: usize, b: usize) -> usize {
-            (a + b - 1) / b
-        }
-
         let rows = options
             .iter()
             .map(|option| option.format(&self.editor_data));
@@ -390,7 +352,7 @@ const fn div_ceil(a: usize, b: usize) -> usize {
 
         let scroll_style = theme.get("ui.menu.scroll");
         if !fits {
-            let scroll_height = div_ceil(win_height.pow(2), len).min(win_height);
+            let scroll_height = win_height.pow(2).div_ceil(len).min(win_height);
             let scroll_line = (win_height - scroll_height) * scroll
                 / std::cmp::max(1, len.saturating_sub(win_height));
 
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index 6a3e198c1..bbd71ca5c 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -8,7 +8,7 @@
 pub mod overlay;
 pub mod picker;
 pub mod popup;
-mod prompt;
+pub mod prompt;
 mod spinner;
 mod statusline;
 mod text;
@@ -17,9 +17,10 @@
 use crate::compositor::Compositor;
 use crate::filter_picker_entry;
 use crate::job::{self, Callback};
-pub use completion::{Completion, CompletionItem};
+pub use completion::Completion;
 pub use editor::EditorView;
 use helix_stdx::rope;
+use helix_view::theme::Style;
 pub use markdown::Markdown;
 pub use menu::Menu;
 pub use picker::{Column as PickerColumn, FileLocation, Picker};
@@ -29,9 +30,22 @@
 pub use text::Text;
 
 use helix_view::Editor;
+use tui::text::Span;
 
+use std::path::Path;
 use std::{error::Error, path::PathBuf};
 
+struct Utf8PathBuf {
+    path: String,
+    is_dir: bool,
+}
+
+impl AsRef<str> for Utf8PathBuf {
+    fn as_ref(&self) -> &str {
+        &self.path
+    }
+}
+
 pub fn prompt(
     cx: &mut crate::commands::Context,
     prompt: std::borrow::Cow<'static, str>,
@@ -265,7 +279,76 @@ pub fn file_picker(root: PathBuf, config: &helix_view::editor::Config) -> FilePi
     picker
 }
 
+type FileExplorer = Picker<(PathBuf, bool), (PathBuf, Style)>;
+
+pub fn file_explorer(root: PathBuf, editor: &Editor) -> Result<FileExplorer, std::io::Error> {
+    let directory_style = editor.theme.get("ui.text.directory");
+    let directory_content = directory_content(&root)?;
+
+    let columns = [PickerColumn::new(
+        "path",
+        |(path, is_dir): &(PathBuf, bool), (root, directory_style): &(PathBuf, Style)| {
+            let name = path.strip_prefix(root).unwrap_or(path).to_string_lossy();
+            if *is_dir {
+                Span::styled(format!("{}/", name), *directory_style).into()
+            } else {
+                name.into()
+            }
+        },
+    )];
+    let picker = Picker::new(
+        columns,
+        0,
+        directory_content,
+        (root, directory_style),
+        move |cx, (path, is_dir): &(PathBuf, bool), action| {
+            if *is_dir {
+                let new_root = helix_stdx::path::normalize(path);
+                let callback = Box::pin(async move {
+                    let call: Callback =
+                        Callback::EditorCompositor(Box::new(move |editor, compositor| {
+                            if let Ok(picker) = file_explorer(new_root, editor) {
+                                compositor.push(Box::new(overlay::overlaid(picker)));
+                            }
+                        }));
+                    Ok(call)
+                });
+                cx.jobs.callback(callback);
+            } else if let Err(e) = cx.editor.open(path, action) {
+                let err = if let Some(err) = e.source() {
+                    format!("{}", err)
+                } else {
+                    format!("unable to open \"{}\"", path.display())
+                };
+                cx.editor.set_error(err);
+            }
+        },
+    )
+    .with_preview(|_editor, (path, _is_dir)| Some((path.as_path().into(), None)));
+
+    Ok(picker)
+}
+
+fn directory_content(path: &Path) -> Result<Vec<(PathBuf, bool)>, std::io::Error> {
+    let mut content: Vec<_> = std::fs::read_dir(path)?
+        .flatten()
+        .map(|entry| {
+            (
+                entry.path(),
+                entry.file_type().is_ok_and(|file_type| file_type.is_dir()),
+            )
+        })
+        .collect();
+
+    content.sort_by(|(path1, is_dir1), (path2, is_dir2)| (!is_dir1, path1).cmp(&(!is_dir2, path2)));
+    if path.parent().is_some() {
+        content.insert(0, (path.join(".."), true));
+    }
+    Ok(content)
+}
+
 pub mod completers {
+    use super::Utf8PathBuf;
     use crate::ui::prompt::Completion;
     use helix_core::fuzzy::fuzzy_match;
     use helix_core::syntax::LanguageServerFeature;
@@ -274,6 +357,7 @@ pub mod completers {
     use helix_view::{editor::Config, Editor};
     use once_cell::sync::Lazy;
     use std::borrow::Cow;
+    use tui::text::Span;
 
     pub type Completer = fn(&Editor, &str) -> Vec<Completion>;
 
@@ -290,7 +374,7 @@ pub fn buffer(editor: &Editor, input: &str) -> Vec<Completion> {
 
         fuzzy_match(input, names, true)
             .into_iter()
-            .map(|(name, _)| ((0..), name))
+            .map(|(name, _)| ((0..), name.into()))
             .collect()
     }
 
@@ -326,6 +410,15 @@ fn get_keys(value: &serde_json::Value, vec: &mut Vec<String>, scope: Option<&str
         }
     }
 
+    pub fn language_servers(editor: &Editor, input: &str) -> Vec<Completion> {
+        let language_servers = doc!(editor).language_servers().map(|ls| ls.name());
+
+        fuzzy_match(input, language_servers, false)
+            .into_iter()
+            .map(|(name, _)| ((0..), Span::raw(name.to_string())))
+            .collect()
+    }
+
     pub fn setting(_editor: &Editor, input: &str) -> Vec<Completion> {
         static KEYS: Lazy<Vec<String>> = Lazy::new(|| {
             let mut keys = Vec::new();
@@ -336,7 +429,7 @@ pub fn setting(_editor: &Editor, input: &str) -> Vec<Completion> {
 
         fuzzy_match(input, &*KEYS, false)
             .into_iter()
-            .map(|(name, _)| ((0..), name.into()))
+            .map(|(name, _)| ((0..), Span::raw(name)))
             .collect()
     }
 
@@ -350,7 +443,7 @@ pub fn filename_with_git_ignore(
         git_ignore: bool,
     ) -> Vec<Completion> {
         filename_impl(editor, input, git_ignore, |entry| {
-            let is_dir = entry.file_type().map_or(false, |entry| entry.is_dir());
+            let is_dir = entry.file_type().is_some_and(|entry| entry.is_dir());
 
             if is_dir {
                 FileMatch::AcceptIncomplete
@@ -401,7 +494,7 @@ pub fn directory_with_git_ignore(
         git_ignore: bool,
     ) -> Vec<Completion> {
         filename_impl(editor, input, git_ignore, |entry| {
-            let is_dir = entry.file_type().map_or(false, |entry| entry.is_dir());
+            let is_dir = entry.file_type().is_some_and(|entry| entry.is_dir());
 
             if is_dir {
                 FileMatch::Accept
@@ -424,7 +517,7 @@ enum FileMatch {
 
     // TODO: we could return an iter/lazy thing so it can fetch as many as it needs.
     fn filename_impl<F>(
-        _editor: &Editor,
+        editor: &Editor,
         input: &str,
         git_ignore: bool,
         filter_fn: F,
@@ -482,7 +575,7 @@ fn filename_impl<F>(
                         return None;
                     }
 
-                    //let is_dir = entry.file_type().map_or(false, |entry| entry.is_dir());
+                    let is_dir = entry.file_type().is_some_and(|entry| entry.is_dir());
 
                     let path = entry.path();
                     let mut path = if is_tilde {
@@ -501,23 +594,35 @@ fn filename_impl<F>(
                     }
 
                     let path = path.into_os_string().into_string().ok()?;
-                    Some(Cow::from(path))
+                    Some(Utf8PathBuf { path, is_dir })
                 })
             }) // TODO: unwrap or skip
-            .filter(|path| !path.is_empty());
+            .filter(|path| !path.path.is_empty());
+
+        let directory_color = editor.theme.get("ui.text.directory");
+
+        let style_from_file = |file: Utf8PathBuf| {
+            if file.is_dir {
+                Span::styled(file.path, directory_color)
+            } else {
+                Span::raw(file.path)
+            }
+        };
 
         // if empty, return a list of dirs and files in current dir
         if let Some(file_name) = file_name {
             let range = (input.len().saturating_sub(file_name.len()))..;
             fuzzy_match(&file_name, files, true)
                 .into_iter()
-                .map(|(name, _)| (range.clone(), name))
+                .map(|(name, _)| (range.clone(), style_from_file(name)))
                 .collect()
 
             // TODO: complete to longest common match
         } else {
-            let mut files: Vec<_> = files.map(|file| (end.clone(), file)).collect();
-            files.sort_unstable_by(|(_, path1), (_, path2)| path1.cmp(path2));
+            let mut files: Vec<_> = files
+                .map(|file| (end.clone(), style_from_file(file)))
+                .collect();
+            files.sort_unstable_by(|(_, path1), (_, path2)| path1.content.cmp(&path2.content));
             files
         }
     }
diff --git a/helix-term/src/ui/picker.rs b/helix-term/src/ui/picker.rs
index 82fe96891..3986ad479 100644
--- a/helix-term/src/ui/picker.rs
+++ b/helix-term/src/ui/picker.rs
@@ -32,7 +32,7 @@
     borrow::Cow,
     collections::HashMap,
     io::Read,
-    path::{Path, PathBuf},
+    path::Path,
     sync::{
         atomic::{self, AtomicUsize},
         Arc,
@@ -63,30 +63,16 @@
 #[derive(PartialEq, Eq, Hash)]
 pub enum PathOrId<'a> {
     Id(DocumentId),
-    // See [PathOrId::from_path_buf]: this will eventually become `Path(&Path)`.
-    Path(Cow<'a, Path>),
-}
-
-impl<'a> PathOrId<'a> {
-    /// Creates a [PathOrId] from a PathBuf
-    ///
-    /// # Deprecated
-    /// The owned version of PathOrId will be removed in a future refactor
-    /// and replaced with `&'a Path`. See the caller of this function for
-    /// more details on its removal.
-    #[deprecated]
-    pub fn from_path_buf(path_buf: PathBuf) -> Self {
-        Self::Path(Cow::Owned(path_buf))
-    }
+    Path(&'a Path),
 }
 
 impl<'a> From<&'a Path> for PathOrId<'a> {
     fn from(path: &'a Path) -> Self {
-        Self::Path(Cow::Borrowed(path))
+        Self::Path(path)
     }
 }
 
-impl<'a> From<DocumentId> for PathOrId<'a> {
+impl From<DocumentId> for PathOrId<'_> {
     fn from(v: DocumentId) -> Self {
         Self::Id(v)
     }
@@ -99,6 +85,7 @@ fn from(v: DocumentId) -> Self {
 
 pub enum CachedPreview {
     Document(Box<Document>),
+    Directory(Vec<(String, bool)>),
     Binary,
     LargeFile,
     NotFound,
@@ -120,12 +107,20 @@ fn document(&self) -> Option<&Document> {
         }
     }
 
+    fn dir_content(&self) -> Option<&Vec<(String, bool)>> {
+        match self {
+            Preview::Cached(CachedPreview::Directory(dir_content)) => Some(dir_content),
+            _ => None,
+        }
+    }
+
     /// Alternate text to show for the preview.
     fn placeholder(&self) -> &str {
         match *self {
             Self::EditorDocument(_) => "<Invalid file location>",
             Self::Cached(preview) => match preview {
                 CachedPreview::Document(_) => "<Invalid file location>",
+                CachedPreview::Directory(_) => "<Invalid directory location>",
                 CachedPreview::Binary => "<Binary file>",
                 CachedPreview::LargeFile => "<File too large to preview>",
                 CachedPreview::NotFound => "<File not found>",
@@ -581,7 +576,6 @@ fn get_preview<'picker, 'editor>(
 
         match path_or_id {
             PathOrId::Path(path) => {
-                let path = path.as_ref();
                 if let Some(doc) = editor.document_by_path(path) {
                     return Some((Preview::EditorDocument(doc), range));
                 }
@@ -599,33 +593,58 @@ fn get_preview<'picker, 'editor>(
                 }
 
                 let path: Arc<Path> = path.into();
-                let data = std::fs::File::open(&path).and_then(|file| {
-                    let metadata = file.metadata()?;
-                    // Read up to 1kb to detect the content type
-                    let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
-                    let content_type = content_inspector::inspect(&self.read_buffer[..n]);
-                    self.read_buffer.clear();
-                    Ok((metadata, content_type))
-                });
-                let preview = data
-                    .map(
-                        |(metadata, content_type)| match (metadata.len(), content_type) {
-                            (_, content_inspector::ContentType::BINARY) => CachedPreview::Binary,
-                            (size, _) if size > MAX_FILE_SIZE_FOR_PREVIEW => {
-                                CachedPreview::LargeFile
+                let preview = std::fs::metadata(&path)
+                    .and_then(|metadata| {
+                        if metadata.is_dir() {
+                            let files = super::directory_content(&path)?;
+                            let file_names: Vec<_> = files
+                                .iter()
+                                .filter_map(|(path, is_dir)| {
+                                    let name = path.file_name()?.to_string_lossy();
+                                    if *is_dir {
+                                        Some((format!("{}/", name), true))
+                                    } else {
+                                        Some((name.into_owned(), false))
+                                    }
+                                })
+                                .collect();
+                            Ok(CachedPreview::Directory(file_names))
+                        } else if metadata.is_file() {
+                            if metadata.len() > MAX_FILE_SIZE_FOR_PREVIEW {
+                                return Ok(CachedPreview::LargeFile);
                             }
-                            _ => Document::open(&path, None, None, editor.config.clone())
-                                .map(|doc| {
+                            let content_type = std::fs::File::open(&path).and_then(|file| {
+                                // Read up to 1kb to detect the content type
+                                let n = file.take(1024).read_to_end(&mut self.read_buffer)?;
+                                let content_type =
+                                    content_inspector::inspect(&self.read_buffer[..n]);
+                                self.read_buffer.clear();
+                                Ok(content_type)
+                            })?;
+                            if content_type.is_binary() {
+                                return Ok(CachedPreview::Binary);
+                            }
+                            Document::open(&path, None, None, editor.config.clone()).map_or(
+                                Err(std::io::Error::new(
+                                    std::io::ErrorKind::NotFound,
+                                    "Cannot open document",
+                                )),
+                                |doc| {
                                     // Asynchronously highlight the new document
                                     helix_event::send_blocking(
                                         &self.preview_highlight_handler,
                                         path.clone(),
                                     );
-                                    CachedPreview::Document(Box::new(doc))
-                                })
-                                .unwrap_or(CachedPreview::NotFound),
-                        },
-                    )
+                                    Ok(CachedPreview::Document(Box::new(doc)))
+                                },
+                            )
+                        } else {
+                            Err(std::io::Error::new(
+                                std::io::ErrorKind::NotFound,
+                                "Neither a dir, nor a file",
+                            ))
+                        }
+                    })
                     .unwrap_or(CachedPreview::NotFound);
                 self.preview_cache.insert(path.clone(), preview);
                 Some((Preview::Cached(&self.preview_cache[&path]), range))
@@ -664,10 +683,6 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
 
         // -- Render the input bar:
 
-        let area = inner.clip_left(1).with_height(1);
-        // render the prompt first since it will clear its background
-        self.prompt.render(area, surface, cx);
-
         let count = format!(
             "{}{}/{}",
             if status.running || self.matcher.active_injectors() > 0 {
@@ -678,6 +693,13 @@ fn render_picker(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context)
             snapshot.matched_item_count(),
             snapshot.item_count(),
         );
+
+        let area = inner.clip_left(1).with_height(1);
+        let line_area = area.clip_right(count.len() as u16 + 1);
+
+        // render the prompt first since it will clear its background
+        self.prompt.render(line_area, surface, cx);
+
         surface.set_stringn(
             (area.x + area.width).saturating_sub(count.len() as u16 + 1),
             area.y,
@@ -838,6 +860,7 @@ fn render_preview(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context
         // clear area
         let background = cx.editor.theme.get("ui.background");
         let text = cx.editor.theme.get("ui.text");
+        let directory = cx.editor.theme.get("ui.text.directory");
         surface.clear_with(area, background);
 
         const BLOCK: Block<'_> = Block::bordered();
@@ -859,6 +882,22 @@ fn render_preview(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context
                     doc
                 }
                 _ => {
+                    if let Some(dir_content) = preview.dir_content() {
+                        for (i, (path, is_dir)) in
+                            dir_content.iter().take(inner.height as usize).enumerate()
+                        {
+                            let style = if *is_dir { directory } else { text };
+                            surface.set_stringn(
+                                inner.x,
+                                inner.y + i as u16,
+                                path,
+                                inner.width as usize,
+                                style,
+                            );
+                        }
+                        return;
+                    }
+
                     let alt_text = preview.placeholder();
                     let x = inner.x + inner.width.saturating_sub(alt_text.len() as u16) / 2;
                     let y = inner.y + inner.height / 2;
@@ -1029,7 +1068,7 @@ fn handle_event(&mut self, event: &Event, ctx: &mut Context) -> EventResult {
             key!(Esc) | ctrl!('c') => return close_fn(self),
             alt!(Enter) => {
                 if let Some(option) = self.selection() {
-                    (self.callback_fn)(ctx, option, Action::Load);
+                    (self.callback_fn)(ctx, option, Action::Replace);
                 }
             }
             key!(Enter) => {
@@ -1088,7 +1127,15 @@ fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
         let inner = block.inner(area);
 
         // prompt area
-        let area = inner.clip_left(1).with_height(1);
+        let render_preview =
+            self.show_preview && self.file_fn.is_some() && area.width > MIN_AREA_WIDTH_FOR_PREVIEW;
+
+        let picker_width = if render_preview {
+            area.width / 2
+        } else {
+            area.width
+        };
+        let area = inner.clip_left(1).with_height(1).with_width(picker_width);
 
         self.prompt.cursor(area, editor)
     }
diff --git a/helix-term/src/ui/popup.rs b/helix-term/src/ui/popup.rs
index 2cefaf61b..db77492db 100644
--- a/helix-term/src/ui/popup.rs
+++ b/helix-term/src/ui/popup.rs
@@ -344,12 +344,8 @@ fn render(&mut self, viewport: Rect, surface: &mut Surface, cx: &mut Context) {
             let fits = len <= win_height;
             let scroll_style = cx.editor.theme.get("ui.menu.scroll");
 
-            const fn div_ceil(a: usize, b: usize) -> usize {
-                (a + b - 1) / b
-            }
-
             if !fits {
-                let scroll_height = div_ceil(win_height.pow(2), len).min(win_height);
+                let scroll_height = win_height.pow(2).div_ceil(len).min(win_height);
                 let scroll_line = (win_height - scroll_height) * scroll
                     / std::cmp::max(1, len.saturating_sub(win_height));
 
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index 6ba2fcb9e..03adeb05b 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -8,6 +8,7 @@
 use std::sync::Arc;
 use std::{borrow::Cow, ops::RangeFrom};
 use tui::buffer::Buffer as Surface;
+use tui::text::Span;
 use tui::widgets::{Block, Widget};
 
 use helix_core::{
@@ -19,7 +20,8 @@
 };
 
 type PromptCharHandler = Box<dyn Fn(&mut Prompt, char, &Context)>;
-pub type Completion = (RangeFrom<usize>, Cow<'static, str>);
+
+pub type Completion = (RangeFrom<usize>, Span<'static>);
 type CompletionFn = Box<dyn FnMut(&Editor, &str) -> Vec<Completion>>;
 type CallbackFn = Box<dyn FnMut(&mut Context, &str, PromptEvent)>;
 pub type DocFn = Box<dyn Fn(&str) -> Option<Cow<str>>>;
@@ -28,6 +30,12 @@ pub struct Prompt {
     prompt: Cow<'static, str>,
     line: String,
     cursor: usize,
+    // Fields used for Component callbacks and rendering:
+    line_area: Rect,
+    anchor: usize,
+    truncate_start: bool,
+    truncate_end: bool,
+    // ---
     completion: Vec<Completion>,
     selection: Option<usize>,
     history_register: Option<char>,
@@ -80,6 +88,10 @@ pub fn new(
             prompt,
             line: String::new(),
             cursor: 0,
+            line_area: Rect::default(),
+            anchor: 0,
+            truncate_start: false,
+            truncate_end: false,
             completion: Vec::new(),
             selection: None,
             history_register,
@@ -233,15 +245,7 @@ fn eval_movement(&self, movement: Movement) -> usize {
                 position
             }
             Movement::StartOfLine => 0,
-            Movement::EndOfLine => {
-                let mut cursor =
-                    GraphemeCursor::new(self.line.len().saturating_sub(1), self.line.len(), false);
-                if let Ok(Some(pos)) = cursor.next_boundary(&self.line, 0) {
-                    pos
-                } else {
-                    self.cursor
-                }
-            }
+            Movement::EndOfLine => self.line.len(),
             Movement::None => self.cursor,
         }
     }
@@ -382,7 +386,7 @@ pub fn change_completion_selection(&mut self, direction: CompletionDirection) {
 
         let (range, item) = &self.completion[index];
 
-        self.line.replace_range(range.clone(), item);
+        self.line.replace_range(range.clone(), &item.content);
 
         self.move_end();
     }
@@ -395,7 +399,7 @@ pub fn exit_selection(&mut self) {
 const BASE_WIDTH: u16 = 30;
 
 impl Prompt {
-    pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context) {
+    pub fn render_prompt(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         let theme = &cx.editor.theme;
         let prompt_color = theme.get("ui.text");
         let completion_color = theme.get("ui.menu");
@@ -407,7 +411,7 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
         let max_len = self
             .completion
             .iter()
-            .map(|(_, completion)| completion.len() as u16)
+            .map(|(_, completion)| completion.content.len() as u16)
             .max()
             .unwrap_or(BASE_WIDTH)
             .max(BASE_WIDTH);
@@ -415,7 +419,8 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
         let cols = std::cmp::max(1, area.width / max_len);
         let col_width = (area.width.saturating_sub(cols)) / cols;
 
-        let height = ((self.completion.len() as u16 + cols - 1) / cols)
+        let height = (self.completion.len() as u16)
+            .div_ceil(cols)
             .min(10) // at most 10 rows (or less)
             .min(area.height.saturating_sub(1));
 
@@ -445,18 +450,22 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
             for (i, (_range, completion)) in
                 self.completion.iter().enumerate().skip(offset).take(items)
             {
-                let color = if Some(i) == self.selection {
-                    selected_color // TODO: just invert bg
+                let is_selected = Some(i) == self.selection;
+
+                let completion_item_style = if is_selected {
+                    selected_color
                 } else {
-                    completion_color
+                    completion_color.patch(completion.style)
                 };
+
                 surface.set_stringn(
                     area.x + col * (1 + col_width),
                     area.y + row,
-                    completion,
+                    &completion.content,
                     col_width.saturating_sub(1) as usize,
-                    color,
+                    completion_item_style,
                 );
+
                 row += 1;
                 if row > area.height - 1 {
                     row = 0;
@@ -500,11 +509,20 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
         // render buffer text
         surface.set_string(area.x, area.y + line, &self.prompt, prompt_color);
 
-        let line_area = area.clip_left(self.prompt.len() as u16).clip_top(line);
+        self.line_area = area
+            .clip_left(self.prompt.len() as u16)
+            .clip_top(line)
+            .clip_right(2);
+
         if self.line.is_empty() {
             // Show the most recently entered value as a suggestion.
             if let Some(suggestion) = self.first_history_completion(cx.editor) {
-                surface.set_string(line_area.x, line_area.y, suggestion, suggestion_color);
+                surface.set_string(
+                    self.line_area.x,
+                    self.line_area.y,
+                    suggestion,
+                    suggestion_color,
+                );
             }
         } else if let Some((language, loader)) = self.language.as_ref() {
             let mut text: ui::text::Text = crate::ui::markdown::highlighted_code_block(
@@ -515,9 +533,34 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
                 None,
             )
             .into();
-            text.render(line_area, surface, cx);
+            text.render(self.line_area, surface, cx);
         } else {
-            surface.set_string(line_area.x, line_area.y, self.line.clone(), prompt_color);
+            if self.line.len() < self.line_area.width as usize {
+                self.anchor = 0;
+            } else if self.cursor < self.anchor {
+                self.anchor = self.cursor;
+            } else if self.cursor - self.anchor > self.line_area.width as usize {
+                self.anchor = self.cursor - self.line_area.width as usize;
+            }
+
+            self.truncate_start = self.anchor > 0;
+            self.truncate_end = self.line.len() - self.anchor > self.line_area.width as usize;
+
+            // if we keep inserting characters just before the end elipsis, we move the anchor
+            // so that those new characters are displayed
+            if self.truncate_end && self.cursor - self.anchor >= self.line_area.width as usize {
+                self.anchor += 1;
+            }
+
+            surface.set_string_anchored(
+                self.line_area.x,
+                self.line_area.y,
+                self.truncate_start,
+                self.truncate_end,
+                &self.line.as_str()[self.anchor..],
+                self.line_area.width as usize - self.truncate_end as usize,
+                |_| prompt_color,
+            );
         }
     }
 }
@@ -687,14 +730,27 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
     }
 
     fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind) {
+        let area = area
+            .clip_left(self.prompt.len() as u16)
+            .clip_right(if self.prompt.len() > 0 { 0 } else { 2 });
+
+        let anchor = self.anchor.min(self.line.len().saturating_sub(1));
+        let mut col = area.left() as usize
+            + UnicodeWidthStr::width(&self.line[anchor..self.cursor.max(anchor)]);
+
+        // ensure the cursor does not go beyond elipses
+        if self.truncate_end && self.cursor - self.anchor >= self.line_area.width as usize {
+            col -= 1;
+        }
+
+        if self.truncate_start && self.cursor == self.anchor {
+            col += 1;
+        }
+
         let line = area.height as usize - 1;
+
         (
-            Some(Position::new(
-                area.y as usize + line,
-                area.x as usize
-                    + self.prompt.len()
-                    + UnicodeWidthStr::width(&self.line[..self.cursor]),
-            )),
+            Some(Position::new(area.y as usize + line, col)),
             editor.config().cursor_shape.from_mode(Mode::Insert),
         )
     }
diff --git a/helix-term/src/ui/text_decorations.rs b/helix-term/src/ui/text_decorations.rs
index 630af5817..931ea4311 100644
--- a/helix-term/src/ui/text_decorations.rs
+++ b/helix-term/src/ui/text_decorations.rs
@@ -164,7 +164,7 @@ fn decorate_grapheme(
         renderer: &mut TextRenderer,
         grapheme: &FormattedGrapheme,
     ) -> usize {
-        if renderer.column_in_bounds(grapheme.visual_pos.col)
+        if renderer.column_in_bounds(grapheme.visual_pos.col, grapheme.width())
             && renderer.offset.row < grapheme.visual_pos.row
         {
             let position = grapheme.visual_pos - renderer.offset;
diff --git a/helix-term/src/ui/text_decorations/diagnostics.rs b/helix-term/src/ui/text_decorations/diagnostics.rs
index 2d9e83700..fb82bcf54 100644
--- a/helix-term/src/ui/text_decorations/diagnostics.rs
+++ b/helix-term/src/ui/text_decorations/diagnostics.rs
@@ -98,20 +98,29 @@ fn draw_decoration_at(&mut self, g: &'static str, severity: Severity, col: u16,
     fn draw_eol_diagnostic(&mut self, diag: &Diagnostic, row: u16, col: usize) -> u16 {
         let style = self.styles.severity_style(diag.severity());
         let width = self.renderer.viewport.width;
-        if !self.renderer.column_in_bounds(col + 1) {
-            return 0;
+        let start_col = (col - self.renderer.offset.col) as u16;
+        let mut end_col = start_col;
+        let mut draw_col = (col + 1) as u16;
+
+        for line in diag.message.lines() {
+            if !self.renderer.column_in_bounds(draw_col as usize, 1) {
+                break;
+            }
+
+            (end_col, _) = self.renderer.set_string_truncated(
+                self.renderer.viewport.x + draw_col,
+                row,
+                line,
+                width.saturating_sub(draw_col) as usize,
+                |_| style,
+                true,
+                false,
+            );
+
+            draw_col = end_col - self.renderer.viewport.x + 2; // double space between lines
         }
-        let col = (col - self.renderer.offset.col) as u16;
-        let (new_col, _) = self.renderer.set_string_truncated(
-            self.renderer.viewport.x + col + 1,
-            row,
-            &diag.message,
-            width.saturating_sub(col + 1) as usize,
-            |_| style,
-            true,
-            false,
-        );
-        new_col - col
+
+        end_col - start_col
     }
 
     fn draw_diagnostic(&mut self, diag: &Diagnostic, col: u16, next_severity: Option<Severity>) {
diff --git a/helix-term/tests/test/commands.rs b/helix-term/tests/test/commands.rs
index 9f196827f..2af1a054f 100644
--- a/helix-term/tests/test/commands.rs
+++ b/helix-term/tests/test/commands.rs
@@ -2,9 +2,30 @@
 
 use super::*;
 
+mod insert;
 mod movement;
 mod write;
 
+#[tokio::test(flavor = "multi_thread")]
+async fn search_selection_detect_word_boundaries_at_eof() -> anyhow::Result<()> {
+    // <https://github.com/helix-editor/helix/issues/12609>
+    test((
+        indoc! {"\
+            #[o|]#ne
+            two
+            three"},
+        "gej*h",
+        indoc! {"\
+            one
+            two
+            three#[
+            |]#"},
+    ))
+    .await?;
+
+    Ok(())
+}
+
 #[tokio::test(flavor = "multi_thread")]
 async fn test_selection_duplication() -> anyhow::Result<()> {
     // Forward
@@ -632,6 +653,49 @@ async fn test_join_selections_space() -> anyhow::Result<()> {
     Ok(())
 }
 
+#[tokio::test(flavor = "multi_thread")]
+async fn test_join_selections_comment() -> anyhow::Result<()> {
+    test((
+        indoc! {"\
+            /// #[a|]#bc
+            /// def
+        "},
+        ":lang rust<ret>J",
+        indoc! {"\
+            /// #[a|]#bc def
+        "},
+    ))
+    .await?;
+
+    // Only join if the comment token matches the previous line.
+    test((
+        indoc! {"\
+            #[| // a
+            // b
+            /// c
+            /// d
+            e
+            /// f
+            // g]#
+        "},
+        ":lang rust<ret>J",
+        indoc! {"\
+            #[| // a b /// c d e f // g]#
+        "},
+    ))
+    .await?;
+
+    test((
+        "#[|\t// Join comments
+\t// with indent]#",
+        ":lang go<ret>J",
+        "#[|\t// Join comments with indent]#",
+    ))
+    .await?;
+
+    Ok(())
+}
+
 #[tokio::test(flavor = "multi_thread")]
 async fn test_read_file() -> anyhow::Result<()> {
     let mut file = tempfile::NamedTempFile::new()?;
@@ -729,3 +793,30 @@ fn foo() {
 
     Ok(())
 }
+
+#[tokio::test(flavor = "multi_thread")]
+async fn macro_play_within_macro_record() -> anyhow::Result<()> {
+    // <https://github.com/helix-editor/helix/issues/12697>
+    //
+    // * `"aQihello<esc>Q` record a macro to register 'a' which inserts "hello"
+    // * `Q"aq<space>world<esc>Q` record a macro to the default macro register which plays the
+    //   macro in register 'a' and then inserts " world"
+    // * `%d` clear the buffer
+    // * `q` replay the macro in the default macro register
+    // * `i<ret>` add a newline at the end
+    //
+    // The inner macro in register 'a' should replay within the outer macro exactly once to insert
+    // "hello world".
+    test((
+        indoc! {"\
+            #[|]#
+        "},
+        r#""aQihello<esc>QQ"aqi<space>world<esc>Q%dqi<ret>"#,
+        indoc! {"\
+            hello world
+            #[|]#"},
+    ))
+    .await?;
+
+    Ok(())
+}
diff --git a/helix-term/tests/test/commands/insert.rs b/helix-term/tests/test/commands/insert.rs
new file mode 100644
index 000000000..a3da5fb22
--- /dev/null
+++ b/helix-term/tests/test/commands/insert.rs
@@ -0,0 +1,514 @@
+use super::*;
+
+#[tokio::test(flavor = "multi_thread")]
+async fn change_line_above_comment() -> anyhow::Result<()> {
+    // <https://github.com/helix-editor/helix/issues/12570>
+    test((
+        indoc! {"\
+        #[fn main() {}
+        |]#// a comment
+        "},
+        ":lang rust<ret>c",
+        indoc! {"\
+        #[
+        |]#// a comment
+        "},
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn insert_newline_many_selections() -> anyhow::Result<()> {
+    test((
+        indoc! {"\
+            #(|o)#ne
+            #(|t)#wo
+            #[|t]#hree
+            "},
+        "i<ret>",
+        indoc! {"\
+            \n#(|o)#ne
+
+            #(|t)#wo
+
+            #[|t]#hree
+            "},
+    ))
+    .await?;
+
+    // In this case the global offset that adjusts selections for inserted and deleted text
+    // should become negative because more text is deleted than is inserted.
+    test((
+        indoc! {"\
+            #[|]#          #(|)#          #(|)#
+            #(|)#          #(|)#          #(|)#
+            "},
+        "i<ret>",
+        indoc! {"\
+            \n#[|]#
+            #(|)#
+            #(|)#
+
+            #(|)#
+            #(|)#
+            #(|)#
+            "},
+    ))
+    .await?;
+
+    // <https://github.com/helix-editor/helix/issues/12495>
+    test((
+        indoc! {"\
+            id #(|1)#,Item #(|1)#,cost #(|1)#,location #(|1)#
+            id #(|2)#,Item #(|2)#,cost #(|2)#,location #(|2)#
+            id #(|1)##(|0)#,Item #(|1)##(|0)#,cost #(|1)##(|0)#,location #(|1)##[|0]#"},
+        "i<ret>",
+        indoc! {"\
+            id
+            #(|1)#,Item
+            #(|1)#,cost
+            #(|1)#,location
+            #(|1)#
+            id
+            #(|2)#,Item
+            #(|2)#,cost
+            #(|2)#,location
+            #(|2)#
+            id
+            #(|1)#
+            #(|0)#,Item
+            #(|1)#
+            #(|0)#,cost
+            #(|1)#
+            #(|0)#,location
+            #(|1)#
+            #[|0]#"},
+    ))
+    .await?;
+
+    // <https://github.com/helix-editor/helix/issues/12461>
+    test((
+        indoc! {"\
+            real R #(||)# real R @ real R
+            #(||)# real R + ureal R i #(||)# real R - ureal R i
+            #(||)# real R + i #(||)# real R - i #(||)# real R infnan i
+            #(||)# + ureal R i #(||)# - ureal R i
+            #(||)# infnan i #(||)# + i #[||]# - i"},
+        "i<ret>",
+        indoc! {"\
+            real R
+            #(||)# real R @ real R
+
+            #(||)# real R + ureal R i
+            #(||)# real R - ureal R i
+
+            #(||)# real R + i
+            #(||)# real R - i
+            #(||)# real R infnan i
+
+            #(||)# + ureal R i
+            #(||)# - ureal R i
+
+            #(||)# infnan i
+            #(||)# + i
+            #[||]# - i"},
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn insert_newline_trim_trailing_whitespace() -> anyhow::Result<()> {
+    // Trailing whitespace is trimmed.
+    test((
+        indoc! {"\
+            hello#[|
+            ]#world
+            "}
+        .replace('', " "),
+        "i<ret>",
+        indoc! {"\
+            hello
+            #[|
+            ]#world
+            "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    // Whitespace that would become trailing is trimmed too.
+    test((
+        indoc! {"\
+            hello#[|w]#orld
+            "}
+        .replace('', " "),
+        "i<ret>",
+        indoc! {"\
+            hello
+            #[|w]#orld
+            "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    // Only whitespace before the cursor is trimmed.
+    test((
+        indoc! {"\
+            hello#[|]#world
+            "}
+        .replace('', " "),
+        "i<ret>",
+        indoc! {"\
+            hello
+            #[|]#world
+            "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn insert_newline_continue_line_comment() -> anyhow::Result<()> {
+    // `insert_newline` continues a single line comment
+    test((
+        indoc! {"\
+            // Hello world!#[|
+            ]#
+            "},
+        ":lang rust<ret>i<ret>",
+        indoc! {"\
+            // Hello world!
+            // #[|
+            ]#
+            "},
+    ))
+    .await?;
+
+    // The comment is not continued if the cursor is before the comment token. (Note that we
+    // are entering insert-mode with `I`.)
+    test((
+        indoc! {"\
+            // Hello world!#[|
+            ]#
+            "},
+        ":lang rust<ret>I<ret>",
+        indoc! {"\
+            \n#[/|]#/ Hello world!
+            "},
+    ))
+    .await?;
+
+    // `insert_newline` again clears the whitespace on the first continued comment and continues
+    // the comment again.
+    test((
+        indoc! {"\
+            // Hello world!
+            // #[|
+            ]#
+            "},
+        ":lang rust<ret>i<ret>",
+        indoc! {"\
+            // Hello world!
+            //
+            // #[|
+            ]#
+            "},
+    ))
+    .await?;
+
+    // Line comment continuation and trailing whitespace is also trimmed when using
+    // `insert_newline` in the middle of a comment.
+    test((
+        indoc! {"\
+            //hello#[|]#world
+            "}
+        .replace('', " "),
+        ":lang rust<ret>i<ret>",
+        indoc! {"\
+            //hello
+            //#[|]#world
+            "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    // Comment continuation should work on multiple selections.
+    // <https://github.com/helix-editor/helix/issues/12539>
+    test((
+        indoc! {"\
+            ///Docs#[|]#
+            pubstructA;
+
+            ///Docs#(|)#
+            pubstructB;
+            "}
+        .replace('', " "),
+        ":lang rust<ret>i<ret><ret>",
+        indoc! {"\
+            ///Docs
+            ///
+            ///#[|]#
+            pubstructA;
+
+            ///Docs
+            ///
+            ///#(|)#
+            pubstructB;
+            "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    Ok(())
+}
+
+/// NOTE: Language is set to markdown to check if the indentation is correct for the new line
+#[tokio::test(flavor = "multi_thread")]
+async fn test_open_above() -> anyhow::Result<()> {
+    // `O` is pressed in the first line
+    test((
+        indoc! {"Helix #[is|]# cool"},
+        ":lang markdown<ret>O",
+        indoc! {"\
+            #[\n|]#
+            Helix is cool
+        "},
+    ))
+    .await?;
+
+    // `O` is pressed in the first line, but the current line has some indentation
+    test((
+        indoc! {"\
+            This line has 2 spaces in front of it#[\n|]#
+        "}
+        .replace('', " "),
+        ":lang markdown<ret>Oa",
+        indoc! {"\
+            a#[\n|]#
+            This line has 2 spaces in front of it
+        "}
+        .replace('', " "),
+    ))
+    .await?;
+
+    // `O` is pressed but *not* in the first line
+    test((
+        indoc! {"\
+            I use
+            b#[t|]#w.
+        "},
+        ":lang markdown<ret>Oarch",
+        indoc! {"\
+            I use
+            arch#[\n|]#
+            btw.
+        "},
+    ))
+    .await?;
+
+    // `O` is pressed but *not* in the first line and the line has some indentation
+    test((
+        indoc! {"\
+            I use
+            b#[t|]#w.
+        "}
+        .replace("", " "),
+        ":lang markdown<ret>Ohelix",
+        indoc! {"\
+            I use
+            helix#[\n|]#
+            btw.
+        "}
+        .replace("", " "),
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn test_open_above_with_multiple_cursors() -> anyhow::Result<()> {
+    // the primary cursor is also in the top line
+    test((
+        indoc! {"#[H|]#elix
+            #(i|)#s
+            #(c|)#ool"},
+        "O",
+        indoc! {
+            "#[\n|]#
+            Helix
+            #(\n|)#
+            is
+            #(\n|)#
+            cool
+            "
+        },
+    ))
+    .await?;
+
+    // now with some additional indentation
+    test((
+        indoc! {"#[H|]#elix
+            #(i|)#s
+            #(c|)#ool"}
+        .replace("", " "),
+        ":indent-style 4<ret>O",
+        indoc! {
+            "#[\n|]#
+            Helix
+            #(\n|)#
+            is
+            #(\n|)#
+            cool
+            "
+        }
+        .replace("", " "),
+    ))
+    .await?;
+
+    // the first line is within a comment, the second not.
+    // However, if we open above, the first newly added line should start within a comment
+    // while the other should be a normal line
+    test((
+        indoc! {"fn main() {
+                // #[VIP|]# comment
+                l#(e|)#t yes = false;
+            }"},
+        ":lang rust<ret>O",
+        indoc! {"fn main() {
+                // #[\n|]#
+                // VIP comment
+                #(\n|)#
+                let yes = false;
+            }"},
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn test_open_below_with_multiple_cursors() -> anyhow::Result<()> {
+    // the primary cursor is also in the top line
+    test((
+        indoc! {"#[H|]#elix
+            #(i|)#s
+            #(c|)#ool"},
+        "o",
+        indoc! {"Helix
+            #[\n|]#
+            is
+            #(\n|)#
+            cool
+            #(\n|)#
+            "
+        },
+    ))
+    .await?;
+
+    // now with some additional indentation
+    test((
+        indoc! {"#[H|]#elix
+            #(i|)#s
+            #(c|)#ool"}
+        .replace("", " "),
+        ":indent-style 4<ret>o",
+        indoc! {
+            "Helix
+            #[\n|]#
+            is
+            #(\n|)#
+            cool
+            #(\n|)#
+            "
+        }
+        .replace("", " "),
+    ))
+    .await?;
+
+    // the first line is within a comment, the second not.
+    // However, if we open below, the first newly added line should start within a comment
+    // while the other should be a normal line
+    test((
+        indoc! {"fn main() {
+                // #[VIP|]# comment
+                l#(e|)#t yes = false;
+            }"},
+        ":lang rust<ret>o",
+        indoc! {"fn main() {
+                // VIP comment
+                // #[\n|]#
+                let yes = false;
+                #(\n|)#
+            }"},
+    ))
+    .await?;
+
+    Ok(())
+}
+
+/// NOTE: To make the `open_above` comment-aware, we're setting the language for each test to rust.
+#[tokio::test(flavor = "multi_thread")]
+async fn test_open_above_with_comments() -> anyhow::Result<()> {
+    // `O` is pressed in the first line inside a line comment
+    test((
+        indoc! {"// a commen#[t|]#"},
+        ":lang rust<ret>O",
+        indoc! {"\
+            // #[\n|]#
+            // a comment
+        "},
+    ))
+    .await?;
+
+    // `O` is pressed in the first line inside a line comment, but with indentation
+    test((
+        indoc! {"// a comm#[e|]#nt"}.replace("", " "),
+        ":lang rust<ret>O",
+        indoc! {"\
+            // #[\n|]#
+            // a comment
+        "}
+        .replace("", " "),
+    ))
+    .await?;
+
+    // `O` is pressed but not in the first line but inside a line comment
+    test((
+        indoc! {"\
+            fn main() { }
+            // yeetus deletus#[\n|]#
+        "},
+        ":lang rust<ret>O",
+        indoc! {"\
+            fn main() { }
+            // #[\n|]#
+            // yeetus deletus
+        "},
+    ))
+    .await?;
+
+    // `O` is pressed but not in the first line but inside a line comment and with indentation
+    test((
+        indoc! {"\
+            fn main() { }
+            // yeetus deletus#[\n|]#
+        "}
+        .replace("", " "),
+        ":lang rust<ret>O",
+        indoc! {"\
+            fn main() { }
+            // #[\n|]#
+            // yeetus deletus
+        "}
+        .replace("", " "),
+    ))
+    .await?;
+
+    Ok(())
+}
diff --git a/helix-term/tests/test/helpers.rs b/helix-term/tests/test/helpers.rs
index 70b3f4022..ef910852c 100644
--- a/helix-term/tests/test/helpers.rs
+++ b/helix-term/tests/test/helpers.rs
@@ -345,7 +345,10 @@ pub fn with_file<P: Into<PathBuf>>(
         path: P,
         pos: Option<helix_core::Position>,
     ) -> Self {
-        self.args.files.push((path.into(), pos.unwrap_or_default()));
+        self.args
+            .files
+            .insert(path.into(), vec![pos.unwrap_or_default()]);
+
         self
     }
 
diff --git a/helix-term/tests/test/languages/yaml.rs b/helix-term/tests/test/languages/yaml.rs
index 10e1861d4..1d9596400 100644
--- a/helix-term/tests/test/languages/yaml.rs
+++ b/helix-term/tests/test/languages/yaml.rs
@@ -795,7 +795,7 @@ async fn auto_indent() -> anyhow::Result<()> {
             "##},
             "i<ret>",
             indoc! {"\
-                foo: 
+                foo:
                   #[|b]#ar
             "},
         ),
diff --git a/helix-tui/Cargo.toml b/helix-tui/Cargo.toml
index ac56c7242..0a3a35534 100644
--- a/helix-tui/Cargo.toml
+++ b/helix-tui/Cargo.toml
@@ -18,11 +18,11 @@ default = ["crossterm"]
 helix-view = { path = "../helix-view", features = ["term"] }
 helix-core = { path = "../helix-core" }
 
-bitflags = "2.6"
+bitflags.workspace = true
 cassowary = "0.3"
-unicode-segmentation = "1.11"
+unicode-segmentation.workspace = true
 crossterm = { version = "0.28", optional = true }
 termini = "1.0"
 serde = { version = "1", "optional" = true, features = ["derive"]}
-once_cell = "1.19"
+once_cell = "1.20"
 log = "~0.4"
diff --git a/helix-tui/src/buffer.rs b/helix-tui/src/buffer.rs
index d28c32fcc..bfcf35ac5 100644
--- a/helix-tui/src/buffer.rs
+++ b/helix-tui/src/buffer.rs
@@ -306,6 +306,68 @@ pub fn set_stringn<S>(
         self.set_string_truncated_at_end(x, y, string.as_ref(), width, style)
     }
 
+    /// Print at most the first `width` characters of a string if enough space is available
+    /// until the end of the line.
+    /// If `ellipsis` is true appends a `` at the end of truncated lines.
+    /// If `truncate_start` is `true`, adds a `` at the beginning of truncated lines.
+    #[allow(clippy::too_many_arguments)]
+    pub fn set_string_anchored(
+        &mut self,
+        x: u16,
+        y: u16,
+        truncate_start: bool,
+        truncate_end: bool,
+        string: &str,
+        width: usize,
+        style: impl Fn(usize) -> Style, // Map a grapheme's string offset to a style
+    ) -> (u16, u16) {
+        // prevent panic if out of range
+        if !self.in_bounds(x, y) || width == 0 {
+            return (x, y);
+        }
+
+        let max_offset = min(
+            self.area.right() as usize - 1,
+            width.saturating_add(x as usize),
+        );
+        let mut start_index = self.index_of(x, y);
+        let mut end_index = self.index_of(max_offset as u16, y);
+
+        if truncate_end {
+            self.content[end_index].set_symbol("");
+            end_index -= 1;
+        }
+
+        if truncate_start {
+            self.content[start_index].set_symbol("");
+            start_index += 1;
+        }
+
+        let graphemes = string.grapheme_indices(true);
+
+        for (byte_offset, s) in graphemes.skip(truncate_start as usize) {
+            if start_index > end_index {
+                break;
+            }
+            let width = s.width();
+            if width == 0 {
+                continue;
+            }
+
+            self.content[start_index].set_symbol(s);
+            self.content[start_index].set_style(style(byte_offset));
+
+            // Reset following cells if multi-width (they would be hidden by the grapheme):
+            for i in start_index + 1..start_index + width {
+                self.content[i].reset();
+            }
+
+            start_index += width;
+        }
+
+        (x, y)
+    }
+
     /// Print at most the first `width` characters of a string if enough space is available
     /// until the end of the line. If `ellipsis` is true appends a `` at the end of
     /// truncated lines. If `truncate_start` is `true`, truncate the beginning of the string
diff --git a/helix-tui/src/text.rs b/helix-tui/src/text.rs
index a5e8a68af..c4313e15f 100644
--- a/helix-tui/src/text.rs
+++ b/helix-tui/src/text.rs
@@ -212,7 +212,7 @@ fn from(s: Cow<'a, str>) -> Span<'a> {
 #[derive(Debug, Default, Clone, PartialEq, Eq)]
 pub struct Spans<'a>(pub Vec<Span<'a>>);
 
-impl<'a> Spans<'a> {
+impl Spans<'_> {
     /// Returns the width of the underlying string.
     ///
     /// ## Examples
diff --git a/helix-tui/src/widgets/block.rs b/helix-tui/src/widgets/block.rs
index 8b8141ea9..ee7aa7573 100644
--- a/helix-tui/src/widgets/block.rs
+++ b/helix-tui/src/widgets/block.rs
@@ -123,7 +123,7 @@ pub fn inner(&self, area: Rect) -> Rect {
     }
 }
 
-impl<'a> Widget for Block<'a> {
+impl Widget for Block<'_> {
     fn render(self, area: Rect, buf: &mut Buffer) {
         if area.area() == 0 {
             return;
diff --git a/helix-tui/src/widgets/paragraph.rs b/helix-tui/src/widgets/paragraph.rs
index 79beb0516..73153a077 100644
--- a/helix-tui/src/widgets/paragraph.rs
+++ b/helix-tui/src/widgets/paragraph.rs
@@ -129,7 +129,7 @@ pub fn alignment(mut self, alignment: Alignment) -> Paragraph<'a> {
     }
 }
 
-impl<'a> Widget for Paragraph<'a> {
+impl Widget for Paragraph<'_> {
     fn render(mut self, area: Rect, buf: &mut Buffer) {
         buf.set_style(area, self.style);
         let text_area = match self.block.take() {
diff --git a/helix-tui/src/widgets/reflow.rs b/helix-tui/src/widgets/reflow.rs
index 67c4db443..ff102eb19 100644
--- a/helix-tui/src/widgets/reflow.rs
+++ b/helix-tui/src/widgets/reflow.rs
@@ -39,7 +39,7 @@ pub fn new(
     }
 }
 
-impl<'a, 'b> LineComposer<'a> for WordWrapper<'a, 'b> {
+impl<'a> LineComposer<'a> for WordWrapper<'a, '_> {
     fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)> {
         if self.max_line_width == 0 {
             return None;
@@ -152,7 +152,7 @@ pub fn set_horizontal_offset(&mut self, horizontal_offset: u16) {
     }
 }
 
-impl<'a, 'b> LineComposer<'a> for LineTruncator<'a, 'b> {
+impl<'a> LineComposer<'a> for LineTruncator<'a, '_> {
     fn next_line(&mut self) -> Option<(&[StyledGrapheme<'a>], u16)> {
         if self.max_line_width == 0 {
             return None;
diff --git a/helix-tui/src/widgets/table.rs b/helix-tui/src/widgets/table.rs
index 3564871de..9c67a376f 100644
--- a/helix-tui/src/widgets/table.rs
+++ b/helix-tui/src/widgets/table.rs
@@ -34,7 +34,7 @@ pub struct Cell<'a> {
     style: Style,
 }
 
-impl<'a> Cell<'a> {
+impl Cell<'_> {
     /// Set the `Style` of this cell.
     pub fn style(mut self, style: Style) -> Self {
         self.style = style;
@@ -351,7 +351,7 @@ pub fn select(&mut self, index: Option<usize>) {
 }
 
 // impl<'a> StatefulWidget for Table<'a> {
-impl<'a> Table<'a> {
+impl Table<'_> {
     // type State = TableState;
 
     pub fn render_table(
@@ -486,7 +486,7 @@ fn render_cell(buf: &mut Buffer, cell: &Cell, area: Rect, truncate: bool) {
     }
 }
 
-impl<'a> Widget for Table<'a> {
+impl Widget for Table<'_> {
     fn render(self, area: Rect, buf: &mut Buffer) {
         let mut state = TableState::default();
         Table::render_table(self, area, buf, &mut state, false);
diff --git a/helix-vcs/Cargo.toml b/helix-vcs/Cargo.toml
index 79d736a1e..289c334ad 100644
--- a/helix-vcs/Cargo.toml
+++ b/helix-vcs/Cargo.toml
@@ -19,8 +19,8 @@ tokio = { version = "1", features = ["rt", "rt-multi-thread", "time", "sync", "p
 parking_lot = "0.12"
 arc-swap = { version = "1.7.1" }
 
-gix = { version = "0.64.0", features = ["attributes", "status"], default-features = false, optional = true }
-imara-diff = "0.1.7"
+gix = { version = "0.70.0", features = ["attributes", "status"], default-features = false, optional = true }
+imara-diff = "0.1.8"
 anyhow = "1"
 
 log = "0.4"
@@ -29,4 +29,4 @@ log = "0.4"
 git = ["gix"]
 
 [dev-dependencies]
-tempfile = "3.12"
+tempfile.workspace = true
diff --git a/helix-vcs/src/git.rs b/helix-vcs/src/git.rs
index 78e582436..b8ddd79fa 100644
--- a/helix-vcs/src/git.rs
+++ b/helix-vcs/src/git.rs
@@ -11,7 +11,7 @@
 use gix::objs::tree::EntryKind;
 use gix::sec::trust::DefaultForLevel;
 use gix::status::{
-    index_worktree::iter::Item,
+    index_worktree::Item,
     plumbing::index_as_worktree::{Change, EntryStatus},
     UntrackedFiles,
 };
@@ -22,18 +22,24 @@
 #[cfg(test)]
 mod test;
 
+#[inline]
+fn get_repo_dir(file: &Path) -> Result<&Path> {
+    file.parent().context("file has no parent directory")
+}
+
 pub fn get_diff_base(file: &Path) -> Result<Vec<u8>> {
     debug_assert!(!file.exists() || file.is_file());
     debug_assert!(file.is_absolute());
+    let file = gix::path::realpath(file).context("resolve symlinks")?;
 
     // TODO cache repository lookup
 
-    let repo_dir = file.parent().context("file has no parent directory")?;
+    let repo_dir = get_repo_dir(&file)?;
     let repo = open_repo(repo_dir)
         .context("failed to open git repo")?
         .to_thread_local();
     let head = repo.head_commit()?;
-    let file_oid = find_file_in_commit(&repo, &head, file)?;
+    let file_oid = find_file_in_commit(&repo, &head, &file)?;
 
     let file_object = repo.find_object(file_oid)?;
     let data = file_object.detach().data;
@@ -56,7 +62,9 @@ pub fn get_diff_base(file: &Path) -> Result<Vec<u8>> {
 pub fn get_current_head_name(file: &Path) -> Result<Arc<ArcSwap<Box<str>>>> {
     debug_assert!(!file.exists() || file.is_file());
     debug_assert!(file.is_absolute());
-    let repo_dir = file.parent().context("file has no parent directory")?;
+    let file = gix::path::realpath(file).context("resolve symlinks")?;
+
+    let repo_dir = get_repo_dir(&file)?;
     let repo = open_repo(repo_dir)
         .context("failed to open git repo")?
         .to_thread_local();
@@ -136,6 +144,7 @@ fn status(repo: &Repository, f: impl Fn(Result<FileChange>) -> bool) -> Result<(
             copies: None,
             percentage: Some(0.5),
             limit: 1000,
+            ..Default::default()
         }));
 
     // No filtering based on path
@@ -190,7 +199,7 @@ fn find_file_in_commit(repo: &Repository, commit: &Commit, file: &Path) -> Resul
     let rel_path = file.strip_prefix(repo_dir)?;
     let tree = commit.tree()?;
     let tree_entry = tree
-        .lookup_entry_by_path(rel_path, &mut Vec::new())?
+        .lookup_entry_by_path(rel_path)?
         .context("file is untracked")?;
     match tree_entry.mode().kind() {
         // not a file, everything is new, do not show diff
diff --git a/helix-vcs/src/git/test.rs b/helix-vcs/src/git/test.rs
index 95ff10b23..164040f50 100644
--- a/helix-vcs/src/git/test.rs
+++ b/helix-vcs/src/git/test.rs
@@ -98,9 +98,13 @@ fn directory() {
     assert!(git::get_diff_base(&dir).is_err());
 }
 
-/// Test that `get_file_head` does not return content for a symlink.
-/// This is important to correctly cover cases where a symlink is removed and replaced by a file.
-/// If the contents of the symlink object were returned a diff between a path and the actual file would be produced (bad ui).
+/// Test that `get_diff_base` resolves symlinks so that the same diff base is
+/// used as the target file.
+///
+/// This is important to correctly cover cases where a symlink is removed and
+/// replaced by a file. If the contents of the symlink object were returned
+/// a diff between a literal file path and the actual file content would be
+/// produced (bad ui).
 #[cfg(any(unix, windows))]
 #[test]
 fn symlink() {
@@ -108,14 +112,41 @@ fn symlink() {
     use std::os::unix::fs::symlink;
     #[cfg(not(unix))]
     use std::os::windows::fs::symlink_file as symlink;
+
     let temp_git = empty_git_repo();
     let file = temp_git.path().join("file.txt");
-    let contents = b"foo".as_slice();
-    File::create(&file).unwrap().write_all(contents).unwrap();
+    let contents = Vec::from(b"foo");
+    File::create(&file).unwrap().write_all(&contents).unwrap();
     let file_link = temp_git.path().join("file_link.txt");
+
     symlink("file.txt", &file_link).unwrap();
+    create_commit(temp_git.path(), true);
+
+    assert_eq!(git::get_diff_base(&file_link).unwrap(), contents);
+    assert_eq!(git::get_diff_base(&file).unwrap(), contents);
+}
+
+/// Test that `get_diff_base` returns content when the file is a symlink to
+/// another file that is in a git repo, but the symlink itself is not.
+#[cfg(any(unix, windows))]
+#[test]
+fn symlink_to_git_repo() {
+    #[cfg(unix)]
+    use std::os::unix::fs::symlink;
+    #[cfg(not(unix))]
+    use std::os::windows::fs::symlink_file as symlink;
+
+    let temp_dir = tempfile::tempdir().expect("create temp dir");
+    let temp_git = empty_git_repo();
 
+    let file = temp_git.path().join("file.txt");
+    let contents = Vec::from(b"foo");
+    File::create(&file).unwrap().write_all(&contents).unwrap();
     create_commit(temp_git.path(), true);
-    assert!(git::get_diff_base(&file_link).is_err());
-    assert_eq!(git::get_diff_base(&file).unwrap(), Vec::from(contents));
+
+    let file_link = temp_dir.path().join("file_link.txt");
+    symlink(&file, &file_link).unwrap();
+
+    assert_eq!(git::get_diff_base(&file_link).unwrap(), contents);
+    assert_eq!(git::get_diff_base(&file).unwrap(), contents);
 }
diff --git a/helix-view/Cargo.toml b/helix-view/Cargo.toml
index ddfa9f7e4..da9f52a21 100644
--- a/helix-view/Cargo.toml
+++ b/helix-view/Cargo.toml
@@ -24,15 +24,15 @@ helix-lsp = { path = "../helix-lsp" }
 helix-dap = { path = "../helix-dap" }
 helix-vcs = { path = "../helix-vcs" }
 
-bitflags = "2.6"
+bitflags.workspace = true
 anyhow = "1"
 crossterm = { version = "0.28", optional = true }
 
-tempfile = "3.12"
+tempfile.workspace = true
 
 # Conversion traits
-once_cell = "1.19"
-url = "2.5.2"
+once_cell = "1.20"
+url = "2.5.4"
 
 arc-swap = { version = "1.7.1" }
 
@@ -40,7 +40,7 @@ tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std
 tokio-stream = "0.1"
 futures-util = { version = "0.3", features = ["std", "async-await"], default-features = false }
 
-slotmap = "1"
+slotmap.workspace = true
 
 chardetng = "0.1"
 
diff --git a/helix-view/src/annotations/diagnostics.rs b/helix-view/src/annotations/diagnostics.rs
index 09085d3fe..7802ca637 100644
--- a/helix-view/src/annotations/diagnostics.rs
+++ b/helix-view/src/annotations/diagnostics.rs
@@ -178,7 +178,7 @@ fn process_anchor_impl(
         horizontal_off: usize,
     ) -> bool {
         // TODO: doing the cursor tracking here works well but is somewhat
-        // duplicate effort/tedious maybe centralize this somehwere?
+        // duplicate effort/tedious maybe centralize this somewhere?
         // In the DocFormatter?
         if grapheme.char_idx == self.cursor {
             self.cursor_line = true;
@@ -248,9 +248,9 @@ pub fn compute_line_diagnostics(&mut self) {
     }
 
     pub fn has_multi(&self, width: u16) -> bool {
-        self.stack.last().map_or(false, |&(_, anchor)| {
-            anchor > self.config.max_diagnostic_start(width)
-        })
+        self.stack
+            .last()
+            .is_some_and(|&(_, anchor)| anchor > self.config.max_diagnostic_start(width))
     }
 }
 
diff --git a/helix-view/src/clipboard.rs b/helix-view/src/clipboard.rs
index 379accc7e..1cf633487 100644
--- a/helix-view/src/clipboard.rs
+++ b/helix-view/src/clipboard.rs
@@ -1,356 +1,225 @@
 // Implementation reference: https://github.com/neovim/neovim/blob/f2906a4669a2eef6d7bf86a29648793d63c98949/runtime/autoload/provider/clipboard.vim#L68-L152
 
-use anyhow::Result;
+use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
+use thiserror::Error;
 
-#[derive(Clone, Copy, Debug)]
+#[derive(Clone, Copy)]
 pub enum ClipboardType {
     Clipboard,
     Selection,
 }
 
-pub trait ClipboardProvider: std::fmt::Debug {
-    fn name(&self) -> Cow<str>;
-    fn get_contents(&self, clipboard_type: ClipboardType) -> Result<String>;
-    fn set_contents(&mut self, contents: String, clipboard_type: ClipboardType) -> Result<()>;
+#[derive(Debug, Error)]
+pub enum ClipboardError {
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+    #[error("could not convert terminal output to UTF-8: {0}")]
+    FromUtf8Error(#[from] std::string::FromUtf8Error),
+    #[cfg(windows)]
+    #[error("Windows API error: {0}")]
+    WinAPI(#[from] clipboard_win::ErrorCode),
+    #[error("clipboard provider command failed")]
+    CommandFailed,
+    #[error("failed to write to clipboard provider's stdin")]
+    StdinWriteFailed,
+    #[error("clipboard provider did not return any contents")]
+    MissingStdout,
+    #[error("This clipboard provider does not support reading")]
+    ReadingNotSupported,
 }
 
-#[cfg(not(windows))]
-macro_rules! command_provider {
-    (paste => $get_prg:literal $( , $get_arg:literal )* ; copy => $set_prg:literal $( , $set_arg:literal )* ; ) => {{
-        log::debug!(
-            "Using {} to interact with the system clipboard",
-            if $set_prg != $get_prg { format!("{}+{}", $set_prg, $get_prg)} else { $set_prg.to_string() }
-        );
-        Box::new(provider::command::Provider {
-            get_cmd: provider::command::Config {
-                prg: $get_prg,
-                args: &[ $( $get_arg ),* ],
-            },
-            set_cmd: provider::command::Config {
-                prg: $set_prg,
-                args: &[ $( $set_arg ),* ],
-            },
-            get_primary_cmd: None,
-            set_primary_cmd: None,
-        })
-    }};
-
-    (paste => $get_prg:literal $( , $get_arg:literal )* ;
-     copy => $set_prg:literal $( , $set_arg:literal )* ;
-     primary_paste => $pr_get_prg:literal $( , $pr_get_arg:literal )* ;
-     primary_copy => $pr_set_prg:literal $( , $pr_set_arg:literal )* ;
-    ) => {{
-        log::debug!(
-            "Using {} to interact with the system and selection (primary) clipboard",
-            if $set_prg != $get_prg { format!("{}+{}", $set_prg, $get_prg)} else { $set_prg.to_string() }
-        );
-        Box::new(provider::command::Provider {
-            get_cmd: provider::command::Config {
-                prg: $get_prg,
-                args: &[ $( $get_arg ),* ],
-            },
-            set_cmd: provider::command::Config {
-                prg: $set_prg,
-                args: &[ $( $set_arg ),* ],
-            },
-            get_primary_cmd: Some(provider::command::Config {
-                prg: $pr_get_prg,
-                args: &[ $( $pr_get_arg ),* ],
-            }),
-            set_primary_cmd: Some(provider::command::Config {
-                prg: $pr_set_prg,
-                args: &[ $( $pr_set_arg ),* ],
-            }),
-        })
-    }};
-}
-
-#[cfg(windows)]
-pub fn get_clipboard_provider() -> Box<dyn ClipboardProvider> {
-    Box::<provider::WindowsProvider>::default()
-}
-
-#[cfg(target_os = "macos")]
-pub fn get_clipboard_provider() -> Box<dyn ClipboardProvider> {
-    use helix_stdx::env::{binary_exists, env_var_is_set};
-
-    if env_var_is_set("TMUX") && binary_exists("tmux") {
-        command_provider! {
-            paste => "tmux", "save-buffer", "-";
-            copy => "tmux", "load-buffer", "-w", "-";
-        }
-    } else if binary_exists("pbcopy") && binary_exists("pbpaste") {
-        command_provider! {
-            paste => "pbpaste";
-            copy => "pbcopy";
-        }
-    } else {
-        Box::new(provider::FallbackProvider::new())
-    }
-}
+type Result<T> = std::result::Result<T, ClipboardError>;
 
+#[cfg(not(target_arch = "wasm32"))]
+pub use external::ClipboardProvider;
 #[cfg(target_arch = "wasm32")]
-pub fn get_clipboard_provider() -> Box<dyn ClipboardProvider> {
-    // TODO:
-    Box::new(provider::FallbackProvider::new())
-}
+pub use noop::ClipboardProvider;
 
-#[cfg(not(any(windows, target_arch = "wasm32", target_os = "macos")))]
-pub fn get_clipboard_provider() -> Box<dyn ClipboardProvider> {
-    use helix_stdx::env::{binary_exists, env_var_is_set};
-    use provider::command::is_exit_success;
-    // TODO: support for user-defined provider, probably when we have plugin support by setting a
-    // variable?
-
-    if env_var_is_set("WAYLAND_DISPLAY") && binary_exists("wl-copy") && binary_exists("wl-paste") {
-        command_provider! {
-            paste => "wl-paste", "--no-newline";
-            copy => "wl-copy", "--type", "text/plain";
-            primary_paste => "wl-paste", "-p", "--no-newline";
-            primary_copy => "wl-copy", "-p", "--type", "text/plain";
-        }
-    } else if env_var_is_set("DISPLAY") && binary_exists("xclip") {
-        command_provider! {
-            paste => "xclip", "-o", "-selection", "clipboard";
-            copy => "xclip", "-i", "-selection", "clipboard";
-            primary_paste => "xclip", "-o";
-            primary_copy => "xclip", "-i";
-        }
-    } else if env_var_is_set("DISPLAY")
-        && binary_exists("xsel")
-        && is_exit_success("xsel", &["-o", "-b"])
-    {
-        // FIXME: check performance of is_exit_success
-        command_provider! {
-            paste => "xsel", "-o", "-b";
-            copy => "xsel", "-i", "-b";
-            primary_paste => "xsel", "-o";
-            primary_copy => "xsel", "-i";
-        }
-    } else if binary_exists("win32yank.exe") {
-        command_provider! {
-            paste => "win32yank.exe", "-o", "--lf";
-            copy => "win32yank.exe", "-i", "--crlf";
-        }
-    } else if binary_exists("termux-clipboard-set") && binary_exists("termux-clipboard-get") {
-        command_provider! {
-            paste => "termux-clipboard-get";
-            copy => "termux-clipboard-set";
-        }
-    } else if env_var_is_set("TMUX") && binary_exists("tmux") {
-        command_provider! {
-            paste => "tmux", "save-buffer", "-";
-            copy => "tmux", "load-buffer", "-w", "-";
-        }
-    } else {
-        Box::new(provider::FallbackProvider::new())
-    }
-}
+// Clipboard not supported for wasm
+#[cfg(target_arch = "wasm32")]
+mod noop {
+    use super::*;
 
-#[cfg(not(target_os = "windows"))]
-pub mod provider {
-    use super::{ClipboardProvider, ClipboardType};
-    use anyhow::Result;
-    use std::borrow::Cow;
+    #[derive(Debug, Clone)]
+    pub enum ClipboardProvider {}
 
-    #[cfg(feature = "term")]
-    mod osc52 {
-        use {super::ClipboardType, crate::base64};
+    impl ClipboardProvider {
+        pub fn detect() -> Self {
+            Self
+        }
 
-        #[derive(Debug)]
-        pub struct SetClipboardCommand {
-            encoded_content: String,
-            clipboard_type: ClipboardType,
+        pub fn name(&self) -> Cow<str> {
+            "none".into()
         }
 
-        impl SetClipboardCommand {
-            pub fn new(content: &str, clipboard_type: ClipboardType) -> Self {
-                Self {
-                    encoded_content: base64::encode(content.as_bytes()),
-                    clipboard_type,
-                }
-            }
+        pub fn get_contents(&self, _clipboard_type: ClipboardType) -> Result<String> {
+            Err(ClipboardError::ReadingNotSupported)
         }
 
-        impl crossterm::Command for SetClipboardCommand {
-            fn write_ansi(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
-                let kind = match &self.clipboard_type {
-                    ClipboardType::Clipboard => "c",
-                    ClipboardType::Selection => "p",
-                };
-                // Send an OSC 52 set command: https://terminalguide.namepad.de/seq/osc-52/
-                write!(f, "\x1b]52;{};{}\x1b\\", kind, &self.encoded_content)
-            }
+        pub fn set_contents(&self, _content: &str, _clipboard_type: ClipboardType) -> Result<()> {
+            Ok(())
         }
     }
+}
 
-    #[derive(Debug)]
-    pub struct FallbackProvider {
-        buf: String,
-        primary_buf: String,
-    }
+#[cfg(not(target_arch = "wasm32"))]
+mod external {
+    use super::*;
 
-    impl FallbackProvider {
-        pub fn new() -> Self {
-            #[cfg(feature = "term")]
-            log::debug!(
-                "No native clipboard provider found. Yanking by OSC 52 and pasting will be internal to Helix"
-            );
-            #[cfg(not(feature = "term"))]
-            log::warn!(
-                "No native clipboard provider found! Yanking and pasting will be internal to Helix"
-            );
-            Self {
-                buf: String::new(),
-                primary_buf: String::new(),
-            }
-        }
+    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+    pub struct Command {
+        command: Cow<'static, str>,
+        #[serde(default)]
+        args: Cow<'static, [Cow<'static, str>]>,
     }
 
-    impl Default for FallbackProvider {
-        fn default() -> Self {
-            Self::new()
-        }
+    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+    #[serde(rename_all = "kebab-case")]
+    pub struct CommandProvider {
+        yank: Command,
+        paste: Command,
+        yank_primary: Option<Command>,
+        paste_primary: Option<Command>,
     }
 
-    impl ClipboardProvider for FallbackProvider {
+    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
+    #[serde(rename_all = "kebab-case")]
+    #[allow(clippy::large_enum_variant)]
+    pub enum ClipboardProvider {
+        Pasteboard,
+        Wayland,
+        XClip,
+        XSel,
+        Win32Yank,
+        Tmux,
+        #[cfg(windows)]
+        Windows,
+        Termux,
         #[cfg(feature = "term")]
-        fn name(&self) -> Cow<str> {
-            Cow::Borrowed("termcode")
-        }
-
-        #[cfg(not(feature = "term"))]
-        fn name(&self) -> Cow<str> {
-            Cow::Borrowed("none")
-        }
+        Termcode,
+        Custom(CommandProvider),
+        None,
+    }
 
-        fn get_contents(&self, clipboard_type: ClipboardType) -> Result<String> {
-            // This is the same noop if term is enabled or not.
-            // We don't use the get side of OSC 52 as it isn't often enabled, it's a security hole,
-            // and it would require this to be async to listen for the response
-            let value = match clipboard_type {
-                ClipboardType::Clipboard => self.buf.clone(),
-                ClipboardType::Selection => self.primary_buf.clone(),
-            };
+    impl Default for ClipboardProvider {
+        #[cfg(windows)]
+        fn default() -> Self {
+            use helix_stdx::env::binary_exists;
 
-            Ok(value)
+            if binary_exists("win32yank.exe") {
+                Self::Win32Yank
+            } else {
+                Self::Windows
+            }
         }
 
-        fn set_contents(&mut self, content: String, clipboard_type: ClipboardType) -> Result<()> {
-            #[cfg(feature = "term")]
-            crossterm::execute!(
-                std::io::stdout(),
-                osc52::SetClipboardCommand::new(&content, clipboard_type)
-            )?;
-            // Set our internal variables to use in get_content regardless of using OSC 52
-            match clipboard_type {
-                ClipboardType::Clipboard => self.buf = content,
-                ClipboardType::Selection => self.primary_buf = content,
+        #[cfg(target_os = "macos")]
+        fn default() -> Self {
+            use helix_stdx::env::{binary_exists, env_var_is_set};
+
+            if env_var_is_set("TMUX") && binary_exists("tmux") {
+                Self::Tmux
+            } else if binary_exists("pbcopy") && binary_exists("pbpaste") {
+                Self::Pasteboard
+            } else {
+                #[cfg(feature = "term")]
+                return Self::Termcode;
+                #[cfg(not(feature = "term"))]
+                return Self::None;
             }
-            Ok(())
         }
-    }
-
-    #[cfg(not(target_arch = "wasm32"))]
-    pub mod command {
-        use super::*;
-        use anyhow::{bail, Context as _};
 
         #[cfg(not(any(windows, target_os = "macos")))]
-        pub fn is_exit_success(program: &str, args: &[&str]) -> bool {
-            std::process::Command::new(program)
-                .args(args)
-                .output()
-                .ok()
-                .and_then(|out| out.status.success().then_some(()))
-                .is_some()
-        }
+        fn default() -> Self {
+            use helix_stdx::env::{binary_exists, env_var_is_set};
+
+            fn is_exit_success(program: &str, args: &[&str]) -> bool {
+                std::process::Command::new(program)
+                    .args(args)
+                    .output()
+                    .ok()
+                    .and_then(|out| out.status.success().then_some(()))
+                    .is_some()
+            }
 
-        #[derive(Debug)]
-        pub struct Config {
-            pub prg: &'static str,
-            pub args: &'static [&'static str],
+            if env_var_is_set("WAYLAND_DISPLAY")
+                && binary_exists("wl-copy")
+                && binary_exists("wl-paste")
+            {
+                Self::Wayland
+            } else if env_var_is_set("DISPLAY") && binary_exists("xclip") {
+                Self::XClip
+            } else if env_var_is_set("DISPLAY")
+                && binary_exists("xsel")
+                // FIXME: check performance of is_exit_success
+                && is_exit_success("xsel", &["-o", "-b"])
+            {
+                Self::XSel
+            } else if binary_exists("termux-clipboard-set") && binary_exists("termux-clipboard-get")
+            {
+                Self::Termux
+            } else if env_var_is_set("TMUX") && binary_exists("tmux") {
+                Self::Tmux
+            } else if binary_exists("win32yank.exe") {
+                Self::Win32Yank
+            } else if cfg!(feature = "term") {
+                Self::Termcode
+            } else {
+                Self::None
+            }
         }
+    }
 
-        impl Config {
-            fn execute(&self, input: Option<&str>, pipe_output: bool) -> Result<Option<String>> {
-                use std::io::Write;
-                use std::process::{Command, Stdio};
-
-                let stdin = input.map(|_| Stdio::piped()).unwrap_or_else(Stdio::null);
-                let stdout = pipe_output.then(Stdio::piped).unwrap_or_else(Stdio::null);
-
-                let mut command: Command = Command::new(self.prg);
-
-                let mut command_mut: &mut Command = command
-                    .args(self.args)
-                    .stdin(stdin)
-                    .stdout(stdout)
-                    .stderr(Stdio::null());
-
-                // Fix for https://github.com/helix-editor/helix/issues/5424
-                if cfg!(unix) {
-                    use std::os::unix::process::CommandExt;
-
-                    unsafe {
-                        command_mut = command_mut.pre_exec(|| match libc::setsid() {
-                            -1 => Err(std::io::Error::last_os_error()),
-                            _ => Ok(()),
-                        });
-                    }
-                }
-
-                let mut child = command_mut.spawn()?;
-
-                if let Some(input) = input {
-                    let mut stdin = child.stdin.take().context("stdin is missing")?;
-                    stdin
-                        .write_all(input.as_bytes())
-                        .context("couldn't write in stdin")?;
-                }
-
-                // TODO: add timer?
-                let output = child.wait_with_output()?;
-
-                if !output.status.success() {
-                    bail!("clipboard provider {} failed", self.prg);
-                }
-
-                if pipe_output {
-                    Ok(Some(String::from_utf8(output.stdout)?))
+    impl ClipboardProvider {
+        pub fn name(&self) -> Cow<'_, str> {
+            fn builtin_name<'a>(
+                name: &'static str,
+                provider: &'static CommandProvider,
+            ) -> Cow<'a, str> {
+                if provider.yank.command != provider.paste.command {
+                    Cow::Owned(format!(
+                        "{} ({}+{})",
+                        name, provider.yank.command, provider.paste.command
+                    ))
                 } else {
-                    Ok(None)
+                    Cow::Owned(format!("{} ({})", name, provider.yank.command))
                 }
             }
-        }
-
-        #[derive(Debug)]
-        pub struct Provider {
-            pub get_cmd: Config,
-            pub set_cmd: Config,
-            pub get_primary_cmd: Option<Config>,
-            pub set_primary_cmd: Option<Config>,
-        }
 
-        impl ClipboardProvider for Provider {
-            fn name(&self) -> Cow<str> {
-                if self.get_cmd.prg != self.set_cmd.prg {
-                    Cow::Owned(format!("{}+{}", self.get_cmd.prg, self.set_cmd.prg))
-                } else {
-                    Cow::Borrowed(self.get_cmd.prg)
-                }
+            match self {
+                // These names should match the config option names from Serde
+                Self::Pasteboard => builtin_name("pasteboard", &PASTEBOARD),
+                Self::Wayland => builtin_name("wayland", &WL_CLIPBOARD),
+                Self::XClip => builtin_name("x-clip", &XCLIP),
+                Self::XSel => builtin_name("x-sel", &XSEL),
+                Self::Win32Yank => builtin_name("win-32-yank", &WIN32),
+                Self::Tmux => builtin_name("tmux", &TMUX),
+                Self::Termux => builtin_name("termux", &TERMUX),
+                #[cfg(windows)]
+                Self::Windows => "windows".into(),
+                #[cfg(feature = "term")]
+                Self::Termcode => "termcode".into(),
+                Self::Custom(command_provider) => Cow::Owned(format!(
+                    "custom ({}+{})",
+                    command_provider.yank.command, command_provider.paste.command
+                )),
+                Self::None => "none".into(),
             }
+        }
 
-            fn get_contents(&self, clipboard_type: ClipboardType) -> Result<String> {
+        pub fn get_contents(&self, clipboard_type: &ClipboardType) -> Result<String> {
+            fn yank_from_builtin(
+                provider: CommandProvider,
+                clipboard_type: &ClipboardType,
+            ) -> Result<String> {
                 match clipboard_type {
-                    ClipboardType::Clipboard => Ok(self
-                        .get_cmd
-                        .execute(None, true)?
-                        .context("output is missing")?),
+                    ClipboardType::Clipboard => execute_command(&provider.yank, None, true)?
+                        .ok_or(ClipboardError::MissingStdout),
                     ClipboardType::Selection => {
-                        if let Some(cmd) = &self.get_primary_cmd {
-                            return cmd.execute(None, true)?.context("output is missing");
+                        if let Some(cmd) = provider.yank_primary.as_ref() {
+                            return execute_command(cmd, None, true)?
+                                .ok_or(ClipboardError::MissingStdout);
                         }
 
                         Ok(String::new())
@@ -358,56 +227,274 @@ fn get_contents(&self, clipboard_type: ClipboardType) -> Result<String> {
                 }
             }
 
-            fn set_contents(&mut self, value: String, clipboard_type: ClipboardType) -> Result<()> {
+            match self {
+                Self::Pasteboard => yank_from_builtin(PASTEBOARD, clipboard_type),
+                Self::Wayland => yank_from_builtin(WL_CLIPBOARD, clipboard_type),
+                Self::XClip => yank_from_builtin(XCLIP, clipboard_type),
+                Self::XSel => yank_from_builtin(XSEL, clipboard_type),
+                Self::Win32Yank => yank_from_builtin(WIN32, clipboard_type),
+                Self::Tmux => yank_from_builtin(TMUX, clipboard_type),
+                Self::Termux => yank_from_builtin(TERMUX, clipboard_type),
+                #[cfg(target_os = "windows")]
+                Self::Windows => match clipboard_type {
+                    ClipboardType::Clipboard => {
+                        let contents =
+                            clipboard_win::get_clipboard(clipboard_win::formats::Unicode)?;
+                        Ok(contents)
+                    }
+                    ClipboardType::Selection => Ok(String::new()),
+                },
+                #[cfg(feature = "term")]
+                Self::Termcode => Err(ClipboardError::ReadingNotSupported),
+                Self::Custom(command_provider) => {
+                    execute_command(&command_provider.yank, None, true)?
+                        .ok_or(ClipboardError::MissingStdout)
+                }
+                Self::None => Err(ClipboardError::ReadingNotSupported),
+            }
+        }
+
+        pub fn set_contents(&self, content: &str, clipboard_type: ClipboardType) -> Result<()> {
+            fn paste_to_builtin(
+                provider: CommandProvider,
+                content: &str,
+                clipboard_type: ClipboardType,
+            ) -> Result<()> {
                 let cmd = match clipboard_type {
-                    ClipboardType::Clipboard => &self.set_cmd,
+                    ClipboardType::Clipboard => &provider.paste,
                     ClipboardType::Selection => {
-                        if let Some(cmd) = &self.set_primary_cmd {
+                        if let Some(cmd) = provider.paste_primary.as_ref() {
                             cmd
                         } else {
                             return Ok(());
                         }
                     }
                 };
-                cmd.execute(Some(&value), false).map(|_| ())
+
+                execute_command(cmd, Some(content), false).map(|_| ())
+            }
+
+            match self {
+                Self::Pasteboard => paste_to_builtin(PASTEBOARD, content, clipboard_type),
+                Self::Wayland => paste_to_builtin(WL_CLIPBOARD, content, clipboard_type),
+                Self::XClip => paste_to_builtin(XCLIP, content, clipboard_type),
+                Self::XSel => paste_to_builtin(XSEL, content, clipboard_type),
+                Self::Win32Yank => paste_to_builtin(WIN32, content, clipboard_type),
+                Self::Tmux => paste_to_builtin(TMUX, content, clipboard_type),
+                Self::Termux => paste_to_builtin(TERMUX, content, clipboard_type),
+                #[cfg(target_os = "windows")]
+                Self::Windows => match clipboard_type {
+                    ClipboardType::Clipboard => {
+                        clipboard_win::set_clipboard(clipboard_win::formats::Unicode, content)?;
+                        Ok(())
+                    }
+                    ClipboardType::Selection => Ok(()),
+                },
+                #[cfg(feature = "term")]
+                Self::Termcode => {
+                    crossterm::queue!(
+                        std::io::stdout(),
+                        osc52::SetClipboardCommand::new(content, clipboard_type)
+                    )?;
+                    Ok(())
+                }
+                Self::Custom(command_provider) => match clipboard_type {
+                    ClipboardType::Clipboard => {
+                        execute_command(&command_provider.paste, Some(content), false).map(|_| ())
+                    }
+                    ClipboardType::Selection => {
+                        if let Some(cmd) = &command_provider.paste_primary {
+                            execute_command(cmd, Some(content), false).map(|_| ())
+                        } else {
+                            Ok(())
+                        }
+                    }
+                },
+                Self::None => Ok(()),
             }
         }
     }
-}
 
-#[cfg(target_os = "windows")]
-mod provider {
-    use super::{ClipboardProvider, ClipboardType};
-    use anyhow::Result;
-    use std::borrow::Cow;
+    macro_rules! command_provider {
+        ($name:ident,
+         yank => $yank_cmd:literal $( , $yank_arg:literal )* ;
+         paste => $paste_cmd:literal $( , $paste_arg:literal )* ; ) => {
+            const $name: CommandProvider = CommandProvider {
+                yank: Command {
+                    command: Cow::Borrowed($yank_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($yank_arg) ),* ])
+                },
+                paste: Command {
+                    command: Cow::Borrowed($paste_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($paste_arg) ),* ])
+                },
+                yank_primary: None,
+                paste_primary: None,
+            };
+        };
+        ($name:ident,
+         yank => $yank_cmd:literal $( , $yank_arg:literal )* ;
+         paste => $paste_cmd:literal $( , $paste_arg:literal )* ;
+         yank_primary => $yank_primary_cmd:literal $( , $yank_primary_arg:literal )* ;
+         paste_primary => $paste_primary_cmd:literal $( , $paste_primary_arg:literal )* ; ) => {
+            const $name: CommandProvider = CommandProvider {
+                yank: Command {
+                    command: Cow::Borrowed($yank_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($yank_arg) ),* ])
+                },
+                paste: Command {
+                    command: Cow::Borrowed($paste_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($paste_arg) ),* ])
+                },
+                yank_primary: Some(Command {
+                    command: Cow::Borrowed($yank_primary_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($yank_primary_arg) ),* ])
+                }),
+                paste_primary: Some(Command {
+                    command: Cow::Borrowed($paste_primary_cmd),
+                    args: Cow::Borrowed(&[ $( Cow::Borrowed($paste_primary_arg) ),* ])
+                }),
+            };
+        };
+    }
 
-    #[derive(Default, Debug)]
-    pub struct WindowsProvider;
+    command_provider! {
+        TMUX,
+        yank => "tmux", "save-buffer", "-";
+        paste => "tmux", "load-buffer", "-w", "-";
+    }
+    command_provider! {
+        PASTEBOARD,
+        yank => "pbpaste";
+        paste => "pbcopy";
+    }
+    command_provider! {
+        WL_CLIPBOARD,
+        yank => "wl-paste", "--no-newline";
+        paste => "wl-copy", "--type", "text/plain";
+        yank_primary => "wl-paste", "-p", "--no-newline";
+        paste_primary => "wl-copy", "-p", "--type", "text/plain";
+    }
+    command_provider! {
+        XCLIP,
+        yank => "xclip", "-o", "-selection", "clipboard";
+        paste => "xclip", "-i", "-selection", "clipboard";
+        yank_primary => "xclip", "-o";
+        paste_primary => "xclip", "-i";
+    }
+    command_provider! {
+        XSEL,
+        yank => "xsel", "-o", "-b";
+        paste => "xsel", "-i", "-b";
+        yank_primary => "xsel", "-o";
+        paste_primary => "xsel", "-i";
+    }
+    command_provider! {
+        WIN32,
+        yank => "win32yank.exe", "-o", "--lf";
+        paste => "win32yank.exe", "-i", "--crlf";
+    }
+    command_provider! {
+        TERMUX,
+        yank => "termux-clipboard-get";
+        paste => "termux-clipboard-set";
+    }
 
-    impl ClipboardProvider for WindowsProvider {
-        fn name(&self) -> Cow<str> {
-            log::debug!("Using clipboard-win to interact with the system clipboard");
-            Cow::Borrowed("clipboard-win")
+    #[cfg(feature = "term")]
+    mod osc52 {
+        use {super::ClipboardType, crate::base64};
+
+        pub struct SetClipboardCommand {
+            encoded_content: String,
+            clipboard_type: ClipboardType,
         }
 
-        fn get_contents(&self, clipboard_type: ClipboardType) -> Result<String> {
-            match clipboard_type {
-                ClipboardType::Clipboard => {
-                    let contents = clipboard_win::get_clipboard(clipboard_win::formats::Unicode)?;
-                    Ok(contents)
+        impl SetClipboardCommand {
+            pub fn new(content: &str, clipboard_type: ClipboardType) -> Self {
+                Self {
+                    encoded_content: base64::encode(content.as_bytes()),
+                    clipboard_type,
                 }
-                ClipboardType::Selection => Ok(String::new()),
             }
         }
 
-        fn set_contents(&mut self, contents: String, clipboard_type: ClipboardType) -> Result<()> {
-            match clipboard_type {
-                ClipboardType::Clipboard => {
-                    clipboard_win::set_clipboard(clipboard_win::formats::Unicode, contents)?;
-                }
-                ClipboardType::Selection => {}
-            };
-            Ok(())
+        impl crossterm::Command for SetClipboardCommand {
+            fn write_ansi(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
+                let kind = match &self.clipboard_type {
+                    ClipboardType::Clipboard => "c",
+                    ClipboardType::Selection => "p",
+                };
+                // Send an OSC 52 set command: https://terminalguide.namepad.de/seq/osc-52/
+                write!(f, "\x1b]52;{};{}\x1b\\", kind, &self.encoded_content)
+            }
+            #[cfg(windows)]
+            fn execute_winapi(&self) -> std::result::Result<(), std::io::Error> {
+                Err(std::io::Error::new(
+                    std::io::ErrorKind::Other,
+                    "OSC clipboard codes not supported by winapi.",
+                ))
+            }
+        }
+    }
+
+    fn execute_command(
+        cmd: &Command,
+        input: Option<&str>,
+        pipe_output: bool,
+    ) -> Result<Option<String>> {
+        use std::io::Write;
+        use std::process::{Command, Stdio};
+
+        let stdin = input.map(|_| Stdio::piped()).unwrap_or_else(Stdio::null);
+        let stdout = pipe_output.then(Stdio::piped).unwrap_or_else(Stdio::null);
+
+        let mut command: Command = Command::new(cmd.command.as_ref());
+
+        #[allow(unused_mut)]
+        let mut command_mut: &mut Command = command
+            .args(cmd.args.iter().map(AsRef::as_ref))
+            .stdin(stdin)
+            .stdout(stdout)
+            .stderr(Stdio::null());
+
+        // Fix for https://github.com/helix-editor/helix/issues/5424
+        #[cfg(unix)]
+        {
+            use std::os::unix::process::CommandExt;
+
+            unsafe {
+                command_mut = command_mut.pre_exec(|| match libc::setsid() {
+                    -1 => Err(std::io::Error::last_os_error()),
+                    _ => Ok(()),
+                });
+            }
+        }
+
+        let mut child = command_mut.spawn()?;
+
+        if let Some(input) = input {
+            let mut stdin = child.stdin.take().ok_or(ClipboardError::StdinWriteFailed)?;
+            stdin
+                .write_all(input.as_bytes())
+                .map_err(|_| ClipboardError::StdinWriteFailed)?;
+        }
+
+        // TODO: add timer?
+        let output = child.wait_with_output()?;
+
+        if !output.status.success() {
+            log::error!(
+                "clipboard provider {} failed with stderr: \"{}\"",
+                cmd.command,
+                String::from_utf8_lossy(&output.stderr)
+            );
+            return Err(ClipboardError::CommandFailed);
+        }
+
+        if pipe_output {
+            Ok(Some(String::from_utf8(output.stdout)?))
+        } else {
+            Ok(None)
         }
     }
 }
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 15aa81dae..06a708f05 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -7,11 +7,13 @@
 use helix_core::chars::char_is_word;
 use helix_core::doc_formatter::TextFormat;
 use helix_core::encoding::Encoding;
+use helix_core::snippets::{ActiveSnippet, SnippetRenderCtx};
 use helix_core::syntax::{Highlight, LanguageServerFeature};
 use helix_core::text_annotations::{InlineAnnotation, Overlay};
 use helix_lsp::util::lsp_pos_to_pos;
 use helix_stdx::faccess::{copy_metadata, readonly};
 use helix_vcs::{DiffHandle, DiffProviderRegistry};
+use once_cell::sync::OnceCell;
 use thiserror;
 
 use ::parking_lot::Mutex;
@@ -135,6 +137,7 @@ pub struct Document {
     text: Rope,
     selections: HashMap<ViewId, Selection>,
     view_data: HashMap<ViewId, ViewData>,
+    pub active_snippet: Option<ActiveSnippet>,
 
     /// Inlay hints annotations for the document, by view.
     ///
@@ -146,6 +149,7 @@ pub struct Document {
     pub inlay_hints_oudated: bool,
 
     path: Option<PathBuf>,
+    relative_path: OnceCell<Option<PathBuf>>,
     encoding: &'static encoding::Encoding,
     has_bom: bool,
 
@@ -298,6 +302,14 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     }
 }
 
+impl Editor {
+    pub(crate) fn clear_doc_relative_paths(&mut self) {
+        for doc in self.documents_mut() {
+            doc.relative_path.take();
+        }
+    }
+}
+
 enum Encoder {
     Utf16Be,
     Utf16Le,
@@ -655,7 +667,9 @@ pub fn from(
 
         Self {
             id: DocumentId::default(),
+            active_snippet: None,
             path: None,
+            relative_path: OnceCell::new(),
             encoding,
             has_bom,
             text,
@@ -703,10 +717,7 @@ pub fn open(
         config: Arc<dyn DynAccess<Config>>,
     ) -> Result<Self, DocumentOpenError> {
         // If the path is not a regular file (e.g.: /dev/random) it should not be opened.
-        if path
-            .metadata()
-            .map_or(false, |metadata| !metadata.is_file())
-        {
+        if path.metadata().is_ok_and(|metadata| !metadata.is_file()) {
             return Err(DocumentOpenError::IrregularFile);
         }
 
@@ -758,9 +769,20 @@ pub fn format(&self) -> Option<BoxFuture<'static, Result<Transaction, FormatterE
                 ))
             })
         {
+            log::debug!(
+                "formatting '{}' with command '{}', args {fmt_args:?}",
+                self.display_name(),
+                fmt_cmd.display(),
+            );
             use std::process::Stdio;
             let text = self.text().clone();
+
             let mut process = tokio::process::Command::new(&fmt_cmd);
+
+            if let Some(doc_dir) = self.path.as_ref().and_then(|path| path.parent()) {
+                process.current_dir(doc_dir);
+            }
+
             process
                 .args(fmt_args)
                 .stdin(Stdio::piped())
@@ -774,17 +796,21 @@ pub fn format(&self) -> Option<BoxFuture<'static, Result<Transaction, FormatterE
                         command: fmt_cmd.to_string_lossy().into(),
                         error: e.kind(),
                     })?;
-                {
-                    let mut stdin = process.stdin.take().ok_or(FormatterError::BrokenStdin)?;
-                    to_writer(&mut stdin, (encoding::UTF_8, false), &text)
-                        .await
-                        .map_err(|_| FormatterError::BrokenStdin)?;
-                }
 
-                let output = process
-                    .wait_with_output()
-                    .await
-                    .map_err(|_| FormatterError::WaitForOutputFailed)?;
+                let mut stdin = process.stdin.take().ok_or(FormatterError::BrokenStdin)?;
+                let input_text = text.clone();
+                let input_task = tokio::spawn(async move {
+                    to_writer(&mut stdin, (encoding::UTF_8, false), &input_text).await
+                    // Note that `stdin` is dropped here, causing the pipe to close. This can
+                    // avoid a deadlock with `wait_with_output` below if the process is waiting on
+                    // stdin to close before exiting.
+                });
+                let (input_result, output_result) = tokio::join! {
+                    input_task,
+                    process.wait_with_output(),
+                };
+                let _ = input_result.map_err(|_| FormatterError::BrokenStdin)?;
+                let output = output_result.map_err(|_| FormatterError::WaitForOutputFailed)?;
 
                 if !output.status.success() {
                     if !output.stderr.is_empty() {
@@ -1030,13 +1056,8 @@ impl Future<Output = Result<DocumentSavedEvent, anyhow::Error>> + 'static + Send
                 if !language_server.is_initialized() {
                     continue;
                 }
-                if let Some(notification) = identifier
-                    .clone()
-                    .and_then(|id| language_server.text_document_did_save(id, &text))
-                {
-                    if let Err(err) = notification.await {
-                        log::error!("Failed to send textDocument/didSave: {err}");
-                    }
+                if let Some(id) = identifier.clone() {
+                    language_server.text_document_did_save(id, &text);
                 }
             }
 
@@ -1169,6 +1190,10 @@ pub fn encoding(&self) -> &'static Encoding {
     pub fn set_path(&mut self, path: Option<&Path>) {
         let path = path.map(helix_stdx::path::canonicalize);
 
+        // `take` to remove any prior relative path that may have existed.
+        // This will get set in `relative_path()`.
+        self.relative_path.take();
+
         // if parent doesn't exist we still want to open the document
         // and error out when document is saved
         self.path = path;
@@ -1412,6 +1437,8 @@ fn apply_impl(
             doc: self,
             view: view_id,
             old_text: &old_doc,
+            changes,
+            ghost_transaction: !emit_lsp_notification,
         });
 
         // if specified, the current selection should instead be replaced by transaction.selection
@@ -1430,16 +1457,12 @@ fn apply_impl(
             // TODO: move to hook
             // emit lsp notification
             for language_server in self.language_servers() {
-                let notify = language_server.text_document_did_change(
+                let _ = language_server.text_document_did_change(
                     self.versioned_identifier(),
                     &old_doc,
                     self.text(),
                     changes,
                 );
-
-                if let Some(notify) = notify {
-                    tokio::spawn(notify);
-                }
             }
         }
 
@@ -1713,6 +1736,12 @@ pub fn version(&self) -> i32 {
         self.version
     }
 
+    pub fn path_completion_enabled(&self) -> bool {
+        self.language_config()
+            .and_then(|lang_config| lang_config.path_completion)
+            .unwrap_or_else(|| self.config.load().path_completion)
+    }
+
     /// maintains the order as configured in the language_servers TOML array
     pub fn language_servers(&self) -> impl Iterator<Item = &helix_lsp::Client> {
         self.language_config().into_iter().flat_map(move |config| {
@@ -1856,16 +1885,19 @@ pub fn set_view_offset(&mut self, view_id: ViewId, new_offset: ViewPosition) {
         self.view_data_mut(view_id).view_position = new_offset;
     }
 
-    pub fn relative_path(&self) -> Option<Cow<Path>> {
-        self.path
+    pub fn relative_path(&self) -> Option<&Path> {
+        self.relative_path
+            .get_or_init(|| {
+                self.path
+                    .as_ref()
+                    .map(|path| helix_stdx::path::get_relative_path(path).to_path_buf())
+            })
             .as_deref()
-            .map(helix_stdx::path::get_relative_path)
     }
 
-    pub fn display_name(&self) -> Cow<'static, str> {
+    pub fn display_name(&self) -> Cow<'_, str> {
         self.relative_path()
-            .map(|path| path.to_string_lossy().to_string().into())
-            .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into())
+            .map_or_else(|| SCRATCH_BUFFER_NAME.into(), |path| path.to_string_lossy())
     }
 
     // transact(Fn) ?
@@ -1920,12 +1952,15 @@ pub fn lsp_diagnostic_to_diagnostic(
             return None;
         };
 
-        let severity = diagnostic.severity.map(|severity| match severity {
-            lsp::DiagnosticSeverity::ERROR => Error,
-            lsp::DiagnosticSeverity::WARNING => Warning,
-            lsp::DiagnosticSeverity::INFORMATION => Info,
-            lsp::DiagnosticSeverity::HINT => Hint,
-            severity => unreachable!("unrecognized diagnostic severity: {:?}", severity),
+        let severity = diagnostic.severity.and_then(|severity| match severity {
+            lsp::DiagnosticSeverity::ERROR => Some(Error),
+            lsp::DiagnosticSeverity::WARNING => Some(Warning),
+            lsp::DiagnosticSeverity::INFORMATION => Some(Info),
+            lsp::DiagnosticSeverity::HINT => Some(Hint),
+            severity => {
+                log::error!("unrecognized diagnostic severity: {:?}", severity);
+                None
+            }
         });
 
         if let Some(lang_conf) = language_config {
@@ -1961,8 +1996,8 @@ pub fn lsp_diagnostic_to_diagnostic(
         };
 
         let ends_at_word =
-            start != end && end != 0 && text.get_char(end - 1).map_or(false, char_is_word);
-        let starts_at_word = start != end && text.get_char(start).map_or(false, char_is_word);
+            start != end && end != 0 && text.get_char(end - 1).is_some_and(char_is_word);
+        let starts_at_word = start != end && text.get_char(start).is_some_and(char_is_word);
 
         Some(Diagnostic {
             range: Range { start, end },
@@ -1995,7 +2030,7 @@ pub fn replace_diagnostics(
             self.clear_diagnostics(language_server_id);
         } else {
             self.diagnostics.retain(|d| {
-                if language_server_id.map_or(false, |id| id != d.provider) {
+                if language_server_id.is_some_and(|id| id != d.provider) {
                     return true;
                 }
 
@@ -2042,6 +2077,16 @@ pub fn auto_pairs<'a>(&'a self, editor: &'a Editor) -> Option<&'a AutoPairs> {
         }
     }
 
+    pub fn snippet_ctx(&self) -> SnippetRenderCtx {
+        SnippetRenderCtx {
+            // TODO snippet variable resolution
+            resolve_var: Box::new(|_| None),
+            tab_width: self.tab_width(),
+            indent_style: self.indent_style,
+            line_ending: self.line_ending.as_str(),
+        }
+    }
+
     pub fn text_format(&self, mut viewport_width: u16, theme: Option<&Theme>) -> TextFormat {
         let config = self.config.load();
         let text_width = self
@@ -2145,7 +2190,6 @@ pub enum FormatterError {
     BrokenStdin,
     WaitForOutputFailed,
     InvalidUtf8Output,
-    DiskReloadError(String),
     NonZeroExitStatus(Option<String>),
 }
 
@@ -2160,7 +2204,6 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
             Self::BrokenStdin => write!(f, "Could not write to formatter stdin"),
             Self::WaitForOutputFailed => write!(f, "Waiting for formatter output failed"),
             Self::InvalidUtf8Output => write!(f, "Invalid UTF-8 formatter output"),
-            Self::DiskReloadError(error) => write!(f, "Error reloading file from disk: {}", error),
             Self::NonZeroExitStatus(Some(output)) => write!(f, "Formatter error: {}", output),
             Self::NonZeroExitStatus(None) => {
                 write!(f, "Formatter exited with non zero exit status")
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index 1708b3b4e..739dcfb49 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -1,8 +1,10 @@
 use crate::{
     annotations::diagnostics::{DiagnosticFilter, InlineDiagnosticsConfig},
+    clipboard::ClipboardProvider,
     document::{
         DocumentOpenError, DocumentSavedEventFuture, DocumentSavedEventResult, Mode, SavePoint,
     },
+    events::DocumentFocusLost,
     graphics::{CursorKind, Rect},
     handlers::Handlers,
     info::Info,
@@ -13,6 +15,7 @@
     Document, DocumentId, View, ViewId,
 };
 use dap::StackFrame;
+use helix_event::dispatch;
 use helix_vcs::DiffProviderRegistry;
 
 use futures_util::stream::select_all::SelectAll;
@@ -267,8 +270,15 @@ pub struct Config {
     pub auto_pairs: AutoPairConfig,
     /// Automatic auto-completion, automatically pop up without user trigger. Defaults to true.
     pub auto_completion: bool,
+    /// Enable filepath completion.
+    /// Show files and directories if an existing path at the cursor was recognized,
+    /// either absolute or relative to the current opened document or current working directory (if the buffer is not yet saved).
+    /// Defaults to true.
+    pub path_completion: bool,
     /// Automatic formatting on save. Defaults to true.
     pub auto_format: bool,
+    /// Default register used for yank/paste. Defaults to '"'
+    pub default_yank_register: char,
     /// Automatic save on focus lost and/or after delay.
     /// Time delay in milliseconds since last edit after which auto save timer triggers.
     /// Time delay defaults to false with 3000ms delay. Focus lost defaults to false.
@@ -296,6 +306,9 @@ pub struct Config {
     /// Whether to instruct the LSP to replace the entire word when applying a completion
     /// or to only insert new text
     pub completion_replace: bool,
+    /// `true` if helix should automatically add a line comment token if you're currently in a comment
+    /// and press `enter`.
+    pub continue_comments: bool,
     /// Whether to display infoboxes. Defaults to true.
     pub auto_info: bool,
     pub file_picker: FilePickerConfig,
@@ -345,10 +358,12 @@ pub struct Config {
     /// Display diagnostic below the line they occur.
     pub inline_diagnostics: InlineDiagnosticsConfig,
     pub end_of_line_diagnostics: DiagnosticFilter,
+    // Set to override the default clipboard provider
+    pub clipboard_provider: ClipboardProvider,
 }
 
 #[derive(Debug, Clone, PartialEq, Deserialize, Serialize, Eq, PartialOrd, Ord)]
-#[serde(rename_all = "kebab-case", default)]
+#[serde(default, rename_all = "kebab-case", deny_unknown_fields)]
 pub struct SmartTabConfig {
     pub enable: bool,
     pub supersede_menu: bool,
@@ -421,7 +436,9 @@ pub fn get_terminal_provider() -> Option<TerminalConfig> {
 pub struct LspConfig {
     /// Enables LSP
     pub enable: bool,
-    /// Display LSP progress messages below statusline
+    /// Display LSP messagess from $/progress below statusline
+    pub display_progress_messages: bool,
+    /// Display LSP messages from window/showMessage below statusline
     pub display_messages: bool,
     /// Enable automatic pop up of signature help (parameter hints)
     pub auto_signature_help: bool,
@@ -439,7 +456,8 @@ impl Default for LspConfig {
     fn default() -> Self {
         Self {
             enable: true,
-            display_messages: false,
+            display_progress_messages: false,
+            display_messages: true,
             auto_signature_help: true,
             display_signature_help_docs: true,
             display_inlay_hints: false,
@@ -944,7 +962,9 @@ fn default() -> Self {
             middle_click_paste: true,
             auto_pairs: AutoPairConfig::default(),
             auto_completion: true,
+            path_completion: true,
             auto_format: true,
+            default_yank_register: '"',
             auto_save: AutoSave::default(),
             idle_timeout: Duration::from_millis(250),
             completion_timeout: Duration::from_millis(250),
@@ -970,6 +990,7 @@ fn default() -> Self {
             },
             text_width: 80,
             completion_replace: false,
+            continue_comments: true,
             workspace_lsp_roots: Vec::new(),
             default_line_ending: LineEndingConfig::default(),
             insert_final_newline: true,
@@ -979,6 +1000,7 @@ fn default() -> Self {
             jump_label_alphabet: ('a'..='z').collect(),
             inline_diagnostics: InlineDiagnosticsConfig::default(),
             end_of_line_diagnostics: DiagnosticFilter::Disable,
+            clipboard_provider: ClipboardProvider::default(),
         }
     }
 }
@@ -1057,6 +1079,7 @@ pub struct Editor {
     redraw_timer: Pin<Box<Sleep>>,
     last_motion: Option<Motion>,
     pub last_completion: Option<CompleteAction>,
+    last_cwd: Option<PathBuf>,
 
     pub exit_code: i32,
 
@@ -1114,6 +1137,7 @@ pub enum CompleteAction {
     Applied {
         trigger_offset: usize,
         changes: Vec<Change>,
+        placeholder: bool,
     },
 }
 
@@ -1180,13 +1204,17 @@ pub fn new(
             theme_loader,
             last_theme: None,
             last_selection: None,
-            registers: Registers::default(),
+            registers: Registers::new(Box::new(arc_swap::access::Map::new(
+                Arc::clone(&config),
+                |config: &Config| &config.clipboard_provider,
+            ))),
             status_msg: None,
             autoinfo: None,
             idle_timer: Box::pin(sleep(conf.idle_timeout)),
             redraw_timer: Box::pin(sleep(Duration::MAX)),
             last_motion: None,
             last_completion: None,
+            last_cwd: None,
             config,
             auto_pairs,
             exit_code: 0,
@@ -1271,6 +1299,13 @@ pub fn set_error<T: Into<Cow<'static, str>>>(&mut self, error: T) {
         self.status_msg = Some((error, Severity::Error));
     }
 
+    #[inline]
+    pub fn set_warning<T: Into<Cow<'static, str>>>(&mut self, warning: T) {
+        let warning = warning.into();
+        log::warn!("editor warning: {}", warning);
+        self.status_msg = Some((warning, Severity::Warning));
+    }
+
     #[inline]
     pub fn get_status(&self) -> Option<(&Cow<'static, str>, &Severity)> {
         self.status_msg.as_ref().map(|(status, sev)| (status, sev))
@@ -1381,9 +1416,7 @@ pub fn move_path(&mut self, old_path: &Path, new_path: &Path) -> io::Result<()>
             if !ls.is_initialized() {
                 continue;
             }
-            if let Some(notification) = ls.did_rename(old_path, &new_path, is_dir) {
-                tokio::spawn(notification);
-            };
+            ls.did_rename(old_path, &new_path, is_dir);
         }
         self.language_servers
             .file_event_handler
@@ -1406,7 +1439,7 @@ pub fn set_doc_path(&mut self, doc_id: DocumentId, path: &Path) {
             }
             // if we are open in LSPs send did_close notification
             for language_server in doc.language_servers() {
-                tokio::spawn(language_server.text_document_did_close(doc.identifier()));
+                language_server.text_document_did_close(doc.identifier());
             }
         }
         // we need to clear the list of language servers here so that
@@ -1487,7 +1520,7 @@ fn launch_language_servers(&mut self, doc_id: DocumentId) {
             });
 
         for (_, language_server) in doc_language_servers_not_in_registry {
-            tokio::spawn(language_server.text_document_did_close(doc.identifier()));
+            language_server.text_document_did_close(doc.identifier());
         }
 
         let language_servers_not_in_doc = language_servers.iter().filter(|(name, ls)| {
@@ -1498,12 +1531,12 @@ fn launch_language_servers(&mut self, doc_id: DocumentId) {
 
         for (_, language_server) in language_servers_not_in_doc {
             // TODO: this now races with on_init code if the init happens too quickly
-            tokio::spawn(language_server.text_document_did_open(
+            language_server.text_document_did_open(
                 doc_url.clone(),
                 doc.version(),
                 doc.text(),
                 language_id.clone(),
-            ));
+            );
         }
 
         doc.language_servers = language_servers;
@@ -1558,7 +1591,7 @@ pub fn switch(&mut self, id: DocumentId, action: Action) {
             self.enter_normal_mode();
         }
 
-        match action {
+        let focust_lost = match action {
             Action::Replace => {
                 let (view, doc) = current_ref!(self);
                 // If the current view is an empty scratch buffer and is not displayed in any other views, delete it.
@@ -1608,6 +1641,10 @@ pub fn switch(&mut self, id: DocumentId, action: Action) {
 
                 self.replace_document_in_view(view_id, id);
 
+                dispatch(DocumentFocusLost {
+                    editor: self,
+                    doc: id,
+                });
                 return;
             }
             Action::Load => {
@@ -1618,6 +1655,7 @@ pub fn switch(&mut self, id: DocumentId, action: Action) {
                 return;
             }
             Action::HorizontalSplit | Action::VerticalSplit => {
+                let focus_lost = self.tree.try_get(self.tree.focus).map(|view| view.doc);
                 // copy the current view, unless there is no view yet
                 let view = self
                     .tree
@@ -1637,10 +1675,17 @@ pub fn switch(&mut self, id: DocumentId, action: Action) {
                 let doc = doc_mut!(self, &id);
                 doc.ensure_view_init(view_id);
                 doc.mark_as_focused();
+                focus_lost
             }
-        }
+        };
 
         self._refresh();
+        if let Some(focus_lost) = focust_lost {
+            dispatch(DocumentFocusLost {
+                editor: self,
+                doc: focus_lost,
+            });
+        }
     }
 
     /// Generate an id for a new document and register it.
@@ -1690,10 +1735,14 @@ pub fn new_file_from_stdin(&mut self, action: Action) -> Result<DocumentId, Erro
         Ok(doc_id)
     }
 
+    pub fn document_id_by_path(&self, path: &Path) -> Option<DocumentId> {
+        self.document_by_path(path).map(|doc| doc.id)
+    }
+
     // ??? possible use for integration tests
     pub fn open(&mut self, path: &Path, action: Action) -> Result<DocumentId, DocumentOpenError> {
         let path = helix_stdx::path::canonicalize(path);
-        let id = self.document_by_path(&path).map(|doc| doc.id);
+        let id = self.document_id_by_path(&path);
 
         let id = if let Some(id) = id {
             id
@@ -1746,8 +1795,7 @@ pub fn close_document(&mut self, doc_id: DocumentId, force: bool) -> Result<(),
         self.saves.remove(&doc_id);
 
         for language_server in doc.language_servers() {
-            // TODO: track error
-            tokio::spawn(language_server.text_document_did_close(doc.identifier()));
+            language_server.text_document_did_close(doc.identifier());
         }
 
         enum Action {
@@ -1867,11 +1915,15 @@ pub fn focus(&mut self, view_id: ViewId) {
                 let doc = doc_mut!(self, &view.doc);
                 view.sync_changes(doc);
             }
+            let view = view!(self, view_id);
+            let doc = doc_mut!(self, &view.doc);
+            doc.mark_as_focused();
+            let focus_lost = self.tree.get(prev_id).doc;
+            dispatch(DocumentFocusLost {
+                editor: self,
+                doc: focus_lost,
+            });
         }
-
-        let view = view!(self, view_id);
-        let doc = doc_mut!(self, &view.doc);
-        doc.mark_as_focused();
     }
 
     pub fn focus_next(&mut self) {
@@ -2154,6 +2206,16 @@ pub fn get_synced_view_id(&mut self, id: DocumentId) -> ViewId {
             current_view.id
         }
     }
+
+    pub fn set_cwd(&mut self, path: &Path) -> std::io::Result<()> {
+        self.last_cwd = helix_stdx::env::set_current_working_dir(path)?;
+        self.clear_doc_relative_paths();
+        Ok(())
+    }
+
+    pub fn get_last_cwd(&mut self) -> Option<&Path> {
+        self.last_cwd.as_deref()
+    }
 }
 
 fn try_restore_indent(doc: &mut Document, view: &mut View) {
diff --git a/helix-view/src/events.rs b/helix-view/src/events.rs
index 881412495..eb97268ce 100644
--- a/helix-view/src/events.rs
+++ b/helix-view/src/events.rs
@@ -1,10 +1,18 @@
-use helix_core::Rope;
+use helix_core::{ChangeSet, Rope};
 use helix_event::events;
 
 use crate::{Document, DocumentId, Editor, ViewId};
 
 events! {
-    DocumentDidChange<'a> { doc: &'a mut Document, view: ViewId, old_text: &'a Rope  }
+    DocumentDidChange<'a> {
+        doc: &'a mut Document,
+        view: ViewId,
+        old_text: &'a Rope,
+        changes: &'a ChangeSet,
+        ghost_transaction: bool
+    }
     SelectionDidChange<'a> { doc: &'a mut Document, view: ViewId }
     DiagnosticsDidChange<'a> { editor: &'a mut Editor, doc: DocumentId }
+    // called **after** a document loses focus (but not when its closed)
+    DocumentFocusLost<'a> { editor: &'a mut Editor, doc: DocumentId }
 }
diff --git a/helix-view/src/graphics.rs b/helix-view/src/graphics.rs
index a26823b97..3cd3c8626 100644
--- a/helix-view/src/graphics.rs
+++ b/helix-view/src/graphics.rs
@@ -263,6 +263,31 @@ pub enum Color {
     Indexed(u8),
 }
 
+impl Color {
+    /// Creates a `Color` from a hex string
+    ///
+    /// # Examples
+    ///
+    /// ```rust
+    /// use helix_view::theme::Color;
+    ///
+    /// let color1 = Color::from_hex("#c0ffee").unwrap();
+    /// let color2 = Color::Rgb(192, 255, 238);
+    ///
+    /// assert_eq!(color1, color2);
+    /// ```
+    pub fn from_hex(hex: &str) -> Option<Self> {
+        if !(hex.starts_with('#') && hex.len() == 7) {
+            return None;
+        }
+        match [1..=2, 3..=4, 5..=6].map(|i| hex.get(i).and_then(|c| u8::from_str_radix(c, 16).ok()))
+        {
+            [Some(r), Some(g), Some(b)] => Some(Self::Rgb(r, g, b)),
+            _ => None,
+        }
+    }
+}
+
 #[cfg(feature = "term")]
 impl From<Color> for crossterm::style::Color {
     fn from(color: Color) -> Self {
@@ -317,6 +342,7 @@ fn from_str(modifier: &str) -> Result<Self, Self::Err> {
     }
 }
 
+#[cfg(feature = "term")]
 impl From<UnderlineStyle> for crossterm::style::Attribute {
     fn from(style: UnderlineStyle) -> Self {
         match style {
diff --git a/helix-view/src/gutter.rs b/helix-view/src/gutter.rs
index 36f719f79..7cd912712 100644
--- a/helix-view/src/gutter.rs
+++ b/helix-view/src/gutter.rs
@@ -178,7 +178,7 @@ pub fn line_numbers<'doc>(
                     && current_line != line;
 
                 let display_num = if relative {
-                    abs_diff(current_line, line)
+                    current_line.abs_diff(line)
                 } else {
                     line + 1
                 };
@@ -226,15 +226,6 @@ pub fn padding<'doc>(
     Box::new(|_line: usize, _selected: bool, _first_visual_line: bool, _out: &mut String| None)
 }
 
-#[inline(always)]
-const fn abs_diff(a: usize, b: usize) -> usize {
-    if a > b {
-        a - b
-    } else {
-        b - a
-    }
-}
-
 pub fn breakpoints<'doc>(
     editor: &'doc Editor,
     doc: &'doc Document,
diff --git a/helix-view/src/handlers.rs b/helix-view/src/handlers.rs
index 93336beb5..a26c4ddb1 100644
--- a/helix-view/src/handlers.rs
+++ b/helix-view/src/handlers.rs
@@ -1,9 +1,11 @@
+use completion::{CompletionEvent, CompletionHandler};
 use helix_event::send_blocking;
 use tokio::sync::mpsc::Sender;
 
 use crate::handlers::lsp::SignatureHelpInvoked;
 use crate::{DocumentId, Editor, ViewId};
 
+pub mod completion;
 pub mod dap;
 pub mod diagnostics;
 pub mod lsp;
@@ -16,7 +18,7 @@ pub enum AutoSaveEvent {
 
 pub struct Handlers {
     // only public because most of the actual implementation is in helix-term right now :/
-    pub completions: Sender<lsp::CompletionEvent>,
+    pub completions: CompletionHandler,
     pub signature_hints: Sender<lsp::SignatureHelpEvent>,
     pub auto_save: Sender<AutoSaveEvent>,
 }
@@ -24,14 +26,11 @@ pub struct Handlers {
 impl Handlers {
     /// Manually trigger completion (c-x)
     pub fn trigger_completions(&self, trigger_pos: usize, doc: DocumentId, view: ViewId) {
-        send_blocking(
-            &self.completions,
-            lsp::CompletionEvent::ManualTrigger {
-                cursor: trigger_pos,
-                doc,
-                view,
-            },
-        );
+        self.completions.event(CompletionEvent::ManualTrigger {
+            cursor: trigger_pos,
+            doc,
+            view,
+        });
     }
 
     pub fn trigger_signature_help(&self, invocation: SignatureHelpInvoked, editor: &Editor) {
diff --git a/helix-view/src/handlers/completion.rs b/helix-view/src/handlers/completion.rs
new file mode 100644
index 000000000..db3f0b26b
--- /dev/null
+++ b/helix-view/src/handlers/completion.rs
@@ -0,0 +1,64 @@
+use std::{collections::HashMap, sync::Arc};
+
+use helix_core::completion::CompletionProvider;
+use helix_event::{send_blocking, TaskController};
+
+use crate::{document::SavePoint, DocumentId, ViewId};
+
+use tokio::sync::mpsc::Sender;
+
+pub struct CompletionHandler {
+    event_tx: Sender<CompletionEvent>,
+    pub active_completions: HashMap<CompletionProvider, ResponseContext>,
+    pub request_controller: TaskController,
+}
+
+impl CompletionHandler {
+    pub fn new(event_tx: Sender<CompletionEvent>) -> Self {
+        Self {
+            event_tx,
+            active_completions: HashMap::new(),
+            request_controller: TaskController::new(),
+        }
+    }
+
+    pub fn event(&self, event: CompletionEvent) {
+        send_blocking(&self.event_tx, event);
+    }
+}
+
+pub struct ResponseContext {
+    /// Whether the completion response is marked as "incomplete."
+    ///
+    /// This is used by LSP. When completions are "incomplete" and you continue typing, the
+    /// completions should be recomputed by the server instead of filtered.
+    pub is_incomplete: bool,
+    pub priority: i8,
+    pub savepoint: Arc<SavePoint>,
+}
+
+pub enum CompletionEvent {
+    /// Auto completion was triggered by typing a word char
+    AutoTrigger {
+        cursor: usize,
+        doc: DocumentId,
+        view: ViewId,
+    },
+    /// Auto completion was triggered by typing a trigger char
+    /// specified by the LSP
+    TriggerChar {
+        cursor: usize,
+        doc: DocumentId,
+        view: ViewId,
+    },
+    /// A completion was manually requested (c-x)
+    ManualTrigger {
+        cursor: usize,
+        doc: DocumentId,
+        view: ViewId,
+    },
+    /// Some text was deleted and the cursor is now at `pos`
+    DeleteText { cursor: usize },
+    /// Invalidate the current auto completion trigger
+    Cancel,
+}
diff --git a/helix-view/src/handlers/dap.rs b/helix-view/src/handlers/dap.rs
index 81766dd59..56eb8efa9 100644
--- a/helix-view/src/handlers/dap.rs
+++ b/helix-view/src/handlers/dap.rs
@@ -5,6 +5,7 @@
 use helix_dap::{self as dap, Client, ConnectionType, Payload, Request, ThreadId};
 use helix_lsp::block_on;
 use log::warn;
+use serde_json::json;
 use std::fmt::Write;
 use std::path::PathBuf;
 
@@ -141,7 +142,6 @@ pub fn breakpoints_changed(
 
 impl Editor {
     pub async fn handle_debugger_message(&mut self, payload: helix_dap::Payload) -> bool {
-        use dap::requests::RunInTerminal;
         use helix_dap::{events, Event};
 
         let debugger = match self.debugger.as_mut() {
@@ -149,250 +149,260 @@ pub async fn handle_debugger_message(&mut self, payload: helix_dap::Payload) ->
             None => return false,
         };
         match payload {
-            Payload::Event(ev) => match *ev {
-                Event::Stopped(events::Stopped {
-                    thread_id,
-                    description,
-                    text,
-                    reason,
-                    all_threads_stopped,
-                    ..
-                }) => {
-                    let all_threads_stopped = all_threads_stopped.unwrap_or_default();
-
-                    if all_threads_stopped {
-                        if let Ok(response) = debugger.request::<dap::requests::Threads>(()).await {
-                            for thread in response.threads {
-                                fetch_stack_trace(debugger, thread.id).await;
+            Payload::Event(event) => {
+                let event = match Event::parse(&event.event, event.body) {
+                    Ok(event) => event,
+                    Err(dap::Error::Unhandled) => {
+                        log::info!("Discarding unknown DAP event '{}'", event.event);
+                        return false;
+                    }
+                    Err(err) => {
+                        log::warn!("Discarding invalid DAP event '{}': {err}", event.event);
+                        return false;
+                    }
+                };
+                match event {
+                    Event::Stopped(events::StoppedBody {
+                        thread_id,
+                        description,
+                        text,
+                        reason,
+                        all_threads_stopped,
+                        ..
+                    }) => {
+                        let all_threads_stopped = all_threads_stopped.unwrap_or_default();
+
+                        if all_threads_stopped {
+                            if let Ok(response) =
+                                debugger.request::<dap::requests::Threads>(()).await
+                            {
+                                for thread in response.threads {
+                                    fetch_stack_trace(debugger, thread.id).await;
+                                }
+                                select_thread_id(self, thread_id.unwrap_or_default(), false).await;
                             }
-                            select_thread_id(self, thread_id.unwrap_or_default(), false).await;
+                        } else if let Some(thread_id) = thread_id {
+                            debugger.thread_states.insert(thread_id, reason.clone()); // TODO: dap uses "type" || "reason" here
+
+                            // whichever thread stops is made "current" (if no previously selected thread).
+                            select_thread_id(self, thread_id, false).await;
                         }
-                    } else if let Some(thread_id) = thread_id {
-                        debugger.thread_states.insert(thread_id, reason.clone()); // TODO: dap uses "type" || "reason" here
 
-                        // whichever thread stops is made "current" (if no previously selected thread).
-                        select_thread_id(self, thread_id, false).await;
-                    }
+                        let scope = match thread_id {
+                            Some(id) => format!("Thread {}", id),
+                            None => "Target".to_owned(),
+                        };
 
-                    let scope = match thread_id {
-                        Some(id) => format!("Thread {}", id),
-                        None => "Target".to_owned(),
-                    };
+                        let mut status = format!("{} stopped because of {}", scope, reason);
+                        if let Some(desc) = description {
+                            write!(status, " {}", desc).unwrap();
+                        }
+                        if let Some(text) = text {
+                            write!(status, " {}", text).unwrap();
+                        }
+                        if all_threads_stopped {
+                            status.push_str(" (all threads stopped)");
+                        }
 
-                    let mut status = format!("{} stopped because of {}", scope, reason);
-                    if let Some(desc) = description {
-                        write!(status, " {}", desc).unwrap();
-                    }
-                    if let Some(text) = text {
-                        write!(status, " {}", text).unwrap();
+                        self.set_status(status);
                     }
-                    if all_threads_stopped {
-                        status.push_str(" (all threads stopped)");
+                    Event::Continued(events::ContinuedBody { thread_id, .. }) => {
+                        debugger
+                            .thread_states
+                            .insert(thread_id, "running".to_owned());
+                        if debugger.thread_id == Some(thread_id) {
+                            debugger.resume_application();
+                        }
                     }
-
-                    self.set_status(status);
-                }
-                Event::Continued(events::Continued { thread_id, .. }) => {
-                    debugger
-                        .thread_states
-                        .insert(thread_id, "running".to_owned());
-                    if debugger.thread_id == Some(thread_id) {
-                        debugger.resume_application();
+                    Event::Thread(_) => {
+                        // TODO: update thread_states, make threads request
                     }
-                }
-                Event::Thread(_) => {
-                    // TODO: update thread_states, make threads request
-                }
-                Event::Breakpoint(events::Breakpoint { reason, breakpoint }) => {
-                    match &reason[..] {
-                        "new" => {
-                            if let Some(source) = breakpoint.source {
-                                self.breakpoints
-                                    .entry(source.path.unwrap()) // TODO: no unwraps
-                                    .or_default()
-                                    .push(Breakpoint {
-                                        id: breakpoint.id,
-                                        verified: breakpoint.verified,
-                                        message: breakpoint.message,
-                                        line: breakpoint.line.unwrap().saturating_sub(1), // TODO: no unwrap
-                                        column: breakpoint.column,
-                                        ..Default::default()
-                                    });
+                    Event::Breakpoint(events::BreakpointBody { reason, breakpoint }) => {
+                        match &reason[..] {
+                            "new" => {
+                                if let Some(source) = breakpoint.source {
+                                    self.breakpoints
+                                        .entry(source.path.unwrap()) // TODO: no unwraps
+                                        .or_default()
+                                        .push(Breakpoint {
+                                            id: breakpoint.id,
+                                            verified: breakpoint.verified,
+                                            message: breakpoint.message,
+                                            line: breakpoint.line.unwrap().saturating_sub(1), // TODO: no unwrap
+                                            column: breakpoint.column,
+                                            ..Default::default()
+                                        });
+                                }
                             }
-                        }
-                        "changed" => {
-                            for breakpoints in self.breakpoints.values_mut() {
-                                if let Some(i) =
-                                    breakpoints.iter().position(|b| b.id == breakpoint.id)
-                                {
-                                    breakpoints[i].verified = breakpoint.verified;
-                                    breakpoints[i].message = breakpoint
-                                        .message
-                                        .clone()
-                                        .or_else(|| breakpoints[i].message.take());
-                                    breakpoints[i].line = breakpoint
-                                        .line
-                                        .map_or(breakpoints[i].line, |line| line.saturating_sub(1));
-                                    breakpoints[i].column =
-                                        breakpoint.column.or(breakpoints[i].column);
+                            "changed" => {
+                                for breakpoints in self.breakpoints.values_mut() {
+                                    if let Some(i) =
+                                        breakpoints.iter().position(|b| b.id == breakpoint.id)
+                                    {
+                                        breakpoints[i].verified = breakpoint.verified;
+                                        breakpoints[i].message = breakpoint
+                                            .message
+                                            .clone()
+                                            .or_else(|| breakpoints[i].message.take());
+                                        breakpoints[i].line =
+                                            breakpoint.line.map_or(breakpoints[i].line, |line| {
+                                                line.saturating_sub(1)
+                                            });
+                                        breakpoints[i].column =
+                                            breakpoint.column.or(breakpoints[i].column);
+                                    }
                                 }
                             }
-                        }
-                        "removed" => {
-                            for breakpoints in self.breakpoints.values_mut() {
-                                if let Some(i) =
-                                    breakpoints.iter().position(|b| b.id == breakpoint.id)
-                                {
-                                    breakpoints.remove(i);
+                            "removed" => {
+                                for breakpoints in self.breakpoints.values_mut() {
+                                    if let Some(i) =
+                                        breakpoints.iter().position(|b| b.id == breakpoint.id)
+                                    {
+                                        breakpoints.remove(i);
+                                    }
                                 }
                             }
-                        }
-                        reason => {
-                            warn!("Unknown breakpoint event: {}", reason);
+                            reason => {
+                                warn!("Unknown breakpoint event: {}", reason);
+                            }
                         }
                     }
-                }
-                Event::Output(events::Output {
-                    category, output, ..
-                }) => {
-                    let prefix = match category {
-                        Some(category) => {
-                            if &category == "telemetry" {
-                                return false;
+                    Event::Output(events::OutputBody {
+                        category, output, ..
+                    }) => {
+                        let prefix = match category {
+                            Some(category) => {
+                                if &category == "telemetry" {
+                                    return false;
+                                }
+                                format!("Debug ({}):", category)
                             }
-                            format!("Debug ({}):", category)
-                        }
-                        None => "Debug:".to_owned(),
-                    };
+                            None => "Debug:".to_owned(),
+                        };
 
-                    log::info!("{}", output);
-                    self.set_status(format!("{} {}", prefix, output));
-                }
-                Event::Initialized(_) => {
-                    // send existing breakpoints
-                    for (path, breakpoints) in &mut self.breakpoints {
-                        // TODO: call futures in parallel, await all
-                        let _ = breakpoints_changed(debugger, path.clone(), breakpoints);
+                        log::info!("{}", output);
+                        self.set_status(format!("{} {}", prefix, output));
                     }
-                    // TODO: fetch breakpoints (in case we're attaching)
-
-                    if debugger.configuration_done().await.is_ok() {
-                        self.set_status("Debugged application started");
-                    }; // TODO: do we need to handle error?
-                }
-                Event::Terminated(terminated) => {
-                    let restart_args = if let Some(terminated) = terminated {
-                        terminated.restart
-                    } else {
-                        None
-                    };
-
-                    let disconnect_args = Some(DisconnectArguments {
-                        restart: Some(restart_args.is_some()),
-                        terminate_debuggee: None,
-                        suspend_debuggee: None,
-                    });
+                    Event::Initialized(_) => {
+                        // send existing breakpoints
+                        for (path, breakpoints) in &mut self.breakpoints {
+                            // TODO: call futures in parallel, await all
+                            let _ = breakpoints_changed(debugger, path.clone(), breakpoints);
+                        }
+                        // TODO: fetch breakpoints (in case we're attaching)
 
-                    if let Err(err) = debugger.disconnect(disconnect_args).await {
-                        self.set_error(format!(
-                            "Cannot disconnect debugger upon terminated event receival {:?}",
-                            err
-                        ));
-                        return false;
+                        if debugger.configuration_done().await.is_ok() {
+                            self.set_status("Debugged application started");
+                        }; // TODO: do we need to handle error?
                     }
+                    Event::Terminated(terminated) => {
+                        let restart_args = if let Some(terminated) = terminated {
+                            terminated.restart
+                        } else {
+                            None
+                        };
+
+                        let disconnect_args = Some(DisconnectArguments {
+                            restart: Some(restart_args.is_some()),
+                            terminate_debuggee: None,
+                            suspend_debuggee: None,
+                        });
+
+                        if let Err(err) = debugger.disconnect(disconnect_args).await {
+                            self.set_error(format!(
+                                "Cannot disconnect debugger upon terminated event receival {:?}",
+                                err
+                            ));
+                            return false;
+                        }
 
-                    match restart_args {
-                        Some(restart_args) => {
-                            log::info!("Attempting to restart debug session.");
-                            let connection_type = match debugger.connection_type() {
-                                Some(connection_type) => connection_type,
-                                None => {
-                                    self.set_error("No starting request found, to be used in restarting the debugging session.");
-                                    return false;
+                        match restart_args {
+                            Some(restart_args) => {
+                                log::info!("Attempting to restart debug session.");
+                                let connection_type = match debugger.connection_type() {
+                                    Some(connection_type) => connection_type,
+                                    None => {
+                                        self.set_error("No starting request found, to be used in restarting the debugging session.");
+                                        return false;
+                                    }
+                                };
+
+                                let relaunch_resp = if let ConnectionType::Launch = connection_type
+                                {
+                                    debugger.launch(restart_args).await
+                                } else {
+                                    debugger.attach(restart_args).await
+                                };
+
+                                if let Err(err) = relaunch_resp {
+                                    self.set_error(format!(
+                                        "Failed to restart debugging session: {:?}",
+                                        err
+                                    ));
                                 }
-                            };
-
-                            let relaunch_resp = if let ConnectionType::Launch = connection_type {
-                                debugger.launch(restart_args).await
-                            } else {
-                                debugger.attach(restart_args).await
-                            };
-
-                            if let Err(err) = relaunch_resp {
-                                self.set_error(format!(
-                                    "Failed to restart debugging session: {:?}",
-                                    err
-                                ));
+                            }
+                            None => {
+                                self.debugger = None;
+                                self.set_status(
+                                    "Terminated debugging session and disconnected debugger.",
+                                );
                             }
                         }
-                        None => {
-                            self.debugger = None;
-                            self.set_status(
-                                "Terminated debugging session and disconnected debugger.",
-                            );
+                    }
+                    Event::Exited(resp) => {
+                        let exit_code = resp.exit_code;
+                        if exit_code != 0 {
+                            self.set_error(format!(
+                                "Debuggee failed to exit successfully (exit code: {exit_code})."
+                            ));
                         }
                     }
-                }
-                Event::Exited(resp) => {
-                    let exit_code = resp.exit_code;
-                    if exit_code != 0 {
-                        self.set_error(format!(
-                            "Debuggee failed to exit successfully (exit code: {exit_code})."
-                        ));
+                    ev => {
+                        log::warn!("Unhandled event {:?}", ev);
+                        return false; // return early to skip render
                     }
                 }
-                ev => {
-                    log::warn!("Unhandled event {:?}", ev);
-                    return false; // return early to skip render
-                }
-            },
+            }
             Payload::Response(_) => unreachable!(),
-            Payload::Request(request) => match request.command.as_str() {
-                RunInTerminal::COMMAND => {
-                    let arguments: dap::requests::RunInTerminalArguments =
-                        serde_json::from_value(request.arguments.unwrap_or_default()).unwrap();
-                    // TODO: no unwrap
-
-                    let config = match self.config().terminal.clone() {
-                        Some(config) => config,
-                        None => {
+            Payload::Request(request) => {
+                let reply = match Request::parse(&request.command, request.arguments) {
+                    Ok(Request::RunInTerminal(arguments)) => {
+                        let config = self.config();
+                        let Some(config) = config.terminal.as_ref() else {
                             self.set_error("No external terminal defined");
                             return true;
-                        }
-                    };
-
-                    // Re-borrowing debugger to avoid issues when loading config
-                    let debugger = match self.debugger.as_mut() {
-                        Some(debugger) => debugger,
-                        None => return false,
-                    };
+                        };
+
+                        let process = match std::process::Command::new(&config.command)
+                            .args(&config.args)
+                            .arg(arguments.args.join(" "))
+                            .spawn()
+                        {
+                            Ok(process) => process,
+                            Err(err) => {
+                                self.set_error(format!(
+                                    "Error starting external terminal: {}",
+                                    err
+                                ));
+                                return true;
+                            }
+                        };
 
-                    let process = match std::process::Command::new(config.command)
-                        .args(config.args)
-                        .arg(arguments.args.join(" "))
-                        .spawn()
-                    {
-                        Ok(process) => process,
-                        Err(err) => {
-                            self.set_error(format!("Error starting external terminal: {}", err));
-                            return true;
-                        }
-                    };
+                        Ok(json!(dap::requests::RunInTerminalResponse {
+                            process_id: Some(process.id()),
+                            shell_process_id: None,
+                        }))
+                    }
+                    Err(err) => Err(err),
+                };
 
-                    let _ = debugger
-                        .reply(
-                            request.seq,
-                            dap::requests::RunInTerminal::COMMAND,
-                            serde_json::to_value(dap::requests::RunInTerminalResponse {
-                                process_id: Some(process.id()),
-                                shell_process_id: None,
-                            })
-                            .map_err(|e| e.into()),
-                        )
-                        .await;
+                if let Some(debugger) = self.debugger.as_mut() {
+                    debugger
+                        .reply(request.seq, &request.command, reply)
+                        .await
+                        .ok();
                 }
-                _ => log::error!("DAP reverse request not implemented: {:?}", request),
-            },
+            }
         }
         true
     }
diff --git a/helix-view/src/handlers/lsp.rs b/helix-view/src/handlers/lsp.rs
index 6aff2e50c..dc2e1755b 100644
--- a/helix-view/src/handlers/lsp.rs
+++ b/helix-view/src/handlers/lsp.rs
@@ -1,37 +1,12 @@
+use std::collections::btree_map::Entry;
 use std::fmt::Display;
 
 use crate::editor::Action;
+use crate::events::DiagnosticsDidChange;
 use crate::Editor;
-use crate::{DocumentId, ViewId};
 use helix_core::Uri;
 use helix_lsp::util::generate_transaction_from_edits;
-use helix_lsp::{lsp, OffsetEncoding};
-
-pub enum CompletionEvent {
-    /// Auto completion was triggered by typing a word char
-    AutoTrigger {
-        cursor: usize,
-        doc: DocumentId,
-        view: ViewId,
-    },
-    /// Auto completion was triggered by typing a trigger char
-    /// specified by the LSP
-    TriggerChar {
-        cursor: usize,
-        doc: DocumentId,
-        view: ViewId,
-    },
-    /// A completion was manually requested (c-x)
-    ManualTrigger {
-        cursor: usize,
-        doc: DocumentId,
-        view: ViewId,
-    },
-    /// Some text was deleted and the cursor is now at `pos`
-    DeleteText { cursor: usize },
-    /// Invalidate the current auto completion trigger
-    Cancel,
-}
+use helix_lsp::{lsp, LanguageServerId, OffsetEncoding};
 
 #[derive(Debug, PartialEq, Eq, Clone, Copy)]
 pub enum SignatureHelpInvoked {
@@ -243,8 +218,8 @@ fn apply_document_resource_op(
         match op {
             ResourceOp::Create(op) => {
                 let uri = Uri::try_from(&op.uri)?;
-                let path = uri.as_path_buf().expect("URIs are valid paths");
-                let ignore_if_exists = op.options.as_ref().map_or(false, |options| {
+                let path = uri.as_path().expect("URIs are valid paths");
+                let ignore_if_exists = op.options.as_ref().is_some_and(|options| {
                     !options.overwrite.unwrap_or(false) && options.ignore_if_exists.unwrap_or(false)
                 });
                 if !ignore_if_exists || !path.exists() {
@@ -255,13 +230,15 @@ fn apply_document_resource_op(
                         }
                     }
 
-                    fs::write(&path, [])?;
-                    self.language_servers.file_event_handler.file_changed(path);
+                    fs::write(path, [])?;
+                    self.language_servers
+                        .file_event_handler
+                        .file_changed(path.to_path_buf());
                 }
             }
             ResourceOp::Delete(op) => {
                 let uri = Uri::try_from(&op.uri)?;
-                let path = uri.as_path_buf().expect("URIs are valid paths");
+                let path = uri.as_path().expect("URIs are valid paths");
                 if path.is_dir() {
                     let recursive = op
                         .options
@@ -270,11 +247,13 @@ fn apply_document_resource_op(
                         .unwrap_or(false);
 
                     if recursive {
-                        fs::remove_dir_all(&path)?
+                        fs::remove_dir_all(path)?
                     } else {
-                        fs::remove_dir(&path)?
+                        fs::remove_dir(path)?
                     }
-                    self.language_servers.file_event_handler.file_changed(path);
+                    self.language_servers
+                        .file_event_handler
+                        .file_changed(path.to_path_buf());
                 } else if path.is_file() {
                     fs::remove_file(path)?;
                 }
@@ -284,7 +263,7 @@ fn apply_document_resource_op(
                 let from = from_uri.as_path().expect("URIs are valid paths");
                 let to_uri = Uri::try_from(&op.new_uri)?;
                 let to = to_uri.as_path().expect("URIs are valid paths");
-                let ignore_if_exists = op.options.as_ref().map_or(false, |options| {
+                let ignore_if_exists = op.options.as_ref().is_some_and(|options| {
                     !options.overwrite.unwrap_or(false) && options.ignore_if_exists.unwrap_or(false)
                 });
                 if !ignore_if_exists || !to.exists() {
@@ -294,4 +273,92 @@ fn apply_document_resource_op(
         }
         Ok(())
     }
+
+    pub fn handle_lsp_diagnostics(
+        &mut self,
+        server_id: LanguageServerId,
+        uri: Uri,
+        version: Option<i32>,
+        mut diagnostics: Vec<lsp::Diagnostic>,
+    ) {
+        let doc = self
+            .documents
+            .values_mut()
+            .find(|doc| doc.uri().is_some_and(|u| u == uri));
+
+        if let Some((version, doc)) = version.zip(doc.as_ref()) {
+            if version != doc.version() {
+                log::info!("Version ({version}) is out of date for {uri:?} (expected ({})), dropping PublishDiagnostic notification", doc.version());
+                return;
+            }
+        }
+
+        let mut unchanged_diag_sources = Vec::new();
+        if let Some((lang_conf, old_diagnostics)) = doc
+            .as_ref()
+            .and_then(|doc| Some((doc.language_config()?, self.diagnostics.get(&uri)?)))
+        {
+            if !lang_conf.persistent_diagnostic_sources.is_empty() {
+                // Sort diagnostics first by severity and then by line numbers.
+                // Note: The `lsp::DiagnosticSeverity` enum is already defined in decreasing order
+                diagnostics.sort_by_key(|d| (d.severity, d.range.start));
+            }
+            for source in &lang_conf.persistent_diagnostic_sources {
+                let new_diagnostics = diagnostics
+                    .iter()
+                    .filter(|d| d.source.as_ref() == Some(source));
+                let old_diagnostics = old_diagnostics
+                    .iter()
+                    .filter(|(d, d_server)| {
+                        *d_server == server_id && d.source.as_ref() == Some(source)
+                    })
+                    .map(|(d, _)| d);
+                if new_diagnostics.eq(old_diagnostics) {
+                    unchanged_diag_sources.push(source.clone())
+                }
+            }
+        }
+
+        let diagnostics = diagnostics.into_iter().map(|d| (d, server_id));
+
+        // Insert the original lsp::Diagnostics here because we may have no open document
+        // for diagnostic message and so we can't calculate the exact position.
+        // When using them later in the diagnostics picker, we calculate them on-demand.
+        let diagnostics = match self.diagnostics.entry(uri) {
+            Entry::Occupied(o) => {
+                let current_diagnostics = o.into_mut();
+                // there may entries of other language servers, which is why we can't overwrite the whole entry
+                current_diagnostics.retain(|(_, lsp_id)| *lsp_id != server_id);
+                current_diagnostics.extend(diagnostics);
+                current_diagnostics
+                // Sort diagnostics first by severity and then by line numbers.
+            }
+            Entry::Vacant(v) => v.insert(diagnostics.collect()),
+        };
+
+        // Sort diagnostics first by severity and then by line numbers.
+        // Note: The `lsp::DiagnosticSeverity` enum is already defined in decreasing order
+        diagnostics.sort_by_key(|(d, server_id)| (d.severity, d.range.start, *server_id));
+
+        if let Some(doc) = doc {
+            let diagnostic_of_language_server_and_not_in_unchanged_sources =
+                |diagnostic: &lsp::Diagnostic, ls_id| {
+                    ls_id == server_id
+                        && diagnostic
+                            .source
+                            .as_ref()
+                            .map_or(true, |source| !unchanged_diag_sources.contains(source))
+                };
+            let diagnostics = Self::doc_diagnostics_with_filter(
+                &self.language_servers,
+                &self.diagnostics,
+                doc,
+                diagnostic_of_language_server_and_not_in_unchanged_sources,
+            );
+            doc.replace_diagnostics(diagnostics, &unchanged_diag_sources, Some(server_id));
+
+            let doc = doc.id();
+            helix_event::dispatch(DiagnosticsDidChange { editor: self, doc });
+        }
+    }
 }
diff --git a/helix-view/src/input.rs b/helix-view/src/input.rs
index 5f5067eac..d359db703 100644
--- a/helix-view/src/input.rs
+++ b/helix-view/src/input.rs
@@ -162,7 +162,12 @@ pub(crate) mod keys {
 impl fmt::Display for KeyEvent {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> std::fmt::Result {
         f.write_fmt(format_args!(
-            "{}{}{}",
+            "{}{}{}{}",
+            if self.modifiers.contains(KeyModifiers::SUPER) {
+                "Meta-"
+            } else {
+                ""
+            },
             if self.modifiers.contains(KeyModifiers::SHIFT) {
                 "S-"
             } else {
@@ -312,6 +317,10 @@ fn width(&self) -> usize {
         if self.modifiers.contains(KeyModifiers::CONTROL) {
             width += 2;
         }
+        if self.modifiers.contains(KeyModifiers::SUPER) {
+            // "-Meta"
+            width += 5;
+        }
         width
     }
 
@@ -387,6 +396,23 @@ fn from_str(s: &str) -> Result<Self, Self::Err> {
                     .then_some(KeyCode::F(function))
                     .ok_or_else(|| anyhow!("Invalid function key '{}'", function))?
             }
+            // Checking that the last token is empty ensures that this branch is only taken if
+            // `-` is used as a code. For example this branch will not be taken for `S-` (which is
+            // missing a code).
+            _ if s.ends_with('-') && tokens.last().is_some_and(|t| t.is_empty()) => {
+                if s == "-" {
+                    return Ok(KeyEvent {
+                        code: KeyCode::Char('-'),
+                        modifiers: KeyModifiers::empty(),
+                    });
+                } else {
+                    let suggestion = format!("{}-{}", s.trim_end_matches('-'), keys::MINUS);
+                    return Err(anyhow!(
+                        "Key '-' cannot be used with modifiers, use '{}' instead",
+                        suggestion
+                    ));
+                }
+            }
             invalid => return Err(anyhow!("Invalid key code '{}'", invalid)),
         };
 
@@ -396,6 +422,7 @@ fn from_str(s: &str) -> Result<Self, Self::Err> {
                 "S" => KeyModifiers::SHIFT,
                 "A" => KeyModifiers::ALT,
                 "C" => KeyModifiers::CONTROL,
+                "Meta" | "Cmd" | "Win" => KeyModifiers::SUPER,
                 _ => return Err(anyhow!("Invalid key modifier '{}-'", token)),
             };
 
@@ -661,6 +688,13 @@ fn parsing_unmodified_keys() {
                 modifiers: KeyModifiers::NONE
             }
         );
+        assert_eq!(
+            str::parse::<KeyEvent>("-").unwrap(),
+            KeyEvent {
+                code: KeyCode::Char('-'),
+                modifiers: KeyModifiers::NONE,
+            }
+        );
     }
 
     #[test]
@@ -709,6 +743,28 @@ fn parsing_modified_keys() {
                 modifiers: KeyModifiers::NONE
             }
         );
+
+        assert_eq!(
+            str::parse::<KeyEvent>("Meta-c").unwrap(),
+            KeyEvent {
+                code: KeyCode::Char('c'),
+                modifiers: KeyModifiers::SUPER
+            }
+        );
+        assert_eq!(
+            str::parse::<KeyEvent>("Win-s").unwrap(),
+            KeyEvent {
+                code: KeyCode::Char('s'),
+                modifiers: KeyModifiers::SUPER
+            }
+        );
+        assert_eq!(
+            str::parse::<KeyEvent>("Cmd-d").unwrap(),
+            KeyEvent {
+                code: KeyCode::Char('d'),
+                modifiers: KeyModifiers::SUPER
+            }
+        );
     }
 
     #[test]
@@ -721,6 +777,7 @@ fn parsing_nonsensical_keys_fails() {
         assert!(str::parse::<KeyEvent>("FU").is_err());
         assert!(str::parse::<KeyEvent>("123").is_err());
         assert!(str::parse::<KeyEvent>("S--").is_err());
+        assert!(str::parse::<KeyEvent>("S-").is_err());
         assert!(str::parse::<KeyEvent>("S-percent").is_err());
     }
 
diff --git a/helix-view/src/keyboard.rs b/helix-view/src/keyboard.rs
index 080bce8dd..d816a52ef 100644
--- a/helix-view/src/keyboard.rs
+++ b/helix-view/src/keyboard.rs
@@ -7,6 +7,7 @@ pub struct KeyModifiers: u8 {
         const SHIFT = 0b0000_0001;
         const CONTROL = 0b0000_0010;
         const ALT = 0b0000_0100;
+        const SUPER = 0b0000_1000;
         const NONE = 0b0000_0000;
     }
 }
@@ -27,6 +28,9 @@ fn from(key_modifiers: KeyModifiers) -> Self {
         if key_modifiers.contains(KeyModifiers::ALT) {
             result.insert(CKeyModifiers::ALT);
         }
+        if key_modifiers.contains(KeyModifiers::SUPER) {
+            result.insert(CKeyModifiers::SUPER);
+        }
 
         result
     }
@@ -48,6 +52,9 @@ fn from(val: crossterm::event::KeyModifiers) -> Self {
         if val.contains(CKeyModifiers::ALT) {
             result.insert(KeyModifiers::ALT);
         }
+        if val.contains(CKeyModifiers::SUPER) {
+            result.insert(KeyModifiers::SUPER);
+        }
 
         result
     }
diff --git a/helix-view/src/register.rs b/helix-view/src/register.rs
index 3a2e1b7cc..d286a85cc 100644
--- a/helix-view/src/register.rs
+++ b/helix-view/src/register.rs
@@ -1,10 +1,11 @@
 use std::{borrow::Cow, collections::HashMap, iter};
 
 use anyhow::Result;
+use arc_swap::access::DynAccess;
 use helix_core::NATIVE_LINE_ENDING;
 
 use crate::{
-    clipboard::{get_clipboard_provider, ClipboardProvider, ClipboardType},
+    clipboard::{ClipboardError, ClipboardProvider, ClipboardType},
     Editor,
 };
 
@@ -20,28 +21,25 @@
 /// * Document path (`%`): filename of the current buffer
 /// * System clipboard (`*`)
 /// * Primary clipboard (`+`)
-#[derive(Debug)]
 pub struct Registers {
     /// The mapping of register to values.
     /// Values are stored in reverse order when inserted with `Registers::write`.
     /// The order is reversed again in `Registers::read`. This allows us to
     /// efficiently prepend new values in `Registers::push`.
     inner: HashMap<char, Vec<String>>,
-    clipboard_provider: Box<dyn ClipboardProvider>,
+    clipboard_provider: Box<dyn DynAccess<ClipboardProvider>>,
     pub last_search_register: char,
 }
 
-impl Default for Registers {
-    fn default() -> Self {
+impl Registers {
+    pub fn new(clipboard_provider: Box<dyn DynAccess<ClipboardProvider>>) -> Self {
         Self {
             inner: Default::default(),
-            clipboard_provider: get_clipboard_provider(),
+            clipboard_provider,
             last_search_register: '/',
         }
     }
-}
 
-impl Registers {
     pub fn read<'a>(&'a self, name: char, editor: &'a Editor) -> Option<RegisterValues<'a>> {
         match name {
             '_' => Some(RegisterValues::new(iter::empty())),
@@ -64,7 +62,7 @@ pub fn read<'a>(&'a self, name: char, editor: &'a Editor) -> Option<RegisterValu
                 Some(RegisterValues::new(iter::once(path)))
             }
             '*' | '+' => Some(read_from_clipboard(
-                self.clipboard_provider.as_ref(),
+                &self.clipboard_provider.load(),
                 self.inner.get(&name),
                 match name {
                     '+' => ClipboardType::Clipboard,
@@ -84,8 +82,8 @@ pub fn write(&mut self, name: char, mut values: Vec<String>) -> Result<()> {
             '_' => Ok(()),
             '#' | '.' | '%' => Err(anyhow::anyhow!("Register {name} does not support writing")),
             '*' | '+' => {
-                self.clipboard_provider.set_contents(
-                    values.join(NATIVE_LINE_ENDING.as_str()),
+                self.clipboard_provider.load().set_contents(
+                    &values.join(NATIVE_LINE_ENDING.as_str()),
                     match name {
                         '+' => ClipboardType::Clipboard,
                         '*' => ClipboardType::Selection,
@@ -114,7 +112,10 @@ pub fn push(&mut self, name: char, mut value: String) -> Result<()> {
                     '*' => ClipboardType::Selection,
                     _ => unreachable!(),
                 };
-                let contents = self.clipboard_provider.get_contents(clipboard_type)?;
+                let contents = self
+                    .clipboard_provider
+                    .load()
+                    .get_contents(&clipboard_type)?;
                 let saved_values = self.inner.entry(name).or_default();
 
                 if !contents_are_saved(saved_values, &contents) {
@@ -127,7 +128,8 @@ pub fn push(&mut self, name: char, mut value: String) -> Result<()> {
                 }
                 value.push_str(&contents);
                 self.clipboard_provider
-                    .set_contents(value, clipboard_type)?;
+                    .load()
+                    .set_contents(&value, clipboard_type)?;
 
                 Ok(())
             }
@@ -198,7 +200,8 @@ pub fn remove(&mut self, name: char) -> bool {
     fn clear_clipboard(&mut self, clipboard_type: ClipboardType) {
         if let Err(err) = self
             .clipboard_provider
-            .set_contents("".into(), clipboard_type)
+            .load()
+            .set_contents("", clipboard_type)
         {
             log::error!(
                 "Failed to clear {} clipboard: {err}",
@@ -210,17 +213,17 @@ fn clear_clipboard(&mut self, clipboard_type: ClipboardType) {
         }
     }
 
-    pub fn clipboard_provider_name(&self) -> Cow<str> {
-        self.clipboard_provider.name()
+    pub fn clipboard_provider_name(&self) -> String {
+        self.clipboard_provider.load().name().into_owned()
     }
 }
 
 fn read_from_clipboard<'a>(
-    provider: &dyn ClipboardProvider,
+    provider: &ClipboardProvider,
     saved_values: Option<&'a Vec<String>>,
     clipboard_type: ClipboardType,
 ) -> RegisterValues<'a> {
-    match provider.get_contents(clipboard_type) {
+    match provider.get_contents(&clipboard_type) {
         Ok(contents) => {
             // If we're pasting the same values that we just yanked, re-use
             // the saved values. This allows pasting multiple selections
@@ -235,6 +238,10 @@ fn read_from_clipboard<'a>(
                 RegisterValues::new(iter::once(contents.into()))
             }
         }
+        Err(ClipboardError::ReadingNotSupported) => match saved_values {
+            Some(values) => RegisterValues::new(values.iter().map(Cow::from).rev()),
+            None => RegisterValues::new(iter::empty()),
+        },
         Err(err) => {
             log::error!(
                 "Failed to read {} clipboard: {err}",
@@ -304,13 +311,13 @@ fn size_hint(&self) -> (usize, Option<usize>) {
     }
 }
 
-impl<'a> DoubleEndedIterator for RegisterValues<'a> {
+impl DoubleEndedIterator for RegisterValues<'_> {
     fn next_back(&mut self) -> Option<Self::Item> {
         self.iter.next_back()
     }
 }
 
-impl<'a> ExactSizeIterator for RegisterValues<'a> {
+impl ExactSizeIterator for RegisterValues<'_> {
     fn len(&self) -> usize {
         self.iter.len()
     }
diff --git a/helix-view/src/theme.rs b/helix-view/src/theme.rs
index 4acc56648..c3f6af882 100644
--- a/helix-view/src/theme.rs
+++ b/helix-view/src/theme.rs
@@ -53,20 +53,34 @@ pub fn new(dirs: &[PathBuf]) -> Self {
 
     /// Loads a theme searching directories in priority order.
     pub fn load(&self, name: &str) -> Result<Theme> {
+        let (theme, warnings) = self.load_with_warnings(name)?;
+
+        for warning in warnings {
+            warn!("Theme '{}': {}", name, warning);
+        }
+
+        Ok(theme)
+    }
+
+    /// Loads a theme searching directories in priority order, returning any warnings
+    pub fn load_with_warnings(&self, name: &str) -> Result<(Theme, Vec<String>)> {
         if name == "default" {
-            return Ok(self.default());
+            return Ok((self.default(), Vec::new()));
         }
         if name == "base16_default" {
-            return Ok(self.base16_default());
+            return Ok((self.base16_default(), Vec::new()));
         }
 
         let mut visited_paths = HashSet::new();
-        let theme = self.load_theme(name, &mut visited_paths).map(Theme::from)?;
+        let (theme, warnings) = self
+            .load_theme(name, &mut visited_paths)
+            .map(Theme::from_toml)?;
 
-        Ok(Theme {
+        let theme = Theme {
             name: name.into(),
             ..theme
-        })
+        };
+        Ok((theme, warnings))
     }
 
     /// Recursively load a theme, merging with any inherited parent themes.
@@ -87,10 +101,7 @@ fn load_theme(&self, name: &str, visited_paths: &mut HashSet<PathBuf>) -> Result
 
         let theme_toml = if let Some(parent_theme_name) = inherits {
             let parent_theme_name = parent_theme_name.as_str().ok_or_else(|| {
-                anyhow!(
-                    "Theme: expected 'inherits' to be a string: {}",
-                    parent_theme_name
-                )
+                anyhow!("Expected 'inherits' to be a string: {}", parent_theme_name)
             })?;
 
             let parent_theme_toml = match parent_theme_name {
@@ -181,9 +192,9 @@ fn path(&self, name: &str, visited_paths: &mut HashSet<PathBuf>) -> Result<PathB
             })
             .ok_or_else(|| {
                 if cycle_found {
-                    anyhow!("Theme: cycle found in inheriting: {}", name)
+                    anyhow!("Cycle found in inheriting: {}", name)
                 } else {
-                    anyhow!("Theme: file not found for: {}", name)
+                    anyhow!("File not found for: {}", name)
                 }
             })
     }
@@ -220,19 +231,11 @@ pub struct Theme {
 
 impl From<Value> for Theme {
     fn from(value: Value) -> Self {
-        if let Value::Table(table) = value {
-            let (styles, scopes, highlights) = build_theme_values(table);
-
-            Self {
-                styles,
-                scopes,
-                highlights,
-                ..Default::default()
-            }
-        } else {
-            warn!("Expected theme TOML value to be a table, found {:?}", value);
-            Default::default()
+        let (theme, warnings) = Theme::from_toml(value);
+        for warning in warnings {
+            warn!("{}", warning);
         }
+        theme
     }
 }
 
@@ -242,31 +245,29 @@ fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
         D: Deserializer<'de>,
     {
         let values = Map::<String, Value>::deserialize(deserializer)?;
-
-        let (styles, scopes, highlights) = build_theme_values(values);
-
-        Ok(Self {
-            styles,
-            scopes,
-            highlights,
-            ..Default::default()
-        })
+        let (theme, warnings) = Theme::from_keys(values);
+        for warning in warnings {
+            warn!("{}", warning);
+        }
+        Ok(theme)
     }
 }
 
 fn build_theme_values(
     mut values: Map<String, Value>,
-) -> (HashMap<String, Style>, Vec<String>, Vec<Style>) {
+) -> (HashMap<String, Style>, Vec<String>, Vec<Style>, Vec<String>) {
     let mut styles = HashMap::new();
     let mut scopes = Vec::new();
     let mut highlights = Vec::new();
 
+    let mut warnings = Vec::new();
+
     // TODO: alert user of parsing failures in editor
     let palette = values
         .remove("palette")
         .map(|value| {
             ThemePalette::try_from(value).unwrap_or_else(|err| {
-                warn!("{}", err);
+                warnings.push(err);
                 ThemePalette::default()
             })
         })
@@ -279,7 +280,7 @@ fn build_theme_values(
     for (name, style_value) in values {
         let mut style = Style::default();
         if let Err(err) = palette.parse_style(&mut style, style_value) {
-            warn!("{}", err);
+            warnings.push(format!("Failed to parse style for key {name:?}. {err}"));
         }
 
         // these are used both as UI and as highlights
@@ -288,7 +289,7 @@ fn build_theme_values(
         highlights.push(style);
     }
 
-    (styles, scopes, highlights)
+    (styles, scopes, highlights, warnings)
 }
 
 impl Theme {
@@ -354,6 +355,27 @@ pub fn is_16_color(&self) -> bool {
                 .all(|color| !matches!(color, Some(Color::Rgb(..))))
         })
     }
+
+    fn from_toml(value: Value) -> (Self, Vec<String>) {
+        if let Value::Table(table) = value {
+            Theme::from_keys(table)
+        } else {
+            warn!("Expected theme TOML value to be a table, found {:?}", value);
+            Default::default()
+        }
+    }
+
+    fn from_keys(toml_keys: Map<String, Value>) -> (Self, Vec<String>) {
+        let (styles, scopes, highlights, load_errors) = build_theme_values(toml_keys);
+
+        let theme = Self {
+            styles,
+            scopes,
+            highlights,
+            ..Default::default()
+        };
+        (theme, load_errors)
+    }
 }
 
 struct ThemePalette {
@@ -408,7 +430,7 @@ fn ansi_string_to_rgb(s: &str) -> Result<Color, String> {
         if let Ok(index) = s.parse::<u8>() {
             return Ok(Color::Indexed(index));
         }
-        Err(format!("Theme: malformed ANSI: {}", s))
+        Err(format!("Malformed ANSI: {}", s))
     }
 
     fn hex_string_to_rgb(s: &str) -> Result<Color, String> {
@@ -422,13 +444,13 @@ fn hex_string_to_rgb(s: &str) -> Result<Color, String> {
             }
         }
 
-        Err(format!("Theme: malformed hexcode: {}", s))
+        Err(format!("Malformed hexcode: {}", s))
     }
 
     fn parse_value_as_str(value: &Value) -> Result<&str, String> {
         value
             .as_str()
-            .ok_or(format!("Theme: unrecognized value: {}", value))
+            .ok_or(format!("Unrecognized value: {}", value))
     }
 
     pub fn parse_color(&self, value: Value) -> Result<Color, String> {
@@ -445,14 +467,14 @@ pub fn parse_modifier(value: &Value) -> Result<Modifier, String> {
         value
             .as_str()
             .and_then(|s| s.parse().ok())
-            .ok_or(format!("Theme: invalid modifier: {}", value))
+            .ok_or(format!("Invalid modifier: {}", value))
     }
 
     pub fn parse_underline_style(value: &Value) -> Result<UnderlineStyle, String> {
         value
             .as_str()
             .and_then(|s| s.parse().ok())
-            .ok_or(format!("Theme: invalid underline style: {}", value))
+            .ok_or(format!("Invalid underline style: {}", value))
     }
 
     pub fn parse_style(&self, style: &mut Style, value: Value) -> Result<(), String> {
@@ -462,9 +484,7 @@ pub fn parse_style(&self, style: &mut Style, value: Value) -> Result<(), String>
                     "fg" => *style = style.fg(self.parse_color(value)?),
                     "bg" => *style = style.bg(self.parse_color(value)?),
                     "underline" => {
-                        let table = value
-                            .as_table_mut()
-                            .ok_or("Theme: underline must be table")?;
+                        let table = value.as_table_mut().ok_or("Underline must be table")?;
                         if let Some(value) = table.remove("color") {
                             *style = style.underline_color(self.parse_color(value)?);
                         }
@@ -473,26 +493,21 @@ pub fn parse_style(&self, style: &mut Style, value: Value) -> Result<(), String>
                         }
 
                         if let Some(attr) = table.keys().next() {
-                            return Err(format!("Theme: invalid underline attribute: {attr}"));
+                            return Err(format!("Invalid underline attribute: {attr}"));
                         }
                     }
                     "modifiers" => {
-                        let modifiers = value
-                            .as_array()
-                            .ok_or("Theme: modifiers should be an array")?;
+                        let modifiers = value.as_array().ok_or("Modifiers should be an array")?;
 
                         for modifier in modifiers {
-                            if modifier
-                                .as_str()
-                                .map_or(false, |modifier| modifier == "underlined")
-                            {
+                            if modifier.as_str() == Some("underlined") {
                                 *style = style.underline_style(UnderlineStyle::Line);
                             } else {
                                 *style = style.add_modifier(Self::parse_modifier(modifier)?);
                             }
                         }
                     }
-                    _ => return Err(format!("Theme: invalid style attribute: {}", name)),
+                    _ => return Err(format!("Invalid style attribute: {}", name)),
                 }
             }
         } else {
diff --git a/helix-view/src/tree.rs b/helix-view/src/tree.rs
index be8bd4e5b..aba947a21 100644
--- a/helix-view/src/tree.rs
+++ b/helix-view/src/tree.rs
@@ -705,7 +705,7 @@ fn next(&mut self) -> Option<Self::Item> {
     }
 }
 
-impl<'a> DoubleEndedIterator for Traverse<'a> {
+impl DoubleEndedIterator for Traverse<'_> {
     fn next_back(&mut self) -> Option<Self::Item> {
         loop {
             let key = self.stack.pop()?;
diff --git a/helix-view/tests/encoding/LICENSE-WHATWG b/helix-view/tests/encoding/LICENSE-WHATWG
new file mode 100644
index 000000000..f690e7196
--- /dev/null
+++ b/helix-view/tests/encoding/LICENSE-WHATWG
@@ -0,0 +1,26 @@
+Copyright  WHATWG (Apple, Google, Mozilla, Microsoft).
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/helix-view/tests/encoding/big5_in.txt b/helix-view/tests/encoding/big5_in.txt
index 564f9f6a4..d5e1f9bc3 100644
--- a/helix-view/tests/encoding/big5_in.txt
+++ b/helix-view/tests/encoding/big5_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/big5_in_ref.txt b/helix-view/tests/encoding/big5_in_ref.txt
index 06eac7313..30f080b76 100644
--- a/helix-view/tests/encoding/big5_in_ref.txt
+++ b/helix-view/tests/encoding/big5_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/big5_out.txt b/helix-view/tests/encoding/big5_out.txt
index 142b833ce..403a07c11 100644
--- a/helix-view/tests/encoding/big5_out.txt
+++ b/helix-view/tests/encoding/big5_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/big5_out_ref.txt b/helix-view/tests/encoding/big5_out_ref.txt
index bf741afbb..ee853f21b 100644
--- a/helix-view/tests/encoding/big5_out_ref.txt
+++ b/helix-view/tests/encoding/big5_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/euc_kr_in.txt b/helix-view/tests/encoding/euc_kr_in.txt
index 88cb355a7..0f429e7b1 100644
--- a/helix-view/tests/encoding/euc_kr_in.txt
+++ b/helix-view/tests/encoding/euc_kr_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/euc_kr_in_ref.txt b/helix-view/tests/encoding/euc_kr_in_ref.txt
index 24867df2f..116e8593f 100644
--- a/helix-view/tests/encoding/euc_kr_in_ref.txt
+++ b/helix-view/tests/encoding/euc_kr_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/euc_kr_out.txt b/helix-view/tests/encoding/euc_kr_out.txt
index 9f30be6ed..3b023126a 100644
--- a/helix-view/tests/encoding/euc_kr_out.txt
+++ b/helix-view/tests/encoding/euc_kr_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/euc_kr_out_ref.txt b/helix-view/tests/encoding/euc_kr_out_ref.txt
index bd886e0df..a11cb3239 100644
--- a/helix-view/tests/encoding/euc_kr_out_ref.txt
+++ b/helix-view/tests/encoding/euc_kr_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/gb18030_in.txt b/helix-view/tests/encoding/gb18030_in.txt
index a5293a98e..2fb7d00e9 100644
--- a/helix-view/tests/encoding/gb18030_in.txt
+++ b/helix-view/tests/encoding/gb18030_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/gb18030_in_ref.txt b/helix-view/tests/encoding/gb18030_in_ref.txt
index bf9188dd0..30e684546 100644
--- a/helix-view/tests/encoding/gb18030_in_ref.txt
+++ b/helix-view/tests/encoding/gb18030_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
@@ -7185,13 +7184,13 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
-
-
-
-
-
-
+
+
+
+
+
+
+
 
 
 
@@ -7204,14 +7203,14 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
-
+
+
 
 
 
 
 
-
+
 
 
 
@@ -23778,7 +23777,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23786,19 +23785,19 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
 
-
-
+
+
 
 
 
 
 
-
+
 
 
 
@@ -23815,7 +23814,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23832,7 +23831,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23848,7 +23847,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
diff --git a/helix-view/tests/encoding/gb18030_out.txt b/helix-view/tests/encoding/gb18030_out.txt
index 72d5e48e7..68264ca1b 100644
--- a/helix-view/tests/encoding/gb18030_out.txt
+++ b/helix-view/tests/encoding/gb18030_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
@@ -7184,13 +7183,13 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
-
-
-
-
-
-
+
+
+
+
+
+
+
 
 
 
@@ -7203,14 +7202,14 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
-
+
+
 
 
 
 
 
-
+
 
 
 
@@ -23777,7 +23776,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23785,19 +23784,19 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
 
-
-
+
+
 
 
 
 
 
-
+
 
 
 
@@ -23814,7 +23813,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23831,7 +23830,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
@@ -23847,7 +23846,7 @@ Instead, please regenerate using generate-encoding-data.py
 
 
 
-
+
 
 
 
diff --git a/helix-view/tests/encoding/gb18030_out_ref.txt b/helix-view/tests/encoding/gb18030_out_ref.txt
index eab1cf0fe..820e7cd94 100644
--- a/helix-view/tests/encoding/gb18030_out_ref.txt
+++ b/helix-view/tests/encoding/gb18030_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/iso_2022_jp_in.txt b/helix-view/tests/encoding/iso_2022_jp_in.txt
index 78d0beffa..58d3e52be 100644
--- a/helix-view/tests/encoding/iso_2022_jp_in.txt
+++ b/helix-view/tests/encoding/iso_2022_jp_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/iso_2022_jp_in_ref.txt b/helix-view/tests/encoding/iso_2022_jp_in_ref.txt
index ef1f74079..51cc69008 100644
--- a/helix-view/tests/encoding/iso_2022_jp_in_ref.txt
+++ b/helix-view/tests/encoding/iso_2022_jp_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/iso_2022_jp_out.txt b/helix-view/tests/encoding/iso_2022_jp_out.txt
index 577dc4d2b..73f9b6ff7 100644
--- a/helix-view/tests/encoding/iso_2022_jp_out.txt
+++ b/helix-view/tests/encoding/iso_2022_jp_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/iso_2022_jp_out_ref.txt b/helix-view/tests/encoding/iso_2022_jp_out_ref.txt
index e0685529f..fc6753b65 100644
--- a/helix-view/tests/encoding/iso_2022_jp_out_ref.txt
+++ b/helix-view/tests/encoding/iso_2022_jp_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0208_in.txt b/helix-view/tests/encoding/jis0208_in.txt
index a38f7a4c1..c39b0503b 100644
--- a/helix-view/tests/encoding/jis0208_in.txt
+++ b/helix-view/tests/encoding/jis0208_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0208_in_ref.txt b/helix-view/tests/encoding/jis0208_in_ref.txt
index ef1f74079..51cc69008 100644
--- a/helix-view/tests/encoding/jis0208_in_ref.txt
+++ b/helix-view/tests/encoding/jis0208_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0208_out.txt b/helix-view/tests/encoding/jis0208_out.txt
index 76e346474..87727fc8c 100644
--- a/helix-view/tests/encoding/jis0208_out.txt
+++ b/helix-view/tests/encoding/jis0208_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0208_out_ref.txt b/helix-view/tests/encoding/jis0208_out_ref.txt
index 42d167a8c..86ec39ce6 100644
--- a/helix-view/tests/encoding/jis0208_out_ref.txt
+++ b/helix-view/tests/encoding/jis0208_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0212_in.txt b/helix-view/tests/encoding/jis0212_in.txt
index b144707b5..8ee54fc1e 100644
--- a/helix-view/tests/encoding/jis0212_in.txt
+++ b/helix-view/tests/encoding/jis0212_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/jis0212_in_ref.txt b/helix-view/tests/encoding/jis0212_in_ref.txt
index 09a72e28b..afbbf0901 100644
--- a/helix-view/tests/encoding/jis0212_in_ref.txt
+++ b/helix-view/tests/encoding/jis0212_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/shift_jis_in.txt b/helix-view/tests/encoding/shift_jis_in.txt
index cee6bb570..3b9d7c366 100644
--- a/helix-view/tests/encoding/shift_jis_in.txt
+++ b/helix-view/tests/encoding/shift_jis_in.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/shift_jis_in_ref.txt b/helix-view/tests/encoding/shift_jis_in_ref.txt
index 19ae14cb6..19570a3b7 100644
--- a/helix-view/tests/encoding/shift_jis_in_ref.txt
+++ b/helix-view/tests/encoding/shift_jis_in_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/shift_jis_out.txt b/helix-view/tests/encoding/shift_jis_out.txt
index 383584b0d..fd13adcab 100644
--- a/helix-view/tests/encoding/shift_jis_out.txt
+++ b/helix-view/tests/encoding/shift_jis_out.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/helix-view/tests/encoding/shift_jis_out_ref.txt b/helix-view/tests/encoding/shift_jis_out_ref.txt
index 25bce72ee..33c12d21b 100644
--- a/helix-view/tests/encoding/shift_jis_out_ref.txt
+++ b/helix-view/tests/encoding/shift_jis_out_ref.txt
@@ -1,5 +1,4 @@
-Any copyright to the test code below this comment is dedicated to the
-Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
+Generated from WHATWG indexes.json; see LICENSE-WHATWG.
 
 This is a generated file. Please do not edit.
 Instead, please regenerate using generate-encoding-data.py
diff --git a/languages.toml b/languages.toml
index cc437f78c..945082a3c 100644
--- a/languages.toml
+++ b/languages.toml
@@ -1,7 +1,7 @@
 # Language support configuration.
 # See the languages documentation: https://docs.helix-editor.com/master/languages.html
 
-use-grammars = { except = [ "hare", "wren", "gemini" ] }
+use-grammars = { except = [ "wren", "gemini" ] }
 
 [language-server]
 
@@ -9,17 +9,21 @@ als = { command = "als" }
 ada-language-server = { command = "ada_language_server" }
 ada-gpr-language-server = {command = "ada_language_server", args = ["--language-gpr"]}
 angular = {command = "ngserver", args = ["--stdio", "--tsProbeLocations", ".", "--ngProbeLocations", ".",]}
+asm-lsp = { command = "asm-lsp" }
 awk-language-server = { command = "awk-language-server" }
 bash-language-server = { command = "bash-language-server", args = ["start"] }
 bass = { command = "bass", args = ["--lsp"] }
+beancount-language-server = { command = "beancount-language-server" }
 bicep-langserver = { command = "bicep-langserver" }
 bitbake-language-server = { command = "bitbake-language-server" }
 bufls = { command = "bufls", args = ["serve"] }
 cairo-language-server = { command = "cairo-language-server", args = [] }
-cl-lsp = { command = "cl-lsp", args = [ "stdio" ] }
+circom-lsp = { command = "circom-lsp" }
+cl-lsp = { command = "cl-lsp" }
 clangd = { command = "clangd" }
 clojure-lsp = { command = "clojure-lsp" }
 cmake-language-server = { command = "cmake-language-server" }
+codeql = { command = "codeql", args = ["execute", "language-server", "--check-errors=ON_CHANGE"] }
 crystalline = { command = "crystalline", args = ["--stdio"] }
 cs = { command = "cs", args = ["launch", "--contrib", "smithy-language-server", "--", "0"] }
 csharp-ls = { command = "csharp-ls" }
@@ -32,32 +36,39 @@ dot-language-server = { command = "dot-language-server", args = ["--stdio"] }
 earthlyls = { command = "earthlyls" }
 elixir-ls = { command = "elixir-ls", config = { elixirLS.dialyzerEnabled = false } }
 elm-language-server = { command = "elm-language-server" }
+elp = { command = "elp", args = ["server"] }
 elvish = { command = "elvish", args = ["-lsp"] }
 erlang-ls = { command = "erlang_ls" }
+fish-lsp = { command = "fish-lsp", args = ["start"], environment = { fish_lsp_show_client_popups = "false" } }
 forc = { command = "forc", args = ["lsp"] }
 forth-lsp = { command = "forth-lsp" }
 fortls = { command = "fortls", args = ["--lowercase_intrinsics"] }
 fsharp-ls = { command = "fsautocomplete", config = { AutomaticWorkspaceInit = true } }
 gleam = { command = "gleam", args = ["lsp"] }
+glsl_analyzer = { command = "glsl_analyzer" }
 graphql-language-service = { command = "graphql-lsp", args = ["server", "-m", "stream"] }
 haskell-language-server = { command = "haskell-language-server-wrapper", args = ["--lsp"] }
+hyprls = { command = "hyprls" }
 idris2-lsp = { command = "idris2-lsp" }
 intelephense = { command = "intelephense", args = ["--stdio"] }
 jdtls = { command = "jdtls" }
+jedi = { command = "jedi-language-server" }
 jq-lsp = { command = "jq-lsp" }
 jsonnet-language-server = { command = "jsonnet-language-server", args= ["-t", "--lint"] }
 julia = { command = "julia", timeout = 60, args = [ "--startup-file=no", "--history-file=no", "--quiet", "-e", "using LanguageServer; runserver()", ] }
 koka = { command = "koka", args = ["--language-server", "--lsstdio"] }
+koto-ls = { command = "koto-ls" }
 kotlin-language-server = { command = "kotlin-language-server" }
-lean = { command = "lean", args = [ "--server" ] }
+lean = { command = "lean", args = [ "--server", "--memory=1024" ] }
 ltex-ls = { command = "ltex-ls" }
+ltex-ls-plus = { command = "ltex-ls-plus" }
 markdoc-ls = { command = "markdoc-ls", args = ["--stdio"] }
 markdown-oxide = { command = "markdown-oxide" }
 marksman = { command = "marksman", args = ["server"] }
 metals = { command = "metals", config = { "isHttpEnabled" = true, metals = { inlayHints = { typeParameters = {enable = true} , hintsInPatternMatch = {enable = true} }  } } }
 mesonlsp = { command = "mesonlsp", args = ["--lsp"] }
 mint = { command = "mint", args = ["ls"] }
-mojo-lsp = { command = "mojo-lsp-server" }
+mojo-lsp = { command = "magic", args = ["run", "mojo-lsp-server"] }
 nil = { command = "nil" }
 nimlangserver = { command = "nimlangserver" }
 nimlsp = { command = "nimlsp" }
@@ -79,18 +90,23 @@ pyright = { command = "pyright-langserver", args = ["--stdio"], config = {} }
 basedpyright = { command = "basedpyright-langserver", args = ["--stdio"], config = {} }
 pylyzer = { command = "pylyzer", args = ["--server"] }
 qmlls = { command = "qmlls" }
+quint-language-server = { command = "quint-language-server", args = ["--stdio"] }
 r = { command = "R", args = ["--no-echo", "-e", "languageserver::run()"] }
 racket = { command = "racket", args = ["-l", "racket-langserver"] }
 regols = { command = "regols" }
 rescript-language-server = { command = "rescript-language-server", args = ["--stdio"] }
 robotframework_ls = { command = "robotframework_ls" }
+ruff = { command = "ruff", args = ["server"] }
+ruby-lsp = { command = "ruby-lsp" }
 serve-d = { command = "serve-d" }
 slint-lsp = { command = "slint-lsp", args = [] }
 solargraph = { command = "solargraph", args = ["stdio"] }
 solc = { command = "solc", args = ["--lsp"] }
 sourcekit-lsp = { command = "sourcekit-lsp" }
+spade-language-server = {command = "spade-language-server"}
 svlangserver = { command = "svlangserver", args = [] }
 swipl = { command = "swipl", args = [ "-g", "use_module(library(lsp_server))", "-g", "lsp_server:main", "-t", "halt", "--", "stdio" ] }
+superhtml = {  command = "superhtml", args = ["lsp"]}
 tailwindcss-ls = { command = "tailwindcss-language-server", args = ["--stdio"] }
 taplo = { command = "taplo", args = ["lsp", "stdio"] }
 templ = { command = "templ", args = ["lsp"] }
@@ -98,6 +114,7 @@ terraform-ls = { command = "terraform-ls", args = ["serve"] }
 texlab = { command = "texlab" }
 typespec = { command = "tsp-server", args = ["--stdio"] }
 vala-language-server = { command = "vala-language-server" }
+vale-ls = { command = "vale-ls" }
 vhdl_ls = { command = "vhdl_ls", args = [] }
 vlang-language-server = { command = "v-analyzer" }
 vscode-css-language-server = { command = "vscode-css-language-server", args = ["--stdio"], config = { provideFormatter = true, css = { validate = { enable = true } } } }
@@ -106,13 +123,17 @@ vscode-json-language-server = { command = "vscode-json-language-server", args =
 vuels = { command = "vue-language-server", args = ["--stdio"], config = { typescript = { tsdk = "node_modules/typescript/lib/" } } }
 wgsl_analyzer = { command = "wgsl_analyzer" }
 yaml-language-server = { command = "yaml-language-server", args = ["--stdio"] }
+yls = { command = "yls", args = ["-vv"] }
 zls = { command = "zls" }
 blueprint-compiler = { command = "blueprint-compiler", args = ["lsp"] }
 typst-lsp = { command = "typst-lsp" }
 tinymist = { command = "tinymist" }
+ts_query_ls = { command = "ts_query_ls" }
 pkgbuild-language-server = { command = "pkgbuild-language-server" }
 helm_ls = { command = "helm_ls", args = ["serve"] }
 ember-language-server = { command = "ember-language-server", args = ["--stdio"] }
+teal-language-server = { command = "teal-language-server" }
+wasm-language-tools = { command = "wat_server" }
 
 [language-server.ansible-language-server]
 command = "ansible-language-server"
@@ -281,7 +302,7 @@ args = { attachCommands = [ "platform select remote-gdb-server", "platform conne
 
 [[grammar]]
 name = "rust"
-source = { git = "https://github.com/tree-sitter/tree-sitter-rust", rev = "9c84af007b0f144954adb26b3f336495cbb320a7" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-rust", rev = "1f63b33efee17e833e0ea29266dd3d713e27e321" }
 
 [[language]]
 name = "sway"
@@ -326,16 +347,30 @@ source = { git = "https://github.com/Beaglefoot/tree-sitter-awk", rev = "a799bc5
 [[language]]
 name = "protobuf"
 scope = "source.proto"
-injection-regex = "protobuf"
+injection-regex = "proto"
 file-types = ["proto"]
 language-servers = [ "bufls", "pbkit" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 indent = { tab-width = 2, unit = "  " }
+grammar = "proto"
 
 [[grammar]]
-name = "protobuf"
-source = { git = "https://github.com/yusdacra/tree-sitter-protobuf", rev = "19c211a01434d9f03efff99f85e19f967591b175"}
+name = "proto"
+source = { git = "https://github.com/sdoerner/tree-sitter-proto", rev = "778ab6ed18a7fcf82c83805a87d63376c51e80bc"}
+
+[[language]]
+name = "textproto"
+file-types = ["txtpb", "textpb", "textproto"]
+comment-token = "#"
+scope = "source.textproto"
+indent = { tab-width = 2, unit = "  " }
+formatter = { command = "txtpbfmt" }
+auto-format = true
+
+[[grammar]]
+name = "textproto"
+source = { git = "https://github.com/PorterAtGoogle/tree-sitter-textproto", rev = "568471b80fd8793d37ed01865d8c2208a9fefd1b"}
 
 [[language]]
 name = "elixir"
@@ -350,7 +385,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "elixir"
-source = { git = "https://github.com/elixir-lang/tree-sitter-elixir", rev = "b20eaa75565243c50be5e35e253d8beb58f45d56"  }
+source = { git = "https://github.com/elixir-lang/tree-sitter-elixir", rev = "02a6f7fd4be28dd94ee4dd2ca19cb777053ea74e" }
 
 [[language]]
 name = "fish"
@@ -359,13 +394,14 @@ injection-regex = "fish"
 file-types = ["fish"]
 shebangs = ["fish"]
 comment-token = "#"
+language-servers = ["fish-lsp"]
 indent = { tab-width = 4, unit = "    " }
 auto-format = true
 formatter = { command = "fish_indent" }
 
 [[grammar]]
 name = "fish"
-source = { git = "https://github.com/ram02z/tree-sitter-fish", rev = "84436cf24c2b3176bfbb220922a0fdbd0141e406" }
+source = { git = "https://github.com/ram02z/tree-sitter-fish", rev = "a78aef9abc395c600c38a037ac779afc7e3cc9e0" }
 
 [[language]]
 name = "mint"
@@ -388,7 +424,7 @@ language-servers = [ "mojo-lsp" ]
 comment-token = "#"
 indent = { tab-width = 4, unit = "    " }
 auto-format = true
-formatter = { command = "mojo", args = ["format", "-q", "-"]}
+formatter = { command = "magic", args = ["run", "mojo" , "format", "-q", "-"]}
 
 [[grammar]]
 name = "mojo"
@@ -442,7 +478,21 @@ file-types = [
   { glob = "composer.lock" },
   { glob = ".watchmanconfig" },
   "avsc",
-  { glob = ".prettierrc" },
+  "ldtk",
+  "ldtkl",
+  { glob = ".swift-format" },
+  "sublime-build",
+  "sublime-color-scheme",
+  "sublime-commands",
+  "sublime-completions",
+  "sublime-keymap",
+  "sublime-macro",
+  "sublime-menu",
+  "sublime-mousemap",
+  "sublime-project",
+  "sublime-settings",
+  "sublime-theme",
+  "sublime-workspace"
 ]
 language-servers = [ "vscode-json-language-server" ]
 auto-format = true
@@ -456,7 +506,9 @@ source = { git = "https://github.com/tree-sitter/tree-sitter-json", rev = "73076
 name = "jsonc"
 scope = "source.json"
 injection-regex = "jsonc"
-file-types = ["jsonc"]
+file-types = ["jsonc", { glob = "tsconfig.json" }, { glob = "bun.lock" }]
+comment-token = "//"
+block-comment-tokens = { start = "/*", end = "*/" }
 grammar = "json"
 language-servers = [ "vscode-json-language-server" ]
 auto-format = true
@@ -721,6 +773,7 @@ injection-regex = "(js|javascript)"
 language-id = "javascript"
 file-types = ["js", "mjs", "cjs", "rules", "es6", "pac", { glob = ".node_repl_history" }, { glob = "jakefile" }]
 shebangs = ["node"]
+roots = [ "package.json" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "typescript-language-server" ]
@@ -748,6 +801,7 @@ scope = "source.jsx"
 injection-regex = "jsx"
 language-id = "javascriptreact"
 file-types = ["jsx"]
+roots = [ "package.json" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "typescript-language-server" ]
@@ -761,6 +815,7 @@ injection-regex = "(ts|typescript)"
 language-id = "typescript"
 file-types = ["ts", "mts", "cts"]
 shebangs = ["deno", "bun", "ts-node"]
+roots = [ "package.json", "tsconfig.json" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "typescript-language-server" ]
@@ -793,6 +848,7 @@ scope = "source.tsx"
 injection-regex = "(tsx)" # |typescript
 language-id = "typescriptreact"
 file-types = ["tsx"]
+roots = [ "package.json", "tsconfig.json" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "typescript-language-server" ]
@@ -836,7 +892,7 @@ scope = "text.html.basic"
 injection-regex = "html"
 file-types = ["html", "htm", "shtml", "xhtml", "xht", "jsp", "asp", "aspx", "jshtm", "volt", "rhtml", "cshtml"]
 block-comment-tokens = { start = "<!--", end = "-->" }
-language-servers = [ "vscode-html-language-server" ]
+language-servers = [ "vscode-html-language-server", "superhtml" ]
 auto-format = true
 indent = { tab-width = 2, unit = "  " }
 
@@ -849,10 +905,10 @@ name = "python"
 scope = "source.python"
 injection-regex = "py(thon)?"
 file-types = ["py", "pyi", "py3", "pyw", "ptl", "rpy", "cpy", "ipy", "pyt", { glob = ".python_history" }, { glob = ".pythonstartup" }, { glob = ".pythonrc" }, { glob = "SConstruct" }, { glob = "SConscript" }]
-shebangs = ["python"]
+shebangs = ["python", "uv"]
 roots = ["pyproject.toml", "setup.py", "poetry.lock", "pyrightconfig.json"]
 comment-token = "#"
-language-servers = [ "pylsp" ]
+language-servers = ["ruff", "jedi", "pylsp"]
 # TODO: pyls needs utf-8 offsets
 indent = { tab-width = 4, unit = "    " }
 
@@ -878,7 +934,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "nickel"
-source = { git = "https://github.com/nickel-lang/tree-sitter-nickel", rev = "e1d9337864d209898a08c26b8cd4c2dd14c15148" }
+source = { git = "https://github.com/nickel-lang/tree-sitter-nickel", rev = "88d836a24b3b11c8720874a1a9286b8ae838d30a" }
 
 [[language]]
 name = "nix"
@@ -909,6 +965,7 @@ file-types = [
   "podspec",
   "rjs",
   "rbi",
+  "rbs",
   { glob = "rakefile" },
   { glob = "gemfile" },
   { glob = "Rakefile" },
@@ -936,7 +993,7 @@ file-types = [
 ]
 shebangs = ["ruby"]
 comment-token = "#"
-language-servers = [ "solargraph" ]
+language-servers = [ "ruby-lsp", "solargraph" ]
 indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
@@ -1011,6 +1068,7 @@ file-types = ["php", "inc", "php4", "php5", "phtml", "ctp"]
 shebangs = ["php"]
 roots = ["composer.json", "index.php"]
 comment-token = "//"
+block-comment-tokens = [{start = "/**", end = "*/"}, {start = "/*", end = "*/"}]
 language-servers = [ "intelephense" ]
 indent = { tab-width = 4, unit = "    " }
 
@@ -1142,7 +1200,7 @@ indent = { tab-width = 4, unit = "    " }
 
 [[grammar]]
 name = "julia"
-source = { git = "https://github.com/tree-sitter/tree-sitter-julia", rev = "8fb38abff74652c4faddbf04d2d5bbbc6b4bae25" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-julia", rev = "e84f10db8eeb8b9807786bfc658808edaa1b4fa2" }
 
 [[language]]
 name = "java"
@@ -1152,6 +1210,8 @@ file-types = ["java", "jav", "pde"]
 roots = ["pom.xml", "build.gradle", "build.gradle.kts"]
 language-servers = [ "jdtls" ]
 indent = { tab-width = 2, unit = "  " }
+comment-tokens = ["//"]
+block-comment-tokens = { start = "/*", end = "*/" }
 
 [[grammar]]
 name = "java"
@@ -1189,6 +1249,7 @@ injection-regex = "beancount"
 file-types = ["beancount", "bean"]
 comment-token = ";"
 indent = { tab-width = 2, unit = "  " }
+language-servers = [ "beancount-language-server" ]
 
 [[grammar]]
 name = "beancount"
@@ -1234,11 +1295,28 @@ indent = { tab-width = 2, unit = "  " }
 name = "ocaml-interface"
 source = { git = "https://github.com/tree-sitter/tree-sitter-ocaml", rev = "9965d208337d88bbf1a38ad0b0fe49e5f5ec9677", subpath = "interface" }
 
+[[language]]
+name = "dune"
+scope = "source.dune"
+roots = ["dune-project"]
+file-types = [{ glob = "dune-project" }, { glob = "dune" }]
+comment-token = ";"
+indent = { tab-width = 1, unit = " " }
+grammar = "scheme"
+auto-format = true
+formatter = { command = "dune", args = ["format-dune-file"] }
+
+[language.auto-pairs]
+'(' = ')'
+'{' = '}'
+'[' = ']'
+'"' = '"'
+
 [[language]]
 name = "lua"
 injection-regex = "lua"
 scope = "source.lua"
-file-types = ["lua"]
+file-types = ["lua", "rockspec"]
 shebangs = ["lua", "luajit"]
 roots = [".luarc.json", ".luacheckrc", ".stylua.toml", "selene.toml", ".git"]
 comment-token = "--"
@@ -1250,12 +1328,28 @@ language-servers = [ "lua-language-server" ]
 name = "lua"
 source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-lua", rev = "88e446476a1e97a8724dff7a23e2d709855077f2" }
 
+[[grammar]]
+name = "teal"
+source = { git = "https://github.com/euclidianAce/tree-sitter-teal", rev = "3db655924b2ff1c54fdf6371b5425ea6b5dccefe" }
+
+[[language]]
+name = "teal"
+scope = "source.tl"
+injection-regex = "teal"
+file-types = ["tl"]
+comment-tokens = "--"
+block-comment-tokens = { start = "--[[", end = "--]]" }
+roots = [ "tlconfig.lua" ]
+language-servers = [ "teal-language-server" ]
+
 [[language]]
 name = "svelte"
 scope = "source.svelte"
 injection-regex = "svelte"
 file-types = ["svelte"]
 indent = { tab-width = 2, unit = "  " }
+comment-token = "//"
+block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "svelteserver" ]
 
 [[grammar]]
@@ -1279,7 +1373,15 @@ source = { git = "https://github.com/ikatyang/tree-sitter-vue", rev = "91fe27547
 [[language]]
 name = "yaml"
 scope = "source.yaml"
-file-types = ["yml", "yaml"]
+file-types = [
+  "yml",
+  "yaml",
+  { glob = ".prettierrc" },
+  { glob = ".clangd" },
+  { glob = ".clang-format" },
+  { glob = ".clang-tidy" },
+  "sublime-syntax"
+]
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
 language-servers = [ "yaml-language-server", "ansible-language-server" ]
@@ -1289,6 +1391,15 @@ injection-regex = "yml|yaml"
 name = "yaml"
 source = { git = "https://github.com/ikatyang/tree-sitter-yaml", rev = "0e36bed171768908f331ff7dff9d956bae016efb" }
 
+[[language]]
+name = "nestedtext"
+scope = "text.nested"
+injection-regex = "nestedtext"
+file-types = ["nt"]
+comment-token = "#"
+indent = { tab-width = 4, unit = "    " }
+grammar = "yaml"
+
 [[language]]
 name = "haskell"
 scope = "source.haskell"
@@ -1339,7 +1450,7 @@ injection-regex = "zig"
 file-types = ["zig", "zon"]
 roots = ["build.zig"]
 auto-format = true
-comment-token = "//"
+comment-tokens = ["//", "///", "//!"]
 language-servers = [ "zls" ]
 indent = { tab-width = 4, unit = "    " }
 formatter = { command = "zig" , args = ["fmt", "--stdin"] }
@@ -1369,7 +1480,7 @@ args = { console = "internalConsole", attachCommands = [ "platform select remote
 
 [[grammar]]
 name = "zig"
-source = { git = "https://github.com/maxxnino/tree-sitter-zig", rev = "0d08703e4c3f426ec61695d7617415fff97029bd" }
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-zig", rev = "eb7d58c2dc4fbeea4745019dee8df013034ae66b" }
 
 [[language]]
 name = "prolog"
@@ -1383,14 +1494,21 @@ language-servers = [ "swipl" ]
 [[language]]
 name = "tsq"
 scope = "source.tsq"
-file-types = ["tsq"]
+file-types = [{ glob = "queries/*.scm" }, { glob = "injections.scm" },  { glob = "highlights.scm" },  { glob = "indents.scm" },  { glob = "textobjects.scm" },  { glob = "locals.scm" },  { glob = "tags.scm" }]
 comment-token = ";"
 injection-regex = "tsq"
+language-servers = ["ts_query_ls"]
+grammar = "query"
 indent = { tab-width = 2, unit = "  " }
 
+[language.auto-pairs]
+'(' = ')'
+'[' = ']'
+'"' = '"'
+
 [[grammar]]
-name = "tsq"
-source = { git = "https://github.com/the-mikedavis/tree-sitter-tsq", rev = "48b5e9f82ae0a4727201626f33a17f69f8e0ff86" }
+name = "query"
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-query", rev = "a6674e279b14958625d7a530cabe06119c7a1532" }
 
 [[language]]
 name = "cmake"
@@ -1426,6 +1544,7 @@ file-types = ["glsl", "vert", "tesc", "tese", "geom", "frag", "comp" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 indent = { tab-width = 4, unit = "    " }
+language-servers = [ "glsl_analyzer" ]
 injection-regex = "glsl"
 
 [[grammar]]
@@ -1443,7 +1562,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "perl"
-source = { git = "https://github.com/tree-sitter-perl/tree-sitter-perl", rev = "e99bb5283805db4cb86c964722d709df21b0ac16" }
+source = { git = "https://github.com/tree-sitter-perl/tree-sitter-perl", rev = "72a08a496a23212f23802490ef6f4700d68cfd0e" }
 
 [[language]]
 name = "pod"
@@ -1453,7 +1572,7 @@ file-types = ["pod"]
 
 [[grammar]]
 name = "pod"
-source = { git = "https://github.com/tree-sitter-perl/tree-sitter-pod", rev = "39da859947b94abdee43e431368e1ae975c0a424" }
+source = { git = "https://github.com/tree-sitter-perl/tree-sitter-pod", rev = "0bf8387987c21bf2f8ed41d2575a8f22b139687f" }
 
 [[language]]
 name = "racket"
@@ -1515,7 +1634,7 @@ injection-regex = "llvm"
 
 [[grammar]]
 name = "llvm"
-source = { git = "https://github.com/benwilliamgraham/tree-sitter-llvm", rev = "e9948edc41e9e5869af99dddb2b5ff5cc5581af6" }
+source = { git = "https://github.com/benwilliamgraham/tree-sitter-llvm", rev = "c14cb839003348692158b845db9edda201374548" }
 
 [[language]]
 name = "llvm-mir"
@@ -1527,7 +1646,7 @@ injection-regex = "mir"
 
 [[grammar]]
 name = "llvm-mir"
-source = { git = "https://github.com/Flakebi/tree-sitter-llvm-mir", rev = "06fabca19454b2dc00c1b211a7cb7ad0bc2585f1" }
+source = { git = "https://github.com/Flakebi/tree-sitter-llvm-mir", rev = "d166ff8c5950f80b0a476956e7a0ad2f27c12505" }
 
 [[language]]
 name = "llvm-mir-yaml"
@@ -1550,13 +1669,13 @@ injection-regex = "tablegen"
 
 [[grammar]]
 name = "tablegen"
-source = { git = "https://github.com/Flakebi/tree-sitter-tablegen", rev = "568dd8a937347175fd58db83d4c4cdaeb6069bd2" }
+source = { git = "https://github.com/Flakebi/tree-sitter-tablegen", rev = "3e9c4822ab5cdcccf4f8aa9dcd42117f736d51d9" }
 
 [[language]]
 name = "markdown"
 scope = "source.md"
 injection-regex = "md|markdown"
-file-types = ["md", "markdown", "mdx", "mkd", "mkdn", "mdwn", "mdown", "markdn", "mdtxt", "mdtext", "workbook", { glob = "PULLREQ_EDITMSG" }]
+file-types = ["md", "livemd", "markdown", "mdx", "mkd", "mkdn", "mdwn", "mdown", "markdn", "mdtxt", "mdtext", "workbook", { glob = "PULLREQ_EDITMSG" }]
 roots = [".marksman.toml"]
 language-servers = [ "marksman", "markdown-oxide" ]
 indent = { tab-width = 2, unit = "  " }
@@ -1577,13 +1696,25 @@ grammar = "markdown_inline"
 name = "markdown_inline"
 source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-markdown", rev = "62516e8c78380e3b51d5b55727995d2c511436d8", subpath = "tree-sitter-markdown-inline" }
 
+[[language]]
+name = "djot"
+scope = "source.djot"
+injection-regex = "dj|djot"
+file-types = ["dj", "djot"]
+indent = { tab-width = 2, unit = "  " }
+block-comment-tokens = { start = "{%", end = "%}" }
+
+[[grammar]]
+name = "djot"
+source = { git = "https://github.com/treeman/tree-sitter-djot", rev = "67e6e23ba7be81a4373e0f49e21207bdc32d12a5" }
+
 [[language]]
 name = "dart"
 scope = "source.dart"
 file-types = ["dart"]
 roots = ["pubspec.yaml"]
 auto-format = true
-comment-token = "//"
+comment-tokens = ["//", "///"]
 block-comment-tokens = { start = "/*", end = "*/" }
 language-servers = [ "dart" ]
 indent = { tab-width = 2, unit = "  " }
@@ -1631,7 +1762,7 @@ language-servers = [ "docker-langserver" ]
 
 [[grammar]]
 name = "dockerfile"
-source = { git = "https://github.com/camdencheek/tree-sitter-dockerfile", rev = "8ee3a0f7587b2bd8c45c8cb7d28bd414604aec62" }
+source = { git = "https://github.com/camdencheek/tree-sitter-dockerfile", rev = "087daa20438a6cc01fa5e6fe6906d77c869d19fe" }
 
 [[language]]
 name = "docker-compose"
@@ -1646,7 +1777,7 @@ grammar = "yaml"
 [[language]]
 name = "git-commit"
 scope = "git.commitmsg"
-file-types = [{ glob = "COMMIT_EDITMSG" }]
+file-types = [{ glob = "COMMIT_EDITMSG" }, { glob = "MERGE_MSG" }]
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
 rulers = [51, 73]
@@ -1674,7 +1805,7 @@ scope = "source.gitrebase"
 file-types = [{ glob = "git-rebase-todo" }]
 injection-regex = "git-rebase"
 comment-token = "#"
-indent = { tab-width = 2, unit = "y" }
+indent = { tab-width = 2, unit = "\t" }
 
 [[grammar]]
 name = "git-rebase"
@@ -1781,7 +1912,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "rescript"
-source = { git = "https://github.com/jaredramirez/tree-sitter-rescript", rev = "467dcf99f68c47823d7b378779a6b282d7ef9782" }
+source = { git = "https://github.com/rescript-lang/tree-sitter-rescript", rev = "5e2a44a9d886b0a509f5bfd0437d33b4871fbac5" }
 
 [[language]]
 name = "erlang"
@@ -1792,11 +1923,11 @@ roots = ["rebar.config"]
 shebangs = ["escript"]
 comment-token = "%%"
 indent = { tab-width = 4, unit = "    " }
-language-servers = [ "erlang-ls" ]
+language-servers = [ "erlang-ls", "elp" ]
 
 [[grammar]]
 name = "erlang"
-source = { git = "https://github.com/the-mikedavis/tree-sitter-erlang", rev = "9d4b36a76d5519e3dbf1ec4f4b61bb1a293f584c" }
+source = { git = "https://github.com/the-mikedavis/tree-sitter-erlang", rev = "33a3e4f1fa77a3e1a2736813f4b27c358f6c0b63" }
 
 [[language]]
 name = "kotlin"
@@ -1826,7 +1957,7 @@ auto-format = true
 
 [[grammar]]
 name = "hcl"
-source = { git = "https://github.com/MichaHoffmann/tree-sitter-hcl", rev = "3cb7fc28247efbcb2973b97e71c78838ad98a583" }
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-hcl", rev = "9e3ec9848f28d26845ba300fd73c740459b83e9b" }
 
 [[language]]
 name = "tfvars"
@@ -1863,7 +1994,7 @@ language-servers = [ "solc" ]
 
 [[grammar]]
 name = "solidity"
-source = { git = "https://github.com/JoranHonig/tree-sitter-solidity", rev = "08338dcee32603383fcef08f36321900bb7a354b" }
+source = { git = "https://github.com/JoranHonig/tree-sitter-solidity", rev = "f7f5251a3f5b1d04f0799b3571b12918af177fc8" }
 
 [[language]]
 name = "gleam"
@@ -1891,7 +2022,7 @@ indent = { tab-width = 4, unit = "    " }
 
 [[grammar]]
 name = "ron"
-source = { git = "https://github.com/zee-editor/tree-sitter-ron", rev = "7762d709a0f7c1f9e269d0125a2e8a7a69006146" }
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-ron", rev = "78938553b93075e638035f624973083451b29055" }
 
 [[language]]
 name = "robot"
@@ -1912,7 +2043,7 @@ scope = "source.r"
 injection-regex = "(r|R)"
 file-types = ["r", "R", { glob = ".Rprofile" }, { glob = "Rprofile.site" }, { glob = ".RHistory" }]
 shebangs = ["r", "R"]
-comment-token = "#"
+comment-tokens = ["#", "#'"]
 indent = { tab-width = 2, unit = "  " }
 language-servers = [ "r" ]
 
@@ -1939,8 +2070,7 @@ file-types = ["swift", "swiftinterface"]
 roots = [ "Package.swift" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
-formatter = { command = "swift-format", args = [ "--configuration", ".swift-format"] }
-auto-format = true
+formatter = { command = "swift-format" }
 language-servers = [ "sourcekit-lsp" ]
 
 [[grammar]]
@@ -1994,7 +2124,7 @@ language-servers = [ "elixir-ls" ]
 
 [[grammar]]
 name = "heex"
-source = { git = "https://github.com/phoenixframework/tree-sitter-heex", rev = "2e1348c3cf2c9323e87c2744796cf3f3868aa82a" }
+source = { git = "https://github.com/phoenixframework/tree-sitter-heex", rev = "f6b83f305a755cd49cf5f6a66b2b789be93dc7b9" }
 
 [[language]]
 name = "sql"
@@ -2105,7 +2235,7 @@ language-servers = [ "cairo-language-server" ]
 
 [[grammar]]
 name = "cairo"
-source = { git = "https://github.com/starkware-libs/tree-sitter-cairo", rev = "e3a0212261c125cb38248458cd856c0ffee2b398" }
+source = { git = "https://github.com/starkware-libs/tree-sitter-cairo", rev = "4c6a25680546761b80a710ead1dd34e76c203125" }
 
 [[language]]
 name = "cpon"
@@ -2130,7 +2260,7 @@ language-servers = [ "ols" ]
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
 indent = { tab-width = 4, unit = "\t" }
-formatter = { command = "odinfmt", args = [ "-stdin", "true" ] }
+formatter = { command = "odinfmt", args = [ "-stdin" ] }
 
 [language.debugger]
 name = "lldb-dap"
@@ -2175,7 +2305,7 @@ source = { git = "https://github.com/staysail/tree-sitter-meson", rev = "32a83e8
 [[language]]
 name = "sshclientconfig"
 scope = "source.sshclientconfig"
-file-types = [{ glob = ".ssh/config" }, { glob = "/etc/ssh/ssh_config" }]
+file-types = [{ glob = ".ssh/config" }, { glob = "/etc/ssh/ssh_config" }, { glob = "ssh_config.d/*.conf" } ]
 comment-token = "#"
 
 [[grammar]]
@@ -2215,7 +2345,7 @@ indent = { tab-width = 4, unit = "\t" }
 
 [[grammar]]
 name = "v"
-source = {git = "https://github.com/v-analyzer/v-analyzer", subpath = "tree_sitter_v", rev = "e14fdf6e661b10edccc744102e4ccf0b187aa8ad"}
+source = {git = "https://github.com/vlang/v-analyzer", subpath = "tree_sitter_v", rev = "e14fdf6e661b10edccc744102e4ccf0b187aa8ad"}
 
 [[language]]
 name = "verilog"
@@ -2299,7 +2429,7 @@ source = { git = "https://github.com/sogaiu/tree-sitter-clojure", rev = "e57c569
 name = "starlark"
 scope = "source.starlark"
 injection-regex = "(starlark|bzl|bazel)"
-file-types = ["bzl", "bazel", "star", { glob = "BUILD" }, { glob = "BUILD.*" }, { glob = "Tiltfile" }, { glob = "WORKSPACE" }]
+file-types = ["bzl", "bazel", "star", { glob = "BUILD" }, { glob = "BUILD.*" }, { glob = "Tiltfile" }, { glob = "WORKSPACE" }, { glob = "WORKSPACE.bzlmod" }]
 comment-token = "#"
 indent = { tab-width = 4, unit = "    " }
 grammar = "python"
@@ -2383,7 +2513,7 @@ formatter = { command = "cue", args = ["fmt", "-"] }
 
 [[grammar]]
 name = "cue"
-source = { git = "https://github.com/eonpatapon/tree-sitter-cue", rev = "61843e3beebf19417e4fede4e8be4df1084317ad" }
+source = { git = "https://github.com/eonpatapon/tree-sitter-cue", rev = "8a5f273bfa281c66354da562f2307c2d394b6c81" }
 
 [[language]]
 name = "slint"
@@ -2397,7 +2527,7 @@ language-servers = [ "slint-lsp" ]
 
 [[grammar]]
 name = "slint"
-source = { git = "https://github.com/slint-ui/tree-sitter-slint", rev = "4a0558cc0fcd7a6110815b9bbd7cc12d7ab31e74" }
+source = { git = "https://github.com/slint-ui/tree-sitter-slint", rev = "f11da7e62051ba8b9d4faa299c26de8aeedfc1cd" }
 
 [[language]]
 name = "task"
@@ -2456,6 +2586,12 @@ injection-regex = "sml"
 file-types = ["sml"]
 block-comment-tokens = { start = "(*", end = "*)" }
 
+[language.auto-pairs]
+'(' = ')'
+'{' = '}'
+'[' = ']'
+'"' = '"'
+
 [[grammar]]
 name = "sml"
 source = { git = "https://github.com/Giorbo/tree-sitter-sml", rev = "bd4055d5554614520d4a0706b34dc0c317c6b608" }
@@ -2478,11 +2614,11 @@ source = { git = "https://github.com/sourcegraph/tree-sitter-jsonnet", rev = "04
 name = "ada"
 scope = "source.ada"
 injection-regex = "ada"
-file-types = ["adb", "ads", "gpr"]
+file-types = ["adb", "ads"]
 roots = ["alire.toml"]
 comment-token = "--"
 indent = { tab-width = 3, unit = "   " }
-language-servers = ["ada-language-server", "ada-gpr-language-server"]
+language-servers = ["ada-language-server"]
 
 
 [[grammar]]
@@ -2520,6 +2656,7 @@ scope = "source.wat"
 comment-token = ";;"
 block-comment-tokens = { start = "(;", end = ";)" }
 file-types = ["wat"]
+language-servers = ["wasm-language-tools"]
 
 [[grammar]]
 name = "wat"
@@ -2638,7 +2775,8 @@ file-types = [
   "xoml",
   "musicxml",
   "glif",
-  "ui"
+  "ui",
+  "sublime-snippet"
 ]
 block-comment-tokens = { start = "<!--", end = "-->" }
 indent = { tab-width = 2, unit = "  " }
@@ -2728,6 +2866,7 @@ file-types = [
   "network",
   { glob = ".editorconfig" },
   { glob = ".npmrc" },
+  { glob = "hgrc" },
   { glob = "npmrc" },
   { glob = "rclone.conf" },
   "properties",
@@ -2740,7 +2879,7 @@ indent = { tab-width = 4, unit = "\t" }
 
 [[grammar]]
 name = "ini"
-source = { git = "https://github.com/justinmk/tree-sitter-ini", rev = "4d247fb876b4ae6b347687de4a179511bf67fcbc" }
+source = { git = "https://github.com/justinmk/tree-sitter-ini", rev = "1b0498a89a1a4c0a3705846699f0b0bad887dd04" }
 
 [[language]]
 name = "inko"
@@ -2760,7 +2899,7 @@ source = { git = "https://github.com/inko-lang/tree-sitter-inko", rev = "7860637
 [[language]]
 name = "bicep"
 scope = "source.bicep"
-file-types = ["bicep"]
+file-types = ["bicep","bicepparam"]
 auto-format = true
 comment-token = "//"
 block-comment-tokens = { start = "/*", end = "*/" }
@@ -2769,7 +2908,7 @@ language-servers = [ "bicep-langserver" ]
 
 [[grammar]]
 name = "bicep"
-source = { git = "https://github.com/the-mikedavis/tree-sitter-bicep", rev = "d8e097fcfa143854861ef737161163a09cc2916b" }
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-bicep", rev = "0092c7d1bd6bb22ce0a6f78497d50ea2b87f19c0" }
 
 [[language]]
 name = "qml"
@@ -2807,7 +2946,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "matlab"
-source = { git = "https://github.com/acristoffers/tree-sitter-matlab", rev = "6071891a8c39600203eba20513666cf93b4d650a" }
+source = { git = "https://github.com/acristoffers/tree-sitter-matlab", rev = "b0a0198b182574cd3ca0447264c83331901b9338" }
 
 [[language]]
 name = "ponylang"
@@ -2947,10 +3086,11 @@ file-types = ["asm", "S", "nasm"]
 injection-regex = "n?asm"
 comment-token = ";"
 indent = { tab-width = 8, unit = "        " }
+language-servers = ["asm-lsp"]
 
 [[grammar]]
 name = "nasm"
-source = { git = "https://github.com/naclsn/tree-sitter-nasm", rev = "a0db15db6fcfb1bf2cc8702500e55e558825c48b" }
+source = { git = "https://github.com/naclsn/tree-sitter-nasm", rev = "570f3d7be01fffc751237f4cfcf52d04e20532d1" }
 
 [[language]]
 name = "gas"
@@ -2959,6 +3099,7 @@ file-types = ["s"]
 injection-regex = "gas"
 comment-token = "#"
 indent = { tab-width = 8, unit = "        " }
+language-servers = ["asm-lsp"]
 
 [[grammar]]
 name = "gas"
@@ -3106,7 +3247,7 @@ indent = { tab-width = 4, unit = "    " }
 
 [[grammar]]
 name = "just"
-source = { git = "https://github.com/poliorcetics/tree-sitter-just", rev = "f58a8fd869035ac4653081401e6c2030251240ab" }
+source = { git = "https://github.com/poliorcetics/tree-sitter-just", rev = "8d03cfdd7ab89ff76d935827de1b93450fa0ec0a" }
 
 [[language]]
 name = "gn"
@@ -3214,6 +3355,7 @@ injection-regex = "nunjucks"
 file-types = ["njk"]
 indent = { tab-width = 2, unit = "  " }
 grammar = "jinja2"
+block-comment-tokens = { start = "{#", end = "#}" }
 
 [[language]]
 name = "jinja"
@@ -3222,6 +3364,7 @@ injection-regex = "jinja"
 file-types = ["jinja", "jinja2", "j2"]
 indent = { tab-width = 2, unit = "  " }
 grammar = "jinja2"
+block-comment-tokens = { start = "{#", end = "#}" }
 
 [[grammar]]
 name = "jinja2"
@@ -3238,7 +3381,7 @@ text-width = 72
 
 [[grammar]]
 name = "jjdescription"
-source = { git = "https://github.com/kareigu/tree-sitter-jjdescription", rev = "2ddec6cad07b366aee276a608e1daa2c29d3caf2" }
+source = { git = "https://github.com/kareigu/tree-sitter-jjdescription", rev = "d09205b52b5a0165b588a793e366c1116468d86f" }
 
 [[language]]
 name = "jq"
@@ -3283,7 +3426,7 @@ indent = { tab-width = 4, unit = "    " }
 
 [[grammar]]
 name = "unison"
-source = { git = "https://github.com/kylegoetz/tree-sitter-unison", rev = "1f505e2447fa876a87aee47ff3d70b9e141c744f" }
+source = { git = "https://github.com/kylegoetz/tree-sitter-unison", rev = "3c97db76d3cdbd002dfba493620c2d5df2fd6fa9" }
 
 [[language]]
 name = "todotxt"
@@ -3401,7 +3544,11 @@ source = { git = "https://github.com/urbit-pilled/tree-sitter-hoon", rev = "1d5d
 [[language]]
 name = "hocon"
 scope = "source.conf"
-file-types = ["conf"]
+file-types = [
+  { glob = "**/src/*/resources/**/*.conf" },
+  { glob = "*scalafmt*.conf" },
+  { glob = "*scalafix*.conf" },
+]
 comment-token = "#"
 auto-format = true
 indent = { tab-width = 2, unit = "  " }
@@ -3514,9 +3661,10 @@ source = { git = "https://github.com/mtoohey31/tree-sitter-ld", rev = "0e9695ae0
 name = "hyprlang"
 scope = "source.hyprlang"
 roots = ["hyprland.conf"]
-file-types = [ { glob = "hyprland.conf" }, { glob = "hyprpaper.conf" }, { glob = "hypridle.conf" }, { glob = "hyprlock.conf" } ]
+file-types = [ { glob = "hypr/*.conf" }]
 comment-token = "#"
 grammar = "hyprlang"
+language-servers = ["hyprls"]
 
 [[grammar]]
 name = "hyprlang"
@@ -3785,4 +3933,244 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "thrift"
-source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-thrift" , rev = "68fd0d80943a828d9e6f49c58a74be1e9ca142cf" }
\ No newline at end of file
+source = { git = "https://github.com/tree-sitter-grammars/tree-sitter-thrift" , rev = "68fd0d80943a828d9e6f49c58a74be1e9ca142cf" }
+
+[[language]]
+name             = "circom"
+scope            = "source.circom"
+injection-regex  = "circom"
+file-types       = ["circom"]
+roots            = ["package.json"]
+comment-tokens   = "//"
+indent           = { tab-width = 4, unit = "    " }
+auto-format      = false
+language-servers = ["circom-lsp"]
+
+[[grammar]]
+name   = "circom"
+source = { git = "https://github.com/Decurity/tree-sitter-circom", rev = "02150524228b1e6afef96949f2d6b7cc0aaf999e" }
+
+[[language]]
+name = "snakemake"
+scope = "source.snakemake"
+roots = ["Snakefile", "config.yaml", "environment.yaml", "workflow/"]
+file-types = ["smk", { glob = "Snakefile" } ]
+comment-tokens = ["#", "##"]
+indent = { tab-width = 2, unit = "  " }
+language-servers = ["pylsp" ]
+
+[language.formatter]
+command = "snakefmt"
+args = ["-"]
+
+[[grammar]]
+name = "snakemake"
+source = { git = "https://github.com/osthomas/tree-sitter-snakemake", rev = "e909815acdbe37e69440261ebb1091ed52e1dec6" }
+
+[[language]]
+name = "cylc"
+scope = "source.cylc"
+injection-regex = "cylc"
+file-types = ["cylc", { glob = "suite.rc" }]
+comment-tokens = "#"
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "cylc"
+source = { git = "https://github.com/elliotfontaine/tree-sitter-cylc", rev = "30dd40d9bf23912e4aefa93eeb4c7090bda3d0f6" }
+
+[[language]]
+name = "quint"
+scope = "source.quint"
+file-types = ["qnt"]
+language-servers = ["quint-language-server"]
+comment-token = "//"
+block-comment-tokens = { start = "/*", end = "*/" }
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "quint"
+source = { git = "https://github.com/gruhn/tree-sitter-quint", rev = "eebbd01edfeff6404778c92efe5554e42e506a18" }
+
+[[language]]
+name = "spade"
+scope = "source.spade"
+roots = ["swim.toml"]
+file-types = ['spade']
+injection-regex = "spade"
+comment-tokens = ["//", "///"]
+block-comment-tokens = [
+  { start = "/*", end = "*/" },
+  { start = "/**", end = "*/" },
+]
+language-servers = [ "spade-language-server" ]
+indent = { tab-width = 4, unit = "    " }
+
+[language.auto-pairs] 
+'(' = ')' 
+'{' = '}' 
+'[' = ']' 
+'"' = '"' 
+'<' = '>' 
+
+[[grammar]]
+name = "spade"
+source = { git = "https://gitlab.com/spade-lang/tree-sitter-spade", rev = "78bf09a88fc1d396f66b69879f908fc6bd2e6934" }
+
+[[language]]
+name = "amber"
+scope = "source.ab"
+file-types = ["ab"]
+comment-token = "//"
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "amber"
+source = { git = "https://github.com/amber-lang/tree-sitter-amber", rev = "c6df3ec2ec243ed76550c525e7ac3d9a10c6c814" }
+
+[[language]]
+name = "koto"
+scope = "source.koto"
+injection-regex = "koto"
+file-types = ["koto"]
+comment-token = "#"
+block-comment-tokens = ["#-", "-#"]
+indent = { tab-width = 2, unit = "  " }
+language-servers = ["koto-ls"]
+
+[[grammar]]
+name = "koto"
+source = { git = "https://github.com/koto-lang/tree-sitter-koto", rev = "b420f7922d0d74905fd0d771e5b83be9ee8a8a9a" }
+
+[[language]]
+name = "gpr"
+scope = "source.gpr"
+injection-regex = "gpr"
+file-types = ["gpr"]
+roots = ["alire.toml"]
+comment-token = "--"
+indent = { tab-width = 3, unit = "   " }
+language-servers = ["ada-gpr-language-server"]
+
+[[grammar]]
+name = "gpr"
+source = { git = "https://github.com/brownts/tree-sitter-gpr", rev = "cea857d3c18d1385d1f5b66cd09ea1e44173945c" }
+
+[[language]]
+name = "vento"
+scope = "text.html.vto"
+file-types = ["vto"]
+block-comment-tokens = { start = "{{#", end = "#}}" }
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "vento"
+source = { git = "https://github.com/ventojs/tree-sitter-vento", rev = "3b32474bc29584ea214e4e84b47102408263fe0e" }
+
+[[language]]
+name = "nginx"
+scope = "source.nginx"
+injection-regex = "nginx"
+file-types = [
+  { glob = "sites-available/*.conf" },
+  { glob = "sites-enabled/*.conf" },
+  { glob = "nginx.conf" },
+  { glob = "conf.d/*.conf" } 
+]
+roots = ["nginx.conf"]
+comment-token = "#"
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "nginx"
+source = { git = "https://gitlab.com/joncoole/tree-sitter-nginx", rev = "b4b61db443602b69410ab469c122c01b1e685aa0" }
+
+[[language]]
+name = "codeql"
+scope = "source.ql"
+file-types = ["ql", "qll"]
+comment-token = "//"
+block-comment-tokens = { start = "/*", end = "*/" }
+indent = { tab-width = 2, unit = "  " }
+injection-regex = "codeql"
+grammar = "ql"
+language-servers = ["codeql"]
+
+[[grammar]]
+name = "ql"
+source = { git = "https://github.com/tree-sitter/tree-sitter-ql", rev = "1fd627a4e8bff8c24c11987474bd33112bead857" }
+
+[[language]]
+name = "gren"
+scope = "source.gren"
+injection-regex = "gren"
+file-types = ["gren"]
+roots = ["gren.json"]
+comment-tokens = "--"
+block-comment-tokens = { start = "{-", end = "-}" }
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "gren"
+source = { git = "https://github.com/MaeBrooks/tree-sitter-gren", rev = "76554f4f2339f5a24eed19c58f2079b51c694152" }
+
+[[language]]
+name = "ghostty"
+scope = "source.ghostty"
+file-types = [{ glob = "ghostty/config" }]
+comment-tokens = "#"
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "ghostty"
+source = { git = "https://github.com/bezhermoso/tree-sitter-ghostty" , rev = "8438a93b44367e962b2ea3a3b6511885bebd196a" }
+
+[[language]]
+name = "tera"
+scope = "source.tera"
+file-types = ["tera"]
+block-comment-tokens = [
+  { start = "{#", end = "#}" },
+  { start = "{#-", end = "-#}" },
+  { start = "{#", end = "-#}" },
+  { start = "{#-", end = "#}" },
+]
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "tera"
+source = { git = "https://github.com/uncenter/tree-sitter-tera", rev = "e8d679a29c03e64656463a892a30da626e19ed8e" }
+
+[[language]]
+name = "fga"
+scope = "source.fga"
+injection-regex = "fga"
+file-types = ["fga"]
+comment-token = "#"
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "fga"
+source = { git = "https://github.com/matoous/tree-sitter-fga", rev = "5005e8dd976e1f67beb3d23204580eb6f8b4c965" }
+
+[[language]]
+name = "csv"
+file-types = ["csv"]
+scope = "source.csv"
+
+[[grammar]]
+name = "csv"
+source = { git = "https://github.com/weartist/rainbow-csv-tree-sitter", rev = "d3dbf916446131417e4c2ea9eb8591b23b466d27" }
+
+[[language]]
+name = "yara"
+scope = "source.yara"
+file-types = ["yara", "yar"]
+indent = { tab-width = 2, unit = "  " }
+comment-tokens = "//"
+block-comment-tokens = { start = "/*", end = "*/"}
+language-servers = [ "yls" ]
+
+[[grammar]]
+name = "yara"
+source = { git = "https://github.com/egibs/tree-sitter-yara", rev = "eb3ede203275c38000177f72ec0f9965312806ef" }
diff --git a/runtime/queries/_jsx/highlights.scm b/runtime/queries/_jsx/highlights.scm
index 2a696641c..70a03091e 100644
--- a/runtime/queries/_jsx/highlights.scm
+++ b/runtime/queries/_jsx/highlights.scm
@@ -1,43 +1,43 @@
+; Punctuation
+; -----------
+
+; Handle attribute delimiter (<Component color="red"/>)
+(jsx_attribute "=" @punctuation.delimiter)
+
+; <Component>
+(jsx_opening_element ["<" ">"] @punctuation.bracket)
+
+; </Component>
+(jsx_closing_element ["</" ">"] @punctuation.bracket)
+
+; <Component />
+(jsx_self_closing_element ["<" "/>"] @punctuation.bracket)
+
+; Attributes
+; ----------
+
+(jsx_attribute (property_identifier) @attribute)
+
 ; Opening elements
 ; ----------------
 
+(jsx_opening_element (identifier) @tag)
+
 (jsx_opening_element ((identifier) @constructor
  (#match? @constructor "^[A-Z]")))
 
-(jsx_opening_element (identifier) @tag)
-
 ; Closing elements
 ; ----------------
 
+(jsx_closing_element (identifier) @tag)
+
 (jsx_closing_element ((identifier) @constructor
  (#match? @constructor "^[A-Z]")))
 
-(jsx_closing_element (identifier) @tag)
-
 ; Self-closing elements
 ; ---------------------
 
-(jsx_self_closing_element ((identifier) @constructor
- (#match? @constructor "^[A-Z]")))
-
 (jsx_self_closing_element (identifier) @tag)
 
-; Attributes
-; ----------
-
-(jsx_attribute (property_identifier) @variable.other.member)
-
-; Punctuation
-; -----------
-
-; Handle attribute delimiter (<Component color="red"/>)
-(jsx_attribute "=" @punctuation.delimiter)
-
-; <Component>
-(jsx_opening_element ["<" ">"] @punctuation.bracket)
-
-; </Component>
-(jsx_closing_element ["</" ">"] @punctuation.bracket)
-
-; <Component />
-(jsx_self_closing_element ["<" "/>"] @punctuation.bracket)
+(jsx_self_closing_element ((identifier) @constructor
+ (#match? @constructor "^[A-Z]")))
diff --git a/runtime/queries/_typescript/highlights.scm b/runtime/queries/_typescript/highlights.scm
index 45c98ba82..a5bfd9ed0 100644
--- a/runtime/queries/_typescript/highlights.scm
+++ b/runtime/queries/_typescript/highlights.scm
@@ -107,9 +107,9 @@
 ; Types
 ; -----
 
+(type_identifier) @type
 (type_parameter
   name: (type_identifier) @type.parameter)
-(type_identifier) @type
 (predefined_type) @type.builtin
 
 ; Type arguments and parameters
@@ -133,10 +133,3 @@
 [
   (template_literal_type)
 ] @string
-
-; Tokens
-; ------
-
-(template_type
-  "${" @punctuation.special
-  "}" @punctuation.special) @embedded
diff --git a/runtime/queries/_typescript/locals.scm b/runtime/queries/_typescript/locals.scm
index 041ad59d1..35e3c0db7 100644
--- a/runtime/queries/_typescript/locals.scm
+++ b/runtime/queries/_typescript/locals.scm
@@ -23,7 +23,7 @@
   (identifier) @local.definition)
 
 ; (i?: t)
-; (i?: t = 1) // Invalid but still posible to hihglight.
+; (i?: t = 1) // Invalid but still possible to highlight.
 (optional_parameter
   (identifier) @local.definition)
 
diff --git a/runtime/queries/ada/highlights.scm b/runtime/queries/ada/highlights.scm
index 643fbd664..38e67d823 100644
--- a/runtime/queries/ada/highlights.scm
+++ b/runtime/queries/ada/highlights.scm
@@ -1,9 +1,3 @@
-;; highlight queries.
-;; See the syntax at https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries
-;; See also https://github.com/nvim-treesitter/nvim-treesitter/blob/master/CONTRIBUTING.md#parser-configurations
-;; for a list of recommended @ tags, though not all of them have matching
-;; highlights in neovim.
-
 [
    "abort"
    "abs"
diff --git a/runtime/queries/ada/locals.scm b/runtime/queries/ada/locals.scm
index e532a2f17..83d62a437 100644
--- a/runtime/queries/ada/locals.scm
+++ b/runtime/queries/ada/locals.scm
@@ -1,6 +1,3 @@
-;;  Better highlighting by referencing to the definition, for variable references.
-;;  See https://tree-sitter.github.io/tree-sitter/syntax-highlighting#local-variables
-
 (compilation) @local.scope
 (package_declaration) @local.scope
 (package_body) @local.scope
diff --git a/runtime/queries/ada/textobjects.scm b/runtime/queries/ada/textobjects.scm
index 284b41256..433b582af 100644
--- a/runtime/queries/ada/textobjects.scm
+++ b/runtime/queries/ada/textobjects.scm
@@ -8,7 +8,7 @@
 ;; For navigations using textobjects, check link below:
 ;; https://docs.helix-editor.com/master/usage.html#navigating-using-tree-sitter-textobjects
 ;;
-;; For Textobject queries explaination, check out link below:
+;; For Textobject queries explanation, check out link below:
 ;; https://docs.helix-editor.com/master/guides/textobject.html
 
 (subprogram_body) @function.around
diff --git a/runtime/queries/adl/textobjects.scm b/runtime/queries/adl/textobjects.scm
index 36e39a2d4..dee01a40c 100644
--- a/runtime/queries/adl/textobjects.scm
+++ b/runtime/queries/adl/textobjects.scm
@@ -1 +1 @@
-(struct (_) @function.inside) @funtion.around
+(struct (_) @function.inside) @function.around
diff --git a/runtime/queries/amber/highlights.scm b/runtime/queries/amber/highlights.scm
new file mode 100644
index 000000000..39f965b58
--- /dev/null
+++ b/runtime/queries/amber/highlights.scm
@@ -0,0 +1,60 @@
+(comment) @comment
+
+[
+    "if"
+    "loop"
+    "for"
+    "return"
+    "fun"
+    "else"
+    "then"
+    "break"
+    "continue"
+    "and"
+    "or"
+    "not"
+    "let"
+    "pub"
+    "main"
+    "echo"
+    "exit"
+    "fun"
+    "import"
+    "from"
+    "as"
+    "in"
+    "fail"
+    "failed"
+    "silent"
+    "nameof"
+    "is"
+    "unsafe"
+    "trust"
+] @keyword
+
+; Literals
+(boolean) @constant.builtin.boolean
+(number) @constant.numeric
+(null) @constant.numeric
+(string) @string
+(status) @keyword
+(command) @string
+(handler) @keyword
+(block) @punctuation.delimiter
+(variable_init) @keyword
+(variable_assignment) @punctuation.delimiter
+(variable) @variable
+(escape_sequence) @constant.character.escape
+(type_name_symbol) @type
+(interpolation) @punctuation.delimiter
+(reference) @keyword
+(preprocessor_directive) @comment
+(shebang) @comment
+(function_definition
+    name: (variable) @function.method)
+(function_call
+    name: (variable) @function.method)
+(import_statement
+    "pub" @keyword
+    "import" @keyword
+    "from" @keyword)
diff --git a/runtime/queries/awk/highlights.scm b/runtime/queries/awk/highlights.scm
index 34d660ad5..d378f8310 100644
--- a/runtime/queries/awk/highlights.scm
+++ b/runtime/queries/awk/highlights.scm
@@ -1,7 +1,5 @@
 ; tree-sitter-awk v0.5.1
 
-; https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries
-
 ; Order matters
 
 [
@@ -109,14 +107,15 @@
 (number) @constant.numeric
 (string) @string
 
-(func_call name: (identifier) @function)
-(func_def name: (identifier) @function)
-
-(field_ref (_) @variable)
 [
   (identifier)
   (field_ref)
 ] @variable
 
+(func_call name: (identifier) @function)
+(func_def name: (identifier) @function)
+
+(field_ref (_) @variable)
+
 (ns_qualified_name "::" @operator)
 (ns_qualified_name (namespace) @namespace)
diff --git a/runtime/queries/bash/highlights.scm b/runtime/queries/bash/highlights.scm
index c3e504f32..19d3cc9f4 100644
--- a/runtime/queries/bash/highlights.scm
+++ b/runtime/queries/bash/highlights.scm
@@ -48,6 +48,9 @@
 
 (comment) @comment
 
+((word) @constant.builtin.boolean
+  (#any-of? @constant.builtin.boolean "true" "false"))
+
 (function_definition name: (word) @function)
 
 (file_descriptor) @constant.numeric.integer
@@ -56,7 +59,7 @@
   (command_substitution)
   (process_substitution)
   (expansion)
-]@embedded
+] @embedded
 
 [
   "$"
diff --git a/runtime/queries/bass/highlights.scm b/runtime/queries/bass/highlights.scm
index f8b70fc1d..e0d673503 100644
--- a/runtime/queries/bass/highlights.scm
+++ b/runtime/queries/bass/highlights.scm
@@ -38,6 +38,17 @@
 (subpath (slash) @function)
 
 
+;;; generic highlighting for all forms
+
+; first symbol in a list form is a combiner call
+(list . (symbol) @function)
+
+; highlight symbols as vars only when they're clearly vars
+(cons (symbol) @variable)
+(scope (symbol) @variable)
+(path form: (symbol) @variable)
+(symbind form: (symbol) @variable)
+
 
 ;;; specific highlighting for builtins & special forms
 
@@ -88,14 +99,3 @@
   .
   (_)
   (symbol) @function)
-
-;;; generic highlighting for all forms
-
-; first symbol in a list form is a combiner call
-(list . (symbol) @function)
-
-; highlight symbols as vars only when they're clearly vars
-(cons (symbol) @variable)
-(scope (symbol) @variable)
-(path form: (symbol) @variable)
-(symbind form: (symbol) @variable)
diff --git a/runtime/queries/bicep/highlights.scm b/runtime/queries/bicep/highlights.scm
index b6f928726..b80de7fd7 100644
--- a/runtime/queries/bicep/highlights.scm
+++ b/runtime/queries/bicep/highlights.scm
@@ -1,73 +1,232 @@
-; Keywords
+; Includes
+[
+  "import"
+  "provider"
+  "with"
+  "as"
+  "from"
+] @keyword.control.import
+
+; Namespaces
+(module_declaration
+  (identifier) @namespace)
+
+; Builtins
+(primitive_type) @type.builtin
+
+((member_expression
+  object: (identifier) @type.builtin)
+  (#eq? @type.builtin "sys"))
+
+; Functions
+(call_expression
+  function: (identifier) @function)
+
+(user_defined_function
+  name: (identifier) @function)
+
+; Properties
+(object_property
+  (identifier) @function.method
+  ":" @punctuation.delimiter
+  (_))
+
+(object_property
+  (compatible_identifier) @function.method
+  ":" @punctuation.delimiter
+  (_))
+
+(property_identifier) @function.method
+
+; Attributes
+(decorator
+  "@" @attribute)
+
+(decorator
+  (call_expression
+    (identifier) @attribute))
+
+(decorator
+  (call_expression
+    (member_expression
+      object: (identifier) @attribute
+      property: (property_identifier) @attribute)))
+
+; Types
+(type_declaration
+  (identifier) @type)
 
+(type_declaration
+  (identifier)
+  "="
+  (identifier) @type)
+
+(type
+  (identifier) @type)
+
+(resource_declaration
+  (identifier) @type)
+
+(resource_expression
+  (identifier) @type)
+
+; Parameters
+(parameter_declaration
+  (identifier) @variable.parameter
+  (_))
+
+(call_expression
+  function: (_)
+  (arguments
+    (identifier) @variable.parameter))
+
+(call_expression
+  function: (_)
+  (arguments
+    (member_expression
+      object: (identifier) @variable.parameter)))
+
+(parameter
+  .
+  (identifier) @variable.parameter)
+
+; Variables
+(variable_declaration
+  (identifier) @variable
+  (_))
+
+(metadata_declaration
+  (identifier) @variable
+  (_))
+
+(output_declaration
+  (identifier) @variable
+  (_))
+
+(object_property
+  (_)
+  ":"
+  (identifier) @variable)
+
+(for_statement
+  "for"
+  (for_loop_parameters
+    (loop_variable) @variable
+    (loop_enumerator) @variable))
+
+; Conditionals
+"if" @keyword.conditional
+
+(ternary_expression
+  "?" @keyword.control.conditional
+  ":" @keyword.control.conditional)
+
+; Loops
+(for_statement
+  "for" @keyword.control.repeat
+  "in"
+  ":" @punctuation.delimiter)
+
+; Keywords
 [
   "module"
-  "var"
+  "metadata"
+  "output"
   "param"
-  "import"
   "resource"
   "existing"
-  "if"
   "targetScope"
-  "output"
+  "type"
+  "var"
+  "using"
+  "test"
 ] @keyword
 
-; Functions
+"func" @keyword.function
 
-(decorator) @function.builtin
+"assert" @keyword.control.exception
 
-(functionCall) @function
+; Operators
+[
+  "+"
+  "-"
+  "*"
+  "/"
+  "%"
+  "||"
+  "&&"
+  "|"
+  "=="
+  "!="
+  "=~"
+  "!~"
+  ">"
+  ">="
+  "<="
+  "<"
+  "??"
+  "="
+  "!"
+  ".?"
+] @operator
 
-(functionCall
-  (functionArgument
-    (variableAccess) @variable))
+(subscript_expression
+  "?" @operator)
 
-; Literals/Types
+(nullable_type
+  "?" @operator)
 
-[
-  "("
-  ")"
-  "["
-  "]"
-  "{"
-  "}"
-] @punctuation.bracket
+"in" @keyword.operator
 
-(resourceDeclaration
-  (string
-    (stringLiteral) @string.special))
+; Literals
+(string) @string
 
-(moduleDeclaration
-  (string
-    (stringLiteral) @string.special))
+(escape_sequence) @constant.character
 
-[
-  (string)
-  (stringLiteral)
-] @string
+(number) @constant.number
 
-(nullLiteral) @keyword
-(booleanLiteral) @constant.builtin.boolean
-(integerLiteral) @constant.numeric.integer
-(comment) @comment
+(boolean) @constant.builtin.boolean
 
-(string
-  (variableAccess
-    (identifier) @variable))
+(null) @constant.builtin
 
-(type) @type
+; Misc
+(compatible_identifier
+  "?" @punctuation.special)
 
-; Variables
+(nullable_return_type) @punctuation.special
+
+[
+  "{"
+  "}"
+] @punctuation.bracket
 
-(localVariable) @variable
+[
+  "["
+  "]"
+] @punctuation.bracket
 
-; Statements
+[
+  "("
+  ")"
+] @punctuation.bracket
 
-(object
-  (objectProperty
-    (identifier) @identifier))
+[
+  "."
+  ":"
+  "::"
+  "=>"
+] @punctuation.delimiter
 
-(propertyAccess
-  (identifier) @identifier)
-  
-(ifCondition) @keyword.control.conditional
+; Interpolation
+(interpolation
+  "${" @punctuation.special
+  "}" @punctuation.special)
+
+(interpolation
+  (identifier) @variable)
+
+; Comments
+[
+  (comment)
+  (diagnostic_comment)
+] @comment
diff --git a/runtime/queries/bitbake/highlights.scm b/runtime/queries/bitbake/highlights.scm
index 6e8ab0cf3..7b37a79b1 100644
--- a/runtime/queries/bitbake/highlights.scm
+++ b/runtime/queries/bitbake/highlights.scm
@@ -23,8 +23,8 @@
 
 ] @operator
 
-(variable_expansion [ "${" "}" ] @punctuation.special)
 [ "(" ")" "{" "}" "[" "]" ] @punctuation.bracket
+(variable_expansion [ "${" "}" ] @punctuation.special)
 
 [
   "noexec"
diff --git a/runtime/queries/c/highlights.scm b/runtime/queries/c/highlights.scm
index 07915f4e3..e48e45ab5 100644
--- a/runtime/queries/c/highlights.scm
+++ b/runtime/queries/c/highlights.scm
@@ -1,3 +1,9 @@
+
+(identifier) @variable
+
+((identifier) @constant
+  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
+
 "sizeof" @keyword
 
 [
@@ -109,6 +115,12 @@
 (char_literal) @constant.character
 (escape_sequence) @constant.character.escape
 
+(field_identifier) @variable.other.member
+(statement_identifier) @label
+(type_identifier) @type
+(primitive_type) @type.builtin
+(sized_type_specifier) @type.builtin
+
 (call_expression
   function: (identifier) @function)
 (call_expression
@@ -128,15 +140,4 @@
 (attribute
   name: (identifier) @attribute)
 
-(field_identifier) @variable.other.member
-(statement_identifier) @label
-(type_identifier) @type
-(primitive_type) @type.builtin
-(sized_type_specifier) @type.builtin
-
-((identifier) @constant
-  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
-
-(identifier) @variable
-
 (comment) @comment
diff --git a/runtime/queries/cairo/highlights.scm b/runtime/queries/cairo/highlights.scm
index 16918c141..fb62c5053 100644
--- a/runtime/queries/cairo/highlights.scm
+++ b/runtime/queries/cairo/highlights.scm
@@ -71,6 +71,8 @@
     "<"
     ">"
   ] @punctuation.bracket)
+(closure_parameters
+  "|" @punctuation.bracket)
 
 ; ---
 ; Variables
@@ -92,6 +94,8 @@
 (parameter
 	pattern: (identifier) @variable.parameter)
 
+(closure_parameters
+	(identifier) @variable.parameter)
 ; -------
 ; Keywords
 ; -------
diff --git a/runtime/queries/cairo/indents.scm b/runtime/queries/cairo/indents.scm
index b20317ab0..8c6abd10a 100644
--- a/runtime/queries/cairo/indents.scm
+++ b/runtime/queries/cairo/indents.scm
@@ -115,6 +115,16 @@
   (#not-same-line? @expr-start @pattern-guard)
 ) @indent
 
+; Align closure parameters if they span more than one line
+(closure_parameters
+  "|"
+  .
+  (_) @anchor
+  (_) @expr-end
+  .
+  (#not-same-line? @anchor @expr-end)
+) @align
+
 (for_expression
   "in" @in
   .
diff --git a/runtime/queries/cairo/locals.scm b/runtime/queries/cairo/locals.scm
index 35acb55c6..68c41a46b 100644
--- a/runtime/queries/cairo/locals.scm
+++ b/runtime/queries/cairo/locals.scm
@@ -7,6 +7,7 @@
   (type_item)
   (trait_item)
   (impl_item)
+  (closure_expression)
   (block)
 ] @local.scope
 
@@ -20,6 +21,8 @@
 (constrained_type_parameter
   left: (type_identifier) @local.definition)
 
+(closure_parameters (identifier) @local.definition)
+
 ; References
 (identifier) @local.reference
 (type_identifier) @local.reference
diff --git a/runtime/queries/cairo/textobjects.scm b/runtime/queries/cairo/textobjects.scm
index 4031873de..4b53097be 100644
--- a/runtime/queries/cairo/textobjects.scm
+++ b/runtime/queries/cairo/textobjects.scm
@@ -1,6 +1,9 @@
 (function_item
   body: (_) @function.inside) @function.around
 
+(closure_expression
+  body: (_) @function.inside) @function.around
+
 (struct_item
   body: (_) @class.inside) @class.around
 
@@ -16,6 +19,9 @@
 (parameters 
   ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
 
+(closure_parameters
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
 (type_parameters
   ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
 
@@ -57,7 +63,7 @@
 (tuple_pattern
   (_) @entry.around)
 
-; Commonly used vec macro intializer is special cased
+; Commonly used vec macro initializer is special cased
 (macro_invocation
   (identifier) @_id (token_tree (_) @entry.around)
   (#eq? @_id "array"))
diff --git a/runtime/queries/capnp/highlights.scm b/runtime/queries/capnp/highlights.scm
index 27ddf8e2d..34b023be0 100644
--- a/runtime/queries/capnp/highlights.scm
+++ b/runtime/queries/capnp/highlights.scm
@@ -1,7 +1,9 @@
 ; Preproc
 
-(unique_id) @keyword.directive
-(top_level_annotation_body) @keyword.directive
+[
+  (unique_id)
+  (top_level_annotation_body)
+] @keyword.directive
 
 ; Includes
 
@@ -9,6 +11,7 @@
   "import"
   "$import"
   "embed"
+  "using"
 ] @keyword.control.import
 
 (import_path) @string
@@ -84,10 +87,10 @@
   "union"
 ] @keyword.storage.type
 
+"extends" @keyword
+
 [
-  "extends"
   "namespace"
-  "using"
   (annotation_target)
 ] @special
 
diff --git a/runtime/queries/cel/highlights.scm b/runtime/queries/cel/highlights.scm
index ab3bae5a5..737707522 100644
--- a/runtime/queries/cel/highlights.scm
+++ b/runtime/queries/cel/highlights.scm
@@ -22,16 +22,10 @@
 "in"
 ] @keyword
 
-; Function calls
-
-(call_expression
-  function: (identifier) @function)
-
-(member_call_expression
-  function: (identifier) @function)
-
 ; Identifiers
 
+(identifier) @variable.other.member
+
 (select_expression
   operand: (identifier) @type)
 
@@ -39,7 +33,13 @@
   operand: (select_expression
     member: (identifier) @type))
 
-(identifier) @variable.other.member
+; Function calls
+
+(call_expression
+  function: (identifier) @function)
+
+(member_call_expression
+  function: (identifier) @function)
 
 ; Literals
 
diff --git a/runtime/queries/circom/highlights.scm b/runtime/queries/circom/highlights.scm
new file mode 100644
index 000000000..774e15169
--- /dev/null
+++ b/runtime/queries/circom/highlights.scm
@@ -0,0 +1,142 @@
+; identifiers
+; -----------
+(identifier) @variable
+
+; Pragma
+; -----------
+(pragma_directive) @keyword.directive
+
+; Include
+; -----------
+(include_directive) @keyword.directive
+
+; Literals
+; --------
+(string) @string
+(int_literal) @constant.numeric.integer
+(comment) @comment
+
+; Definitions
+; -----------
+(function_definition
+  name:  (identifier) @keyword.function)
+
+(template_definition
+  name:  (identifier) @keyword.function)
+
+; Use constructor coloring for special functions
+(main_component_definition) @constructor
+
+; Invocations
+(call_expression . (identifier) @function)
+
+; Function parameters
+(parameter name: (identifier) @variable.parameter)
+
+; Members
+(member_expression property: (property_identifier) @variable.other.member)
+
+; Tokens
+; -------
+
+; Keywords
+[
+ "signal"
+ "var"
+ "component"
+] @keyword.storage.type
+
+[  "include" ] @keyword.control.import
+
+[
+ "public"
+ "input"
+ "output"
+ ] @keyword.storage.modifier
+
+[
+ "for"
+ "while"
+] @keyword.control.repeat
+
+[
+ "if"
+ "else"
+] @keyword.control.conditional
+
+[
+ "return"
+] @keyword.control.return
+
+[
+  "function"
+  "template"
+] @keyword.function
+
+; Punctuation
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+] @punctuation.bracket
+
+[
+  "."
+  ","
+  ";"
+] @punctuation.delimiter
+
+; Operators
+; https://docs.circom.io/circom-language/basic-operators
+[
+  "="
+  "?"
+  "&&"
+  "||"
+  "!"
+  "<" 
+  ">" 
+  "<=" 
+  ">=" 
+  "==" 
+  "!=" 
+  "+"
+  "-"
+  "*"
+  "**"
+  "/"
+  "\\"
+  "%"
+  "+="
+  "-="
+  "*="
+  "**="
+  "/="
+  "\\="
+  "%="
+  "++"
+  "--"
+  "&"
+  "|"
+  "~"
+  "^"
+  ">>"
+  "<<"
+  "&="
+  "|="
+  ; "\~=" ; bug, uncomment and circom will not highlight
+  "^="
+  ">>="
+  "<<="
+] @operator
+
+[
+  "<=="
+  "==>"
+  "<--"
+  "-->"
+  "==="
+] @operator
diff --git a/runtime/queries/circom/locals.scm b/runtime/queries/circom/locals.scm
new file mode 100644
index 000000000..e0ea12de0
--- /dev/null
+++ b/runtime/queries/circom/locals.scm
@@ -0,0 +1,9 @@
+(function_definition) @local.scope
+(template_definition) @local.scope
+(main_component_definition) @local.scope
+(block_statement) @local.scope
+
+(parameter name: (identifier) @local.definition) @local.definition
+
+
+(identifier) @local.reference
\ No newline at end of file
diff --git a/runtime/queries/clojure/highlights.scm b/runtime/queries/clojure/highlights.scm
index 1441ea97d..8155e6e3b 100644
--- a/runtime/queries/clojure/highlights.scm
+++ b/runtime/queries/clojure/highlights.scm
@@ -10,6 +10,14 @@
 
 (comment) @comment
 
+;; other symbols
+(sym_lit) @variable
+
+;; other calls
+(list_lit
+ .
+ (sym_lit) @function)
+
 ;; metadata experiment
 (meta_lit
  marker: "^" @punctuation)
@@ -61,20 +69,12 @@
 ((sym_lit) @operator
  (#match? @operator "^%"))
 
-;; other calls
-(list_lit
- .
- (sym_lit) @function)
-
 ;; interop-ish
 (list_lit
  .
  (sym_lit) @function.method
  (#match? @function.method "^\\."))
 
-;; other symbols
-(sym_lit) @variable
-
 ;; quote
 (quoting_lit) @constant.character.escape
 
diff --git a/runtime/queries/codeql/highlights.scm b/runtime/queries/codeql/highlights.scm
new file mode 100644
index 000000000..aed7b5382
--- /dev/null
+++ b/runtime/queries/codeql/highlights.scm
@@ -0,0 +1,104 @@
+[
+  "and"
+  "any"
+  "as"
+  "asc"
+  "avg"
+  "by"
+  "class"
+  "concat"
+  "count"
+  "desc"
+  "else"
+  "exists"
+  "extends"
+  "forall"
+  "forex"
+  "from"
+  "if"
+  "implements"
+  "implies"
+  "import"
+  "in"
+  "instanceof"
+  "max"
+  "min"
+  "module"
+  "newtype"
+  "not"
+  "or"
+  "order"
+  "rank"
+  "select"
+  "strictconcat"
+  "strictcount"
+  "strictsum"
+  "sum"
+  "then"
+  "where"
+
+  (false)
+  (predicate)
+  (result)
+  (specialId)
+  (super)
+  (this)
+  (true)
+] @keyword
+
+[
+  "boolean"
+  "float"
+  "int"
+  "date"
+  "string"
+] @type.builtin
+
+(annotName) @attribute
+
+[
+  "<"
+  "<="
+  "="
+  ">"
+  ">="
+  "-"
+  "!="
+  "/"
+  "*"
+  "%"
+  "+"
+  "::"
+] @operator
+
+[
+  "("
+  ")"
+  "{"
+  "}"
+  "["
+  "]"
+] @punctuation.bracket
+
+[
+  ","
+  "|"
+] @punctuation.delimiter
+
+(className) @type
+
+(varName) @variable
+
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+
+(string) @string
+
+(aritylessPredicateExpr (literalId) @function)
+(predicateName) @function
+
+[
+  (line_comment)
+  (block_comment)
+  (qldoc)
+] @comment
diff --git a/runtime/queries/codeql/textobjects.scm b/runtime/queries/codeql/textobjects.scm
new file mode 100644
index 000000000..8ca02e3ce
--- /dev/null
+++ b/runtime/queries/codeql/textobjects.scm
@@ -0,0 +1,16 @@
+(qldoc) @comment.around
+(block_comment) @comment.around
+(line_comment) @comment.inside
+(line_comment)+ @comment.around
+
+(classlessPredicate
+  ((varDecl) @parameter.inside . ","?) @parameter.around
+  (body "{" (_)* @function.inside "}")) @function.around
+(memberPredicate
+  ((varDecl) @parameter.inside . ","?) @parameter.around
+  (body "{" (_)* @function.inside "}")) @function.around
+
+(dataclass
+  ("{" (_)* @class.inside "}")?) @class.around
+(datatype) @class.around
+(datatypeBranch) @class.around
diff --git a/runtime/queries/comment/highlights.scm b/runtime/queries/comment/highlights.scm
index e0916cece..56c1fd7d9 100644
--- a/runtime/queries/comment/highlights.scm
+++ b/runtime/queries/comment/highlights.scm
@@ -1,34 +1,34 @@
+(tag
+ (name) @ui.text
+ (user)? @constant)
+
 ; Hint level tags
 ((tag (name) @hint)
- (#match? @hint "^(HINT|MARK|PASSED|STUB|MOCK)$"))
+ (#any-of? @hint "HINT" "MARK" "PASSED" "STUB" "MOCK"))
 
 ("text" @hint
- (#match? @hint "^(HINT|MARK|PASSED|STUB|MOCK)$"))
+ (#any-of? @hint "HINT" "MARK" "PASSED" "STUB" "MOCK"))
 
 ; Info level tags
 ((tag (name) @info)
- (#match? @info "^(INFO|NOTE|TODO|PERF|OPTIMIZE|PERFORMANCE|QUESTION|ASK)$"))
+ (#any-of? @info "INFO" "NOTE" "TODO" "PERF" "OPTIMIZE" "PERFORMANCE" "QUESTION" "ASK"))
 
 ("text" @info
- (#match? @info "^(INFO|NOTE|TODO|PERF|OPTIMIZE|PERFORMANCE|QUESTION|ASK)$"))
+ (#any-of? @info "INFO" "NOTE" "TODO" "PERF" "OPTIMIZE" "PERFORMANCE" "QUESTION" "ASK"))
 
 ; Warning level tags
 ((tag (name) @warning)
- (#match? @warning "^(HACK|WARN|WARNING|TEST|TEMP)$"))
+ (#any-of? @warning "HACK" "WARN" "WARNING" "TEST" "TEMP"))
 
 ("text" @warning
- (#match? @warning "^(HACK|WARN|WARNING|TEST|TEMP)$"))
+ (#any-of? @warning "HACK" "WARN" "WARNING" "TEST" "TEMP"))
 
 ; Error level tags
 ((tag (name) @error)
- (#match? @error "^(BUG|FIXME|ISSUE|XXX|FIX|SAFETY|FIXIT|FAILED|DEBUG)$"))
+ (#any-of? @error "BUG" "FIXME" "ISSUE" "XXX" "FIX" "SAFETY" "FIXIT" "FAILED" "DEBUG" "INVARIANT" "COMPLIANCE"))
 
 ("text" @error
- (#match? @error "^(BUG|FIXME|ISSUE|XXX|FIX|SAFETY|FIXIT|FAILED|DEBUG)$"))
-
-(tag
- (name) @ui.text
- (user)? @constant)
+ (#any-of? @error "BUG" "FIXME" "ISSUE" "XXX" "FIX" "SAFETY" "FIXIT" "FAILED" "DEBUG" "INVARIANT" "COMPLIANCE"))
 
 ; Issue number (#123)
 ("text" @constant.numeric
diff --git a/runtime/queries/cpon/highlights.scm b/runtime/queries/cpon/highlights.scm
index f85caf469..039284e70 100644
--- a/runtime/queries/cpon/highlights.scm
+++ b/runtime/queries/cpon/highlights.scm
@@ -13,7 +13,6 @@
 
 (string) @string
 (escape_sequence) @constant.character.escape
-(ERROR) @error
 
 "," @punctuation.delimiter
 [
diff --git a/runtime/queries/cpp/highlights.scm b/runtime/queries/cpp/highlights.scm
index c1d14a0b1..291163d37 100644
--- a/runtime/queries/cpp/highlights.scm
+++ b/runtime/queries/cpp/highlights.scm
@@ -1,3 +1,26 @@
+; inherits: c
+
+; Constants
+
+(this) @variable.builtin
+(nullptr) @constant.builtin
+
+; Types
+
+(using_declaration ("using" "namespace" (identifier) @namespace))
+(using_declaration ("using" "namespace" (qualified_identifier name: (identifier) @namespace)))
+(namespace_definition name: (namespace_identifier) @namespace)
+(namespace_identifier) @namespace
+
+(qualified_identifier name: (identifier) @type.enum.variant)
+
+(auto) @type
+"decltype" @type
+
+(ref_qualifier ["&" "&&"] @type.builtin)
+(reference_declarator ["&" "&&"] @type.builtin)
+(abstract_reference_declarator ["&" "&&"] @type.builtin)
+
 ; Functions
 
 ; These casts are parsed as function calls, but are not.
@@ -28,27 +51,6 @@
 (function_declarator
   declarator: (field_identifier) @function)
 
-; Types
-
-(using_declaration ("using" "namespace" (identifier) @namespace))
-(using_declaration ("using" "namespace" (qualified_identifier name: (identifier) @namespace)))
-(namespace_definition name: (namespace_identifier) @namespace)
-(namespace_identifier) @namespace
-
-(qualified_identifier name: (identifier) @type.enum.variant)
-
-(auto) @type
-"decltype" @type
-
-(ref_qualifier ["&" "&&"] @type.builtin)
-(reference_declarator ["&" "&&"] @type.builtin)
-(abstract_reference_declarator ["&" "&&"] @type.builtin)
-
-; Constants
-
-(this) @variable.builtin
-(nullptr) @constant.builtin
-
 ; Parameters
 
 (parameter_declaration
@@ -132,5 +134,3 @@
 ; Strings
 
 (raw_string_literal) @string
-
-; inherits: c
diff --git a/runtime/queries/css/highlights.scm b/runtime/queries/css/highlights.scm
index b5262e8f6..ee85d1414 100644
--- a/runtime/queries/css/highlights.scm
+++ b/runtime/queries/css/highlights.scm
@@ -28,6 +28,9 @@
  "or"
 ] @keyword.operator
 
+(property_name) @variable.other.member
+(plain_value) @constant
+
 ((property_name) @variable
  (#match? @variable "^--"))
 ((plain_value) @variable
@@ -39,7 +42,6 @@
 (function_name) @function
 (id_name) @label
 (namespace_name) @namespace
-(property_name) @variable.other.member
 
 [
  "@charset"
@@ -81,5 +83,3 @@
  ":"
  "::"
 ] @punctuation.delimiter
-
-(plain_value) @constant
diff --git a/runtime/queries/csv/highlights.scm b/runtime/queries/csv/highlights.scm
new file mode 100644
index 000000000..b4743d799
--- /dev/null
+++ b/runtime/queries/csv/highlights.scm
@@ -0,0 +1,14 @@
+(first)@type
+(second)@function
+(third)@constant
+(fourth)@operator
+(fifth)@type
+(sixth)@function
+(seventh)@constant
+
+[
+  ";"
+  ","
+  "|"
+] @punctuation.delimiter
+
diff --git a/runtime/queries/cue/highlights.scm b/runtime/queries/cue/highlights.scm
index aef016e8b..4168036b5 100644
--- a/runtime/queries/cue/highlights.scm
+++ b/runtime/queries/cue/highlights.scm
@@ -1,12 +1,46 @@
-(package_clause "package" @keyword.control.import)
+; Includes
+[
+  "package"
+  "import"
+] @keyword.control.import
 
-(package_identifier) @variable
+; Namespaces
+(package_identifier) @namespace
 
-(import_declaration "import" @keyword.control.import)
+(import_spec
+  [
+    "."
+    "_"
+  ] @punctuation.special)
 
 [
-  "!"
+  (attr_path)
+  (package_path)
+] @string.special.url ; In attributes
+
+; Attributes
+(attribute) @attribute
+
+; Conditionals
+"if" @keyword.control.conditional
+
+; Repeats
+"for" @keyword.control.repeat
+
+(for_clause
+  "_" @punctuation.special)
+
+; Keywords
+"let" @keyword
+
+"in" @keyword.operator
+
+; Operators
+[
+  "+"
+  "-"
   "*"
+  "/"
   "|"
   "&"
   "||"
@@ -19,92 +53,103 @@
   ">="
   "=~"
   "!~"
-  "+"
-  "-"
-  "*"
-  "/"
+  "!"
+  "="
 ] @operator
 
-(unary_expression "*" @operator.default)
-
-(unary_expression "=~" @operator.regexp)
-
-(unary_expression "!~" @operator.regexp)
-
-(binary_expression _ "&" @operator.unify _)
-
-(binary_expression _ "|" @operator.disjunct _)
+; Fields & Properties
+(field
+  (label
+    (identifier) @variable.other.member))
 
-(builtin) @function.builtin
+(selector_expression
+  (_)
+  (identifier) @variable.other.member)
 
-(qualified_identifier) @function.builtin
+; Functions
+(call_expression
+  function: (identifier) @function)
 
-(let_clause "let" @keyword.storage.type)
+(call_expression
+  function: (selector_expression
+    (_)
+    (identifier) @function))
 
-(for_clause "for" @keyword.control.repeat)
-(for_clause "in" @keyword.control.repeat)
+(call_expression
+  function: (builtin_function) @function)
 
-(guard_clause "if" @keyword.control.conditional)
+(builtin_function) @function.builtin
 
-(comment) @comment
+; Variables
+(identifier) @variable
 
-[
-  (string_type)
-  (simple_string_lit)
-  (multiline_string_lit)
-  (bytes_type)
-  (simple_bytes_lit)
-  (multiline_bytes_lit)
-] @string
+; Types
+(primitive_type) @type.builtin
 
-[
-  (number_type)
-  (int_lit)
-  (int_type)
-  (uint_type)
-] @constant.numeric.integer
+((identifier) @type
+  (#match? @type "^_?#"))
 
 [
-  (float_lit)
-  (float_type)
-] @constant.numeric.float
-
-[
-  (bool_type)
-  (true)
-  (false)
-] @constant.builtin.boolean
-
-(null) @constant.builtin
-
-(ellipsis) @punctuation.bracket
+  (slice_type)
+  (pointer_type)
+] @type ; In attributes
 
+; Punctuation
 [
   ","
   ":"
 ] @punctuation.delimiter
 
 [
-  "("
-  ")"
-  "["
-  "]"
   "{"
   "}"
+  "["
+  "]"
+  "("
+  ")"
+  "<"
+  ">"
 ] @punctuation.bracket
 
-(interpolation "\\(" @punctuation.bracket (_) ")" @punctuation.bracket) @variable.other.member
+[
+  (ellipsis)
+  "?"
+] @punctuation.special
+
+; Literals
+(string) @string
 
-(field (label (identifier) @variable.other.member))
+[
+  (escape_char)
+  (escape_unicode)
+] @constant.character.escape
 
-(
-  (identifier) @keyword.storage.type
-  (#match? @keyword.storage.type "^#")
-)
+(number) @constant.numeric
 
-(field (label alias: (identifier) @label))
+(float) @constant.numeric.float
 
-(let_clause left: (identifier) @label)
+(si_unit
+  (float)
+  (_) @string.special.symbol)
 
+(boolean) @constant.builtin.boolean
 
-(attribute (identifier) @tag)
+[
+  (null)
+  (top)
+  (bottom)
+] @constant.builtin
+
+; Interpolations
+(interpolation
+  "\\(" @punctuation.special
+  (_)
+  ")" @punctuation.special)
+
+(interpolation
+  "\\("
+  (identifier) @variable
+  ")")
+
+; Comments
+(comment) @comment
diff --git a/runtime/queries/cylc/highlights.scm b/runtime/queries/cylc/highlights.scm
new file mode 100644
index 000000000..d28753c4e
--- /dev/null
+++ b/runtime/queries/cylc/highlights.scm
@@ -0,0 +1,98 @@
+[
+  (jinja2_expression)
+  (jinja2_statement)
+  (jinja2_comment)
+  (jinja2_shebang)
+] @special
+
+(include_statement
+  directive: _ @keyword.directive
+  path: _ @string.special.path)
+
+(comment) @comment.line
+
+(graph_section
+  name: _? @label)
+
+(task_section
+  name: (_
+    (task_name) @namespace))
+
+(top_section
+  brackets_open: _ @punctuation.bracket
+  name: _? @label
+  brackets_close: _ @punctuation.bracket)
+
+(sub_section_1
+  brackets_open: _ @punctuation.bracket
+  name: _? @label
+  brackets_close: _ @punctuation.bracket)
+
+(sub_section_2
+  brackets_open: _ @punctuation.bracket
+  name: _? @label
+  brackets_close: _ @punctuation.bracket)
+
+(runtime_section
+  brackets_open: _ @punctuation.bracket
+  name: _? @label
+  brackets_close: _ @punctuation.bracket)
+
+(graph_setting
+  key: (_) @constant.numeric.integer
+  operator: (_)? @operator)
+
+(quoted_graph_string
+  quotes_open: _ @string
+  quotes_close: _ @string)
+
+(multiline_graph_string
+  quotes_open: _ @string
+  quotes_close: _ @string)
+
+[
+  (graph_logical)
+  (graph_arrow)
+  (graph_parenthesis)
+] @operator
+
+(intercycle_annotation
+  (recurrence) @constant.numeric.integer)
+
+(graph_task
+  xtrigger: _? @operator
+  suicide: _? @operator
+  name: _ @namespace)
+
+(task_parameter
+  "<" @tag
+  name: (_)? @special
+  ","? @tag
+  "="? @tag
+  selection: (_)? @special
+  ">" @tag)
+
+(intercycle_annotation
+  "[" @tag
+  (recurrence)? @constant.numeric.integer
+  "]" @tag)
+
+(task_output
+  ":" @tag
+  (nametag) @variable.other)
+
+(task_output
+  "?"? @tag)
+
+(setting
+  key: (key) @variable
+  operator: (_)? @operator
+  value: [
+    (unquoted_string) @string
+    (quoted_string) @string
+    (multiline_string) @string
+    (boolean) @constant.builtin.boolean
+    (integer) @constant.numeric.integer
+  ]?)
+
+(datetime) @constant.numeric.float
diff --git a/runtime/queries/cylc/indents.scm b/runtime/queries/cylc/indents.scm
new file mode 100644
index 000000000..865386c78
--- /dev/null
+++ b/runtime/queries/cylc/indents.scm
@@ -0,0 +1,19 @@
+[
+  (top_section)
+  (sub_section_1)
+  (sub_section_2)
+  (graph_section)
+  (runtime_section)
+  (task_section)
+] @indent
+
+[
+  (top_section)
+  (sub_section_1)
+  (sub_section_2)
+  (graph_section)
+  (runtime_section)
+  (task_section)
+] @extend
+
+(line_continuation) @indent.always
diff --git a/runtime/queries/cylc/injections.scm b/runtime/queries/cylc/injections.scm
new file mode 100644
index 000000000..d10931f45
--- /dev/null
+++ b/runtime/queries/cylc/injections.scm
@@ -0,0 +1,20 @@
+((setting
+  key: (key) @key
+  (#match? @key "^script$|-script$|^script-")
+  value: (_
+    (string_content) @injection.content))
+  (#set! "injection.language" "bash"))
+
+; Requires no spacing around "=" in environment settings for proper highlighting.
+; Could be improved if Tree-sitter allowed to specify the target node of the injected
+; language, instead of always using the root node.
+; See this proposal:
+; https://github.com/tree-sitter/tree-sitter/issues/3625
+((task_section
+  (sub_section_2
+    name: (_) @section_name
+    (#eq? @section_name "environment")
+    (setting) @injection.content))
+  (#set! "injection.language" "bash")
+  (#set! injection.combined)
+  (#set! injection.include-children))
diff --git a/runtime/queries/cylc/textobjects.scm b/runtime/queries/cylc/textobjects.scm
new file mode 100644
index 000000000..00ed52ff8
--- /dev/null
+++ b/runtime/queries/cylc/textobjects.scm
@@ -0,0 +1,23 @@
+(comment) @comment.inside
+
+(comment)+ @comment.around
+
+(_
+  brackets_open: _
+  name: _?
+  brackets_close: _
+  _* @class.inside) @class.around
+
+(setting
+  value: _? @function.inside) @function.around
+
+(graph_setting
+  value: _? @function.inside) @function.around
+
+(graph_string_content
+  (graph_task) @entry.inside)
+
+(task_parameter
+  ((_) @parameter.inside
+    .
+    ","? @parameter.around) @parameter.around)
diff --git a/runtime/queries/d/highlights.scm b/runtime/queries/d/highlights.scm
index b5db84316..ee16c901a 100644
--- a/runtime/queries/d/highlights.scm
+++ b/runtime/queries/d/highlights.scm
@@ -217,6 +217,8 @@
     (cfloat)
 ] @warning ; these types are deprecated
 
+(identifier) @variable
+
 (label (identifier) @label)
 (goto_statement (goto) @keyword (identifier) @label)
 
@@ -224,7 +226,6 @@
 (int_literal) @constant.numeric.integer
 (float_literal) @constant.numeric.float
 (char_literal) @constant.character
-(identifier) @variable
 (at_attribute) @attribute
 
 ; everything after __EOF_ is plain text
diff --git a/runtime/queries/dart/highlights.scm b/runtime/queries/dart/highlights.scm
index dab584962..c93bf3944 100644
--- a/runtime/queries/dart/highlights.scm
+++ b/runtime/queries/dart/highlights.scm
@@ -233,7 +233,3 @@
 ; when used as an identifier:
 ((identifier) @variable.builtin
  (#match? @variable.builtin "^(abstract|as|base|covariant|deferred|dynamic|export|external|factory|Function|get|implements|import|interface|library|operator|mixin|part|sealed|set|static|typedef)$"))
-
-; Error
-(ERROR) @error
-
diff --git a/runtime/queries/devicetree/highlights.scm b/runtime/queries/devicetree/highlights.scm
index d27c79e4a..b9b29fe20 100644
--- a/runtime/queries/devicetree/highlights.scm
+++ b/runtime/queries/devicetree/highlights.scm
@@ -51,14 +51,14 @@
 
 (integer_literal) @constant.numeric.integer
 
+(identifier) @variable
+
 (call_expression
   function: (identifier) @function)
 
 (labeled_item
   label: (identifier) @label)
 
-(identifier) @variable
-
 (unit_address) @tag
 
 (reference) @constant
diff --git a/runtime/queries/djot/highlights.scm b/runtime/queries/djot/highlights.scm
new file mode 100644
index 000000000..1db4c8d7a
--- /dev/null
+++ b/runtime/queries/djot/highlights.scm
@@ -0,0 +1,286 @@
+(heading) @markup.heading
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.1
+  (#eq? @markup.heading.marker "# "))
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.2
+  (#eq? @markup.heading.marker "## "))
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.3
+  (#eq? @markup.heading.marker "### "))
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.4
+  (#eq? @markup.heading.marker "##### "))
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.5
+  (#eq? @markup.heading.marker "###### "))
+
+((heading
+  (marker) @markup.heading.marker) @markup.heading.6
+  (#eq? @markup.heading.marker "####### "))
+
+(thematic_break) @special
+
+[
+  (div_marker_begin)
+  (div_marker_end)
+] @tag
+
+[
+  (code_block)
+  (raw_block)
+  (frontmatter)
+] @markup.raw.block
+
+[
+  (code_block_marker_begin)
+  (code_block_marker_end)
+  (raw_block_marker_begin)
+  (raw_block_marker_end)
+] @punctuation.bracket
+
+(language) @type.enum.variant
+
+(inline_attribute _ @attribute)
+
+(language_marker) @punctuation.delimiter
+
+[
+  (block_quote)
+  (block_quote_marker)
+] @markup.quote
+
+(table_header) @markup.heading
+
+(table_header "|" @punctuation.special)
+
+(table_row "|" @punctuation.special)
+
+(table_separator) @punctuation.special
+
+(table_caption (marker) @punctuation.special)
+
+(table_caption) @label
+
+[
+  (list_marker_dash)
+  (list_marker_plus)
+  (list_marker_star)
+  (list_marker_definition)
+] @markup.list.unnumbered
+
+[
+  (list_marker_decimal_period)
+  (list_marker_decimal_paren)
+  (list_marker_decimal_parens)
+  (list_marker_lower_alpha_period)
+  (list_marker_lower_alpha_paren)
+  (list_marker_lower_alpha_parens)
+  (list_marker_upper_alpha_period)
+  (list_marker_upper_alpha_paren)
+  (list_marker_upper_alpha_parens)
+  (list_marker_lower_roman_period)
+  (list_marker_lower_roman_paren)
+  (list_marker_lower_roman_parens)
+  (list_marker_upper_roman_period)
+  (list_marker_upper_roman_paren)
+  (list_marker_upper_roman_parens)
+] @markup.list.numbered
+
+(list_marker_task
+  (unchecked)) @markup.list.unchecked
+
+(list_marker_task
+  (checked)) @markup.list.checked
+
+(checked
+  [
+    "x"
+    "X"
+  ] @constant.builtin.boolean) @markup.list.checked
+
+[
+  (ellipsis)
+  (en_dash)
+  (em_dash)
+  (quotation_marks)
+] @punctuation.special
+
+(list_item (term) @constructor)
+
+(quotation_marks) @markup.quote
+
+((quotation_marks) @constant.character.escape
+  (#any-of? @constant.character.escape "\\\"" "\\'"))
+
+[
+  (hard_line_break)
+  (backslash_escape)
+] @constant.character.escape
+
+(emphasis) @markup.italic
+
+(strong) @markup.bold
+
+(symbol) @string.special.symbol
+
+(delete) @markup.strikethrough
+
+(insert) @markup.italic
+
+(highlighted) @markup.bold
+
+(superscript) @string.special.superscript
+
+(subscript) @string.special.subscript
+
+[
+  (emphasis_begin)
+  (emphasis_end)
+  (strong_begin)
+  (strong_end)
+  (superscript_begin)
+  (superscript_end)
+  (subscript_begin)
+  (subscript_end)
+  (highlighted_begin)
+  (highlighted_end)
+  (insert_begin)
+  (insert_end)
+  (delete_begin)
+  (delete_end)
+  (verbatim_marker_begin)
+  (verbatim_marker_end)
+  (math_marker)
+  (math_marker_begin)
+  (math_marker_end)
+  (raw_inline_attribute)
+  (raw_inline_marker_begin)
+  (raw_inline_marker_end)
+] @punctuation.bracket
+
+(math) @markup.raw
+
+(verbatim) @markup.raw
+
+(raw_inline) @markup.raw
+
+(comment) @comment.block
+
+(inline_comment) @comment.line
+
+(span
+  [
+    "["
+    "]"
+  ] @punctuation.bracket)
+
+(inline_attribute
+  [
+    "{"
+    "}"
+  ] @punctuation.bracket)
+
+(block_attribute
+  [
+    "{"
+    "}"
+  ] @punctuation.bracket)
+
+[
+  (class)
+  (class_name)
+] @type
+
+; NOTE: Not perfectly semantically accurate, but a fair approximation.
+(identifier) @string.special.symbol
+
+(key_value "=" @operator)
+
+(key_value (key) @attribute)
+
+(key_value (value) @string)
+
+(link_text
+  [
+    "["
+    "]"
+  ] @punctuation.bracket)
+
+(autolink
+  [
+    "<"
+    ">"
+  ] @punctuation.bracket)
+
+(inline_link (inline_link_destination) @markup.link.url)
+
+(link_reference_definition ":" @punctuation.delimiter)
+
+(full_reference_link (link_text) @markup.link.text)
+
+(full_reference_link (link_label) @markup.link.label)
+
+(collapsed_reference_link "[]" @punctuation.bracket)
+
+(full_reference_link
+  [
+    "["
+    "]"
+  ] @punctuation.bracket)
+
+(collapsed_reference_link (link_text) @markup.link.text)
+
+(inline_link (link_text) @markup.link.text)
+
+(full_reference_image (link_label) @markup.link.label)
+
+(full_reference_image
+  [
+    "["
+    "]"
+  ] @punctuation.bracket)
+
+(collapsed_reference_image "[]" @punctuation.bracket)
+
+(image_description
+  [
+    "!["
+    "]"
+  ] @punctuation.bracket)
+
+(image_description) @label
+
+(link_reference_definition
+  [
+    "["
+    "]"
+  ] @punctuation.bracket)
+
+(link_reference_definition (link_label) @markup.link.label)
+
+(inline_link_destination
+  [
+    "("
+    ")"
+  ] @punctuation.bracket)
+
+[
+  (autolink)
+  (inline_link_destination)
+  (link_destination)
+] @markup.link.url
+
+(footnote (reference_label) @markup.link.label)
+
+(footnote_reference (reference_label) @markup.link.label)
+
+[
+  (footnote_marker_begin)
+  (footnote_marker_end)
+] @punctuation.bracket
diff --git a/runtime/queries/djot/injections.scm b/runtime/queries/djot/injections.scm
new file mode 100644
index 000000000..63d9b0a7f
--- /dev/null
+++ b/runtime/queries/djot/injections.scm
@@ -0,0 +1,19 @@
+(comment (content) @injection.content
+  (#set! injection.language "comment"))
+
+(math (content) @injection.content
+  (#set! injection.language "latex") (#set! injection.include-unnamed-children))
+
+(code_block
+  (language) @injection.language
+  (code) @injection.content (#set! injection.include-unnamed-children))
+
+(raw_block
+  (raw_block_info
+    (language) @injection.language)
+  (content) @injection.content (#set! injection.include-unnamed-children))
+
+(raw_inline
+  (content) @injection.content (#set! injection.include-unnamed-children)
+  (raw_inline_attribute
+    (language) @injection.language))
diff --git a/runtime/queries/dockerfile/highlights.scm b/runtime/queries/dockerfile/highlights.scm
index cdbf807c2..7e638ecb6 100644
--- a/runtime/queries/dockerfile/highlights.scm
+++ b/runtime/queries/dockerfile/highlights.scm
@@ -19,6 +19,8 @@
 	"SHELL"
 	"MAINTAINER"
 	"CROSS_BUILD"
+	(heredoc_marker)
+	(heredoc_end)
 ] @keyword
 
 [
@@ -35,7 +37,21 @@
 	(image_digest
 		"@" @punctuation.special))
 
-(double_quoted_string) @string
+[
+	(double_quoted_string)
+	(single_quoted_string)
+	(json_string)
+	(heredoc_line)
+] @string
+
+[
+  (heredoc_marker)
+  (heredoc_end)
+] @label
+
+((heredoc_block
+  (heredoc_line) @string)
+  (#set! "priority" 90))
 
 (expansion
   [
@@ -52,3 +68,6 @@
 	(param)
 	(mount_param)
 ] @constant
+
+(expose_instruction
+  (expose_port) @constant.numeric.integer)
diff --git a/runtime/queries/dot/highlights.scm b/runtime/queries/dot/highlights.scm
index 6ad64d287..fb67cfaf6 100644
--- a/runtime/queries/dot/highlights.scm
+++ b/runtime/queries/dot/highlights.scm
@@ -1,3 +1,5 @@
+(identifier) @variable
+
 (keyword) @keyword
 (string_literal) @string
 (number_literal) @constant.numeric
@@ -33,11 +35,6 @@
     (identifier) @constant)
 )
 
-[
-  (comment)
-  (preproc)
-] @comment
+(comment) @comment
 
-(ERROR) @error
-
-(identifier) @variable
+(preproc) @keyword.directive
diff --git a/runtime/queries/dune/highlights.scm b/runtime/queries/dune/highlights.scm
new file mode 100644
index 000000000..e11eb7881
--- /dev/null
+++ b/runtime/queries/dune/highlights.scm
@@ -0,0 +1 @@
+; inherits: scheme
diff --git a/runtime/queries/ecma/highlights.scm b/runtime/queries/ecma/highlights.scm
index dc8ce5e73..d56bbe14a 100644
--- a/runtime/queries/ecma/highlights.scm
+++ b/runtime/queries/ecma/highlights.scm
@@ -1,125 +1,6 @@
-; Special identifiers
-;--------------------
-
-([
-    (identifier)
-    (shorthand_property_identifier)
-    (shorthand_property_identifier_pattern)
- ] @constant
- (#match? @constant "^[A-Z_][A-Z\\d_]+$"))
-
-
-((identifier) @constructor
- (#match? @constructor "^[A-Z]"))
-
-((identifier) @variable.builtin
- (#match? @variable.builtin "^(arguments|module|console|window|document)$")
- (#is-not? local))
-
-((identifier) @function.builtin
- (#eq? @function.builtin "require")
- (#is-not? local))
-
-; Function and method definitions
-;--------------------------------
-
-(function
-  name: (identifier) @function)
-(function_declaration
-  name: (identifier) @function)
-(method_definition
-  name: (property_identifier) @function.method)
-(method_definition
-  name: (private_property_identifier) @function.method.private)
-
-(pair
-  key: (property_identifier) @function.method
-  value: [(function) (arrow_function)])
-(pair
-  key: (private_property_identifier) @function.method.private
-  value: [(function) (arrow_function)])
-
-(assignment_expression
-  left: (member_expression
-    property: (property_identifier) @function.method)
-  right: [(function) (arrow_function)])
-(assignment_expression
-  left: (member_expression
-    property: (private_property_identifier) @function.method.private)
-  right: [(function) (arrow_function)])
-
-(variable_declarator
-  name: (identifier) @function
-  value: [(function) (arrow_function)])
-
-(assignment_expression
-  left: (identifier) @function
-  right: [(function) (arrow_function)])
-
-; Function and method parameters
-;-------------------------------
-
-; Arrow function parameters in the form `p => ...` are supported by both
-; javascript and typescript grammars without conflicts.
-(arrow_function
-  parameter: (identifier) @variable.parameter)
-  
-; Function and method calls
-;--------------------------
-
-(call_expression
-  function: (identifier) @function)
-
-(call_expression
-  function: (member_expression
-    property: (property_identifier) @function.method))
-(call_expression
-  function: (member_expression
-    property: (private_property_identifier) @function.method.private))
-
-; Variables
-;----------
-
-(identifier) @variable
-
-; Properties
-;-----------
-
-(property_identifier) @variable.other.member
-(private_property_identifier) @variable.other.member.private
-(shorthand_property_identifier) @variable.other.member
-(shorthand_property_identifier_pattern) @variable.other.member
-
-; Literals
-;---------
-
-(this) @variable.builtin
-(super) @variable.builtin
-
-[
-  (true)
-  (false)
-  (null)
-  (undefined)
-] @constant.builtin
-
-(comment) @comment
-
-[
-  (string)
-  (template_string)
-] @string
-
-(regex) @string.regexp
-(number) @constant.numeric.integer
-
 ; Tokens
 ;-------
 
-(template_substitution
-  "${" @punctuation.special
-  "}" @punctuation.special) @embedded
-
 [
   ";"
   (optional_chain) ; ?.
@@ -186,6 +67,10 @@
   "}"
 ]  @punctuation.bracket
 
+(template_substitution
+  "${" @punctuation.special
+  "}" @punctuation.special) @embedded
+
 [
   "async"
   "debugger"
@@ -260,3 +145,139 @@
   "catch"
 ] @keyword.control.exception
 
+; Variables
+;----------
+
+(identifier) @variable
+
+; Properties
+;-----------
+
+(property_identifier) @variable.other.member
+(private_property_identifier) @variable.other.member.private
+(shorthand_property_identifier) @variable.other.member
+(shorthand_property_identifier_pattern) @variable.other.member
+
+; Function and method definitions
+;--------------------------------
+
+(function
+  name: (identifier) @function)
+(function_declaration
+  name: (identifier) @function)
+(method_definition
+  name: (property_identifier) @function.method)
+(method_definition
+  name: (private_property_identifier) @function.method.private)
+
+(pair
+  key: (property_identifier) @function.method
+  value: [(function) (arrow_function)])
+(pair
+  key: (private_property_identifier) @function.method.private
+  value: [(function) (arrow_function)])
+
+(assignment_expression
+  left: (member_expression
+    property: (property_identifier) @function.method)
+  right: [(function) (arrow_function)])
+(assignment_expression
+  left: (member_expression
+    property: (private_property_identifier) @function.method.private)
+  right: [(function) (arrow_function)])
+
+(variable_declarator
+  name: (identifier) @function
+  value: [(function) (arrow_function)])
+
+(assignment_expression
+  left: (identifier) @function
+  right: [(function) (arrow_function)])
+
+; Function and method parameters
+;-------------------------------
+
+; Arrow function parameters in the form `p => ...` are supported by both
+; javascript and typescript grammars without conflicts.
+(arrow_function
+  parameter: (identifier) @variable.parameter)
+  
+; Function and method calls
+;--------------------------
+
+(call_expression
+  function: (identifier) @function)
+
+(call_expression
+  function: (member_expression
+    property: (property_identifier) @function.method))
+(call_expression
+  function: (member_expression
+    property: (private_property_identifier) @function.method.private))
+
+; Literals
+;---------
+
+(this) @variable.builtin
+(super) @variable.builtin
+
+[
+  (true)
+  (false)
+  (null)
+  (undefined)
+] @constant.builtin
+
+(comment) @comment
+
+[
+  (string)
+  (template_string)
+] @string
+
+(regex) @string.regexp
+(number) @constant.numeric.integer
+
+; Special identifiers
+;--------------------
+
+((identifier) @constructor
+ (#match? @constructor "^[A-Z]"))
+
+([
+    (identifier)
+    (shorthand_property_identifier)
+    (shorthand_property_identifier_pattern)
+ ] @constant
+ (#match? @constant "^[A-Z_][A-Z\\d_]+$"))
+
+((identifier) @variable.builtin
+ (#match? @variable.builtin "^(arguments|module|console|window|document)$")
+ (#is-not? local))
+
+(call_expression
+ (identifier) @function.builtin
+ (#any-of? @function.builtin
+  "eval"
+  "fetch"
+  "isFinite"
+  "isNaN"
+  "parseFloat"
+  "parseInt"
+  "decodeURI"
+  "decodeURIComponent"
+  "encodeURI"
+  "encodeURIComponent"
+  "require"
+  "alert"
+  "prompt"
+  "btoa"
+  "atob"
+  "confirm"
+  "structuredClone"
+  "setTimeout"
+  "clearTimeout"
+  "setInterval"
+  "clearInterval"
+  "queueMicrotask")
+ (#is-not? local))
diff --git a/runtime/queries/ecma/injections.scm b/runtime/queries/ecma/injections.scm
index af3aef105..72ad31da4 100644
--- a/runtime/queries/ecma/injections.scm
+++ b/runtime/queries/ecma/injections.scm
@@ -7,7 +7,20 @@
     (member_expression
       property: (property_identifier) @injection.language)
   ]
-  arguments: (template_string) @injection.content)
+  arguments: (template_string) @injection.content
+  (#any-of? @injection.language "html" "css" "json" "sql" "js" "ts" "bash"))
+
+; Parse the contents of $ template literals as shell commands
+
+(call_expression
+  function: [
+    (identifier) @_template_function_name
+    (member_expression
+      property: (property_identifier) @_template_function_name)
+  ]
+  arguments: (template_string) @injection.content
+ (#eq? @_template_function_name "$")
+ (#set! injection.language "bash"))
 
 ; Parse the contents of gql template literals
 
diff --git a/runtime/queries/edoc/highlights.scm b/runtime/queries/edoc/highlights.scm
index 5bab79928..66b3ccf96 100644
--- a/runtime/queries/edoc/highlights.scm
+++ b/runtime/queries/edoc/highlights.scm
@@ -16,8 +16,8 @@
    (section_marker) @markup.heading.marker)
  (#eq? @markup.heading.marker "===="))
 
-(macro (tag) @function.macro)
 (tag) @keyword
+(macro (tag) @function.macro)
 (macro_escape) @constant.character.escape
 (inline_quote) @markup.raw.inline
 (email_address) @markup.link.url
diff --git a/runtime/queries/elisp/highlights.scm b/runtime/queries/elisp/highlights.scm
index 1639168b7..648c02211 100644
--- a/runtime/queries/elisp/highlights.scm
+++ b/runtime/queries/elisp/highlights.scm
@@ -26,6 +26,8 @@
   "while"
 ] @keyword
 
+(string) @string
+
 ;; Function definitions
 [
  "defun"
@@ -47,8 +49,6 @@
 (float) @constant.numeric.float
 (char) @constant.character
 
-(string) @string
-
 [
   "("
   ")"
diff --git a/runtime/queries/elixir/highlights.scm b/runtime/queries/elixir/highlights.scm
index 6c0d1094b..c93accd05 100644
--- a/runtime/queries/elixir/highlights.scm
+++ b/runtime/queries/elixir/highlights.scm
@@ -15,80 +15,56 @@
 ; See the License for the specific language governing permissions and
 ; limitations under the License.
 
-; Reserved keywords
-
-["when" "and" "or" "not" "in" "not in" "fn" "do" "end" "catch" "rescue" "after" "else"] @keyword
-
-; Operators
-
-; * doc string
-(unary_operator
-  operator: "@" @comment.block.documentation
-  operand: (call
-    target: (identifier) @comment.block.documentation.__attribute__
-    (arguments
-      [
-        (string) @comment.block.documentation
-        (charlist) @comment.block.documentation
-        (sigil
-          quoted_start: _ @comment.block.documentation
-          quoted_end: _ @comment.block.documentation) @comment.block.documentation
-        (boolean) @comment.block.documentation
-      ]))
-  (#match? @comment.block.documentation.__attribute__ "^(moduledoc|typedoc|doc)$"))
-
-; * module attribute
-(unary_operator
-  operator: "@" @variable.other.member
-  operand: [
-    (identifier) @variable.other.member
-    (call
-      target: (identifier) @variable.other.member)
-    (boolean) @variable.other.member
-    (nil) @variable.other.member
-  ])
-
-; * capture operator
-(unary_operator
-  operator: "&"
-  operand: [
-    (integer) @operator
-    (binary_operator
-      left: [
-        (call target: (dot left: (_) right: (identifier) @function))
-        (identifier) @function
-      ] operator: "/" right: (integer) @operator)
-  ])
-
-(operator_identifier) @operator
-
-(unary_operator
-  operator: _ @operator)
+; Punctuation
 
-(binary_operator
-  operator: _ @operator)
+[
+ "%"
+] @punctuation
 
-(dot
-  operator: _ @operator)
+[
+ ","
+ ";"
+] @punctuation.delimiter
 
-(stab_clause
-  operator: _ @operator)
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "<<"
+  ">>"
+] @punctuation.bracket
 
 ; Literals
 
-(nil) @constant.builtin
-
 (boolean) @constant.builtin.boolean
+(nil) @constant.builtin
 (integer) @constant.numeric.integer
 (float) @constant.numeric.float
+(char) @constant.character
 
-(alias) @namespace
+; Identifiers
 
-(call
-  target: (dot
-    left: (atom) @namespace))
+; * regular
+(identifier) @variable
 
-(char) @constant.character
+; * unused
+(
+  (identifier) @comment.unused
+  (#match? @comment.unused "^_")
+)
+
+; * special
+(
+  (identifier) @constant.builtin
+  (#any-of? @constant.builtin "__MODULE__" "__DIR__" "__ENV__" "__CALLER__" "__STACKTRACE__")
+)
+
+; Comment
+
+(comment) @comment
 
 ; Quoted content
 
@@ -96,6 +72,11 @@
 
 (escape_sequence) @constant.character.escape
 
+[
+  (string)
+  (charlist)
+] @string
+
 [
   (atom)
   (quoted_atom)
@@ -103,51 +84,61 @@
   (quoted_keyword)
 ] @string.special.symbol
 
-[
-  (string)
-  (charlist)
-] @string
-
 ; Note that we explicitly target sigil quoted start/end, so they are not overridden by delimiters
 
 (sigil
   (sigil_name) @__name__
-  quoted_start: _ @string
-  quoted_end: _ @string
-  (#match? @__name__ "^[sS]$")) @string
+  quoted_start: _ @string.special
+  quoted_end: _ @string.special) @string.special
 
 (sigil
   (sigil_name) @__name__
-  quoted_start: _ @string.regexp
-  quoted_end: _ @string.regexp
-  (#match? @__name__ "^[rR]$")) @string.regexp
+  quoted_start: _ @string
+  quoted_end: _ @string
+  (#match? @__name__ "^[sS]$")) @string
 
 (sigil
   (sigil_name) @__name__
-  quoted_start: _ @string.special
-  quoted_end: _ @string.special) @string.special
+  quoted_start: _ @string.regex
+  quoted_end: _ @string.regex
+  (#match? @__name__ "^[rR]$")) @string.regex
 
 ; Calls
 
+; * local function call
+(call
+  target: (identifier) @function)
+
+; * remote function call
+(call
+  target: (dot
+    right: (identifier) @function))
+
+; * field without parentheses or block
+(call
+  target: (dot
+    right: (identifier) @variable.other.member)
+  .)
+
+; * remote call without parentheses or block (overrides above)
+(call
+  target: (dot
+    left: [
+      (alias)
+      (atom)
+    ]
+    right: (identifier) @function)
+  .)
+
 ; * definition keyword
 (call
   target: (identifier) @keyword
-  (#match? @keyword "^(def|defdelegate|defexception|defguard|defguardp|defimpl|defmacro|defmacrop|defmodule|defn|defnp|defoverridable|defp|defprotocol|defstruct)$"))
+  (#any-of? @keyword "def" "defdelegate" "defexception" "defguard" "defguardp" "defimpl" "defmacro" "defmacrop" "defmodule" "defn" "defnp" "defoverridable" "defp" "defprotocol" "defstruct"))
 
 ; * kernel or special forms keyword
 (call
   target: (identifier) @keyword
-  (#match? @keyword "^(alias|case|cond|else|for|if|import|quote|raise|receive|require|reraise|super|throw|try|unless|unquote|unquote_splicing|use|with)$"))
-
-; * function call
-(call
-  target: [
-    ; local
-    (identifier) @function
-    ; remote
-    (dot
-      right: (identifier) @function)
-  ])
+  (#any-of? @keyword "alias" "case" "cond" "for" "if" "import" "quote" "raise" "receive" "require" "reraise" "super" "throw" "try" "unless" "unquote" "unquote_splicing" "use" "with"))
 
 ; * just identifier in function definition
 (call
@@ -159,7 +150,12 @@
         left: (identifier) @function
         operator: "when")
     ])
-  (#match? @keyword "^(def|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp|defp)$"))
+  (#any-of? @keyword "def" "defdelegate" "defguard" "defguardp" "defmacro" "defmacrop" "defn" "defnp" "defp"))
+
+; * pipe into identifier (function call)
+(binary_operator
+  operator: "|>"
+  right: (identifier) @function)
 
 ; * pipe into identifier (definition)
 (call
@@ -168,52 +164,78 @@
     (binary_operator
       operator: "|>"
       right: (identifier) @variable))
-  (#match? @keyword "^(def|defdelegate|defguard|defguardp|defmacro|defmacrop|defn|defnp|defp)$"))
+  (#any-of? @keyword "def" "defdelegate" "defguard" "defguardp" "defmacro" "defmacrop" "defn" "defnp" "defp"))
 
-; * pipe into identifier (function call)
+; * pipe into field without parentheses (function call)
 (binary_operator
   operator: "|>"
-  right: (identifier) @function)
+  right: (call
+    target: (dot
+      right: (identifier) @function)))
 
-; Identifiers
+; Operators
 
-; * special
-(
-  (identifier) @constant.builtin
-  (#match? @constant.builtin "^(__MODULE__|__DIR__|__ENV__|__CALLER__|__STACKTRACE__)$")
-)
+; * capture operand
+(unary_operator
+  operator: "&"
+  operand: [
+    (integer) @operator
+    (binary_operator
+      left: [
+        (call target: (dot left: (_) right: (identifier) @function))
+        (identifier) @function
+      ] operator: "/" right: (integer) @operator)
+  ])
 
-; * unused
-(
-  (identifier) @comment
-  (#match? @comment "^_")
-)
+(operator_identifier) @operator
 
-; * regular
-(identifier) @variable
+(unary_operator
+  operator: _ @operator)
 
-; Comment
+(binary_operator
+  operator: _ @operator)
 
-(comment) @comment
+(dot
+  operator: _ @operator)
 
-; Punctuation
+(stab_clause
+  operator: _ @operator)
 
-[
- "%"
-] @punctuation
+; * module attribute
+(unary_operator
+  operator: "@" @variable.other.member
+  operand: [
+    (identifier) @variable.other.member
+    (call
+      target: (identifier) @variable.other.member)
+    (boolean) @variable.other.member
+    (nil) @variable.other.member
+  ])
 
-[
- ","
- ";"
-] @punctuation.delimiter
+; * doc string
+(unary_operator
+  operator: "@" @comment.block.documentation
+  operand: (call
+    target: (identifier) @comment.block.documentation.__attribute__
+    (arguments
+      [
+        (string) @comment.block.documentation
+        (charlist) @comment.block.documentation
+        (sigil
+          quoted_start: _ @comment.block.documentation
+          quoted_end: _ @comment.block.documentation) @comment.block.documentation
+        (boolean) @comment.block.documentation
+      ]))
+  (#any-of? @comment.block.documentation.__attribute__ "moduledoc" "typedoc" "doc"))
 
-[
-  "("
-  ")"
-  "["
-  "]"
-  "{"
-  "}"
-  "<<"
-  ">>"
-] @punctuation.bracket
+; Module
+
+(alias) @namespace
+
+(call
+  target: (dot
+    left: (atom) @namespace))
+
+; Reserved keywords
+
+["when" "and" "or" "not" "in" "not in" "fn" "do" "end" "catch" "rescue" "after" "else"] @keyword
diff --git a/runtime/queries/elvish/highlights.scm b/runtime/queries/elvish/highlights.scm
index fd70488df..af26d5c28 100644
--- a/runtime/queries/elvish/highlights.scm
+++ b/runtime/queries/elvish/highlights.scm
@@ -63,13 +63,13 @@
 (number) @constant.numeric
 (string) @string
 
+(variable (identifier) @variable)
 ((variable (identifier) @function)
   (#match? @function ".+\\~$"))
 ((variable (identifier) @constant.builtin.boolean)
  (#match? @constant.builtin.boolean "(true|false)"))
 ((variable (identifier) @constant.builtin)
  (#match? @constant.builtin "(_|after-chdir|args|before-chdir|buildinfo|nil|notify-bg-job-success|num-bg-jobs|ok|paths|pid|pwd|value-out-indicator|version)"))
-(variable (identifier) @variable)
 
 ["$" "@"] @punctuation.special
 ["(" ")" "[" "]" "{" "}"] @punctuation.bracket
diff --git a/runtime/queries/erlang/highlights.scm b/runtime/queries/erlang/highlights.scm
index f09f61042..041fb021b 100644
--- a/runtime/queries/erlang/highlights.scm
+++ b/runtime/queries/erlang/highlights.scm
@@ -1,3 +1,45 @@
+; Comments
+(tripledot) @comment.discard
+
+[(comment) (line_comment) (shebang)] @comment
+
+; Basic types
+(variable) @variable
+((atom) @constant.builtin.boolean
+ (#match? @constant.builtin.boolean "^(true|false)$"))
+(atom) @string.special.symbol
+[(string) (sigil)] @string
+(character) @constant.character
+(escape_sequence) @constant.character.escape
+
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+
+; Punctuation
+["," "." "-" ";"] @punctuation.delimiter
+["(" ")" "#" "{" "}" "[" "]" "<<" ">>"] @punctuation.bracket
+
+; Operators
+(binary_operator
+  left: (atom) @function
+  operator: "/"
+  right: (integer) @constant.numeric.integer)
+
+((binary_operator operator: _ @keyword.operator)
+ (#match? @keyword.operator "^\\w+$"))
+((unary_operator operator: _ @keyword.operator)
+ (#match? @keyword.operator "^\\w+$"))
+
+(binary_operator operator: _ @operator)
+(unary_operator operator: _ @operator)
+["/" ":" "->"] @operator
+
+
+; Keywords
+(attribute name: (atom) @keyword)
+
+["case" "fun" "if" "of" "when" "end" "receive" "try" "catch" "after" "begin" "maybe"] @keyword
+
 ; Attributes
 ; module declaration
 (attribute
@@ -122,46 +164,3 @@
 
 (record field: (atom) @variable.other.member)
 (record name: (atom) @type)
-
-; Keywords
-(attribute name: (atom) @keyword)
-
-["case" "fun" "if" "of" "when" "end" "receive" "try" "catch" "after" "begin" "maybe"] @keyword
-
-; Operators
-(binary_operator
-  left: (atom) @function
-  operator: "/"
-  right: (integer) @constant.numeric.integer)
-
-((binary_operator operator: _ @keyword.operator)
- (#match? @keyword.operator "^\\w+$"))
-((unary_operator operator: _ @keyword.operator)
- (#match? @keyword.operator "^\\w+$"))
-
-(binary_operator operator: _ @operator)
-(unary_operator operator: _ @operator)
-["/" ":" "->"] @operator
-
-; Comments
-(tripledot) @comment.discard
-
-[(comment) (line_comment) (shebang)] @comment
-
-; Basic types
-(variable) @variable
-((atom) @constant.builtin.boolean
- (#match? @constant.builtin.boolean "^(true|false)$"))
-(atom) @string.special.symbol
-[(string) (sigil)] @string
-(character) @constant.character
-(escape_sequence) @constant.character.escape
-
-(integer) @constant.numeric.integer
-(float) @constant.numeric.float
-
-; Punctuation
-["," "." "-" ";"] @punctuation.delimiter
-["(" ")" "#" "{" "}" "[" "]" "<<" ">>"] @punctuation.bracket
-
-; (ERROR) @error
diff --git a/runtime/queries/esdl/highlights.scm b/runtime/queries/esdl/highlights.scm
index 7dfde0223..a009933f7 100644
--- a/runtime/queries/esdl/highlights.scm
+++ b/runtime/queries/esdl/highlights.scm
@@ -18,6 +18,8 @@
   "function"
 ] @keyword
 
+(identifier) @variable
+
 (modifier) @keyword
 (extending) @keyword
 
@@ -31,7 +33,6 @@ (module name: (identifier) @namespace)
 (link) @variable.other.member
 (annotation) @variable.other.member
 
-(identifier) @variable
 (string) @string
 (edgeql_fragment) @string
 ; Builtins
@@ -56,8 +57,8 @@ (module name: (identifier) @namespace)
   "anytype"
 ] @type.builtin
 
-(true) @constant.builtin
-(false) @constant.builtin
+(true) @constant.builtin.boolean
+(false) @constant.builtin.boolean
 (null) @constant.builtin
 
 ; Delimiters
diff --git a/runtime/queries/fga/highlights.scm b/runtime/queries/fga/highlights.scm
new file mode 100644
index 000000000..402f6f4d1
--- /dev/null
+++ b/runtime/queries/fga/highlights.scm
@@ -0,0 +1,97 @@
+; Expressions 
+
+(call_expression
+  function: (identifier) @function)
+
+(call_expression
+  function: (selector_expression
+    field: (identifier) @function.method))
+
+
+; Type Definitions
+
+(type_declaration (identifier) @type)
+
+(definition 
+  relation: (identifier) @variable)
+
+
+; Relation Definitions 
+
+(relation_def (identifier) @variable.other.member)
+
+(direct_relationship (identifier) @type)
+(direct_relationship (conditional (identifier) @function))
+
+(relation_ref 
+  . (identifier) @type
+  (identifier) @variable.other.member)
+
+(indirect_relation
+  . (identifier) @variable.other.member
+    (identifier) @variable)
+
+
+; Condition Defintions
+
+(condition_declaration
+  name: (identifier) @function)
+
+(condition_declaration (param (identifier) @variable.parameter))
+
+(binary_expression (identifier) @variable)
+
+((type_identifier) @type.builtin
+  (#any-of? @type.builtin "string" "int" "map" "uint" "list" "timestamp" "bool" "duration" "double" "ipaddress"))
+
+
+; Operators
+
+[
+  "!="
+  "%"
+  "&"
+  "&&"
+  "&^"
+  "*"
+  "+"
+  "-"
+  "/"
+  "<"
+  "<<"
+  "<="
+  "=="
+  ">"
+  ">="
+  ">>"
+  "^"
+  "|"
+  "||"
+] @operator
+
+[
+  "or"
+  "and"
+  "but not"
+  "from"
+  "with"
+] @keyword.operator
+
+; Keywords
+
+[
+  "model"
+  "schema"
+  "type"
+  "relations"
+  "define"
+] @keyword
+
+[
+  "condition"
+] @keyword.function
+
+; Misc
+
+(version) @constant.numeric
+(comment) @comment
diff --git a/runtime/queries/fga/indents.scm b/runtime/queries/fga/indents.scm
new file mode 100644
index 000000000..a75c37610
--- /dev/null
+++ b/runtime/queries/fga/indents.scm
@@ -0,0 +1,8 @@
+[
+  (source_file)
+  (type_declaration)
+  (relations)
+  (condition_declaration)
+] @indent
+
+"}" @outdent
diff --git a/runtime/queries/fga/textobjects.scm b/runtime/queries/fga/textobjects.scm
new file mode 100644
index 000000000..eddaa6142
--- /dev/null
+++ b/runtime/queries/fga/textobjects.scm
@@ -0,0 +1,9 @@
+(condition_declaration
+  body: (_) @function.inside) @function.around
+
+(param 
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(comment) @comment.inside
+
+(comment)+ @comment.around
diff --git a/runtime/queries/fish/highlights.scm b/runtime/queries/fish/highlights.scm
index 4235cdd62..225d27962 100644
--- a/runtime/queries/fish/highlights.scm
+++ b/runtime/queries/fish/highlights.scm
@@ -4,14 +4,13 @@
  "&&"
  "||"
  "|"
+ "&|"
+ "2>|"
  "&"
- "="
- "!="
  ".."
  "!"
  (direction)
  (stream_redirect)
- (test_option)
 ] @operator
 
 [
@@ -39,12 +38,12 @@
  "case"
 ] @keyword.control.conditional)
 
-(else_clause 
+(else_clause
 [
  "else"
 ] @keyword.control.conditional)
 
-(else_if_clause 
+(else_if_clause
 [
  "else"
  "if"
@@ -95,25 +94,30 @@
 
 ;; Commands
 
+(command name: (word) @function)
+
+(command
+  name: (word) @function.builtin (#match? @function.builtin "^test$")
+  argument: (word) @operator (#match? @operator "^(!?=|-[a-zA-Z]+)$"))
+
+(command
+  name: (word) @punctuation.bracket (#match? @punctuation.bracket "^\\[$")
+  argument: (word) @operator (#match? @operator "^(!?=|-[a-zA-Z]+)$"))
+
 (command
   argument: [
              (word) @variable.parameter (#match? @variable.parameter "^-")
             ]
 )
 
-; non-builtin command names
-(command name: (word) @function)
-
-; derived from builtin -n (fish 3.2.2)
+; derived from builtin -n (fish 3.7.1)
 (command
   name: [
-        (word) @function.builtin
-        (#match? @function.builtin "^(\.|:|_|alias|argparse|bg|bind|block|breakpoint|builtin|cd|command|commandline|complete|contains|count|disown|echo|emit|eval|exec|exit|fg|functions|history|isatty|jobs|math|printf|pwd|random|read|realpath|set|set_color|source|status|string|test|time|type|ulimit|wait)$")
-        ]
+    (word) @function.builtin
+    (#any-of? @function.builtin "abbr" "alias" "and" "argparse" "begin" "bg" "bind" "block" "break" "breakpoint" "builtin" "case" "cd" "command" "commandline" "complete" "contains" "continue" "count" "disown" "echo" "else" "emit" "end" "eval" "exec" "exit" "false" "fg" "for" "function" "functions" "history" "if" "isatty" "jobs" "math" "not" "or" "path" "printf" "pwd" "random" "read" "realpath" "return" "set" "set_color" "source" "status" "string" "switch" "test" "time" "true" "type" "ulimit" "wait" "while")
+  ]
 )
 
-(test_command "test" @function.builtin)
-
 ;; Functions
 
 (function_definition ["function" "end"] @keyword.function)
@@ -121,7 +125,7 @@
 (function_definition
   name: [
         (word) (concatenation)
-        ] 
+        ]
 @function)
 
 (function_definition
@@ -146,11 +150,6 @@
 (integer) @constant.numeric.integer
 (float) @constant.numeric.float
 (comment) @comment
-(test_option) @string
 
 ((word) @constant.builtin.boolean
 (#match? @constant.builtin.boolean "^(true|false)$"))
-
-;; Error
-
-(ERROR) @error
diff --git a/runtime/queries/fortran/highlights.scm b/runtime/queries/fortran/highlights.scm
index 90f4ecd0e..0901a4aa7 100644
--- a/runtime/queries/fortran/highlights.scm
+++ b/runtime/queries/fortran/highlights.scm
@@ -112,6 +112,8 @@
   "\\.neqv\\."
 ] @keyword.operator
 
+(identifier) @variable
+
  ;; Brackets
  [
   "("
@@ -163,7 +165,6 @@
 (derived_type_member_expression
   (type_member) @variable.other.member)
 
-(identifier) @variable
 (string_literal) @string
 (number_literal) @constant.numeric
 (boolean_literal) @constant.builtin.boolean
diff --git a/runtime/queries/ghostty/highlights.scm b/runtime/queries/ghostty/highlights.scm
new file mode 100644
index 000000000..4ae953e52
--- /dev/null
+++ b/runtime/queries/ghostty/highlights.scm
@@ -0,0 +1,68 @@
+; extends
+; Comments
+(comment) @comment
+
+; Keys
+(property) @variable
+
+; Values
+(boolean) @constant.builtin.boolean
+
+
+[
+ (number)
+ (adjustment)
+] @constant.numeric
+
+[
+ "+"
+ "="
+ (keybind_trigger ">")
+] @operator
+
+(":") @punctuation.delimiter
+
+[
+ (string)
+ (color)
+] @string
+
+; (color) are hex values
+(color "#" @punctuation.special
+ (#eq? @punctuation.special "#"))
+
+(path_value "?" @keyword.control.conditional
+    (#eq? @keyword.control.conditional "?"))
+
+; `palette`
+(palette_index) @variable.other.member
+
+; `path_directive`
+(path_directive (property) @keyword.import)
+(path_directive (path_value (string) @string.special.path ))
+
+
+(action_name) @function.builtin
+(action_argument (string) @variable.parameter ) 
+
+; (tuple)
+(tuple "," @punctuation.delimiter.special
+       (#eq? @punctuation.delimiter.special ","))
+
+; `keybind`
+(keybind_value) @string.special
+
+; clear is a special keyword that clear all existing keybind up to that point
+((keybind_value) @keyword 
+ (#eq? @keyword "clear"))
+
+; NOTE: The order here matters!
+[
+ (key_qualifier)
+ (keybind_modifier)
+] @attribute
+
+[
+ (modifier_key)
+ (key)
+] @constant.builtin
diff --git a/runtime/queries/gjs/highlights.scm b/runtime/queries/gjs/highlights.scm
index 519838521..3e63dc794 100644
--- a/runtime/queries/gjs/highlights.scm
+++ b/runtime/queries/gjs/highlights.scm
@@ -1 +1 @@
-; inherits: _gjs,_javascript,ecma
+; inherits: ecma,_javascript,_gjs
diff --git a/runtime/queries/gleam/highlights.scm b/runtime/queries/gleam/highlights.scm
index b40574b04..961afc344 100644
--- a/runtime/queries/gleam/highlights.scm
+++ b/runtime/queries/gleam/highlights.scm
@@ -1,3 +1,7 @@
+; Variables
+(identifier) @variable
+(discard) @comment.unused
+
 ; Comments
 (module_comment) @comment
 (statement_comment) @comment
@@ -72,10 +76,6 @@
 ((identifier) @error
  (#any-of? @error "auto" "delegate" "derive" "else" "implement" "macro" "test" "echo"))
 
-; Variables
-(identifier) @variable
-(discard) @comment.unused
-
 ; Keywords
 [
   (visibility_modifier) ; "pub"
diff --git a/runtime/queries/glimmer/highlights.scm b/runtime/queries/glimmer/highlights.scm
index 789722ad0..d0a88fe44 100644
--- a/runtime/queries/glimmer/highlights.scm
+++ b/runtime/queries/glimmer/highlights.scm
@@ -30,7 +30,7 @@
 
 ; == Mustache Statements ===
 
-; Hightlight the whole statement, to color brackets and separators
+; Highlight the whole statement, to color brackets and separators
 (mustache_statement) @punctuation.delimiter
 
 ; An identifier in a mustache expression is a variable
diff --git a/runtime/queries/go/highlights.scm b/runtime/queries/go/highlights.scm
index 7dc20e69c..0f9be0483 100644
--- a/runtime/queries/go/highlights.scm
+++ b/runtime/queries/go/highlights.scm
@@ -1,8 +1,34 @@
-; Function calls
 
-(call_expression
-  function: (identifier) @function.builtin
-  (#match? @function.builtin "^(append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println|real|recover)$"))
+; Identifiers
+
+(field_identifier) @variable.other.member
+
+(identifier) @variable
+
+(package_identifier) @namespace
+
+(parameter_declaration (identifier) @variable.parameter)
+(variadic_parameter_declaration (identifier) @variable.parameter)
+
+(const_spec
+  name: (identifier) @constant)
+
+(type_spec 
+  name: (type_identifier) @constructor)
+
+(keyed_element (literal_element (identifier) @variable.other.member))
+(field_declaration
+  name: (field_identifier) @variable.other.member)
+
+(parameter_declaration (identifier) @variable.parameter)
+(variadic_parameter_declaration (identifier) @variable.parameter)
+
+(label_name) @label
+
+(const_spec
+  name: (identifier) @constant)
+
+; Function calls
 
 (call_expression
   function: (identifier) @function)
@@ -11,9 +37,14 @@
   function: (selector_expression
     field: (field_identifier) @function.method))
 
+(call_expression
+  function: (identifier) @function.builtin
+  (#match? @function.builtin "^(append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println|real|recover)$"))
 
 ; Types
 
+(type_identifier) @type
+
 (type_parameter_list
   (parameter_declaration
     name: (identifier) @type.parameter))
@@ -21,8 +52,6 @@
 ((type_identifier) @type.builtin
   (#match? @type.builtin "^(any|bool|byte|comparable|complex128|complex64|error|float32|float64|int|int16|int32|int64|int8|rune|string|uint|uint16|uint32|uint64|uint8|uintptr)$"))
 
-(type_identifier) @type
-
 ; Function definitions
 
 (function_declaration
@@ -34,28 +63,6 @@
 (method_spec 
   name: (field_identifier) @function.method) 
 
-; Identifiers
-
-(const_spec
-  name: (identifier) @constant)
-
-(parameter_declaration (identifier) @variable.parameter)
-(variadic_parameter_declaration (identifier) @variable.parameter)
-
-(type_spec 
-  name: (type_identifier) @constructor)
-(field_identifier) @variable.other.member
-(keyed_element (literal_element (identifier) @variable.other.member))
-(identifier) @variable
-(package_identifier) @namespace
-
-(parameter_declaration (identifier) @variable.parameter)
-(variadic_parameter_declaration (identifier) @variable.parameter)
-
-(label_name) @label
-
-(const_spec
-  name: (identifier) @constant)
 
 ; Operators
 
diff --git a/runtime/queries/godot-resource/highlights.scm b/runtime/queries/godot-resource/highlights.scm
index d8a69f655..f6bae6691 100644
--- a/runtime/queries/godot-resource/highlights.scm
+++ b/runtime/queries/godot-resource/highlights.scm
@@ -25,5 +25,4 @@
 
 "=" @operator
 
-(ERROR) @error
 (comment) @comment
diff --git a/runtime/queries/gotmpl/highlights.scm b/runtime/queries/gotmpl/highlights.scm
index 5921d161d..2f47f4bdc 100644
--- a/runtime/queries/gotmpl/highlights.scm
+++ b/runtime/queries/gotmpl/highlights.scm
@@ -73,4 +73,3 @@
 (nil) @constant.builtin
 
 (comment) @comment
-(ERROR) @error
diff --git a/runtime/queries/gpr/highlights.scm b/runtime/queries/gpr/highlights.scm
new file mode 100644
index 000000000..9d24928b1
--- /dev/null
+++ b/runtime/queries/gpr/highlights.scm
@@ -0,0 +1,51 @@
+[ "abstract" "all" "at"
+  "case"
+  "end" "extends" "external" "external_as_list"
+  "for"
+  "is"
+  "limited"
+  "null"
+  "others"
+  "package"
+  ;; "project"
+  "renames"
+  "type"
+  "use"
+  "when"
+  "with"
+  ] @keyword
+
+;; Avoid highlighting Project in Project'Project_Dir
+(project_declaration "project" @keyword)
+
+;; highlight qualifiers as keywords (not all qualifiers are actual keywords)
+(project_qualifier _ @keyword)
+
+[":=" "&" "|" "=>"] @operator
+
+(comment) @comment
+(string_literal) @string
+(numeric_literal) @constant.numeric
+
+;; Type
+(typed_string_declaration name: (identifier) @type)
+(variable_declaration type: (name (identifier) @type .))
+
+;; Variable
+(variable_declaration name: (identifier) @variable)
+(variable_reference (name (identifier) @variable .) .)
+
+;; Function
+(builtin_function_call name: _ @function.builtin)
+
+;; Attribute
+(attribute_declaration name: (identifier) @attribute)
+(attribute_reference (identifier) @attribute)
+
+;; Package
+(variable_reference (name (identifier) @function .) "'")
+(package_declaration
+ [ name: (identifier) @function
+   endname: (identifier) @function
+   origname: (name (identifier) @function .)
+   basename: (name (identifier) @function .)])
diff --git a/runtime/queries/gren/highlights.scm b/runtime/queries/gren/highlights.scm
new file mode 100644
index 000000000..aef763a22
--- /dev/null
+++ b/runtime/queries/gren/highlights.scm
@@ -0,0 +1,111 @@
+[
+  (module)
+  (as)
+  (exposing)
+  (backslash)
+] @keyword
+
+(import) @keyword.control.import
+
+[
+  "if"
+  "then"
+  "else"
+  (when)
+  (is)
+] @keyword.control.conditional
+
+[
+  (type)
+  (alias)
+  (infix)
+  (port)
+  "let"
+  "in"
+] @keyword.storage.type
+
+(dot) @operator
+
+[
+  (colon)
+  (arrow)
+  (eq)
+  (operator_identifier)
+  "|"
+] @keyword.operator
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+] @punctuation.bracket
+
+"," @punctuation.delimiter
+
+; modules
+
+(module_declaration(upper_case_qid) @namespace)
+(import_clause(upper_case_qid) @namespace)
+(import_clause(as_clause(upper_case_identifier) @namespace))
+(exposing_list(exposed_type(upper_case_identifier) @type))
+(exposing_list(exposed_value) @variable)
+
+; functions
+
+(type_annotation(lower_case_identifier) @function)
+(port_annotation(lower_case_identifier) @function)
+(file (value_declaration (function_declaration_left(lower_case_identifier) @function)))
+
+; types
+
+(field name: (lower_case_identifier) @variable.other.member)
+(field_type name: (lower_case_identifier) @variable.other.member)
+(field_access_expr(lower_case_identifier) @variable)
+
+(type_declaration(upper_case_identifier) @type)
+(type_declaration typeName: (lower_type_name) @type.parameter)
+
+(type_alias_declaration name: (upper_case_identifier) @type)
+(type_alias_declaration typeVariable: (lower_type_name) @type.parameter)
+
+(type_ref(upper_case_qid) @type)
+(type_ref(upper_case_qid(upper_case_identifier) @namespace (dot) (upper_case_identifier) @type))
+
+(type_variable(lower_case_identifier) @type.parameter)
+
+; variables
+
+(union_pattern constructor: (upper_case_qid (upper_case_identifier) @namespace (dot) (upper_case_identifier) @constructor)) 
+(union_pattern constructor: (upper_case_qid (upper_case_identifier) @constructor)) 
+
+(union_variant(upper_case_identifier) @constructor)
+
+(value_expr name: (value_qid (upper_case_identifier) @namespace))
+(value_expr(upper_case_qid(upper_case_identifier) @namespace (dot) (upper_case_identifier) @constructor))
+(value_expr(upper_case_qid(upper_case_identifier)) @constructor)
+
+(value_expr(value_qid(upper_case_identifier) @namespace (dot) (lower_case_identifier) @variable))
+(value_expr(value_qid(lower_case_identifier) @variable))
+
+(let_in_expr(value_declaration(function_declaration_left(lower_case_identifier) @variable)))
+
+(function_declaration_left(lower_pattern(lower_case_identifier) @variable.parameter))
+
+; comments
+
+(line_comment) @comment
+(block_comment) @comment
+
+; numbers
+
+(number_constant_expr) @constant.numeric
+
+; strings
+
+(string_escape) @constant.character.escape
+
+(string_constant_expr) @string
+(char_constant_expr) @constant.character
diff --git a/runtime/queries/gren/locals.scm b/runtime/queries/gren/locals.scm
new file mode 100644
index 000000000..ab1031156
--- /dev/null
+++ b/runtime/queries/gren/locals.scm
@@ -0,0 +1,14 @@
+(value_declaration) @local.scope
+(type_alias_declaration) @local.scope
+(type_declaration) @local.scope
+(type_annotation) @local.scope
+(port_annotation) @local.scope
+(infix_declaration) @local.scope
+(let_in_expr) @local.scope
+
+(function_declaration_left (lower_pattern (lower_case_identifier)) @local.definition)
+(function_declaration_left (lower_case_identifier) @local.definition)
+
+(value_expr(value_qid(upper_case_identifier)) @local.reference)
+(value_expr(value_qid(lower_case_identifier)) @local.reference)
+(type_ref (upper_case_qid) @local.reference)
diff --git a/runtime/queries/gren/textobjects.scm b/runtime/queries/gren/textobjects.scm
new file mode 100644
index 000000000..38565784e
--- /dev/null
+++ b/runtime/queries/gren/textobjects.scm
@@ -0,0 +1,56 @@
+
+(line_comment) @comment.inside
+(line_comment)+ @comment.around
+(block_comment) @comment.inside
+(block_comment)+ @comment.around
+
+((type_annotation)?
+  (value_declaration
+    (function_declaration_left (lower_case_identifier))
+    (eq)
+    (_) @function.inside
+  )
+) @function.around
+
+(parenthesized_expr
+  (anonymous_function_expr
+    (
+      (arrow)
+      (_) @function.inside
+    )
+  )
+) @function.around
+
+(value_declaration
+  (function_declaration_left
+    (lower_pattern
+      (lower_case_identifier) @parameter.inside @parameter.around
+    )
+  )
+)
+
+(value_declaration
+  (function_declaration_left
+    (pattern) @parameter.inside @parameter.around
+  )
+)
+
+(value_declaration
+  (function_declaration_left
+    (record_pattern
+      (lower_pattern
+        (lower_case_identifier) @parameter.inside
+      )
+    ) @parameter.around
+  )
+)
+
+(parenthesized_expr
+  (anonymous_function_expr
+    (
+      (backslash)
+      (pattern) @parameter.inside
+      (arrow)
+    )
+  )
+)
diff --git a/runtime/queries/gts/highlights.scm b/runtime/queries/gts/highlights.scm
index 5ad3ee1bb..120e8f20d 100644
--- a/runtime/queries/gts/highlights.scm
+++ b/runtime/queries/gts/highlights.scm
@@ -1 +1 @@
-; inherits: _gjs,_typescript,ecma
+; inherits: ecma,_typescript,_gjs
diff --git a/runtime/queries/hare/highlights.scm b/runtime/queries/hare/highlights.scm
index 5115328d4..adaea14e3 100644
--- a/runtime/queries/hare/highlights.scm
+++ b/runtime/queries/hare/highlights.scm
@@ -118,6 +118,8 @@
 ] @constant.builtin
 (literal "void") @constant.builtin
 
+(identifier) @variable
+
 (string_literal) @string
 (escape_sequence) @constant.character.escape
 (rune_literal) @string
@@ -138,5 +140,4 @@
 (decl_attr) @special
 (fndec_attrs) @special
 
-(identifier) @variable
 (struct_union_field (name)) @variable
diff --git a/runtime/queries/haskell/highlights.scm b/runtime/queries/haskell/highlights.scm
index 3d416de8d..162b0a17f 100644
--- a/runtime/queries/haskell/highlights.scm
+++ b/runtime/queries/haskell/highlights.scm
@@ -7,7 +7,254 @@
 (char) @constant.character
 (string) @string
 
-(con_unit) @constant.builtin ; unit, as in ()
+(exp_apply
+ (exp_name
+  (variable) @function.builtin
+   (#any-of? @function.builtin
+    ; built in functions from the Haskell prelude (https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html)
+    ; basic data types
+    "not"
+    "maybe"
+    "either"
+
+    ; tuples
+    "fst"
+    "snd"
+    "curry"
+    "uncurry"
+
+    ; Ord
+    "compare"
+    "min"
+    "max"
+
+    ; Enum
+    "succ"
+    "pred"
+    "toEnum"
+    "fromEnum"
+    "enumFrom"
+    "enumFromThen"
+    "enumFromThenTo"
+
+    ; Num
+    "negate"
+    "abs"
+    "signum"
+    "fromInteger"
+
+    ; Real
+    "toRational"
+
+    ; Integral
+    "quot"
+    "rem"
+    "div"
+    "mod"
+    "quotRem"
+    "divMod"
+    "toInteger"
+
+    ; Fractional
+    "recip"
+    "fromRational"
+
+    ; Floating
+    "exp"
+    "log"
+    "sqrt"
+    "logBase"
+    "sin"
+    "cos"
+    "tan"
+    "asin"
+    "acos"
+    "atan"
+    "sinh"
+    "cosh"
+    "tanh"
+    "asinh"
+    "acosh"
+    "atanh"
+
+    ; RealFrac
+    "properFraction"
+    "truncate"
+    "round"
+    "ceiling"
+    "floor"
+
+    ; RealFloat
+    "floatRadix"
+    "floatDigits"
+    "floatRange"
+    "decodeFloat"
+    "encodeFloat"
+    "exponent"
+    "significand"
+    "scaleFloat"
+    "isNaN"
+    "isInfinite"
+    "isDenormalized"
+    "isNegativeZero"
+    "isIEEE"
+    "atan2"
+
+    ; Numeric functions
+    "subtract"
+    "even"
+    "odd"
+    "gcd"
+    "lcm"
+    "fromIntegral"
+    "realToFrac"
+
+    ; Monoid
+    "mempty"
+    "mconcat"
+    "mappend"
+
+    ; Functor
+    "fmap"
+
+    ; Applicative
+    "liftA2"
+    "pure"
+    
+    ; Monad
+    "return"
+
+    ; MonadFail
+    "fail"
+    "mapM_"
+    "sequence_"
+
+    ; Foldable
+    "foldMap"
+    "foldr"
+    "foldl"
+    "foldl'"
+    "foldr1"
+    "foldl1"
+    "elem"
+    "maximum"
+    "minimum"
+    "sum"
+    "product"
+
+    ; Traversable
+    "traverse"
+    "sequenceA"
+    "mapM"
+    "sequence"
+
+    ; miscellaneous
+    "id"
+    "const"
+    "flip"
+    "until"
+    "asTypeOf"
+    "error"
+    "errorWithoutStackTrace"
+    "undefined"
+
+    ; List
+    "map"
+    "filter"
+    "head"
+    "last"
+    "tail"
+    "init"
+    "null"
+    "length"
+    "reverse"
+
+    ; Foldable
+    "and"
+    "or"
+    "any"
+    "all"
+    "concat"
+    "concatMap"
+
+    ; Building lists
+    "scanl"
+    "scanl1"
+    "scanr"
+    "scanr1"
+
+    ; Infinite lists
+    "iterate"
+    "repeat"
+    "replicate"
+    "cycle"
+
+    ; Sublists
+    "take"
+    "drop"
+    "takeWhile"
+    "dropWhile"
+    "span"
+    "break"
+    "splitAt"
+
+    ; Searching lists
+    "notElem"
+    "lookup"
+
+    ; zipping and unzipping
+    "zip"
+    "zip3"
+    "zipWith"
+    "zipWith3"
+    "unzip"
+    "unzip3"
+
+    ; String
+    "lines"
+    "words"
+    "unlines"
+    "unwords"
+
+    ; Converting to String
+    "show"
+    "showList"
+    "shows"
+    "showChar"
+    "showString"
+    "showParen"
+
+    ; Converting from String
+    "readsPrec"
+    "readList"
+    "reads"
+    "readParen"
+    "read"
+    "lex"
+
+    ; Input and output
+    "putChar"
+    "putStr"
+    "putStrLn"
+    "print"
+    "getChar"
+    "getLine"
+    "getContents"
+    "interact"
+
+    ; Files 
+    "readFile"
+    "writeFile"
+    "appendFile"
+    "readIO"
+    "readLn"
+
+    ; Exception handling
+    "ioError"
+    "userError")
+  )
+)
+
 
 (comment) @comment
 
@@ -30,6 +277,20 @@
 ] @punctuation.delimiter
 
 
+;; ----------------------------------------------------------------------------
+;; Literals and comments
+
+(integer) @constant.numeric.integer
+(exp_negation) @constant.numeric.integer
+(exp_literal (float)) @constant.numeric.float
+(char) @constant.character
+(string) @string
+
+(comment) @comment
+
+(con_unit [ "(" ")" ] @constant.builtin) ; unit, as in ()
+
+
 ;; ----------------------------------------------------------------------------
 ;; Keywords, operators, includes
 
@@ -103,6 +364,8 @@
 ;; ----------------------------------------------------------------------------
 ;; Functions and variables
 
+(variable) @variable
+
 (signature name: (variable) @type)
 (function
   name: (variable) @function
@@ -117,7 +380,6 @@
 (exp_apply . (exp_name (variable) @function))
 (exp_apply . (exp_name (qualified_variable (variable) @function)))
 
-(variable) @variable
 (pat_wildcard) @variable
 
 ;; ----------------------------------------------------------------------------
diff --git a/runtime/queries/hcl/highlights.scm b/runtime/queries/hcl/highlights.scm
index d00f74f37..ffeb79a58 100644
--- a/runtime/queries/hcl/highlights.scm
+++ b/runtime/queries/hcl/highlights.scm
@@ -1,48 +1,3 @@
-(ERROR) @error
-
-; { key: val }
-
-(object_elem val: (expression
-  (variable_expr
-      (identifier) @type.builtin (#match? @type.builtin "^(bool|string|number|object|tuple|list|map|set|any)$"))))
-
-(get_attr (identifier) @variable.builtin (#match? @variable.builtin  "^(root|cwd|module)$"))
-(variable_expr (identifier) @variable.builtin (#match? @variable.builtin "^(var|local|path)$"))
-((identifier) @type.builtin (#match? @type.builtin "^(bool|string|number|object|tuple|list|map|set|any)$"))
-((identifier) @keyword (#match? @keyword "^(module|root|cwd|resource|variable|data|locals|terraform|provider|output)$"))
-
-; highlight identifier keys as though they were block attributes
-(object_elem key: (expression (variable_expr (identifier) @variable.other.member)))
-
-(attribute (identifier) @variable.other.member)
-(function_call (identifier) @function.method)
-(block (identifier) @type.builtin)
-
-(identifier) @variable
-(comment) @comment
-(null_lit) @constant.builtin
-(numeric_lit) @constant.numeric
-(bool_lit) @constant.builtin.boolean
-
-[
-  (template_interpolation_start) ; ${
-  (template_interpolation_end) ; }
-  (template_directive_start) ; %{
-  (template_directive_end) ; }
-  (strip_marker) ; ~
-] @punctuation.special
-
-[
-  (heredoc_identifier) ; <<END
-  (heredoc_start) ; END
-] @punctuation.delimiter
-
-[
-  (quoted_template_start) ; "
-  (quoted_template_end); "
-  (template_literal) ; non-interpolation/directive content
-] @string
-
 [ 
   "if"
   "else"
@@ -98,3 +53,47 @@
   "&&"
   "||"
 ] @operator
+
+(identifier) @variable
+
+; { key: val }
+
+(object_elem val: (expression
+  (variable_expr
+      (identifier) @type.builtin (#match? @type.builtin "^(bool|string|number|object|tuple|list|map|set|any)$"))))
+
+(get_attr (identifier) @variable.builtin (#match? @variable.builtin  "^(root|cwd|module)$"))
+(variable_expr (identifier) @variable.builtin (#match? @variable.builtin "^(var|local|path)$"))
+((identifier) @type.builtin (#match? @type.builtin "^(bool|string|number|object|tuple|list|map|set|any)$"))
+((identifier) @keyword (#match? @keyword "^(module|root|cwd|resource|variable|data|locals|terraform|provider|output)$"))
+
+; highlight identifier keys as though they were block attributes
+(object_elem key: (expression (variable_expr (identifier) @variable.other.member)))
+
+(attribute (identifier) @variable.other.member)
+(function_call (identifier) @function.method)
+(block (identifier) @type.builtin)
+
+(comment) @comment
+(null_lit) @constant.builtin
+(numeric_lit) @constant.numeric
+(bool_lit) @constant.builtin.boolean
+
+[
+  (template_interpolation_start) ; ${
+  (template_interpolation_end) ; }
+  (template_directive_start) ; %{
+  (template_directive_end) ; }
+  (strip_marker) ; ~
+] @punctuation.special
+
+[
+  (heredoc_identifier) ; <<END
+  (heredoc_start) ; END
+] @punctuation.delimiter
+
+[
+  (quoted_template_start) ; "
+  (quoted_template_end); "
+  (template_literal) ; non-interpolation/directive content
+] @string
diff --git a/runtime/queries/hocon/highlights.scm b/runtime/queries/hocon/highlights.scm
index d1aa38a27..95210394e 100644
--- a/runtime/queries/hocon/highlights.scm
+++ b/runtime/queries/hocon/highlights.scm
@@ -10,6 +10,8 @@
 
 (value [":" "=" "+=" ] @operator)
 
+[ "(" ")" "[" "]" "{" "}" ]  @punctuation.bracket
+
 (substitution (_) @string)
 (substitution ["${" "${?" "}"] @punctuation.special)
 
@@ -22,8 +24,6 @@
 
 (include) @keyword.directive
 
-[ "(" ")" "[" "]" "{" "}" ]  @punctuation.bracket
-
 (unit) @keyword
 (path (_) @keyword)
 (unquoted_path "." @punctuation.delimiter)
diff --git a/runtime/queries/inko/highlights.scm b/runtime/queries/inko/highlights.scm
index 2f1cdc127..d5730dce2 100644
--- a/runtime/queries/inko/highlights.scm
+++ b/runtime/queries/inko/highlights.scm
@@ -49,6 +49,12 @@
   "|="
 ] @operator
 
+; Identifiers/variable references
+(identifier) @variable
+
+((identifier) @function
+  (#is-not? local))
+
 ; Keywords
 [
   "as"
@@ -185,9 +191,3 @@
   name: _ @function)
 
 (field) @variable.other.member
-
-; Identifiers/variable references
-((identifier) @function
-  (#is-not? local))
-
-(identifier) @variable
diff --git a/runtime/queries/janet/highlights.scm b/runtime/queries/janet/highlights.scm
index 133559439..94e4cdce1 100644
--- a/runtime/queries/janet/highlights.scm
+++ b/runtime/queries/janet/highlights.scm
@@ -10,12 +10,15 @@
 
 (num_lit) @constant.numeric
 
-[(bool_lit) (nil_lit)] @constant.builtin
+(bool_lit) @constant.builtin.boolean
+(nil_lit) @constant.builtin 
 
 (comment) @comment
 
-((sym_lit) @variable
- (#match? @variable "^\\*.+\\*$"))
+(sym_lit) @variable
+
+((sym_lit) @variable.builtin
+ (#match? @variable.builtin "^\\*.+\\*$"))
 
 (short_fn_lit
  .
@@ -57,8 +60,6 @@
  .
  (sym_lit) @function)
 
-(sym_lit) @variable
-
 ["{" "@{" "}"
  "[" "@[" "]"
  "(" "@(" ")"] @punctuation.bracket
diff --git a/runtime/queries/java/highlights.scm b/runtime/queries/java/highlights.scm
index ae99a33ab..1f5da9c60 100644
--- a/runtime/queries/java/highlights.scm
+++ b/runtime/queries/java/highlights.scm
@@ -1,3 +1,5 @@
+(identifier) @variable
+
 ; Methods
 
 (method_declaration
@@ -54,8 +56,6 @@
 ((identifier) @constant
  (#match? @constant "^_*[A-Z][A-Z\\d_]+$"))
 
-(identifier) @variable
-
 (this) @variable.builtin
 
 ; Literals
diff --git a/runtime/queries/javascript/highlights.scm b/runtime/queries/javascript/highlights.scm
index 2a40b3723..bd09e0487 100644
--- a/runtime/queries/javascript/highlights.scm
+++ b/runtime/queries/javascript/highlights.scm
@@ -1,3 +1,3 @@
 ; See runtime/queries/ecma/README.md for more info.
 
-; inherits: _javascript,ecma
+; inherits: ecma,_javascript
diff --git a/runtime/queries/jjdescription/injections.scm b/runtime/queries/jjdescription/injections.scm
new file mode 100644
index 000000000..f34f44da5
--- /dev/null
+++ b/runtime/queries/jjdescription/injections.scm
@@ -0,0 +1,3 @@
+(((scissors_inner) @injection.content)
+ (#set! injection.include-children)
+ (#set! injection.language "diff"))
diff --git a/runtime/queries/json/highlights.scm b/runtime/queries/json/highlights.scm
index 17bb5f75b..69005074d 100644
--- a/runtime/queries/json/highlights.scm
+++ b/runtime/queries/json/highlights.scm
@@ -10,7 +10,6 @@
 
 (string) @string
 (escape_sequence) @constant.character.escape
-(ERROR) @error
 
 "," @punctuation.delimiter
 [
diff --git a/runtime/queries/jsonnet/highlights.scm b/runtime/queries/jsonnet/highlights.scm
index f54e7d5c7..c5cb49ff6 100644
--- a/runtime/queries/jsonnet/highlights.scm
+++ b/runtime/queries/jsonnet/highlights.scm
@@ -15,6 +15,7 @@
 (binaryop) @operator
 (unaryop) @operator
 
+(id) @variable
 (param identifier: (id) @variable.parameter)
 (bind function: (id) @function)
 (fieldname (id) @variable.other.member)
@@ -35,4 +36,3 @@
   ";"
   "="
 ] @punctuation.delimiter
-(id) @variable
diff --git a/runtime/queries/jsx/highlights.scm b/runtime/queries/jsx/highlights.scm
index eb2b1b1a4..4d0e168a8 100644
--- a/runtime/queries/jsx/highlights.scm
+++ b/runtime/queries/jsx/highlights.scm
@@ -1,3 +1,3 @@
 ; See runtime/queries/ecma/README.md for more info.
 
-; inherits: _jsx,_javascript,ecma
+; inherits: ecma,_javascript,_jsx
diff --git a/runtime/queries/julia/folds.scm b/runtime/queries/julia/folds.scm
index 91eede5f6..91a26c0c9 100644
--- a/runtime/queries/julia/folds.scm
+++ b/runtime/queries/julia/folds.scm
@@ -1,11 +1,14 @@
 [
- (module_definition)
- (struct_definition)
- (macro_definition)
- (function_definition)
- (compound_expression) ; begin blocks
- (let_statement)
- (if_statement)
- (for_statement)
- (while_statement)
+  (module_definition)
+  (struct_definition)
+  (macro_definition)
+  (function_definition)
+  (if_statement)
+  (try_statement)
+  (for_statement)
+  (while_statement)
+  (let_statement)
+  (quote_statement)
+  (do_clause)
+  (compound_statement) ; begin block
 ] @fold
diff --git a/runtime/queries/julia/highlights.scm b/runtime/queries/julia/highlights.scm
index 013f50632..7072640ff 100644
--- a/runtime/queries/julia/highlights.scm
+++ b/runtime/queries/julia/highlights.scm
@@ -1,39 +1,48 @@
-; ----------
-; Primitives
-; ----------
+; ------------
+; Variables identifiers
+; ------------
 
-[
-  (line_comment)
-  (block_comment)
-] @comment
+(identifier) @variable
 
+; Remaining identifiers that start with capital letters should be types (PascalCase)
 (
-  ((identifier) @constant.builtin)
-  (#match? @constant.builtin "^(nothing|missing|undef)$"))
+  (identifier) @type
+  (#match? @type "^[A-Z]"))
 
-[
-  (true)
-  (false)
-] @constant.builtin.boolean
+; SCREAMING_SNAKE_CASE
+(
+  (identifier) @constant
+  (#match? @constant "^[A-Z][A-Z0-9_]*$"))
 
-(integer_literal) @constant.numeric.integer
-(float_literal) @constant.numeric.float
+(const_statement
+  (assignment
+    . (identifier) @constant))
 
-(
-  ((identifier) @constant.numeric.float)
-  (#match? @constant.numeric.float "^((Inf|NaN)(16|32|64)?)$"))
+; Field expressions are either module content or struct fields.
+; Module types and constants should already be captured, so this
+; assumes the remaining identifiers to be struct fields.
+(field_expression
+  (_)
+  (identifier) @variable.other.member)
 
-(character_literal) @constant.character
-(escape_sequence) @constant.character.escape
+(quote_expression
+  ":" @string.special.symbol
+  [
+    (identifier)
+    (operator)
+  ] @string.special.symbol)
 
-(string_literal) @string
+; ------
+; Macros
+; ------
 
-(prefixed_string_literal
-  prefix: (identifier) @function.macro) @string
+(macro_definition
+  name: (identifier) @function.macro)
+
+(macro_identifier
+  "@" @function.macro
+  (identifier) @function.macro)
 
-(quote_expression
-  (identifier) @string.special.symbol) 
-  
 ; -------------------
 ; Modules and Imports
 ; -------------------
@@ -50,49 +59,6 @@
 (scoped_identifier
   (identifier) @namespace)
 
-; -----
-; Types
-; -----
-
-(abstract_definition
-  name: (identifier) @type)
-  
-(primitive_definition
-  name: (identifier) @type)
-
-(struct_definition
-  name: (identifier) @type)
-
-(struct_definition
-  . (_)
-    (identifier) @variable.other.member)
-
-(struct_definition
-  . (_)
-  (typed_expression
-    . (identifier) @variable.other.member))
-    
-(type_parameter_list
-  (identifier) @type)
-
-(constrained_type_parameter
-  (identifier) @type)
-  
-(subtype_clause
-  (identifier) @type)
-
-(typed_expression
-  (identifier) @type . )
-
-(parameterized_identifier
-  (identifier) @type)
-  
-(type_argument_list
-  (identifier) @type)
-
-(where_clause
-  (identifier) @type)
-
 ; -------------------
 ; Function definition
 ; -------------------
@@ -119,22 +85,6 @@
   ; prevent constructors (PascalCase) to be highlighted as functions
   (#match? @function "^[^A-Z]"))
 
-(parameter_list
-  (identifier) @variable.parameter)
-
-(typed_parameter
-  (identifier) @variable.parameter
-  (identifier)? @type)
-
-(optional_parameter
-  . (identifier) @variable.parameter)
-
-(slurp_parameter
-  (identifier) @variable.parameter)
-
-(function_expression
-  . (identifier) @variable.parameter)
-
 ; ---------------
 ; Functions calls
 ; ---------------
@@ -146,13 +96,13 @@
   (#match? @function "^[^A-Z]"))
 
 (
-  (broadcast_call_expression
-    (identifier) @function)
+  (call_expression
+    (field_expression (identifier) @function .))
   (#match? @function "^[^A-Z]"))
 
 (
-  (call_expression
-    (field_expression (identifier) @function .))
+  (broadcast_call_expression
+    (identifier) @function)
   (#match? @function "^[^A-Z]"))
 
 (
@@ -160,78 +110,279 @@
     (field_expression (identifier) @function .))
   (#match? @function "^[^A-Z]"))
 
-; ------
-; Macros
-; ------
 
-(macro_definition
-  name: (identifier) @function.macro)
+; -------------------
+; Functions builtins
+; -------------------
+
+((identifier) @function.builtin
+  (#any-of? @function.builtin
+    "_abstracttype" "_apply_iterate" "_apply_pure" "_call_in_world" "_call_in_world_total"
+    "_call_latest" "_equiv_typedef" "_expr" "_primitivetype" "_setsuper!" "_structtype" "_typebody!"
+    "_typevar" "applicable" "apply_type" "arrayref" "arrayset" "arraysize" "const_arrayref"
+    "donotdelete" "fieldtype" "get_binding_type" "getfield" "ifelse" "invoke" "isa" "isdefined"
+    "modifyfield!" "nfields" "replacefield!" "set_binding_type!" "setfield!" "sizeof" "svec"
+    "swapfield!" "throw" "tuple" "typeassert" "typeof"))
+
+; -----------
+; Parameters
+; -----------
+
+(parameter_list
+  (identifier) @variable.parameter)
+
+(optional_parameter
+  . (identifier) @variable.parameter)
+
+(slurp_parameter
+  (identifier) @variable.parameter)
+
+(typed_parameter
+  parameter: (identifier)? @variable.parameter
+  type: (_) @type)
+
+(function_expression
+  . (identifier) @variable.parameter) ; Single parameter arrow functions
+
+; -----
+; Types
+; -----
+
+; Definitions
+(abstract_definition
+  name: (identifier) @type.definition) @keyword
+
+(primitive_definition
+  name: (identifier) @type.definition) @keyword
+
+(struct_definition
+  name: (identifier) @type)
+
+(struct_definition
+  . (_)
+    (identifier) @variable.other.member)
+
+(struct_definition
+  . (_)
+  (typed_expression
+    . (identifier) @variable.other.member))
+
+(type_clause
+  [
+    (identifier) @type
+    (field_expression
+      (identifier) @type .)
+  ])
+
+; Annotations
+(parametrized_type_expression
+  (_) @type
+  (curly_expression
+    (_) @type))
+
+(type_parameter_list
+  (identifier) @type)
+
+(typed_expression
+  (identifier) @type . )
+
+(function_definition
+  return_type: (identifier) @type)
+
+(short_function_definition
+  return_type: (identifier) @type)
+
+(where_clause
+  (identifier) @type)
+
+(where_clause
+  (curly_expression
+    (_) @type))
+
+; ---------
+; Builtins
+; ---------
+
+; This list was generated with:
+;
+;  istype(x) = typeof(x) === DataType || typeof(x) === UnionAll
+;  get_types(m) = filter(x -> istype(Base.eval(m, x)), names(m))
+;  type_names = sort(union(get_types(Core), get_types(Base)))
+;
+((identifier) @type.builtin
+  (#any-of? @type.builtin
+    "AbstractArray" "AbstractChannel" "AbstractChar" "AbstractDict" "AbstractDisplay"
+    "AbstractFloat" "AbstractIrrational" "AbstractLock" "AbstractMatch" "AbstractMatrix"
+    "AbstractPattern" "AbstractRange" "AbstractSet" "AbstractSlices" "AbstractString"
+    "AbstractUnitRange" "AbstractVecOrMat" "AbstractVector" "Any" "ArgumentError" "Array"
+    "AssertionError" "Atomic" "BigFloat" "BigInt" "BitArray" "BitMatrix" "BitSet" "BitVector" "Bool"
+    "BoundsError" "By" "CanonicalIndexError" "CapturedException" "CartesianIndex" "CartesianIndices"
+    "Cchar" "Cdouble" "Cfloat" "Channel" "Char" "Cint" "Cintmax_t" "Clong" "Clonglong" "Cmd" "Colon"
+    "ColumnSlices" "Complex" "ComplexF16" "ComplexF32" "ComplexF64" "ComposedFunction"
+    "CompositeException" "ConcurrencyViolationError" "Condition" "Cptrdiff_t" "Cshort" "Csize_t"
+    "Cssize_t" "Cstring" "Cuchar" "Cuint" "Cuintmax_t" "Culong" "Culonglong" "Cushort" "Cvoid"
+    "Cwchar_t" "Cwstring" "DataType" "DenseArray" "DenseMatrix" "DenseVecOrMat" "DenseVector" "Dict"
+    "DimensionMismatch" "Dims" "DivideError" "DomainError" "EOFError" "Enum" "ErrorException"
+    "Exception" "ExponentialBackOff" "Expr" "Float16" "Float32" "Float64" "Function" "GlobalRef"
+    "HTML" "IO" "IOBuffer" "IOContext" "IOStream" "IdDict" "IndexCartesian" "IndexLinear"
+    "IndexStyle" "InexactError" "InitError" "Int" "Int128" "Int16" "Int32" "Int64" "Int8" "Integer"
+    "InterruptException" "InvalidStateException" "Irrational" "KeyError" "LazyString" "LinRange"
+    "LineNumberNode" "LinearIndices" "LoadError" "Lt" "MIME" "Matrix" "Method" "MethodError"
+    "Missing" "MissingException" "Module" "NTuple" "NamedTuple" "Nothing" "Number" "Ordering"
+    "OrdinalRange" "OutOfMemoryError" "OverflowError" "Pair" "ParseError" "PartialQuickSort" "Perm"
+    "PermutedDimsArray" "Pipe" "ProcessFailedException" "Ptr" "QuoteNode" "Rational" "RawFD"
+    "ReadOnlyMemoryError" "Real" "ReentrantLock" "Ref" "Regex" "RegexMatch" "Returns"
+    "ReverseOrdering" "RoundingMode" "RowSlices" "SegmentationFault" "Set" "Signed" "Slices" "Some"
+    "SpinLock" "StackFrame" "StackOverflowError" "StackTrace" "Stateful" "StepRange" "StepRangeLen"
+    "StridedArray" "StridedMatrix" "StridedVecOrMat" "StridedVector" "String" "StringIndexError"
+    "SubArray" "SubString" "SubstitutionString" "Symbol" "SystemError" "Task" "TaskFailedException"
+    "Text" "TextDisplay" "Timer" "Tmstruct" "Tuple" "Type" "TypeError" "TypeVar" "UInt" "UInt128"
+    "UInt16" "UInt32" "UInt64" "UInt8" "UndefInitializer" "UndefKeywordError" "UndefRefError"
+    "UndefVarError" "Union" "UnionAll" "UnitRange" "Unsigned" "Val" "VecElement" "VecOrMat" "Vector"
+    "VersionNumber" "WeakKeyDict" "WeakRef"))
+
+((identifier) @variable.builtin
+  (#any-of? @variable.builtin "begin" "end")
+  (#has-ancestor? @variable.builtin index_expression))
+
+((identifier) @variable.builtin
+  (#any-of? @variable.builtin "begin" "end")
+  (#has-ancestor? @variable.builtin range_expression))
 
-(macro_identifier
-  "@" @function.macro
-  (identifier) @function.macro)
 
 ; --------
 ; Keywords
 ; --------
 
-(function_definition 
-  ["function" "end"] @keyword.function)
+[
+  "global"
+  "local"
+] @keyword
+
+(compound_statement
+  [
+    "begin"
+    "end"
+  ] @keyword)
+
+(quote_statement
+  [
+    "quote"
+    "end"
+  ] @keyword)
+
+(let_statement
+  [
+    "let"
+    "end"
+  ] @keyword)
 
 (if_statement
-  ["if" "end"] @keyword.control.conditional)
+  [
+    "if"
+    "end"
+  ] @keyword.control.conditional)
+
 (elseif_clause
-  ["elseif"] @keyword.control.conditional)
+  "elseif" @keyword.control.conditional)
+
 (else_clause
-  ["else"] @keyword.control.conditional)
-(ternary_expression
-  ["?" ":"] @keyword.control.conditional)
+  "else" @keyword.control.conditional)
 
-(for_statement
-  ["for" "end"] @keyword.control.repeat)
-(while_statement
-  ["while" "end"] @keyword.control.repeat)
-(break_statement) @keyword.control.repeat
-(continue_statement) @keyword.control.repeat
-(for_binding
-  "in" @keyword.control.repeat)
-(for_clause
-  "for" @keyword.control.repeat)
+(if_clause
+  "if" @keyword.control.conditional) ; `if` clause in comprehensions
+
+(ternary_expression
+  [
+    "?"
+    ":"
+  ] @keyword.control.conditional)
 
 (try_statement
-  ["try" "end" ] @keyword.control.exception)
+  [
+    "try"
+    "end"
+  ] @keyword.control.exception)
+
 (finally_clause
   "finally" @keyword.control.exception)
+
 (catch_clause
   "catch" @keyword.control.exception)
 
+(for_statement
+  [
+    "for"
+    "end"
+  ] @keyword.control.repeat)
+
+(while_statement
+  [
+    "while"
+    "end"
+  ] @keyword.control.repeat)
+
+(for_clause
+  "for" @keyword.control.repeat)
+
 [
-  "export"
-  "import"
-  "using"
-] @keyword.control.import
+  (break_statement)
+  (continue_statement)
+] @keyword.control.repeat
+
+(module_definition
+  [
+    "module"
+    "baremodule"
+    "end"
+  ] @keyword.control.import)
+
+(import_statement
+  [
+    "import"
+    "using"
+  ] @keyword.control.import)
+
+(import_alias
+  "as" @keyword.control.import)
+
+(export_statement
+  "export" @keyword.control.import)
+
+(selected_import
+  ":" @punctuation.delimiter)
+
+(struct_definition
+  [
+    "struct"
+    "end"
+  ] @keyword)
+
+(macro_definition
+  [
+    "macro"
+    "end"
+  ] @keyword)
+
+(function_definition
+  [
+    "function"
+    "end"
+  ] @keyword.function)
+
+(do_clause
+  [
+    "do"
+    "end"
+  ] @keyword.function)
+
+(return_statement
+  "return" @keyword.control.return)
 
 [
-  "abstract"
-  "baremodule"
-  "begin"
   "const"
-  "do"
-  "end"
-  "let"
-  "macro"
-  "module"
   "mutable"
-  "primitive"
-  "quote"
-  "return"
-  "struct"
-  "type"
-  "where"
-] @keyword
-
-; TODO: fix this
-((identifier) @keyword (#match? @keyword "global|local"))
+] @keyword.storage.modifier
 
 ; ---------
 ; Operators
@@ -239,14 +390,34 @@
 
 [
   (operator)
-  "::"
-  "<:"
-  ":"
-  "=>"
-  "..."
-  "$"
+  "="
+  ""
 ] @operator
 
+(adjoint_expression
+  "'" @operator)
+
+(range_expression
+  ":" @operator)
+
+((operator) @keyword.operator
+  (#any-of? @keyword.operator "in" "isa"))
+
+(for_binding
+  "in" @keyword.operator)
+
+(where_clause
+  "where" @keyword.operator)
+
+(where_expression
+  "where" @keyword.operator)
+
+(binary_expression
+  (_)
+  (operator) @operator
+  (identifier) @function
+  (#any-of? @operator "|>" ".|>"))
+
 ; ------------
 ; Punctuations
 ; ------------
@@ -255,40 +426,58 @@
   "."
   "," 
   ";"
+  "::"
+  "->"
 ] @punctuation.delimiter
 
+"..." @punctuation.special
+
 [
-  "["
-  "]"
   "("
   ")" 
+  "["
+  "]"
   "{" 
   "}"
 ] @punctuation.bracket
 
-; ---------------------
-; Remaining identifiers
-; ---------------------
+; ---------
+; Literals
+; ---------
+
+(boolean_literal) @constant.builtin.boolean
 
-(const_statement
-  (variable_declaration
-    . (identifier) @constant))
+(integer_literal) @constant.numeric.integer
+
+(float_literal) @constant.numeric.float
 
-; SCREAMING_SNAKE_CASE
 (
-  (identifier) @constant
-  (#match? @constant "^[A-Z][A-Z0-9_]*$"))
+  ((identifier) @constant.numeric.float)
+  (#match? @constant.numeric.float "^((Inf|NaN)(16|32|64)?)$"))
 
-; remaining identifiers that start with capital letters should be types (PascalCase)
 (
-  (identifier) @type
-  (#match? @type "^[A-Z]"))
+  ((identifier) @constant.builtin)
+  (#match? @constant.builtin "^(nothing|missing|undef)$"))
 
-; Field expressions are either module content or struct fields.
-; Module types and constants should already be captured, so this
-; assumes the remaining identifiers to be struct fields.
-(field_expression
-  (_)
-  (identifier) @variable.other.member)
+(character_literal) @constant.character
 
-(identifier) @variable
+(escape_sequence) @constant.character.escape
+
+(string_literal) @string
+
+(prefixed_string_literal
+  prefix: (identifier) @function.macro) @string
+
+(command_literal) @string
+
+(prefixed_command_literal
+  prefix: (identifier) @function.macro) @string
+
+; ---------
+; Comments
+; ---------
+
+[
+  (line_comment)
+  (block_comment)
+] @comment
diff --git a/runtime/queries/julia/indents.scm b/runtime/queries/julia/indents.scm
index 08f55aa7f..d73201771 100644
--- a/runtime/queries/julia/indents.scm
+++ b/runtime/queries/julia/indents.scm
@@ -2,15 +2,39 @@
   (struct_definition)
   (macro_definition)
   (function_definition)
-  (compound_expression)
-  (let_statement)
+  (compound_statement)
   (if_statement)
+  (try_statement)
   (for_statement)
   (while_statement)
+  (let_statement)
+  (quote_statement)
   (do_clause)
-  (parameter_list)
+  (assignment)
+  (for_binding)
+  (call_expression)
+  (parenthesized_expression)
+  (tuple_expression)
+  (comprehension_expression)
+  (matrix_expression)
+  (vector_expression)
 ] @indent
 
 [
   "end"
+  ")"
+  "]"
+  "}"
 ] @outdent
+
+(argument_list
+  . (_) @anchor
+  (#set! "scope" "tail")) @align
+
+(parameter_list
+  . (_) @anchor
+  (#set! "scope" "tail")) @align
+
+(curly_expression
+  . (_) @anchor
+  (#set! "scope" "tail")) @align
diff --git a/runtime/queries/julia/injections.scm b/runtime/queries/julia/injections.scm
index fd174a4a0..3b80163f8 100644
--- a/runtime/queries/julia/injections.scm
+++ b/runtime/queries/julia/injections.scm
@@ -9,7 +9,8 @@
       (primitive_definition)
       (abstract_definition)
       (struct_definition)
-      (assignment_expression)
+      (short_function_definition)
+      (assignment)
       (const_statement)
     ])
   (#set! injection.language "markdown"))
@@ -21,10 +22,17 @@
   ] @injection.content
   (#set! injection.language "comment"))
 
+(
+  [
+    (command_literal)
+    (prefixed_command_literal)
+  ] @injection.content
+  (#set! injection.language "sh"))
+
 (
   (prefixed_string_literal
     prefix: (identifier) @function.macro) @injection.content
-  (#eq? @function.macro "re")
+  (#eq? @function.macro "r")
   (#set! injection.language "regex"))
 
 (
diff --git a/runtime/queries/julia/locals.scm b/runtime/queries/julia/locals.scm
index 70b31e509..bbf72c0e2 100644
--- a/runtime/queries/julia/locals.scm
+++ b/runtime/queries/julia/locals.scm
@@ -2,43 +2,100 @@
 ; Definitions
 ; -----------
 
-; Imports
-(import_statement
+; Variables
+(assignment
   (identifier) @local.definition)
-  
+
+(assignment
+  (tuple_expression
+    (identifier) @local.definition))
+
 ; Constants
 (const_statement
-  (variable_declaration
+  (assignment
     . (identifier) @local.definition))
 
+; let/const bindings
+(let_binding
+  (identifier) @local.definition)
+
+(let_binding
+  (tuple_expression
+    (identifier) @local.definition))
+
+; For bindings
+(for_binding
+  (identifier) @local.definition)
+
+(for_binding
+  (tuple_expression
+    (identifier) @local.definition))
+
+; Types
+(struct_definition
+  name: (identifier) @local.definition)
+
+(abstract_definition
+  name: (identifier) @local.definition)
+
+(abstract_definition
+  name: (identifier) @local.definition)
+
+(type_parameter_list
+  (identifier) @local.definition)
+
+; Module imports
+(import_statement
+  (identifier) @local.definition)
+
 ; Parameters
 (parameter_list
   (identifier) @local.definition)
 
-(typed_parameter
-  . (identifier) @local.definition)
-
-(optional_parameter .
+(optional_parameter
+  .
   (identifier) @local.definition)
 
 (slurp_parameter
   (identifier) @local.definition)
 
+(typed_parameter
+  parameter: (identifier) @local.definition
+  (_))
+
+; Single parameter arrow function
 (function_expression
-  . (identifier) @local.definition)
- 
-; ------
-; Scopes
-; ------
+  .
+  (identifier) @local.definition)
 
-[
-  (function_definition)
-  (short_function_definition)
-  (macro_definition)
-] @local.scope
+; Function/macro definitions
+(function_definition
+  name: (identifier) @local.definition) @local.scope
+
+(short_function_definition
+  name: (identifier) @local.definition) @local.scope
+
+(macro_definition
+  name: (identifier) @local.definition) @local.scope
 
 ; ----------
 ; References
 ; ----------
 
 (identifier) @local.reference
+ 
+; ------
+; Scopes
+; ------
+
+[
+  (for_statement)
+  (while_statement)
+  (try_statement)
+  (catch_clause)
+  (finally_clause)
+  (let_statement)
+  (quote_statement)
+  (do_clause)
+] @local.scope 
+
diff --git a/runtime/queries/just/highlights.scm b/runtime/queries/just/highlights.scm
index 258fadb9e..17fcef437 100644
--- a/runtime/queries/just/highlights.scm
+++ b/runtime/queries/just/highlights.scm
@@ -3,6 +3,7 @@
 [
   "export"
   "import"
+  "unexport"
 ] @keyword.control.import
 
 "mod" @keyword.directive
@@ -18,6 +19,11 @@
   "else"
 ] @keyword.control.conditional
 
+[
+  "&&"
+  "||"
+] @operator
+
 ; Variables
 
 (value
@@ -31,6 +37,9 @@
 
 (shell_variable_name) @variable
 
+(unexport
+  name: (identifier) @variable)
+
 ; Functions
 
 (recipe
@@ -83,6 +92,7 @@
   "=="
   "!="
   "=~"
+  "!~"
   "@"
   "="
   "$"
diff --git a/runtime/queries/koka/highlights.scm b/runtime/queries/koka/highlights.scm
index 1ef409278..cec2881f0 100644
--- a/runtime/queries/koka/highlights.scm
+++ b/runtime/queries/koka/highlights.scm
@@ -1,3 +1,48 @@
+; Identifiers
+
+(qconid) @namespace
+
+(qidop) @namespace
+
+(varid) @variable
+
+(conid) @constructor
+
+(puredecl
+  (binder
+    (identifier
+      [(varid) (idop)] @constant)))
+
+; TODO: Highlight vars differently once helix has an appropriate highlight query
+; for that purpose.
+
+(pparameter
+  (pattern
+    (identifier
+      (varid) @variable.parameter)))
+
+(paramid
+  (identifier
+    (varid) @variable.parameter))
+
+(typedecl
+  "effect"
+  (varid) @type)
+
+(typeid
+  (varid) @type)
+
+(tbinder
+  (varid) @type)
+
+(typecon
+  (varid) @type)
+
+(qvarid
+  (qid) @namespace)
+
+(modulepath (varid) @namespace)
+
 ; Function calls
 
 (appexpr
@@ -55,51 +100,6 @@
   (identifier
     [(varid) (idop)] @function))
 
-; Identifiers
-
-(puredecl
-  (binder
-    (identifier
-      [(varid) (idop)] @constant)))
-
-; TODO: Highlight vars differently once helix has an appropriate highlight query
-; for that purpose.
-
-(pparameter
-  (pattern
-    (identifier
-      (varid) @variable.parameter)))
-
-(paramid
-  (identifier
-    (varid) @variable.parameter))
-
-(typedecl
-  "effect"
-  (varid) @type)
-
-(typeid
-  (varid) @type)
-
-(tbinder
-  (varid) @type)
-
-(typecon
-  (varid) @type)
-
-(qvarid
-  (qid) @namespace)
-
-(modulepath (varid) @namespace)
-
-(qconid) @namespace
-
-(qidop) @namespace
-
-(varid) @variable
-
-(conid) @constructor
-
 ; Operators
 
 [
diff --git a/runtime/queries/kotlin/highlights.scm b/runtime/queries/kotlin/highlights.scm
index 5b19f849e..11fae3317 100644
--- a/runtime/queries/kotlin/highlights.scm
+++ b/runtime/queries/kotlin/highlights.scm
@@ -1,21 +1,20 @@
-;;; Operators & Punctuation
+;;; Identifiers
+(simple_identifier) @variable
 
-(multi_line_string_literal
-	"$" @punctuation
-  (interpolated_identifier) @none)
-(multi_line_string_literal
-	"${" @punctuation
-	(interpolated_expression) @none
-	"}" @punctuation.)
+; `field` keyword inside property getter/setter
+; FIXME: This will highlight the keyword outside of getters and setters
+;        since tree-sitter does not allow us to check for arbitrary nestation
+((simple_identifier) @variable.builtin
+(#eq? @variable.builtin "field"))
 
-; NOTE: `interpolated_identifier`s can be highlighted in any way
-(line_string_literal
-	"$" @punctuation
-	(interpolated_identifier) @none)
-(line_string_literal
-	"${" @punctuation
-	(interpolated_expression) @none
-	"}" @punctuation)
+; `it` keyword inside lambdas
+; FIXME: This will highlight the keyword outside of lambdas since tree-sitter
+;        does not allow us to check for arbitrary nestation
+((simple_identifier) @variable.builtin
+(#eq? @variable.builtin "it"))
+
+
+;;; Operators & Punctuation
 
 [
 	"."
@@ -69,6 +68,23 @@
 	"->"
 ] @operator
 
+(multi_line_string_literal
+	"$" @punctuation
+  (interpolated_identifier) @none)
+(multi_line_string_literal
+	"${" @punctuation
+	(interpolated_expression) @none
+	"}" @punctuation.)
+
+; NOTE: `interpolated_identifier`s can be highlighted in any way
+(line_string_literal
+	"$" @punctuation
+	(interpolated_identifier) @none)
+(line_string_literal
+	"${" @punctuation
+	(interpolated_expression) @none
+	"}" @punctuation)
+
 ;;; Keywords
 
 (type_alias "typealias" @keyword)
@@ -281,18 +297,3 @@
 
 ; `this` this keyword inside classes
 (this_expression) @variable.builtin
-
-;;; Identifiers
-; `field` keyword inside property getter/setter
-; FIXME: This will highlight the keyword outside of getters and setters
-;        since tree-sitter does not allow us to check for arbitrary nestation
-((simple_identifier) @variable.builtin
-(#eq? @variable.builtin "field"))
-
-; `it` keyword inside lambdas
-; FIXME: This will highlight the keyword outside of lambdas since tree-sitter
-;        does not allow us to check for arbitrary nestation
-((simple_identifier) @variable.builtin
-(#eq? @variable.builtin "it"))
-
-(simple_identifier) @variable
diff --git a/runtime/queries/koto/folds.scm b/runtime/queries/koto/folds.scm
new file mode 100644
index 000000000..d20d0120b
--- /dev/null
+++ b/runtime/queries/koto/folds.scm
@@ -0,0 +1,9 @@
+[
+  (assign)
+  (comment)
+  (function)
+  (list)
+  (map)
+  (tuple)
+  (string)
+] @fold
diff --git a/runtime/queries/koto/highlights.scm b/runtime/queries/koto/highlights.scm
new file mode 100644
index 000000000..1e9104aa3
--- /dev/null
+++ b/runtime/queries/koto/highlights.scm
@@ -0,0 +1,151 @@
+[
+  "="
+  "+"
+  "-"
+  "*"
+  "/"
+  "%"
+  "+="
+  "-="
+  "*="
+  "/="
+  "%="
+  "=="
+  "!="
+  "<"
+  ">"
+  "<="
+  ">="
+  ".."
+  "..="
+  "->"
+  (null_check)
+] @operator
+
+[
+  "let"
+] @keyword
+
+[
+  "and"
+  "not"
+  "or"
+] @keyword.operator
+
+[
+  "return"
+  "yield"
+] @keyword.control.return
+
+[
+  "if"
+  "then"
+  "else"
+  "else if"
+  "match"
+  "switch"
+] @keyword.control.conditional
+
+[
+  (break)
+  (continue)
+  "for"
+  "in"
+  "loop"
+  "until"
+  "while"
+] @keyword.control.repeat
+
+[
+  "throw"
+  "try"
+  "catch"
+  "finally"
+] @keyword.control.exception
+
+[
+  "export"
+  "from"
+  "import"
+  "as"
+] @keyword.control.import
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "|"
+] @punctuation.bracket
+
+(string (interpolation ["{" "}"] @punctuation.special))
+
+[
+  ";"
+  ":"
+  ","
+] @punctuation.delimiter
+
+(identifier) @variable
+
+(import_module
+  (identifier) @module)
+
+(import_item
+  (identifier) @module)
+
+(export
+  (identifier) @module)
+
+(call
+  function: (identifier) @function.method)
+
+(chain
+  lookup: (identifier) @variable.other.member)
+
+[
+  (true)
+  (false)
+] @constant.builtin.boolean
+
+(comment) @comment
+
+(debug) @keyword
+
+(string) @string
+
+(fill_char) @punctuation.delimiter
+
+(alignment) @operator
+
+(escape) @constant.character.escape
+
+(null) @constant.builtin
+
+(number) @constant.numeric
+
+(meta) @keyword.directive
+
+(meta
+  name: (identifier) @variable.other.member)
+
+(entry_inline
+  key: (identifier) @variable.other.member)
+
+(entry_block
+  key: (identifier) @variable.other.member)
+
+(self) @variable.builtin
+
+(variable
+  type: (identifier) @type)
+
+(arg
+  (_ (identifier) @variable.parameter))
+
+(ellipsis) @variable.parameter
+
+(function
+  output_type: (identifier) @type)
diff --git a/runtime/queries/koto/indents.scm b/runtime/queries/koto/indents.scm
new file mode 100644
index 000000000..0eab2b50f
--- /dev/null
+++ b/runtime/queries/koto/indents.scm
@@ -0,0 +1,61 @@
+[
+  (list)
+  (map)
+  (tuple)
+] @indent
+
+[
+  (for)
+  (else_if)
+  (else)
+  (match)
+  (switch)
+  (until)
+  (while)
+] @indent @extend
+
+(assign
+  "=" @indent @extend
+  !rhs
+)
+(assign
+  "=" @indent @extend
+  rhs: (_) @anchor
+  (#not-same-line? @indent @anchor)
+)
+
+(if
+  condition: (_) @indent @extend
+  !then
+)
+(if
+  condition: (_) @indent @extend
+  then: (_) @anchor
+  (#not-same-line? @indent @anchor)
+)
+
+(function
+  (args) @indent @extend
+  !body
+)
+(function
+  (args) @indent @extend
+  body: (_) @anchor
+  (#not-same-line? @indent @anchor)
+)
+
+(match_arm
+  "then" @indent @extend
+  !then
+)
+(match_arm
+  "then" @indent @extend
+  then: (_) @anchor
+  (#not-same-line? @indent @anchor)
+)
+
+[
+  "}"
+  "]"
+  ")"
+] @outdent
diff --git a/runtime/queries/koto/injections.scm b/runtime/queries/koto/injections.scm
new file mode 100644
index 000000000..2f0e58eb6
--- /dev/null
+++ b/runtime/queries/koto/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+  (#set! injection.language "comment"))
diff --git a/runtime/queries/koto/locals.scm b/runtime/queries/koto/locals.scm
new file mode 100644
index 000000000..1886b1886
--- /dev/null
+++ b/runtime/queries/koto/locals.scm
@@ -0,0 +1,30 @@
+; Scopes
+(module (_) @local.scope)
+
+(function
+  body: (_) @local.scope)
+
+; Definitions
+(assign
+  lhs: (identifier) @local.definition)
+
+(variable
+  (identifier) @local.definition)
+
+(arg
+  (identifier) @local.definition)
+
+(arg
+  (variable (identifier)) @local.definition)
+
+(import_item
+  (identifier) @local.definition)
+
+(entry_block
+  (identifier) @local.definition)
+
+(entry_inline
+  (identifier) @local.definition)
+
+; References
+(identifier) @local.reference
diff --git a/runtime/queries/koto/textobjects.scm b/runtime/queries/koto/textobjects.scm
new file mode 100644
index 000000000..15455689c
--- /dev/null
+++ b/runtime/queries/koto/textobjects.scm
@@ -0,0 +1,38 @@
+(comment) @comment.inside
+
+(comment)+ @comment.around
+
+(function
+  body: (_) @function.inside) @function.around
+
+(args
+  ((arg) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(call_args
+  ((call_arg) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(chain
+  call: (tuple
+    ((element) @parameter.inside . ","? @parameter.around) @parameter.around))
+
+(map
+  ((entry_inline) @entry.inside . ","? @entry.around) @entry.around)
+
+(map_block
+  ((entry_block) @entry.inside) @entry.around)
+
+(list
+  ((element) @entry.inside . ","? @entry.around) @entry.around)
+
+(tuple
+  (_) @entry.around)
+
+(assign
+  (meta (test))
+  (function body: (_) @test.inside)
+) @test.around
+
+(entry_block
+  key: (meta (test))
+  value: (function body: (_) @test.inside)
+) @test.around
diff --git a/runtime/queries/latex/highlights.scm b/runtime/queries/latex/highlights.scm
index 3174d80b9..34745d815 100644
--- a/runtime/queries/latex/highlights.scm
+++ b/runtime/queries/latex/highlights.scm
@@ -1,6 +1,4 @@
 ;; General syntax
-(ERROR) @error
-
 (command_name) @function
 (caption
   command: _ @function)
diff --git a/runtime/queries/ld/highlights.scm b/runtime/queries/ld/highlights.scm
index e0c9dd1e1..c4ba0bb15 100644
--- a/runtime/queries/ld/highlights.scm
+++ b/runtime/queries/ld/highlights.scm
@@ -1,11 +1,11 @@
 ; Identifiers
 
+[(NAME) (SYMBOLNAME)] @variable
+
 (section
   .
   (NAME) @namespace)
 
-[(NAME) (SYMBOLNAME)] @variable
-
 ; Operators
 
 [
diff --git a/runtime/queries/ldif/highlights.scm b/runtime/queries/ldif/highlights.scm
index 882ace9fc..06f7f6c17 100644
--- a/runtime/queries/ldif/highlights.scm
+++ b/runtime/queries/ldif/highlights.scm
@@ -1,5 +1,7 @@
 (comment) @comment
 
+(attributeType) @type.parameter
+
 ((distinguishedName
   (name
     (name_componet
@@ -13,7 +15,6 @@
 (changerecord) @constant
 (mod_spec) @constant
 
-(attributeType) @type.parameter
 (change_modify) @string
 
 (value_spec) @keyword
diff --git a/runtime/queries/lean/highlights.scm b/runtime/queries/lean/highlights.scm
index ca19b8353..648507f73 100644
--- a/runtime/queries/lean/highlights.scm
+++ b/runtime/queries/lean/highlights.scm
@@ -1,3 +1,8 @@
+; Variables
+(identifier) @variable
+
+; Namespaces
+
 (open
   namespace: (identifier) @namespace)
 (namespace
@@ -209,9 +214,3 @@
 ["|" "," "." ":" ";"] @punctuation.delimiter
 
 (sorry) @error
-
-;; Error
-(ERROR) @error
-
-; Variables
-(identifier) @variable
diff --git a/runtime/queries/llvm-mir/highlights.scm b/runtime/queries/llvm-mir/highlights.scm
index 792346122..4f59431b5 100644
--- a/runtime/queries/llvm-mir/highlights.scm
+++ b/runtime/queries/llvm-mir/highlights.scm
@@ -75,11 +75,16 @@
   "pre-instr-symbol"
   "post-instr-symbol"
   "heap-alloc-marker"
+  "pcsections"
+  "mmra"
+  "cfi-type"
   "debug-instr-number"
   "debug-location"
+  "dbg-instr-ref"
   "mcsymbol"
   "tied-def"
   "target-flags"
+  "vscale"
   "CustomRegMask"
   "same_value"
   "def_cfa_register"
@@ -118,11 +123,16 @@
   "got"
   "jump-table"
   "syncscope"
-  "address-taken"
+  "machine-block-address-taken"
+  "ir-block-address-taken"
   "landing-pad"
   "inlineasm-br-indirect-target"
   "ehfunclet-entry"
+  "bb_id"
+  "call-frame-size"
   "bbsections"
+  "Exception"
+  "Cold"
 
   (intpred)
   (floatpred)
@@ -132,5 +142,3 @@
   (instruction_flag)
   (float_keyword)
 ] @keyword
-
-(ERROR) @error
diff --git a/runtime/queries/llvm/highlights.scm b/runtime/queries/llvm/highlights.scm
index cb705197e..dea5b0ab8 100644
--- a/runtime/queries/llvm/highlights.scm
+++ b/runtime/queries/llvm/highlights.scm
@@ -17,9 +17,11 @@
 
 [
   "to"
+  "nneg"
   "nuw"
   "nsw"
   "exact"
+  "disjoint"
   "unwind"
   "from"
   "cleanup"
@@ -154,5 +156,3 @@
   "none"
   "zeroinitializer"
 ] @constant.builtin
-
-(ERROR) @error
diff --git a/runtime/queries/lua/highlights.scm b/runtime/queries/lua/highlights.scm
index 2f3b3c05f..2e7d2bac3 100644
--- a/runtime/queries/lua/highlights.scm
+++ b/runtime/queries/lua/highlights.scm
@@ -115,6 +115,18 @@
  "}"
 ] @punctuation.bracket
 
+;; Variables
+(identifier) @variable
+
+((identifier) @variable.builtin
+ (#eq? @variable.builtin "self"))
+
+(variable_list
+  (attribute
+    "<" @punctuation.bracket
+    (identifier) @attribute
+    ">" @punctuation.bracket))
+
 ; ;; Constants
 [
 (false)
@@ -207,18 +219,3 @@
 
 ;; Property
 (dot_index_expression field: (identifier) @variable.other.member)
-
-;; Variables
-((identifier) @variable.builtin
- (#eq? @variable.builtin "self"))
-
-(variable_list
-  (attribute
-    "<" @punctuation.bracket
-    (identifier) @attribute
-    ">" @punctuation.bracket))
-
-(identifier) @variable
-
-;; Error
-(ERROR) @error
diff --git a/runtime/queries/markdown/highlights.scm b/runtime/queries/markdown/highlights.scm
index 72bb68dc2..a80fc1be8 100644
--- a/runtime/queries/markdown/highlights.scm
+++ b/runtime/queries/markdown/highlights.scm
@@ -2,12 +2,12 @@
 (setext_heading (paragraph) @markup.heading.1 (setext_h1_underline) @markup.heading.marker)
 (setext_heading (paragraph) @markup.heading.2 (setext_h2_underline) @markup.heading.marker)
 
-(atx_heading (atx_h1_marker) @markup.heading.marker (inline) @markup.heading.1)
-(atx_heading (atx_h2_marker) @markup.heading.marker (inline) @markup.heading.2)
-(atx_heading (atx_h3_marker) @markup.heading.marker (inline) @markup.heading.3)
-(atx_heading (atx_h4_marker) @markup.heading.marker (inline) @markup.heading.4)
-(atx_heading (atx_h5_marker) @markup.heading.marker (inline) @markup.heading.5)
-(atx_heading (atx_h6_marker) @markup.heading.marker (inline) @markup.heading.6)
+(atx_heading (atx_h1_marker) @markup.heading.marker) @markup.heading.1
+(atx_heading (atx_h2_marker) @markup.heading.marker) @markup.heading.2
+(atx_heading (atx_h3_marker) @markup.heading.marker) @markup.heading.3
+(atx_heading (atx_h4_marker) @markup.heading.marker) @markup.heading.4
+(atx_heading (atx_h5_marker) @markup.heading.marker) @markup.heading.5
+(atx_heading (atx_h6_marker) @markup.heading.marker) @markup.heading.6
 
 [
   (indented_code_block)
diff --git a/runtime/queries/matlab/indents.scm b/runtime/queries/matlab/indents.scm
index b2a8e55dd..4aacccd88 100644
--- a/runtime/queries/matlab/indents.scm
+++ b/runtime/queries/matlab/indents.scm
@@ -1,4 +1,5 @@
 [
+  (arguments_statement)
   (if_statement)
   (for_statement)
   (while_statement)
diff --git a/runtime/queries/meson/highlights.scm b/runtime/queries/meson/highlights.scm
index c4775540f..58c2baca8 100644
--- a/runtime/queries/meson/highlights.scm
+++ b/runtime/queries/meson/highlights.scm
@@ -1,7 +1,6 @@
 (comment) @comment
 
-; these are listed first, because they override keyword queries
-(function_expression (identifier) @function)
+(identifier) @variable
 
 [
     (assignment_operator)
@@ -59,4 +58,5 @@
     (fstring_literal)
 ] @string
 
-(identifier) @variable
+; these are listed last, because they override keyword queries
+(function_expression (identifier) @function)
diff --git a/runtime/queries/mojo/highlights.scm b/runtime/queries/mojo/highlights.scm
index 7acaf1ead..d6de0a92a 100644
--- a/runtime/queries/mojo/highlights.scm
+++ b/runtime/queries/mojo/highlights.scm
@@ -1,3 +1,28 @@
+; Variables
+
+(identifier) @variable
+
+(attribute attribute: (identifier) @variable.other.member)
+
+((identifier) @constant
+  (#match? @constant "^_*[A-Z][A-Z\\d_]*$"))
+
+((identifier) @type
+  (#match? @type "^[A-Z]"))
+
+; Literals
+(none) @constant.builtin
+[
+  (true)
+  (false)
+] @constant.builtin.boolean
+
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(comment) @comment
+(string) @string
+(escape_sequence) @constant.character.escape
+
 ; Docstrings
 
 (expression_statement (string) @comment.block.documentation)
@@ -98,30 +123,6 @@
 (class_definition name: (identifier) @type)
 (class_definition superclasses: (argument_list (identifier) @type))
 
-; Variables
-
-((identifier) @constant
-  (#match? @constant "^_*[A-Z][A-Z\\d_]*$"))
-
-((identifier) @type
-  (#match? @type "^[A-Z]"))
-
-(attribute attribute: (identifier) @variable.other.member)
-(identifier) @variable
-
-; Literals
-(none) @constant.builtin
-[
-  (true)
-  (false)
-] @constant.builtin.boolean
-
-(integer) @constant.numeric.integer
-(float) @constant.numeric.float
-(comment) @comment
-(string) @string
-(escape_sequence) @constant.character.escape
-
 ["," "." ":" ";" (ellipsis)] @punctuation.delimiter
 (interpolation
   "{" @punctuation.special
@@ -246,5 +247,3 @@
 ((identifier) @type.builtin
   (#match? @type.builtin
     "^(BaseException|Exception|ArithmeticError|BufferError|LookupError|AssertionError|AttributeError|EOFError|FloatingPointError|GeneratorExit|ImportError|ModuleNotFoundError|IndexError|KeyError|KeyboardInterrupt|MemoryError|NameError|NotImplementedError|OSError|OverflowError|RecursionError|ReferenceError|RuntimeError|StopIteration|StopAsyncIteration|SyntaxError|IndentationError|TabError|SystemError|SystemExit|TypeError|UnboundLocalError|UnicodeError|UnicodeEncodeError|UnicodeDecodeError|UnicodeTranslateError|ValueError|ZeroDivisionError|EnvironmentError|IOError|WindowsError|BlockingIOError|ChildProcessError|ConnectionError|BrokenPipeError|ConnectionAbortedError|ConnectionRefusedError|ConnectionResetError|FileExistsError|FileNotFoundError|InterruptedError|IsADirectoryError|NotADirectoryError|PermissionError|ProcessLookupError|TimeoutError|Warning|UserWarning|DeprecationWarning|PendingDeprecationWarning|SyntaxWarning|RuntimeWarning|FutureWarning|ImportWarning|UnicodeWarning|BytesWarning|ResourceWarning)$"))
-
-(ERROR) @error
diff --git a/runtime/queries/move/highlights.scm b/runtime/queries/move/highlights.scm
index 86a79dc22..bf607e1f2 100644
--- a/runtime/queries/move/highlights.scm
+++ b/runtime/queries/move/highlights.scm
@@ -23,12 +23,16 @@
 (borrow_expression "&" @keyword.storage.modifier.ref)
 (borrow_expression "&mut" @keyword.storage.modifier.mut)
 
+(identifier) @variable
+
 (constant_identifier) @constant
 ((identifier) @constant
  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
 
 (function_identifier) @function
 
+(primitive_type) @type.builtin
+
 (struct_identifier) @type
 (pack_expression
   access: (module_access
@@ -152,6 +156,3 @@
   "with"
 ] @keyword
 
-(primitive_type) @type.buildin
-
-(identifier) @variable
diff --git a/runtime/queries/nasm/highlights.scm b/runtime/queries/nasm/highlights.scm
index 5e3cfebe6..6cdc4f97a 100644
--- a/runtime/queries/nasm/highlights.scm
+++ b/runtime/queries/nasm/highlights.scm
@@ -4,6 +4,12 @@
 
 (preproc_expression) @keyword.directive
 
+(word) @variable
+((word) @constant
+  (#match? @constant "^[A-Z_][?A-Z_0-9]+$"))
+((word) @constant.builtin
+  (#match? @constant.builtin "^__\\?[A-Z_a-z0-9]+\\?__$"))
+
 [
   (line_here_token)
   (section_here_token)
@@ -56,12 +62,6 @@
 (float_literal) @constant.numeric.float
 (packed_bcd_literal) @constant.numeric.integer
 
-((word) @constant
-  (#match? @constant "^[A-Z_][?A-Z_0-9]+$"))
-((word) @constant.builtin
-  (#match? @constant.builtin "^__\\?[A-Z_a-z0-9]+\\?__$"))
-(word) @variable
-
 (preproc_arg) @keyword.directive
 
 [
diff --git a/runtime/queries/nestedtext/highlights.scm b/runtime/queries/nestedtext/highlights.scm
new file mode 100644
index 000000000..4ba254e82
--- /dev/null
+++ b/runtime/queries/nestedtext/highlights.scm
@@ -0,0 +1 @@
+; inherits: yaml
diff --git a/runtime/queries/nestedtext/indents.scm b/runtime/queries/nestedtext/indents.scm
new file mode 100644
index 000000000..4ba254e82
--- /dev/null
+++ b/runtime/queries/nestedtext/indents.scm
@@ -0,0 +1 @@
+; inherits: yaml
diff --git a/runtime/queries/nestedtext/injections.scm b/runtime/queries/nestedtext/injections.scm
new file mode 100644
index 000000000..4ba254e82
--- /dev/null
+++ b/runtime/queries/nestedtext/injections.scm
@@ -0,0 +1 @@
+; inherits: yaml
diff --git a/runtime/queries/nestedtext/textobjects.scm b/runtime/queries/nestedtext/textobjects.scm
new file mode 100644
index 000000000..4ba254e82
--- /dev/null
+++ b/runtime/queries/nestedtext/textobjects.scm
@@ -0,0 +1 @@
+; inherits: yaml
diff --git a/runtime/queries/nginx/highlights.scm b/runtime/queries/nginx/highlights.scm
new file mode 100644
index 000000000..2b6dd3473
--- /dev/null
+++ b/runtime/queries/nginx/highlights.scm
@@ -0,0 +1,45 @@
+(comment) @comment
+
+(block_directive
+	(directive) @type)
+
+[
+	"{"
+	"}"
+	"("
+	")"
+	"["
+	"]"
+] @punctuation.bracket
+
+(simple_directive
+	(directive) @function)
+
+[
+	";"
+] @punctuation.delimiter
+
+((generic) @keyword
+ (#any-of? @keyword
+ 	"on"
+ 	"off"
+ 	"any"
+ 	"auto"))
+
+(modifier) @operator
+
+(generic) @variable
+
+(string) @string
+
+(number) @constant.numeric
+(metric) @constant.numeric
+
+(variable) @variable.parameter
+
+(regex) @string
+
+(modifier) @keyword.operator
+
+(lua_block_directive
+	"access_by_lua_block" @function)
diff --git a/runtime/queries/nginx/injections.scm b/runtime/queries/nginx/injections.scm
new file mode 100644
index 000000000..03c3786f9
--- /dev/null
+++ b/runtime/queries/nginx/injections.scm
@@ -0,0 +1,9 @@
+((lua_code) @injection.content
+ (#set! injection.language "lua")
+ (#set! injection.combined))
+
+((regex) @injection.content
+ (#set! injection.language "regex"))
+
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/nickel/highlights.scm b/runtime/queries/nickel/highlights.scm
index 4e4bf6694..e5da72162 100644
--- a/runtime/queries/nickel/highlights.scm
+++ b/runtime/queries/nickel/highlights.scm
@@ -23,17 +23,19 @@
 (let_in_block
   "let" @keyword
   "rec"? @keyword
+  "in" @keyword
+)
+
+(let_binding
   pat: (pattern
     (ident) @variable
   )
-  "in" @keyword
 )
+
 (fun_expr
   "fun" @keyword.function
   pats:
-    (pattern
-      id: (ident) @variable.parameter
-    )+
+    (pattern_fun (ident) @variable.parameter)+
   "=>" @operator
 )
 (record_field) @variable.other.member
diff --git a/runtime/queries/nim/highlights.scm b/runtime/queries/nim/highlights.scm
index e02ba5165..791e8e023 100644
--- a/runtime/queries/nim/highlights.scm
+++ b/runtime/queries/nim/highlights.scm
@@ -1,3 +1,5 @@
+(identifier) @variable
+
 ;; Constants, Comments, and Literals
 
 (comment) @comment.line
@@ -226,7 +228,7 @@
       "isnot"
     ]
   right: (_) @type)
-; types in "is" comparisions
+; types in "is" comparisons
 
 (except_branch
   values: (expression_list
@@ -329,5 +331,3 @@
 (dot_expression
   left: (identifier) @variable
   right: (identifier) @variable.other.member)
-
-(identifier) @variable
diff --git a/runtime/queries/nix/highlights.scm b/runtime/queries/nix/highlights.scm
index 4633e1786..b55bcf8c4 100644
--- a/runtime/queries/nix/highlights.scm
+++ b/runtime/queries/nix/highlights.scm
@@ -1,5 +1,23 @@
 (comment) @comment
 
+[
+  ";"
+  "."
+  ","
+  "="
+  ":"
+  (ellipses)
+] @punctuation.delimiter
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+] @punctuation.bracket
+
 "assert" @keyword.control.exception
 "or" @keyword.operator
 "rec" @keyword.control.repeat
@@ -17,6 +35,18 @@
   "with" 
 ] @keyword
 
+(variable_expression name: (identifier) @variable)
+
+(select_expression
+  attrpath: (attrpath attr: (identifier)) @variable.other.member)
+
+(apply_expression
+  function: [
+    (variable_expression name: (identifier) @function)
+    (select_expression
+      attrpath: (attrpath
+        attr: (identifier) @function .))])
+
 ((identifier) @variable.builtin
  (#match? @variable.builtin "^(__currentSystem|__currentTime|__nixPath|__nixVersion|__storeDir|builtins)$")
  (#is-not? local))
@@ -59,28 +89,16 @@
   name: (identifier) @variable.parameter
   "?"? @punctuation.delimiter)
 
-(select_expression
-  attrpath: (attrpath attr: (identifier)) @variable.other.member)
-
 (interpolation
   "${" @punctuation.special
   "}" @punctuation.special) @embedded
 
-(apply_expression
-  function: [
-    (variable_expression name: (identifier) @function)
-    (select_expression
-      attrpath: (attrpath
-        attr: (identifier) @function .))])
-
 (unary_expression
   operator: _ @operator)
 
 (binary_expression
   operator: _ @operator)
 
-(variable_expression name: (identifier) @variable)
-
 (binding
   attrpath: (attrpath attr: (identifier)) @variable.other.member)
 
@@ -92,21 +110,3 @@
   "?" @operator
   attrpath: (attrpath
     attr: (identifier) @variable.other.member))
-
-[
-  ";"
-  "."
-  ","
-  "="
-  ":"
-  (ellipses)
-] @punctuation.delimiter
-
-[
-  "("
-  ")"
-  "["
-  "]"
-  "{"
-  "}"
-] @punctuation.bracket
\ No newline at end of file
diff --git a/runtime/queries/nix/indents.scm b/runtime/queries/nix/indents.scm
new file mode 100644
index 000000000..b06b0b52d
--- /dev/null
+++ b/runtime/queries/nix/indents.scm
@@ -0,0 +1,22 @@
+[
+  (indented_string_expression)
+  (string_expression)
+
+  ; these are all direct parents of (binding_set)
+  (attrset_expression)
+  (let_attrset_expression)
+  (rec_attrset_expression)
+  (let_expression)
+
+  (list_expression)
+  (parenthesized_expression)
+] @indent
+
+
+(if_expression [ "if" "then" "else" ] @align)
+
+[
+  "}"
+  "]"
+  ")"
+] @outdent
diff --git a/runtime/queries/nix/injections.scm b/runtime/queries/nix/injections.scm
index 9804b75be..ce53d39e3 100644
--- a/runtime/queries/nix/injections.scm
+++ b/runtime/queries/nix/injections.scm
@@ -1,7 +1,7 @@
 ((comment) @injection.content
  (#set! injection.language "comment"))
 
-; mark arbitary languages with a comment
+; mark arbitrary languages with a comment
 ((((comment) @injection.language) .
   (indented_string_expression (string_fragment) @injection.content))
   (#set! injection.combined))
@@ -50,6 +50,15 @@
  (#set! injection.language "json")
  (#set! injection.combined))
 
+; builtins.fromTOML toml
+; Example: https://github.com/NixOS/nix/blob/3e8cd2ffe6c2c6ed8aae7853ddcfcc6d2a49b0ce/tests/functional/lang/eval-okay-fromTOML.nix
+((apply_expression
+   function: (_) @_func
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)fromTOML$")
+ (#set! injection.language "toml")
+ (#set! injection.combined))
+
 ; trivial-builders.nix pkgs.writeShellScript[Bin] name content
 ((apply_expression
    function: (apply_expression function: (_) @_func)
@@ -127,6 +136,16 @@
   (#set! injection.language "haskell")
   (#set! injection.combined))
 
+; pkgs.writers.writeNim[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeNim(Bin)?$")
+  (#set! injection.language "nim")
+  (#set! injection.combined))
+
 ; pkgs.writers.writeJS[Bin] name attrs content
 (apply_expression
   (apply_expression
@@ -157,6 +176,67 @@
   (#set! injection.language "python")
   (#set! injection.combined))
 
+; pkgs.writers.writeNu[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeNu(Bin)?$")
+  (#set! injection.language "nu")
+  (#set! injection.combined))
+
+; pkgs.writers.writeRuby[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeRuby(Bin)?$")
+  (#set! injection.language "ruby")
+  (#set! injection.combined))
+
+; pkgs.writers.writeLua[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeLua(Bin)?$")
+  (#set! injection.language "lua")
+  (#set! injection.combined))
+
+; pkgs.writers.writeNginxConfig name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeNginxConfig$")
+  (#set! injection.language "nginx")
+  (#set! injection.combined))
+
+; pkgs.writers.writeGuile[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeGuile(Bin)?$")
+  (#set! injection.language "scheme") ; Guile is a GNU specific implementation of scheme
+  (#set! injection.combined))
+
+
+; pkgs.writers.writeBabashka[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeBabashka(Bin)?$")
+  (#set! injection.language "clojure")
+  (#set! injection.combined))
+
 ; pkgs.writers.writeFSharp[Bin] name content
 ; No query available for f-sharp as of the time of writing
 ; See: https://github.com/helix-editor/helix/issues/4943
diff --git a/runtime/queries/ocaml/highlights.scm b/runtime/queries/ocaml/highlights.scm
index f2a4f0a4c..5e2a576f3 100644
--- a/runtime/queries/ocaml/highlights.scm
+++ b/runtime/queries/ocaml/highlights.scm
@@ -1,3 +1,25 @@
+; Punctuation
+;------------
+
+"%" @punctuation.special
+
+["(" ")" "[" "]" "{" "}" "[|" "|]" "[<" "[>"] @punctuation.bracket
+
+[
+  "," "." ";" ":" "=" "|" "~" "?" "+" "-" "!" ">" "&"
+  "->" ";;" ":>" "+=" ":=" ".."
+] @punctuation.delimiter
+
+(object_type ["<" ">"] @punctuation.bracket)
+
+(attribute ["[@" "]"] @punctuation.special)
+(item_attribute ["[@@" "]"] @punctuation.special)
+(floating_attribute ["[@@@" "]"] @punctuation.special)
+(extension ["[%" "]"] @punctuation.special)
+(item_extension ["[%%" "]"] @punctuation.special)
+(quoted_extension ["{%" "}"] @punctuation.special)
+(quoted_item_extension ["{%%" "}"] @punctuation.special)
+
 ; Modules
 ;--------
 
@@ -83,9 +105,7 @@
 ; Operators
 ;----------
 
-(match_expression (match_operator) @keyword)
-
-(value_definition [(let_operator) (let_and_operator)] @keyword)
+["*" "#" "::" "<-"] @operator
 
 [
   (prefix_operator)
@@ -105,7 +125,9 @@
   (match_operator)
 ] @operator
 
-["*" "#" "::" "<-"] @operator
+(match_expression (match_operator) @keyword)
+
+(value_definition [(let_operator) (let_and_operator)] @keyword)
 
 ; Keywords
 ;---------
@@ -118,28 +140,6 @@
   "then" "to" "try" "type" "val" "virtual" "when" "while" "with"
 ] @keyword
 
-; Punctuation
-;------------
-
-(attribute ["[@" "]"] @punctuation.special)
-(item_attribute ["[@@" "]"] @punctuation.special)
-(floating_attribute ["[@@@" "]"] @punctuation.special)
-(extension ["[%" "]"] @punctuation.special)
-(item_extension ["[%%" "]"] @punctuation.special)
-(quoted_extension ["{%" "}"] @punctuation.special)
-(quoted_item_extension ["{%%" "}"] @punctuation.special)
-
-"%" @punctuation.special
-
-["(" ")" "[" "]" "{" "}" "[|" "|]" "[<" "[>"] @punctuation.bracket
-
-(object_type ["<" ">"] @punctuation.bracket)
-
-[
-  "," "." ";" ":" "=" "|" "~" "?" "+" "-" "!" ">" "&"
-  "->" ";;" ":>" "+=" ":=" ".."
-] @punctuation.delimiter
-
 ; Attributes
 ;-----------
 
diff --git a/runtime/queries/odin/highlights.scm b/runtime/queries/odin/highlights.scm
index bdc4c1290..ed8f03ab3 100644
--- a/runtime/queries/odin/highlights.scm
+++ b/runtime/queries/odin/highlights.scm
@@ -1,13 +1,21 @@
+
+; Variables
+
+(identifier) @variable
+
 [
   (calling_convention)
   (tag)
 ] @keyword.directive
 
 [
-  "import"
-  "package"
+ "package"
 ] @namespace
 
+[
+  "import" 
+] @keyword.control.import
+
 [
   "foreign"
   "using"
@@ -200,7 +208,7 @@
 
 (struct . (identifier) @type)
 
-(field_type . (identifier) "." (identifier) @type)
+(field_type . (identifier) @keyword.storage.type "." (identifier) @type)
 
 (bit_set_type (identifier) @type ";")
 
@@ -248,6 +256,8 @@ (struct . (identifier) @type)
 
 (using_statement (identifier) @namespace)
 
+(import_declaration (identifier) @keyword.storage.type)
+
 ; Parameters
 
 (parameter (identifier) @variable.parameter ":" "="? (identifier)? @constant)
@@ -259,7 +269,3 @@ (struct . (identifier) @type)
 (call_expression argument: (identifier) @variable.parameter "=")
 
 (procedure_type (parameters (parameter (identifier) @variable.parameter)))
-
-; Variables
-
-(identifier) @variable
diff --git a/runtime/queries/odin/textobjects.scm b/runtime/queries/odin/textobjects.scm
new file mode 100644
index 000000000..85b0687de
--- /dev/null
+++ b/runtime/queries/odin/textobjects.scm
@@ -0,0 +1,22 @@
+(procedure_declaration (identifier) (procedure (block) @function.inside)) @function.around
+(procedure_declaration (identifier) (procedure (uninitialized) @function.inside)) @function.around
+(overloaded_procedure_declaration (identifier) @function.inside) @function.around
+
+(procedure_type (parameters (parameter (identifier) @parameter.inside) @parameter.around))
+(procedure (parameters (parameter (identifier) @parameter.inside) @parameter.around))
+
+((procedure_declaration
+  (attributes (attribute "@" "(" (identifier) @attr_name ")"))
+  (identifier) (procedure (block) @test.inside)) @test.around
+ (#match? @attr_name "test"))
+
+(comment) @comment.inside
+(comment)+ @comment.around
+(block_comment) @comment.inside
+(block_comment)+ @comment.around
+
+(struct_declaration (identifier) "::") @class.around
+(enum_declaration (identifier) "::") @class.around
+(union_declaration (identifier) "::") @class.around
+(bit_field_declaration (identifier) "::") @class.around
+(const_declaration (identifier) "::" [(array_type) (distinct_type) (bit_set_type) (pointer_type)]) @class.around
diff --git a/runtime/queries/opencl/highlights.scm b/runtime/queries/opencl/highlights.scm
index 9d76d6c66..36133bd21 100644
--- a/runtime/queries/opencl/highlights.scm
+++ b/runtime/queries/opencl/highlights.scm
@@ -106,6 +106,11 @@
 
 [(true) (false)] @constant.builtin.boolean
 
+(identifier) @variable
+
+((identifier) @constant
+  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
+
 (enumerator name: (identifier) @type.enum.variant)
 
 (string_literal) @string
@@ -142,9 +147,4 @@
 (vector_type) @type.builtin
 (other_builtin_type) @type.builtin
 
-((identifier) @constant
-  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
-
-(identifier) @variable
-
 (comment) @comment
diff --git a/runtime/queries/openscad/highlights.scm b/runtime/queries/openscad/highlights.scm
index c06738e85..90d5ac59d 100644
--- a/runtime/queries/openscad/highlights.scm
+++ b/runtime/queries/openscad/highlights.scm
@@ -3,13 +3,14 @@
 (boolean) @constant.builtin.boolean
 (include_path) @string.special.path
 
+(identifier) @variable
+
 (parameters_declaration (identifier) @variable.parameter)
 (function_declaration name: (identifier) @function)
 
 (function_call function: (identifier) @function)
 (module_call name: (identifier) @function)
 
-(identifier) @variable
 (special_variable) @variable.builtin
 
 [
@@ -60,4 +61,4 @@
   "."
 ] @punctuation.delimiter
 
-(comment) @comment
\ No newline at end of file
+(comment) @comment
diff --git a/runtime/queries/pascal/highlights.scm b/runtime/queries/pascal/highlights.scm
index 5368a22b8..ed6895734 100644
--- a/runtime/queries/pascal/highlights.scm
+++ b/runtime/queries/pascal/highlights.scm
@@ -1,4 +1,4 @@
-; -- Identifier type inferrence
+; -- Identifier type inference
 
 ; VERY QUESTIONABLE: Highlighting of identifiers based on spelling
 (exprBinary ((identifier) @constant
diff --git a/runtime/queries/perl/highlights.scm b/runtime/queries/perl/highlights.scm
index c2496f9fb..5f2243330 100644
--- a/runtime/queries/perl/highlights.scm
+++ b/runtime/queries/perl/highlights.scm
@@ -1,9 +1,9 @@
 [
-  "use" "no" "require" "package"
+  "use" "no" "require" "package" "class" "role"
 ] @keyword.control.import
 
 [
-  "sub"
+  "sub" "method" "async" "extended"
 ] @keyword.function
 
 [
@@ -17,7 +17,7 @@
 ] @keyword.control.repeat
 
 [
-  "my" "our" "local"
+  "my" "our" "local" "state"
 ] @keyword.storage.modifier
 
 [
@@ -29,15 +29,18 @@
 ] @constant.builtin
 
 (phaser_statement phase: _ @keyword.directive)
+(class_phaser_statement phase: _ @keyword.directive)
 
 [
-  "or" "and"
+  "or" "xor" "and"
   "eq" "ne" "cmp" "lt" "le" "ge" "gt"
   "isa"
 ] @keyword.operator
 
 (comment) @comment
 
+(function) @function
+
 (eof_marker) @keyword.directive
 (data_section) @comment
 
@@ -55,7 +58,7 @@
 
 [(quoted_regexp) (match_regexp)] @string.regexp
 
-(autoquoted_bareword _?) @string.special
+(autoquoted_bareword) @string.special
 
 [(scalar) (arraylen)] @variable
 (scalar_deref_expression ["->" "$" "*"] @variable)
@@ -94,5 +97,3 @@
 
 (func0op_call_expression function: _ @function.builtin)
 (func1op_call_expression function: _ @function.builtin)
-
-(function) @function
diff --git a/runtime/queries/php-only/highlights.scm b/runtime/queries/php-only/highlights.scm
index 9fdbe0298..d19e0cee0 100644
--- a/runtime/queries/php-only/highlights.scm
+++ b/runtime/queries/php-only/highlights.scm
@@ -1,6 +1,23 @@
 (php_tag) @tag
 "?>" @tag
 
+; Variables
+
+(variable_name) @variable
+
+(relative_scope) @variable.builtin
+
+((name) @constant
+ (#match? @constant "^_?[A-Z][A-Z\\d_]+$"))
+((name) @constant.builtin
+ (#match? @constant.builtin "^__[A-Z][A-Z\d_]+__$"))
+
+((name) @constructor
+ (#match? @constructor "^[A-Z]"))
+
+((name) @variable.builtin
+ (#eq? @variable.builtin "this"))
+
 ; Types
 
 (primitive_type) @type.builtin
@@ -38,23 +55,6 @@
 (member_access_expression
   name: (name) @variable.other.member)
 
-; Variables
-
-(relative_scope) @variable.builtin
-
-((name) @constant
- (#match? @constant "^_?[A-Z][A-Z\\d_]+$"))
-((name) @constant.builtin
- (#match? @constant.builtin "^__[A-Z][A-Z\d_]+__$"))
-
-((name) @constructor
- (#match? @constructor "^[A-Z]"))
-
-((name) @variable.builtin
- (#eq? @variable.builtin "this"))
-
-(variable_name) @variable
-
 ; Basic tokens
 [
   (string)
diff --git a/runtime/queries/php/highlights.scm b/runtime/queries/php/highlights.scm
index b9429ae8a..737e2d5f2 100644
--- a/runtime/queries/php/highlights.scm
+++ b/runtime/queries/php/highlights.scm
@@ -1,6 +1,21 @@
 (php_tag) @tag
 "?>" @tag
 
+; Variables
+
+(relative_scope) @variable.builtin
+
+(variable_name) @variable
+
+((name) @constant
+ (#match? @constant "^_?[A-Z][A-Z\\d_]+$"))
+
+((name) @constructor
+ (#match? @constructor "^[A-Z]"))
+
+((name) @variable.builtin
+ (#eq? @variable.builtin "this"))
+
 ; Types
 [
   (primitive_type)
@@ -110,21 +125,6 @@
 (member_access_expression
   name: (name) @variable.other.member)
 
-; Variables
-
-(relative_scope) @variable.builtin
-
-((name) @constant
- (#match? @constant "^_?[A-Z][A-Z\\d_]+$"))
-
-((name) @constructor
- (#match? @constructor "^[A-Z]"))
-
-((name) @variable.builtin
- (#eq? @variable.builtin "this"))
-
-(variable_name) @variable
-
 ; Attributes
 (attribute_list) @attribute
 
diff --git a/runtime/queries/php/indents.scm b/runtime/queries/php/indents.scm
index b22393ed1..04229d2f7 100644
--- a/runtime/queries/php/indents.scm
+++ b/runtime/queries/php/indents.scm
@@ -14,4 +14,5 @@
 [
   "}"
   ")"
+  "]"
 ] @outdent
diff --git a/runtime/queries/pkl/highlights.scm b/runtime/queries/pkl/highlights.scm
index 1de6ba3c0..3f2f13170 100644
--- a/runtime/queries/pkl/highlights.scm
+++ b/runtime/queries/pkl/highlights.scm
@@ -126,7 +126,7 @@
 (slStringLiteral) @string
 (mlStringLiteral) @string
 
-(escapeSequence) @constent.character.escape
+(escapeSequence) @constant.character.escape
 
 (intLiteral) @constant.numeric.integer
 (floatLiteral) @constant.numeric.float
@@ -149,14 +149,14 @@
 
 ; Identifiers
 
+(identifier) @variable
+
 (classProperty (identifier) @variable.other.member)
 (objectProperty (identifier) @variable.other.member)
 
 (parameterList (typedIdentifier (identifier) @variable.parameter))
 (objectBodyParameters (typedIdentifier (identifier) @variable.parameter))
 
-(identifier) @variable
-
 ; Method definitions
 
 (classMethod (methodHeader (identifier)) @function.method)
diff --git a/runtime/queries/po/highlights.scm b/runtime/queries/po/highlights.scm
index b090f129d..56874427f 100644
--- a/runtime/queries/po/highlights.scm
+++ b/runtime/queries/po/highlights.scm
@@ -11,5 +11,3 @@
 
 (number) @constant.numeric
 (string) @string
-
-(ERROR) @error
diff --git a/runtime/queries/ponylang/highlights.scm b/runtime/queries/ponylang/highlights.scm
index 2d0594a7c..f67e9a688 100644
--- a/runtime/queries/ponylang/highlights.scm
+++ b/runtime/queries/ponylang/highlights.scm
@@ -9,6 +9,7 @@
 (character) @constant.character
 
 ;; strings and docstring
+(string) @string
 (source_file docstring: (string) @string.special)
 (entity docstring: (string) @string.special)
 (method docstring: (string) @string.special) ; docstring for methods without body
@@ -18,7 +19,6 @@
 (behavior body: (block . (string) @string.special))
 (constructor body: (block . (string) @string.special))
 (field docstring: (string) @string.special)
-(string) @string
 
 ;; Punctuation
 [
@@ -137,6 +137,14 @@
   "<="
 ] @operator
 
+;; variables
+;; references to upper case things are considered constructors
+(identifier) @variable
+(
+  (identifier) @constructor
+  (#match? @constructor "^[A-Z]")
+)
+
 ;; Types
 (entity name: (identifier) @type)
 (nominal_type name: (identifier) @type)
@@ -166,11 +174,3 @@
 ;; annotations
 (annotations (identifier) @attribute)
 
-;; variables
-;; references to upper case things are considered constructors
-(
-  (identifier) @constructor
-  (#match @constructor "^[A-Z]")
-)
-(identifier) @variable
-
diff --git a/runtime/queries/protobuf/highlights.scm b/runtime/queries/protobuf/highlights.scm
index c35c430e3..15dd7bb3a 100644
--- a/runtime/queries/protobuf/highlights.scm
+++ b/runtime/queries/protobuf/highlights.scm
@@ -1,5 +1,6 @@
 [
   "syntax"
+  "edition"
   "package"
   "option"
   "import"
@@ -7,44 +8,45 @@
   "rpc"
   "returns"
   "message"
+  "map"
   "enum"
   "oneof"
   "repeated"
+  "optional"
+  "required"
   "reserved"
   "to"
   "stream"
   "extend"
-  "optional"
 ] @keyword
 
 [
-  (keyType)
+  (key_type)
   (type)
+  (message_or_enum_type)
 ] @type.builtin
 
 [
-  (mapName)
-  (enumName)
-  (messageName)
-  (extendName)
-  (serviceName)
-  (rpcName)
+  (enum_name)
+  (message_name)
+  (service_name)
+  (rpc_name)
 ] @type
 
 [
-  (fieldName)
-  (optionName)
+  (field_name)
+  (option_name)
 ] @variable.other.member
-(enumVariantName) @type.enum.variant
+(enum_variant_name) @type.enum.variant
 
-(fullIdent) @namespace
+(full_ident) @namespace
 
-(intLit) @constant.numeric.integer
-(floatLit) @constant.numeric.float
-(boolLit) @constant.builtin.boolean
-(strLit) @string
+(int_lit) @constant.numeric.integer
+(float_lit) @constant.numeric.float
+(bool) @constant.builtin.boolean
+(string) @string
 
-(constant) @constant
+(block_lit) @constant
 
 (comment) @comment
 
@@ -55,4 +57,8 @@
   "]"
   "{"
   "}"
-]  @punctuation.bracket
\ No newline at end of file
+]  @punctuation.bracket
+
+"=" @operator
+
+";" @punctuation.delimiter
diff --git a/runtime/queries/protobuf/indents.scm b/runtime/queries/protobuf/indents.scm
index d457d75f1..d55e81b2d 100644
--- a/runtime/queries/protobuf/indents.scm
+++ b/runtime/queries/protobuf/indents.scm
@@ -1,10 +1,10 @@
 [
-  (messageBody)
-  (enumBody)
-  (oneofBody)
-  (serviceBody)
-  (rpcBody)
-  (msgLit)
+  (message_body)
+  (enum_body)
+  (oneof_body)
+  (service_body)
+  (rpc_body)
+  (block_lit)
 ] @indent
 
 "}" @outdent
diff --git a/runtime/queries/protobuf/textobjects.scm b/runtime/queries/protobuf/textobjects.scm
index 6f06b1349..7b0cfb198 100644
--- a/runtime/queries/protobuf/textobjects.scm
+++ b/runtime/queries/protobuf/textobjects.scm
@@ -1,9 +1,9 @@
-(message (messageBody) @class.inside) @class.around
-(enum (enumBody) @class.inside) @class.around
-(service (serviceBody) @class.inside) @class.around
+(message (message_body) @class.inside) @class.around
+(enum (enum_body) @class.inside) @class.around
+(service (service_body) @class.inside) @class.around
 
-(rpc (enumMessageType) @parameter.inside) @function.inside
-(rpc (enumMessageType) @parameter.around) @function.around
+(rpc (message_or_enum_type) @parameter.inside) @function.inside
+(rpc (message_or_enum_type) @parameter.around) @function.around
 
 (comment) @comment.inside
 (comment)+ @comment.around
diff --git a/runtime/queries/purescript/highlights.scm b/runtime/queries/purescript/highlights.scm
index b7868e6e7..314fb3132 100644
--- a/runtime/queries/purescript/highlights.scm
+++ b/runtime/queries/purescript/highlights.scm
@@ -1,19 +1,3 @@
-; ----------------------------------------------------------------------------
-; Record fields would need to come before literal strings in order to be captured correctly
-
- (record_accessor
-    field: [ (variable)
-             (string)
-             (triple_quote_string)
-           ] @variable.other.member)
-
- (exp_record_access
-    field: [ (variable)
-             (string)
-             (triple_quote_string)
-           ] @variable.other.member)
-
-
 ; ----------------------------------------------------------------------------
 ; Literals and comments
 
@@ -21,6 +5,7 @@
  (exp_negation) @constant.numeric.integer
  (exp_literal (number)) @constant.numeric.float
  (char) @constant.character
+
  [
    (string)
    (triple_quote_string)
@@ -28,7 +13,6 @@
 
  (comment) @comment
 
-
 ; ----------------------------------------------------------------------------
 ; Punctuation
 
@@ -41,18 +25,19 @@
    "]"
  ] @punctuation.bracket
 
- [
- (comma)
- ";"
- ] @punctuation.delimiter
+ (comma) @punctuation.delimiter
 
+; ----------------------------------------------------------------------------
+; Types
+
+ (type) @type
+
+ (constructor) @constructor
 
 ; ----------------------------------------------------------------------------
 ; Keywords, operators, includes
 
- ; This needs to come before the other "else" in
- ; order to be highlighted correctly
- (class_instance "else" @keyword)
+ (module) @namespace
 
  [
    "if"
@@ -95,7 +80,6 @@
  ] @operator
 
  (qualified_module (module) @constructor)
- (module) @namespace
  (qualified_type (module) @namespace)
  (qualified_variable (module) @namespace)
  (import (module) @namespace)
@@ -122,6 +106,11 @@
    "infixr"
  ] @keyword
 
+ ; NOTE
+ ; Needs to come after the other `else` in
+ ; order to be highlighted correctly
+ (class_instance "else" @keyword)
+
  (type_role_declaration
    "role" @keyword
    role: (type_role) @keyword)
@@ -131,10 +120,27 @@
 ; ----------------------------------------------------------------------------
 ; Functions and variables
 
+ (variable) @variable
+
  (row_field (field_name) @variable.other.member)
  (record_field (field_name) @variable.other.member)
  (record_field (field_pun) @variable.other.member)
 
+ ; NOTE
+ ; Record fields must come after literal strings and
+ ; plain variables in order to be highlighted correctly
+ (record_accessor
+    field: [ (variable)
+             (string)
+             (triple_quote_string)
+           ] @variable.other.member)
+
+ (exp_record_access
+    field: [ (variable)
+             (string)
+             (triple_quote_string)
+           ] @variable.other.member)
+
  (signature name: (variable) @type)
  (function name: (variable) @function)
  (class_instance (instance_name) @function)
@@ -151,14 +157,5 @@
  (exp_ticked (exp_name (variable) @operator))
  (exp_ticked (exp_name (qualified_variable (variable) @operator)))
 
- (variable) @variable
-
- ("@" @namespace)  ; "as" pattern operator, e.g. x@Constructor
-
-; ----------------------------------------------------------------------------
-; Types
-
- (type) @type
-
- (constructor) @constructor
+ (patterns (pat_as "@" @namespace))
 
diff --git a/runtime/queries/python/highlights.scm b/runtime/queries/python/highlights.scm
index 9f7d2790c..e9e81aae6 100644
--- a/runtime/queries/python/highlights.scm
+++ b/runtime/queries/python/highlights.scm
@@ -1,125 +1,8 @@
-; Imports
-
-(dotted_name
-  (identifier)* @namespace)
-
-(aliased_import
-  alias: (identifier) @namespace)
-
-; Builtin functions
-
-((call
-  function: (identifier) @function.builtin)
- (#match?
-   @function.builtin
-   "^(abs|all|any|ascii|bin|bool|breakpoint|bytearray|bytes|callable|chr|classmethod|compile|complex|delattr|dict|dir|divmod|enumerate|eval|exec|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|iter|len|list|locals|map|max|memoryview|min|next|object|oct|open|ord|pow|print|property|range|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|vars|zip|__import__)$"))
-
-; Function calls
-
-[
-  "def"
-  "lambda"
-] @keyword.function
-
-(call
-  function: (attribute attribute: (identifier) @constructor)
- (#match? @constructor "^[A-Z]"))
-(call
-  function: (identifier) @constructor
- (#match? @constructor "^[A-Z]"))
-
-(call
-  function: (attribute attribute: (identifier) @function.method))
-
-(call
-  function: (identifier) @function)
-
-; Function definitions
-
-(function_definition
-  name: (identifier) @constructor
- (#match? @constructor "^(__new__|__init__)$"))
-
-(function_definition
-  name: (identifier) @function)
-
-; Decorators
-
-(decorator) @function
-(decorator (identifier) @function)
-(decorator (attribute attribute: (identifier) @function))
-(decorator (call
-  function: (attribute attribute: (identifier) @function)))
-
-; Parameters
-
-((identifier) @variable.builtin
- (#match? @variable.builtin "^(self|cls)$"))
-
-(parameters (identifier) @variable.parameter)
-(parameters (typed_parameter (identifier) @variable.parameter))
-(parameters (default_parameter name: (identifier) @variable.parameter))
-(parameters (typed_default_parameter name: (identifier) @variable.parameter))
-
-(parameters
-  (list_splat_pattern ; *args
-    (identifier) @variable.parameter))
-(parameters
-  (dictionary_splat_pattern ; **kwargs
-    (identifier) @variable.parameter))
-
-(lambda_parameters
-  (identifier) @variable.parameter)
-
-; Types
-
-((identifier) @type.builtin
- (#match?
-   @type.builtin
-   "^(bool|bytes|dict|float|frozenset|int|list|set|str|tuple)$"))
-
-; In type hints make everything types to catch non-conforming identifiers
-; (e.g., datetime.datetime) and None
-(type [(identifier) (none)] @type)
-; Handle [] . and | nesting 4 levels deep
-(type
-  (_ [(identifier) (none)]? @type
-    (_ [(identifier) (none)]? @type
-      (_ [(identifier) (none)]? @type
-        (_ [(identifier) (none)]? @type)))))
-
-(class_definition name: (identifier) @type)
-(class_definition superclasses: (argument_list (identifier) @type))
-
-; Variables
-
-((identifier) @constant
- (#match? @constant "^_*[A-Z][A-Z\\d_]*$"))
-
-((identifier) @type
- (#match? @type "^[A-Z]"))
-
-(attribute attribute: (identifier) @variable.other.member)
-(identifier) @variable
-
-; Literals
-(none) @constant.builtin
-[
-  (true)
-  (false)
-] @constant.builtin.boolean
-
-(integer) @constant.numeric.integer
-(float) @constant.numeric.float
-(comment) @comment
-(string) @string
-(escape_sequence) @constant.character.escape
-
 ["," "." ":" ";" (ellipsis)] @punctuation.delimiter
+["(" ")" "[" "]" "{" "}"] @punctuation.bracket
 (interpolation
   "{" @punctuation.special
   "}" @punctuation.special) @embedded
-["(" ")" "[" "]" "{" "}"] @punctuation.bracket
 
 [
   "-"
@@ -223,8 +106,126 @@
   "is"
 ] @keyword.operator
 
+; Literals
+(none) @constant.builtin
+[
+  (true)
+  (false)
+] @constant.builtin.boolean
+
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(comment) @comment
+(string) @string
+(escape_sequence) @constant.character.escape
+
+; Variables
+
+(identifier) @variable
+
+(attribute attribute: (identifier) @variable.other.member)
+
+; Imports
+
+(dotted_name
+  (identifier)* @namespace)
+
+(aliased_import
+  alias: (identifier) @namespace)
+
+; Function calls
+
+[
+  "def"
+  "lambda"
+] @keyword.function
+
+(call
+  function: (attribute attribute: (identifier) @function.method))
+
+(call
+  function: (identifier) @function)
+
+(call
+  function: (attribute attribute: (identifier) @constructor)
+ (#match? @constructor "^[A-Z]"))
+(call
+  function: (identifier) @constructor
+ (#match? @constructor "^[A-Z]"))
+
+; Builtin functions
+
+((call
+  function: (identifier) @function.builtin)
+ (#match?
+   @function.builtin
+   "^(abs|all|any|ascii|bin|bool|breakpoint|bytearray|bytes|callable|chr|classmethod|compile|complex|delattr|dict|dir|divmod|enumerate|eval|exec|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|iter|len|list|locals|map|max|memoryview|min|next|object|oct|open|ord|pow|print|property|range|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|vars|zip|__import__)$"))
+
+; Function definitions
+
+(function_definition
+  name: (identifier) @function)
+
+(function_definition
+  name: (identifier) @constructor
+ (#match? @constructor "^(__new__|__init__)$"))
+
+; Decorators
+
+(decorator) @function
+(decorator (identifier) @function)
+(decorator (attribute attribute: (identifier) @function))
+(decorator (call
+  function: (attribute attribute: (identifier) @function)))
+
+; Parameters
+
+(parameters (identifier) @variable.parameter)
+(parameters (typed_parameter (identifier) @variable.parameter))
+(parameters (default_parameter name: (identifier) @variable.parameter))
+(parameters (typed_default_parameter name: (identifier) @variable.parameter))
+
+(parameters
+  (list_splat_pattern ; *args
+    (identifier) @variable.parameter))
+(parameters
+  (dictionary_splat_pattern ; **kwargs
+    (identifier) @variable.parameter))
+
+(lambda_parameters
+  (identifier) @variable.parameter)
+
+; Builtins, constants, etc.
+
+((identifier) @variable.builtin
+ (#match? @variable.builtin "^(self|cls)$"))
+
 ((identifier) @type.builtin
   (#match? @type.builtin
     "^(BaseException|Exception|ArithmeticError|BufferError|LookupError|AssertionError|AttributeError|EOFError|FloatingPointError|GeneratorExit|ImportError|ModuleNotFoundError|IndexError|KeyError|KeyboardInterrupt|MemoryError|NameError|NotImplementedError|OSError|OverflowError|RecursionError|ReferenceError|RuntimeError|StopIteration|StopAsyncIteration|SyntaxError|IndentationError|TabError|SystemError|SystemExit|TypeError|UnboundLocalError|UnicodeError|UnicodeEncodeError|UnicodeDecodeError|UnicodeTranslateError|ValueError|ZeroDivisionError|EnvironmentError|IOError|WindowsError|BlockingIOError|ChildProcessError|ConnectionError|BrokenPipeError|ConnectionAbortedError|ConnectionRefusedError|ConnectionResetError|FileExistsError|FileNotFoundError|InterruptedError|IsADirectoryError|NotADirectoryError|PermissionError|ProcessLookupError|TimeoutError|Warning|UserWarning|DeprecationWarning|PendingDeprecationWarning|SyntaxWarning|RuntimeWarning|FutureWarning|ImportWarning|UnicodeWarning|BytesWarning|ResourceWarning)$"))
 
-(ERROR) @error
+((identifier) @type
+ (#match? @type "^[A-Z]"))
+
+((identifier) @constant
+ (#match? @constant "^_*[A-Z][A-Z\\d_]*$"))
+
+; Types
+
+((identifier) @type.builtin
+ (#match?
+   @type.builtin
+   "^(bool|bytes|dict|float|frozenset|int|list|set|str|tuple)$"))
+
+; In type hints make everything types to catch non-conforming identifiers
+; (e.g., datetime.datetime) and None
+(type [(identifier) (none)] @type)
+; Handle [] . and | nesting 4 levels deep
+(type
+  (_ [(identifier) (none)]? @type
+    (_ [(identifier) (none)]? @type
+      (_ [(identifier) (none)]? @type
+        (_ [(identifier) (none)]? @type)))))
+
+(class_definition name: (identifier) @type)
+(class_definition superclasses: (argument_list (identifier) @type))
diff --git a/runtime/queries/quint/highlights.scm b/runtime/queries/quint/highlights.scm
new file mode 100644
index 000000000..edb56fbad
--- /dev/null
+++ b/runtime/queries/quint/highlights.scm
@@ -0,0 +1,94 @@
+[
+  "module"
+  "type"
+  "assume"
+  "const"
+  "var"
+  "val"
+  "nondet"
+  "def"
+  "pure"
+  "action"
+  "temporal"
+  "run"
+] @keyword
+
+(match_expr "match" @keyword.control.conditional)
+
+(if_else_condition 
+  "if" @keyword.control.conditional
+  "else" @keyword.control.conditional)
+
+(import "import" @keyword.control.import)
+(import "as" @keyword.control.import)
+(import "from" @keyword.control.import)
+(export "export" @keyword.control.import)
+(export "as" @keyword.control.import)
+
+[
+  "true"
+  "false"
+  "Int"
+  "Nat"
+  "Bool"
+] @constant.builtin
+
+[
+  ";"
+  "."
+  ","
+] @punctuation.delimiter
+
+[
+  "-"
+  "+"
+  "*"
+  "/"
+  "%"
+  "<"
+  "<="
+  "="
+  "=="
+  "!="
+  "=>"
+  ">"
+  ">="
+  "^"
+  "->"
+] @operator
+
+(infix_and "and" @operator)
+(infix_or "or" @operator)
+(infix_iff "iff" @operator)
+(infix_implies "implies" @operator)
+
+(braced_and "and" @keyword)
+(braced_or "or" @keyword)
+(braced_all "all" @keyword)
+(braced_any "any" @keyword)
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+] @punctuation.bracket
+
+(polymorphic_type 
+  (type) @type.parameter)
+
+(variant_constructor) @type.enum.variant
+
+(type) @type
+(int_literal) @constant.numeric.integer
+(comment) @comment
+(string) @string
+
+(operator_application
+  operator: (qualified_identifier) @function)
+
+(operator_definition
+  name: (qualified_identifier) @function
+  arguments: (typed_argument_list))
diff --git a/runtime/queries/r/highlights.scm b/runtime/queries/r/highlights.scm
index 4b931a053..29526bcfe 100644
--- a/runtime/queries/r/highlights.scm
+++ b/runtime/queries/r/highlights.scm
@@ -1,5 +1,6 @@
 ; highlights.scm
 
+(identifier) @variable
 
 ; Literals
 
@@ -121,8 +122,3 @@
 
 (namespace_get function: (identifier) @function.method)
 (namespace_get_internal function: (identifier) @function.method)
-
-(identifier) @variable
-
-; Error
-(ERROR) @error
diff --git a/runtime/queries/regex/highlights.scm b/runtime/queries/regex/highlights.scm
index 302cc6b31..0e81a3e74 100644
--- a/runtime/queries/regex/highlights.scm
+++ b/runtime/queries/regex/highlights.scm
@@ -50,4 +50,3 @@
   ])
 
 (class_character) @constant.character
-(ERROR) @error
diff --git a/runtime/queries/rescript/highlights.scm b/runtime/queries/rescript/highlights.scm
index ed41322b4..8decebb44 100644
--- a/runtime/queries/rescript/highlights.scm
+++ b/runtime/queries/rescript/highlights.scm
@@ -1,5 +1,69 @@
 (comment) @comment
 
+[
+  "."
+  ","
+  "|"
+] @punctuation.delimiter
+
+[
+  "++"
+  "+"
+  "+."
+  "-"
+  "-."
+  "*"
+  "**"
+  "*."
+  "/."
+  "<="
+  "=="
+  "==="
+  "!"
+  "!="
+  "!=="
+  ">="
+  "&&"
+  "||"
+  "="
+  ":="
+  "->"
+  "|>"
+  ":>"
+  "+="
+  (uncurry)
+] @operator
+
+; Explicitly enclose these operators with binary_expression
+; to avoid confusion with JSX tag delimiters
+(binary_expression ["<" ">" "/"] @operator)
+
+[
+  "("
+  ")"
+  "{"
+  "}"
+  "["
+  "]"
+] @punctuation.bracket
+
+(polyvar_type
+  [
+   "["
+   "[>"
+   "[<"
+   "]"
+  ] @punctuation.bracket)
+
+[
+  "~"
+  "?"
+  "=>"
+  ".."
+  "..."
+] @punctuation.special
+
+
 ; Identifiers
 ;------------
 
@@ -10,11 +74,10 @@
 [
   (type_identifier)
   (unit_type)
+  (list)
+  (list_pattern)
 ] @type
 
-(list ["list{" "}"] @type)
-(list_pattern ["list{" "}"] @type)
-
 [
   (variant_identifier)
   (polyvar_identifier)
@@ -72,14 +135,16 @@
 ; single parameter with no parens
 (function parameter: (value_identifier) @variable.parameter)
 
+; first-level descructuring (required for nvim-tree-sitter as it only matches direct
+; children and the above patterns do not match destructuring patterns in NeoVim)
+(parameter (tuple_pattern (tuple_item_pattern (value_identifier) @variable.parameter)))
+(parameter (array_pattern (value_identifier) @variable.parameter))
+(parameter (record_pattern (value_identifier) @variable.parameter))
+
 ; Meta
 ;-----
 
-[
- "@"
- "@@"
- (decorator_identifier)
-] @keyword.directive
+(decorator_identifier) @keyword.directive
 
 (extension_identifier) @keyword
 ("%") @keyword
@@ -87,7 +152,7 @@
 ; Misc
 ;-----
 
-; (subscript_expression index: (string) @attribute)
+(subscript_expression index: (string) @attribute)
 (polyvar_type_pattern "#" @constant)
 
 [
@@ -101,18 +166,21 @@
   "external"
   "let"
   "module"
+  "mutable"
   "private"
   "rec"
   "type"
   "and"
   "assert"
-  "async"
   "await"
   "with"
-  "unpack"
-] @keyword.storage.type
+  "lazy"
+  "constraint"
+] @keyword
 
-"mutable" @keyword.storage.modifier
+((function "async" @keyword.storage))
+
+(module_unpack "unpack" @keyword)
 
 [
   "if"
@@ -139,68 +207,6 @@
   "while"
 ] @keyword.control.conditional
 
-[
-  "."
-  ","
-  "|"
-] @punctuation.delimiter
-
-[
-  "++"
-  "+"
-  "+."
-  "-"
-  "-."
-  "*"
-  "**"
-  "*."
-  "/."
-  "<="
-  "=="
-  "==="
-  "!"
-  "!="
-  "!=="
-  ">="
-  "&&"
-  "||"
-  "="
-  ":="
-  "->"
-  "|>"
-  ":>"
-  (uncurry)
-] @operator
-
-; Explicitly enclose these operators with binary_expression
-; to avoid confusion with JSX tag delimiters
-(binary_expression ["<" ">" "/"] @operator)
-
-[
-  "("
-  ")"
-  "{"
-  "}"
-  "["
-  "]"
-] @punctuation.bracket
-
-(polyvar_type
-  [
-   "["
-   "[>"
-   "[<"
-   "]"
-  ] @punctuation.bracket)
-
-[
-  "~"
-  "?"
-  "=>"
-  ".."
-  "..."
-] @punctuation.special
-
 (ternary_expression ["?" ":"] @operator)
 
 ; JSX
@@ -213,8 +219,3 @@
 (jsx_self_closing_element ["/" ">" "<"] @punctuation.special)
 (jsx_fragment [">" "<" "/"] @punctuation.special)
 (jsx_attribute (property_identifier) @attribute)
-
-; Error
-;----------
-
-(ERROR) @keyword.control.exception
diff --git a/runtime/queries/rescript/injections.scm b/runtime/queries/rescript/injections.scm
index 03e29b008..67f530d3b 100644
--- a/runtime/queries/rescript/injections.scm
+++ b/runtime/queries/rescript/injections.scm
@@ -1,8 +1,29 @@
-((comment) @injection.content
- (#set! injection.language "comment"))
+((comment) @injection.content (#set! injection.language "comment"))
 
-((raw_js) @injection.content
- (#set! injection.language "javascript"))
+; %re
+(extension_expression
+  (extension_identifier) @_name
+  (#eq? @_name "re")
+  (expression_statement (_) @injection.content (#set! injection.language "regex")))
+
+; %raw
+(extension_expression
+  (extension_identifier) @_name
+  (#eq? @_name "raw")
+  (expression_statement
+    (_ (_)  @injection.content (#set! injection.language "javascript"))))
+
+; %graphql
+(extension_expression
+  (extension_identifier) @_name
+  (#eq? @_name "graphql")
+  (expression_statement
+    (_ (_) @injection.content (#set! injection.language "graphql"))))
+
+; %relay
+(extension_expression
+  (extension_identifier) @_name
+  (#eq? @_name "relay")
+  (expression_statement
+    (_ (_) @injection.content (#set! injection.language "graphql") )))
 
-((raw_gql) @injection.content
- (#set! injection.language "graphql"))
\ No newline at end of file
diff --git a/runtime/queries/rescript/locals.scm b/runtime/queries/rescript/locals.scm
index 1240ed160..4de73890e 100644
--- a/runtime/queries/rescript/locals.scm
+++ b/runtime/queries/rescript/locals.scm
@@ -1,7 +1,7 @@
 (switch_expression) @local.scope
-(if_expression) @local.scope
 
 ; Definitions
 ;------------
-(type_declaration) @local.defintion
-(let_binding) @local.defintion
+(type_declaration) @local.definition
+(let_binding) @local.definition
+(module_declaration) @local.definition
diff --git a/runtime/queries/rescript/textobjects.scm b/runtime/queries/rescript/textobjects.scm
index 4f1d8c53a..32c77b8f9 100644
--- a/runtime/queries/rescript/textobjects.scm
+++ b/runtime/queries/rescript/textobjects.scm
@@ -1,7 +1,7 @@
 ; Classes (modules)
 ;------------------
 
-(module_declaration definition: ((_) @class.inside)) @class.around
+(module_binding definition: ((_) @class.inside)) @class.around
 
 ; Blocks
 ;-------
diff --git a/runtime/queries/ron/highlights.scm b/runtime/queries/ron/highlights.scm
index 1061d559a..fe0545cd8 100644
--- a/runtime/queries/ron/highlights.scm
+++ b/runtime/queries/ron/highlights.scm
@@ -1,21 +1,19 @@
-; Literals
-;------------
-
-(string) @string
-(boolean) @constant.builtin.boolean
-(integer) @constant.numeric.integer
-(float) @constant.numeric.float
-(char) @constant.character
-
 ; Structs
 ;------------
 
 (enum_variant) @type.enum.variant
 (struct_entry (_) @variable.other.member ":")
 (struct_name (identifier)) @type
+(unit_struct) @type.builtin
 
+; Literals
+;------------
 
-
+(string) @string
+(boolean) @constant.builtin.boolean
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(char) @constant.character
 
 ; Comments
 ;------------
@@ -37,6 +35,7 @@
 "{" @punctuation.bracket
 "}" @punctuation.bracket
 
+"-" @operator
 
 ; Special
 ;------------
diff --git a/runtime/queries/ruby/highlights.scm b/runtime/queries/ruby/highlights.scm
index 7c69276ba..35babfe32 100644
--- a/runtime/queries/ruby/highlights.scm
+++ b/runtime/queries/ruby/highlights.scm
@@ -1,3 +1,81 @@
+; Operators
+[
+":"
+"?"
+"~"
+"=>"
+"->"
+"!"
+] @operator
+
+(assignment
+  "=" @operator)
+
+(operator_assignment
+  operator: ["+=" "-=" "*=" "**=" "/=" "||=" "|=" "&&=" "&=" "%=" ">>=" "<<=" "^="] @operator)
+
+(binary
+  operator: ["/" "|" "==" "===" "||" "&&" ">>" "<<" "<" ">" "<=" ">=" "&" "^" "!~" "=~" "<=>" "**" "*" "!=" "%" "-" "+"] @operator)
+
+(range
+  operator: [".." "..."] @operator)
+
+[
+  ","
+  ";"
+  "."
+  "&."
+] @punctuation.delimiter
+
+[
+  "|"
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "%w("
+  "%i("
+] @punctuation.bracket
+
+; Identifiers
+
+[
+  (identifier)
+] @variable
+((identifier) @function.method
+ (#is-not? local))
+
+[
+  (class_variable)
+  (instance_variable)
+] @variable.other.member
+
+((identifier) @constant.builtin
+ (#match? @constant.builtin "^(__FILE__|__LINE__|__ENCODING__)$"))
+
+((constant) @constant.builtin
+ (#match? @constant.builtin "^(ENV|ARGV|ARGF|RUBY_PLATFORM|RUBY_RELEASE_DATE|RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING)$"))
+
+((constant) @constant
+ (#match? @constant "^[A-Z\\d_]+$"))
+
+(constant) @constructor
+
+(self) @variable.builtin
+(super) @function.builtin
+
+[(forward_parameter)(forward_argument)] @variable.parameter
+(keyword_parameter name:((_)":" @variable.parameter) @variable.parameter)
+(optional_parameter name:((_)"=" @operator) @variable.parameter)
+(optional_parameter name: (identifier) @variable.parameter)
+(splat_parameter name: (identifier) @variable.parameter) @variable.parameter
+(hash_splat_parameter name: (identifier) @variable.parameter) @variable.parameter
+(method_parameters (identifier) @variable.parameter)
+(block_parameter (identifier) @variable.parameter)
+(block_parameters (identifier) @variable.parameter)
+
 ; Keywords
 
 [
@@ -73,43 +151,6 @@
 (method name: [(identifier) (constant)] @function.method)
 (singleton_method name: [(identifier) (constant)] @function.method)
 
-; Identifiers
-
-[
-  (class_variable)
-  (instance_variable)
-] @variable.other.member
-
-((identifier) @constant.builtin
- (#match? @constant.builtin "^(__FILE__|__LINE__|__ENCODING__)$"))
-
-((constant) @constant.builtin
- (#match? @constant.builtin "^(ENV|ARGV|ARGF|RUBY_PLATFORM|RUBY_RELEASE_DATE|RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING)$"))
-
-((constant) @constant
- (#match? @constant "^[A-Z\\d_]+$"))
-
-(constant) @constructor
-
-(self) @variable.builtin
-(super) @function.builtin
-
-[(forward_parameter)(forward_argument)] @variable.parameter
-(keyword_parameter name:((_)":" @variable.parameter) @variable.parameter)
-(optional_parameter name:((_)"=" @operator) @variable.parameter)
-(optional_parameter name: (identifier) @variable.parameter)
-(splat_parameter name: (identifier) @variable.parameter) @variable.parameter
-(hash_splat_parameter name: (identifier) @variable.parameter) @variable.parameter
-(method_parameters (identifier) @variable.parameter)
-(block_parameter (identifier) @variable.parameter)
-(block_parameters (identifier) @variable.parameter)
-
-((identifier) @function.method
- (#is-not? local))
-[
-  (identifier)
-] @variable
-
 ; Literals
 
 [
@@ -147,44 +188,3 @@
   "}" @punctuation.special) @embedded
 
 (comment) @comment
-
-; Operators
-[
-":"
-"?"
-"~"
-"=>"
-"->"
-"!"
-] @operator
-
-(assignment
-  "=" @operator)
-
-(operator_assignment
-  operator: ["+=" "-=" "*=" "**=" "/=" "||=" "|=" "&&=" "&=" "%=" ">>=" "<<=" "^="] @operator)
-
-(binary
-  operator: ["/" "|" "==" "===" "||" "&&" ">>" "<<" "<" ">" "<=" ">=" "&" "^" "!~" "=~" "<=>" "**" "*" "!=" "%" "-" "+"] @operator)
-
-(range
-  operator: [".." "..."] @operator)
-
-[
-  ","
-  ";"
-  "."
-  "&."
-] @punctuation.delimiter
-
-[
-  "|"
-  "("
-  ")"
-  "["
-  "]"
-  "{"
-  "}"
-  "%w("
-  "%i("
-] @punctuation.bracket
diff --git a/runtime/queries/rust/highlights.scm b/runtime/queries/rust/highlights.scm
index 2981075fb..52c13dd77 100644
--- a/runtime/queries/rust/highlights.scm
+++ b/runtime/queries/rust/highlights.scm
@@ -1,10 +1,80 @@
 ; -------
-; Tree-Sitter doesn't allow overrides in regards to captures,
-; though it is possible to affect the child node of a captured
-; node. Thus, the approach here is to flip the order so that
-; overrides are unnecessary.
+; Basic identifiers
 ; -------
 
+; We do not style ? as an operator on purpose as it allows styling ? differently, as many highlighters do. @operator.special might have been a better scope, but @special is already documented so the change would break themes (including the intent of the default theme)
+"?" @special
+
+(type_identifier) @type
+(identifier) @variable
+(field_identifier) @variable.other.member
+
+; -------
+; Operators
+; -------
+
+[
+  "*"
+  "'"
+  "->"
+  "=>"
+  "<="
+  "="
+  "=="
+  "!"
+  "!="
+  "%"
+  "%="
+  "&"
+  "&="
+  "&&"
+  "|"
+  "|="
+  "||"
+  "^"
+  "^="
+  "*"
+  "*="
+  "-"
+  "-="
+  "+"
+  "+="
+  "/"
+  "/="
+  ">"
+  "<"
+  ">="
+  ">>"
+  "<<"
+  ">>="
+  "<<="
+  "@"
+  ".."
+  "..="
+  "'"
+] @operator
+
+; -------
+; Paths
+; -------
+
+(use_declaration
+  argument: (identifier) @namespace)
+(use_wildcard
+  (identifier) @namespace)
+(extern_crate_declaration
+  name: (identifier) @namespace
+  alias: (identifier)? @namespace)
+(mod_item
+  name: (identifier) @namespace)
+(scoped_use_list
+  path: (identifier)? @namespace)
+(use_list
+  (identifier) @namespace)
+(use_as_clause
+  path: (identifier)? @namespace
+  alias: (identifier) @namespace)
+
 ; -------
 ; Types
 ; -------
@@ -15,6 +85,12 @@
   left: (type_identifier) @type.parameter)
 (optional_type_parameter
   name: (type_identifier) @type.parameter)
+((type_arguments (type_identifier) @constant)
+ (#match? @constant "^[A-Z_]+$"))
+(type_arguments (type_identifier) @type)
+(tuple_struct_pattern "_" @comment.unused)
+((type_arguments (type_identifier) @comment.unused)
+ (#eq? @comment.unused "_"))
 
 ; ---
 ; Primitives
@@ -30,6 +106,8 @@
   (string_literal)
   (raw_string_literal)
 ] @string
+(outer_doc_comment_marker "/" @comment)
+(inner_doc_comment_marker "!" @comment)
 [
   (line_comment)
   (block_comment)
@@ -40,7 +118,6 @@
 ; ---
 
 (self) @variable.builtin
-(enum_variant (identifier) @type.enum.variant)
 
 (field_initializer
   (field_identifier) @variable.other.member)
@@ -55,55 +132,6 @@
   "'" @label
   (identifier) @label)
 
-; ---
-; Prelude
-; ---
-
-((identifier) @type.enum.variant.builtin
- (#any-of? @type.enum.variant.builtin "Some" "None" "Ok" "Err"))
-
-
-
-((type_identifier) @type.builtin
- (#any-of?
-    @type.builtin
-    "Send"
-    "Sized"
-    "Sync"
-    "Unpin"
-    "Drop"
-    "Fn"
-    "FnMut"
-    "FnOnce"
-    "AsMut"
-    "AsRef"
-    "From"
-    "Into"
-    "DoubleEndedIterator"
-    "ExactSizeIterator"
-    "Extend"
-    "IntoIterator"
-    "Iterator"
-    "Option"
-    "Result"
-    "Clone"
-    "Copy"
-    "Debug"
-    "Default"
-    "Eq"
-    "Hash"
-    "Ord"
-    "PartialEq"
-    "PartialOrd"
-    "ToOwned"
-    "Box"
-    "String"
-    "ToString"
-    "Vec"
-    "FromIterator"
-    "TryFrom"
-    "TryInto"))
-
 ; ---
 ; Punctuation
 ; ---
@@ -113,6 +141,7 @@
   "."
   ";"
   ","
+  ":"
 ] @punctuation.delimiter
 
 [
@@ -134,8 +163,10 @@
     "<"
     ">"
   ] @punctuation.bracket)
+(for_lifetimes ["<" ">"] @punctuation.bracket)
 (closure_parameters
   "|" @punctuation.bracket)
+(bracketed_type ["<" ">"] @punctuation.bracket)
 
 ; ---
 ; Variables
@@ -165,8 +196,7 @@
 
 (for_expression
   "for" @keyword.control.repeat)
-((identifier) @keyword.control
-  (#match? @keyword.control "^yield$"))
+(gen_block "gen" @keyword.control)
 
 "in" @keyword.control
 
@@ -187,6 +217,7 @@
   "continue"
   "return"
   "await"
+  "yield"
 ] @keyword.control.return
 
 "use" @keyword.control.import
@@ -195,6 +226,10 @@
 
 (type_cast_expression "as" @keyword.operator)
 
+((generic_type
+    type: (type_identifier) @keyword)
+ (#eq? @keyword "use"))
+
 [
   (crate)
   (super)
@@ -232,6 +267,7 @@
 [
   "static"
   "const"
+  "raw"
   "ref"
   "move"
   "dyn"
@@ -239,36 +275,52 @@
 
 ; TODO: variable.mut to highlight mutable identifiers via locals.scm
 
+; ---
+; Remaining Paths
+; ---
+
+(scoped_identifier
+  path: (identifier)? @namespace
+  name: (identifier) @namespace)
+(scoped_type_identifier
+  path: (identifier) @namespace)
+
 ; -------
-; Constructors
+; Functions
 ; -------
-; TODO: this is largely guesswork, remove it once we get actual info from locals.scm or r-a
-
-(struct_expression
-  name: (type_identifier) @constructor)
 
-(tuple_struct_pattern
-  type: [
-    (identifier) @constructor
+(call_expression
+  function: [
+    ((identifier) @function)
     (scoped_identifier
-      name: (identifier) @constructor)
+      name: (identifier) @function)
+    (field_expression
+      field: (field_identifier) @function)
   ])
-(struct_pattern
-  type: [
-    ((type_identifier) @constructor)
-    (scoped_type_identifier
-      name: (type_identifier) @constructor)
+(generic_function
+  function: [
+    ((identifier) @function)
+    (scoped_identifier
+      name: (identifier) @function)
+    (field_expression
+      field: (field_identifier) @function.method)
   ])
-(match_pattern
-  ((identifier) @constructor) (#match? @constructor "^[A-Z]"))
-(or_pattern
-  ((identifier) @constructor)
-  ((identifier) @constructor)
-  (#match? @constructor "^[A-Z]"))
+
+(function_item
+  name: (identifier) @function)
+
+(function_signature_item
+  name: (identifier) @function)
 
 ; -------
 ; Guess Other Types
 ; -------
+; Other PascalCase identifiers are assumed to be structs.
+
+((identifier) @type
+  (#match? @type "^[A-Z]"))
+
+(never_type "!" @type)
 
 ((identifier) @constant
  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
@@ -303,52 +355,43 @@
       (#match? @type "^[A-Z]")
       (#match? @constructor "^[A-Z]")))
 
-; ---
-; Other PascalCase identifiers are assumed to be structs.
-; ---
+(enum_variant (identifier) @type.enum.variant)
 
-((identifier) @type
-  (#match? @type "^[A-Z]"))
 
 ; -------
-; Functions
+; Constructors
 ; -------
+; TODO: this is largely guesswork, remove it once we get actual info from locals.scm or r-a
 
-(call_expression
-  function: [
-    ((identifier) @function)
+(struct_expression
+  name: (type_identifier) @constructor)
+
+(tuple_struct_pattern
+  type: [
+    (identifier) @constructor
     (scoped_identifier
-      name: (identifier) @function)
-    (field_expression
-      field: (field_identifier) @function)
+      name: (identifier) @constructor)
   ])
-(generic_function
-  function: [
-    ((identifier) @function)
-    (scoped_identifier
-      name: (identifier) @function)
-    (field_expression
-      field: (field_identifier) @function.method)
+(struct_pattern
+  type: [
+    ((type_identifier) @constructor)
+    (scoped_type_identifier
+      name: (type_identifier) @constructor)
   ])
-
-(function_item
-  name: (identifier) @function)
-
-(function_signature_item
-  name: (identifier) @function)
+(match_pattern
+  ((identifier) @constructor) (#match? @constructor "^[A-Z]"))
+(or_pattern
+  ((identifier) @constructor)
+  ((identifier) @constructor)
+  (#match? @constructor "^[A-Z]"))
 
 ; ---
 ; Macros
 ; ---
 
-(attribute
-  (identifier) @special
-  arguments: (token_tree (identifier) @type)
-  (#eq? @special "derive")
-)
-
 (attribute
   (identifier) @function.macro)
+(inner_attribute_item "!" @punctuation)
 (attribute
   [
     (identifier) @function.macro
@@ -372,88 +415,65 @@
 (metavariable) @variable.parameter
 (fragment_specifier) @type
 
-; -------
-; Operators
-; -------
-
-[
-  "*"
-  "'"
-  "->"
-  "=>"
-  "<="
-  "="
-  "=="
-  "!"
-  "!="
-  "%"
-  "%="
-  "&"
-  "&="
-  "&&"
-  "|"
-  "|="
-  "||"
-  "^"
-  "^="
-  "*"
-  "*="
-  "-"
-  "-="
-  "+"
-  "+="
-  "/"
-  "/="
-  ">"
-  "<"
-  ">="
-  ">>"
-  "<<"
-  ">>="
-  "<<="
-  "@"
-  ".."
-  "..="
-  "'"
-] @operator
-
-; -------
-; Paths
-; -------
-
-(use_declaration
-  argument: (identifier) @namespace)
-(use_wildcard
-  (identifier) @namespace)
-(extern_crate_declaration
-  name: (identifier) @namespace
-  alias: (identifier)? @namespace)
-(mod_item
-  name: (identifier) @namespace)
-(scoped_use_list
-  path: (identifier)? @namespace)
-(use_list
-  (identifier) @namespace)
-(use_as_clause
-  path: (identifier)? @namespace
-  alias: (identifier) @namespace)
+(attribute
+  (identifier) @special
+  arguments: (token_tree (identifier) @type)
+  (#eq? @special "derive")
+)
 
 ; ---
-; Remaining Paths
+; Prelude
 ; ---
 
-(scoped_identifier
-  path: (identifier)? @namespace
-  name: (identifier) @namespace)
-(scoped_type_identifier
-  path: (identifier) @namespace)
+((identifier) @type.enum.variant.builtin
+ (#any-of? @type.enum.variant.builtin "Some" "None" "Ok" "Err"))
 
-; -------
-; Remaining Identifiers
-; -------
 
-"?" @special
+(call_expression
+  (identifier) @function.builtin
+  (#any-of? @function.builtin
+    "drop"
+    "size_of"
+    "size_of_val"
+    "align_of"
+    "align_of_val"))
 
-(type_identifier) @type
-(identifier) @variable
-(field_identifier) @variable.other.member
+((type_identifier) @type.builtin
+ (#any-of?
+    @type.builtin
+    "Send"
+    "Sized"
+    "Sync"
+    "Unpin"
+    "Drop"
+    "Fn"
+    "FnMut"
+    "FnOnce"
+    "AsMut"
+    "AsRef"
+    "From"
+    "Into"
+    "DoubleEndedIterator"
+    "ExactSizeIterator"
+    "Extend"
+    "IntoIterator"
+    "Iterator"
+    "Option"
+    "Result"
+    "Clone"
+    "Copy"
+    "Debug"
+    "Default"
+    "Eq"
+    "Hash"
+    "Ord"
+    "PartialEq"
+    "PartialOrd"
+    "ToOwned"
+    "Box"
+    "String"
+    "ToString"
+    "Vec"
+    "FromIterator"
+    "TryFrom"
+    "TryInto"))
diff --git a/runtime/queries/rust/textobjects.scm b/runtime/queries/rust/textobjects.scm
index de517d362..e9ecb8baa 100644
--- a/runtime/queries/rust/textobjects.scm
+++ b/runtime/queries/rust/textobjects.scm
@@ -69,7 +69,7 @@
 (tuple_pattern
   (_) @entry.around)
 
-; Commonly used vec macro intializer is special cased
+; Commonly used vec macro initializer is special cased
 (macro_invocation
   (identifier) @_id (token_tree (_) @entry.around)
   (#eq? @_id "vec"))
diff --git a/runtime/queries/scala/highlights.scm b/runtime/queries/scala/highlights.scm
index e21a3909d..5e5d63e47 100644
--- a/runtime/queries/scala/highlights.scm
+++ b/runtime/queries/scala/highlights.scm
@@ -2,6 +2,9 @@
 
 ;; variables
 
+(identifier) @variable
+
+(operator_identifier) @operator
 
 ((identifier) @variable.builtin
  (#match? @variable.builtin "^this$"))
@@ -262,7 +265,3 @@
 
 (case_block
   (case_clause ("case") @keyword.control.conditional))
-
-(identifier) @variable
-
-(operator_identifier) @operator
diff --git a/runtime/queries/scheme/highlights.scm b/runtime/queries/scheme/highlights.scm
index c7050847f..a0c15a121 100644
--- a/runtime/queries/scheme/highlights.scm
+++ b/runtime/queries/scheme/highlights.scm
@@ -10,32 +10,28 @@
 (block_comment) @comment.block
 (directive) @keyword.directive
 
-; operators
+; variables
 
-((symbol) @operator
- (#match? @operator "^(\\+|-|\\*|/|=|>|<|>=|<=)$"))
+((symbol) @variable.builtin
+ (#eq? @variable.builtin "..."))
 
-; keywords
+((symbol) @variable.builtin
+ (#eq? @variable.builtin "."))
 
-(list
-  .
-  ((symbol) @keyword.conditional
-   (#match? @keyword.conditional "^(if|cond|case|when|unless)$"
-  )))
- 
-(list
-  .
-  (symbol) @keyword
-  (#match? @keyword
-   "^(define-syntax|let\\*|lambda||case|=>|quote-splicing|unquote-splicing|set!|let|letrec|letrec-syntax|let-values|let\\*-values|do|else|define|cond|syntax-rules|unquote|begin|quote|let-syntax|and|if|quasiquote|letrec|delay|or|when|unless|identifier-syntax|assert|library|export|import|rename|only|except|prefix)$"
-   ))
+(symbol) @variable
+
+["(" ")" "[" "]" "{" "}"] @punctuation.bracket
+
+(quote "'") @operator
+(unquote_splicing ",@") @operator
+(unquote ",") @operator
+(quasiquote "`") @operator
+
+; procedure
 
 (list
   .
-  (symbol) @function.builtin
-  (#match? @function.builtin
-   "^(caar|cadr|call-with-input-file|call-with-output-file|cdar|cddr|list|open-input-file|open-output-file|with-input-from-file|with-output-to-file|\\*|\\+|-|/|<|<=|=|>|>=|abs|acos|angle|append|apply|asin|assoc|assq|assv|atan|boolean\\?|caaaar|caaadr|caaar|caadar|caaddr|caadr|cadaar|cadadr|cadar|caddar|cadddr|caddr|call-with-current-continuation|call-with-values|car|cdaaar|cdaadr|cdaar|cdadar|cdaddr|cdadr|cddaar|cddadr|cddar|cdddar|cddddr|cdddr|cdr|ceiling|char->integer|char-alphabetic\\?|char-ci<=\\?|char-ci<\\?|char-ci=\\?|char-ci>=\\?|char-ci>\\?|char-downcase|char-lower-case\\?|char-numeric\\?|char-ready\\?|char-upcase|char-upper-case\\?|char-whitespace\\?|char<=\\?|char<\\?|char=\\?|char>=\\?|char>\\?|char\\?|close-input-port|close-output-port|complex\\?|cons|cos|current-error-port|current-input-port|current-output-port|denominator|display|dynamic-wind|eof-object\\?|eq\\?|equal\\?|eqv\\?|eval|even\\?|exact->inexact|exact\\?|exp|expt|floor|flush-output|for-each|force|gcd|imag-part|inexact->exact|inexact\\?|input-port\\?|integer->char|integer\\?|interaction-environment|lcm|length|list->string|list->vector|list-ref|list-tail|list\\?|load|log|magnitude|make-polar|make-rectangular|make-string|make-vector|map|max|member|memq|memv|min|modulo|negative\\?|newline|not|null-environment|null\\?|number->string|number\\?|numerator|odd\\?|output-port\\?|pair\\?|peek-char|positive\\?|procedure\\?|quotient|rational\\?|rationalize|read|read-char|real-part|real\\?|remainder|reverse|round|scheme-report-environment|set-car!|set-cdr!|sin|sqrt|string|string->list|string->number|string->symbol|string-append|string-ci<=\\?|string-ci<\\?|string-ci=\\?|string-ci>=\\?|string-ci>\\?|string-copy|string-fill!|string-length|string-ref|string-set!|string<=\\?|string<\\?|string=\\?|string>=\\?|string>\\?|string\\?|substring|symbol->string|symbol\\?|tan|transcript-off|transcript-on|truncate|values|vector|vector->list|vector-fill!|vector-length|vector-ref|vector-set!|vector\\?|write|write-char|zero\\?)$"
-   ))
+  (symbol) @function)
 
 ; special forms
 
@@ -62,12 +58,10 @@
  (#match? @_f
   "^(let|let\\*|let-syntax|let-values|let\\*-values|letrec|letrec\\*|letrec-syntax)$"))
 
-; quote
+; operators
 
-(list
- .
- (symbol) @_f
- (#eq? @_f "quote")) @string.symbol
+((symbol) @operator
+ (#match? @operator "^(\\+|-|\\*|/|=|>|<|>=|<=)$"))
 
 ; library
 
@@ -79,26 +73,31 @@
 
  (#eq? @_lib "library"))
 
-; procedure
+; quote
 
 (list
-  .
-  (symbol) @function)
-
-;; variables
-
-((symbol) @variable.builtin
- (#eq? @variable.builtin "..."))
-
-((symbol) @variable.builtin
- (#eq? @variable.builtin "."))
-
-(symbol) @variable
+ .
+ (symbol) @_f
+ (#eq? @_f "quote")) @string.symbol
 
-["(" ")" "[" "]" "{" "}"] @punctuation.bracket
+; keywords
 
-(quote "'") @operator
-(unquote_splicing ",@") @operator
-(unquote ",") @operator
-(quasiquote "`") @operator
+(list
+  .
+  ((symbol) @keyword.conditional
+   (#match? @keyword.conditional "^(if|cond|case|when|unless)$"
+  )))
+ 
+(list
+  .
+  (symbol) @keyword
+  (#match? @keyword
+   "^(define-syntax|let\\*|lambda||case|=>|quote-splicing|unquote-splicing|set!|let|letrec|letrec-syntax|let-values|let\\*-values|do|else|define|cond|syntax-rules|unquote|begin|quote|let-syntax|and|if|quasiquote|letrec|delay|or|when|unless|identifier-syntax|assert|library|export|import|rename|only|except|prefix)$"
+   ))
 
+(list
+  .
+  (symbol) @function.builtin
+  (#match? @function.builtin
+   "^(caar|cadr|call-with-input-file|call-with-output-file|cdar|cddr|list|open-input-file|open-output-file|with-input-from-file|with-output-to-file|\\*|\\+|-|/|<|<=|=|>|>=|abs|acos|angle|append|apply|asin|assoc|assq|assv|atan|boolean\\?|caaaar|caaadr|caaar|caadar|caaddr|caadr|cadaar|cadadr|cadar|caddar|cadddr|caddr|call-with-current-continuation|call-with-values|car|cdaaar|cdaadr|cdaar|cdadar|cdaddr|cdadr|cddaar|cddadr|cddar|cdddar|cddddr|cdddr|cdr|ceiling|char->integer|char-alphabetic\\?|char-ci<=\\?|char-ci<\\?|char-ci=\\?|char-ci>=\\?|char-ci>\\?|char-downcase|char-lower-case\\?|char-numeric\\?|char-ready\\?|char-upcase|char-upper-case\\?|char-whitespace\\?|char<=\\?|char<\\?|char=\\?|char>=\\?|char>\\?|char\\?|close-input-port|close-output-port|complex\\?|cons|cos|current-error-port|current-input-port|current-output-port|denominator|display|dynamic-wind|eof-object\\?|eq\\?|equal\\?|eqv\\?|eval|even\\?|exact->inexact|exact\\?|exp|expt|floor|flush-output|for-each|force|gcd|imag-part|inexact->exact|inexact\\?|input-port\\?|integer->char|integer\\?|interaction-environment|lcm|length|list->string|list->vector|list-ref|list-tail|list\\?|load|log|magnitude|make-polar|make-rectangular|make-string|make-vector|map|max|member|memq|memv|min|modulo|negative\\?|newline|not|null-environment|null\\?|number->string|number\\?|numerator|odd\\?|output-port\\?|pair\\?|peek-char|positive\\?|procedure\\?|quotient|rational\\?|rationalize|read|read-char|real-part|real\\?|remainder|reverse|round|scheme-report-environment|set-car!|set-cdr!|sin|sqrt|string|string->list|string->number|string->symbol|string-append|string-ci<=\\?|string-ci<\\?|string-ci=\\?|string-ci>=\\?|string-ci>\\?|string-copy|string-fill!|string-length|string-ref|string-set!|string<=\\?|string<\\?|string=\\?|string>=\\?|string>\\?|string\\?|substring|symbol->string|symbol\\?|tan|transcript-off|transcript-on|truncate|values|vector|vector->list|vector-fill!|vector-length|vector-ref|vector-set!|vector\\?|write|write-char|zero\\?)$"
+   ))
diff --git a/runtime/queries/scss/highlights.scm b/runtime/queries/scss/highlights.scm
index de20e0474..eb361f96a 100644
--- a/runtime/queries/scss/highlights.scm
+++ b/runtime/queries/scss/highlights.scm
@@ -43,6 +43,8 @@
 "@warn" @constant.builtin
 "@while" @keyword.control.repeat
 
+(property_name) @variable.other.member
+
 ((property_name) @variable
  (#match? @variable "^--"))
 ((plain_value) @variable
@@ -59,7 +61,6 @@
 (class_name) @variable
 (id_name) @variable
 (namespace_name) @variable
-(property_name) @variable.other.member
 (feature_name) @variable
 (variable) @variable
 (variable_name) @variable.other.member
diff --git a/runtime/queries/slint/textobjects.scm b/runtime/queries/slint/textobjects.scm
index 7e2f36096..258ce4e03 100644
--- a/runtime/queries/slint/textobjects.scm
+++ b/runtime/queries/slint/textobjects.scm
@@ -1,5 +1,5 @@
 (function_definition
-  (imperative_block) @funtion.inside) @function.around
+  (imperative_block) @function.inside) @function.around
 
 (callback_event
   (imperative_block) @function.inside) @function.around
diff --git a/runtime/queries/snakemake/LICENSE b/runtime/queries/snakemake/LICENSE
new file mode 100755
index 000000000..3dea16274
--- /dev/null
+++ b/runtime/queries/snakemake/LICENSE
@@ -0,0 +1,20 @@
+Copyright (c) 2016 Max Brunsfeld
+Copyright (c) 2023 Oliver Thomas
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/runtime/queries/snakemake/folds.scm b/runtime/queries/snakemake/folds.scm
new file mode 100755
index 000000000..d154f3cde
--- /dev/null
+++ b/runtime/queries/snakemake/folds.scm
@@ -0,0 +1,8 @@
+; inherits: python
+
+[
+  (rule_definition)
+  (rule_inheritance)
+  (module_definition)
+  (checkpoint_definition)
+] @fold
diff --git a/runtime/queries/snakemake/highlights.scm b/runtime/queries/snakemake/highlights.scm
new file mode 100755
index 000000000..18d81811f
--- /dev/null
+++ b/runtime/queries/snakemake/highlights.scm
@@ -0,0 +1,76 @@
+; inherits: python
+
+; Compound directives
+[
+  "rule"
+  "checkpoint"
+  "module"
+] @keyword
+
+; Top level directives (eg. configfile, include)
+(module
+  (directive
+    name: _ @keyword))
+
+; Subordinate directives (eg. input, output)
+((_)
+  body: (_
+    (directive
+      name: _ @label)))
+
+; rule/module/checkpoint names
+(rule_definition
+  name: (identifier) @type)
+
+(module_definition
+  name: (identifier) @type)
+
+(checkpoint_definition
+  name: (identifier) @type)
+
+; Rule imports
+(rule_import
+  "use" @keyword.import
+  "rule" @keyword.import
+  "from" @keyword.import
+  "exclude"? @keyword.import
+  "as"? @keyword.import
+  "with"? @keyword.import)
+
+; Rule inheritance
+(rule_inheritance
+  "use" @keyword
+  "rule" @keyword
+  "with" @keyword)
+
+; Wildcard names
+(wildcard (identifier) @variable)
+(wildcard (flag) @variable.parameter.builtin)
+
+; builtin variables
+((identifier) @variable.builtin
+  (#any-of? @variable.builtin "checkpoints" "config" "gather" "rules" "scatter" "workflow"))
+
+; References to directive labels in wildcard interpolations
+; the #any-of? queries are moved above the #has-ancestor? queries to
+; short-circuit the potentially expensive tree traversal, if possible
+; see:
+; https://github.com/nvim-treesitter/nvim-treesitter/pull/4302#issuecomment-1685789790
+; directive labels in wildcard context
+((wildcard
+  (identifier) @label)
+  (#any-of? @label "input" "log" "output" "params" "resources" "threads" "wildcards"))
+
+((wildcard
+  (attribute
+    object: (identifier) @label))
+  (#any-of? @label "input" "log" "output" "params" "resources" "threads" "wildcards"))
+
+((wildcard
+  (subscript
+    value: (identifier) @label))
+  (#any-of? @label "input" "log" "output" "params" "resources" "threads" "wildcards"))
+
+; directive labels in block context (eg. within 'run:')
+((identifier) @label
+  (#any-of? @label "input" "log" "output" "params" "resources" "threads" "wildcards"))
diff --git a/runtime/queries/snakemake/indents.scm b/runtime/queries/snakemake/indents.scm
new file mode 100755
index 000000000..6685fccb1
--- /dev/null
+++ b/runtime/queries/snakemake/indents.scm
@@ -0,0 +1,27 @@
+; inherits: python
+
+
+[
+  (rule_definition)
+  (checkpoint_definition)
+  (rule_inheritance)
+  (module_definition)
+] @indent
+
+[
+  (rule_definition)
+  (checkpoint_definition)
+  (rule_inheritance)
+  (module_definition)
+] @extend
+
+
+(directive) @indent
+(directive) @extend
+
+(rule_import
+  "with"
+  ":") @indent
+(rule_import
+  "with"
+  ":") @extend
diff --git a/runtime/queries/snakemake/injections.scm b/runtime/queries/snakemake/injections.scm
new file mode 100755
index 000000000..fa56daabb
--- /dev/null
+++ b/runtime/queries/snakemake/injections.scm
@@ -0,0 +1,5 @@
+; inherits: python
+
+(wildcard
+  (constraint) @injection.content
+  (#set! injection.language "regex"))
diff --git a/runtime/queries/snakemake/locals.scm b/runtime/queries/snakemake/locals.scm
new file mode 100755
index 000000000..0b920cbf9
--- /dev/null
+++ b/runtime/queries/snakemake/locals.scm
@@ -0,0 +1 @@
+; inherits: python
diff --git a/runtime/queries/solidity/highlights.scm b/runtime/queries/solidity/highlights.scm
index 73f354a25..0e49429df 100644
--- a/runtime/queries/solidity/highlights.scm
+++ b/runtime/queries/solidity/highlights.scm
@@ -1,17 +1,23 @@
+; identifiers
+; -----------
+(identifier) @variable
+((identifier) @variable.builtin (#any-of? @variable.builtin "this" "msg" "block" "tx"))
+(yul_identifier) @variable
+
 ; Pragma
 (pragma_directive) @keyword.directive
 (solidity_version_comparison_operator _ @keyword.directive)
 
-
 ; Literals
 ; --------
-
 [
  (string)
  (hex_string_literal)
  (unicode_string_literal)
  (yul_string_literal)
 ] @string
+(hex_string_literal "hex" @string.special.symbol)
+(unicode_string_literal "unicode" @string.special.symbol)
 [
  (number_literal)
  (yul_decimal_number)
@@ -20,14 +26,13 @@
 [
  (true)
  (false)
+ (yul_boolean)
 ] @constant.builtin.boolean
 
 (comment) @comment
 
-
 ; Definitions and references
 ; -----------
-
 (type_name) @type
 
 [
@@ -35,7 +40,8 @@
   (number_unit)
 ] @type.builtin
 
-(user_defined_type (identifier) @type)
+(user_defined_type (_) @type)
+(user_defined_type_definition name: (identifier) @type)
 (type_alias (identifier) @type)
 
 ; Color payable in payable address conversion as type and not as keyword
@@ -44,24 +50,15 @@
 (type_name "(" @punctuation.bracket "=>" @punctuation.delimiter ")" @punctuation.bracket)
 
 ; Definitions
-(struct_declaration 
-  name: (identifier) @type)
-(enum_declaration 
-  name: (identifier) @type)
-(contract_declaration
-  name: (identifier) @type) 
-(library_declaration
-  name: (identifier) @type) 
-(interface_declaration
-  name: (identifier) @type)
-(event_definition 
-  name: (identifier) @type) 
-
-(function_definition
-  name:  (identifier) @function)
-
-(modifier_definition
-  name:  (identifier) @function)
+(struct_declaration name: (identifier) @type)
+(enum_declaration name: (identifier) @type)
+(contract_declaration name: (identifier) @type)
+(library_declaration name: (identifier) @type)
+(interface_declaration name: (identifier) @type)
+(event_definition name: (identifier) @type)
+(error_declaration name: (identifier) @type)
+(function_definition name: (identifier) @function)
+(modifier_definition name: (identifier) @function)
 (yul_evm_builtin) @function.builtin
 
 ; Use constructor coloring for special functions
@@ -72,14 +69,16 @@
 
 (struct_member name: (identifier) @variable.other.member)
 (enum_value) @constant
+; SCREAMING_SNAKE_CASE identifier are constants
+((identifier) @constant (#match? @constant "^[A-Z][A-Z_]+$"))
 
 ; Invocations
-(emit_statement . (identifier) @type)
-(revert_statement error: (identifier) @type)
-(modifier_invocation (identifier) @function)
+(emit_statement name: (expression (identifier) @type))
+(revert_statement error: (expression (identifier) @type))
+(modifier_invocation . (_) @function)
 
-(call_expression . (member_expression property: (identifier) @function.method))
-(call_expression . (identifier) @function)
+(call_expression . (_(member_expression property: (_) @function.method)))
+(call_expression . (expression (identifier) @function))
 
 ; Function parameters
 (call_struct_argument name: (identifier) @field)
@@ -87,15 +86,20 @@
 (parameter name: (identifier) @variable.parameter)
 
 ; Yul functions
-(yul_function_call function: (yul_identifier) @function)
-(yul_function_definition . (yul_identifier) @function (yul_identifier) @variable.parameter)
-
+(yul_function_call function: (_) @function)
+(yul_function_definition
+  ("function" (yul_identifier) @function "(" (
+      (yul_identifier) @variable.parameter ("," (yul_identifier) @variable.parameter)*
+    )
+  )
+)
 
 ; Structs and members
 (member_expression property: (identifier) @variable.other.member)
-(struct_expression type: ((identifier) @type .))
+(struct_expression type: ((expression (identifier)) @type .))
 (struct_field_assignment name: (identifier) @variable.other.member)
 
+
 ; Tokens
 ; -------
 
@@ -110,9 +114,9 @@
  "struct"
  "enum"
  "event"
+ "type"
  "assembly"
  "emit"
-
  "public"
  "internal"
  "private"
@@ -120,7 +124,6 @@
  "pure"
  "view"
  "payable"
-
  "modifier"
  "var"
  "let"
@@ -134,6 +137,8 @@
  "storage"
  "calldata"
  "constant"
+ "transient"
+ (immutable)
 ] @keyword.storage.modifier
 
 [
@@ -172,7 +177,6 @@
 (event_parameter "indexed" @keyword)
 
 ; Punctuation
-
 [
   "("
   ")"
@@ -182,7 +186,6 @@
   "}"
 ] @punctuation.bracket
 
-
 [
   "."
   ","
@@ -191,14 +194,11 @@
   "=>"
 ] @punctuation.delimiter
 
-
 ; Operators
-
 [
   "&&"
   "||"
   ">>"
-  ">>>"
   "<<"
   "&"
   "^"
@@ -213,15 +213,12 @@
   "<="
   "=="
   "!="
-  "!=="
   ">="
   ">"
   "!"
   "~"
   "-"
   "+"
-  "delete"
-  "new"
   "++"
   "--"
   "+="
@@ -240,11 +237,3 @@
   "delete"
   "new"
 ] @keyword.operator
-
-; TODO: move to top when order swapped
-; identifiers
-; -----------
-((identifier) @variable.builtin
- (#match? @variable.builtin "^(this|msg|block|tx)$"))
-(identifier) @variable
-(yul_identifier) @variable
diff --git a/runtime/queries/solidity/locals.scm b/runtime/queries/solidity/locals.scm
index 29bdc02cb..ac8b62a39 100644
--- a/runtime/queries/solidity/locals.scm
+++ b/runtime/queries/solidity/locals.scm
@@ -1,9 +1,9 @@
 (function_definition) @local.scope
+(constructor_definition) @local.scope
 (block_statement) @local.scope
 
 (function_definition (parameter name: (identifier) @local.definition))
+(constructor_definition (parameter name: (identifier) @local.definition))
+(variable_declaration name: (identifier) @local.definition)
 
-; still have to support tuple assignments
-(assignment_expression left: (identifier) @local.definition)
-
-(identifier) @local.reference
\ No newline at end of file
+(identifier) @local.reference
diff --git a/runtime/queries/solidity/textobjects.scm b/runtime/queries/solidity/textobjects.scm
index 4e5ffdd12..8b2860c3d 100644
--- a/runtime/queries/solidity/textobjects.scm
+++ b/runtime/queries/solidity/textobjects.scm
@@ -17,7 +17,7 @@
   ((parameter) @parameter.inside . ","? @parameter.around) @parameter.around)
 
 (return_type_definition 
-  ((parameter) @parameter.inside . ","? @parameter.around) @parameter.around)
+  ((parameter) @entry.inside . ","? @entry.around) @entry.around)
 
 (modifier_definition 
   ((parameter) @parameter.inside . ","? @parameter.around) @parameter.around)
@@ -29,13 +29,13 @@
   ((error_parameter) @parameter.inside . ","? @parameter.around) @parameter.around)
 
 (call_argument
-  ((call_struct_argument) @parameter.inside . ","? @parameter.around) @parameter.around)
+  ((call_struct_argument) @entry.inside . ","? @entry.around) @entry.around)
 
 (call_expression
   ((call_argument) @parameter.inside . ","? @parameter.around) @parameter.around)
 
 (variable_declaration_tuple
-  ((variable_declaration) @parameter.inside . ","? @parameter.around) @parameter.around)
+  ((variable_declaration) @entry.inside . ","? @entry.around) @entry.around)
 
 (emit_statement
   ((call_argument) @parameter.inside . ","? @parameter.around) @parameter.around)
@@ -52,3 +52,4 @@
 (comment) @comment.inside
 
 (comment)+ @comment.around
+
diff --git a/runtime/queries/spade/highlights.scm b/runtime/queries/spade/highlights.scm
new file mode 100644
index 000000000..ba5d5d73a
--- /dev/null
+++ b/runtime/queries/spade/highlights.scm
@@ -0,0 +1,128 @@
+(self) @variable.builtin
+
+(unit_definition (identifier) @function)
+
+(parameter (identifier) @variable.parameter)
+
+((pipeline_reg_marker) @keyword)
+
+(scoped_identifier
+  path: (identifier) @namespace)
+(scoped_identifier
+ (scoped_identifier
+  name: (identifier) @namespace))
+
+((builtin_type) @type.builtin)
+
+((identifier) @type.builtin
+ (#any-of?
+    @type.builtin
+    "uint"
+    "Option"
+    "Memory"))
+
+((identifier) @type.enum.variant.builtin
+ (#any-of? @type.enum.variant.builtin "Some" "None"))
+
+((pipeline_stage_name) @label)
+
+((stage_reference
+    stage: (identifier) @label))
+
+[
+    "pipeline"
+    "let"
+    "set"
+    "entity"
+    "fn"
+    "reg"
+    "reset"
+    "initial"
+    "inst"
+    "assert"
+    "struct"
+    "enum"
+    "stage"
+    "impl"
+    "port"
+    "decl"
+    "mod"
+    "where"
+    "trait"
+] @keyword
+
+[
+ "use"
+] @keyword.import
+
+[
+    "gen"
+] @keyword.directive
+
+((gen_if_expression  ["if" "else"] @keyword.directive))
+((naked_gen_if_expression  ["if" "else"] @keyword.directive))
+
+((attribute) ["#" "[" "]"] @punctuation.delimiter)
+
+[
+  "else"
+  "if"
+  "match"
+] @keyword.control.conditional
+
+(bool_literal) @constant.builtin.boolean
+(int_literal) @constant.numeric.integer
+
+[
+  "&"
+  "inv"
+  "-"
+  "=>"
+  ">"
+  "<"
+  "::<"
+  "::$<"
+  "="
+  "->"
+  "~"
+  "!"
+] @operator
+
+
+((op_add) @operator)
+((op_sub) @operator)
+((op_mul) @operator)
+((op_equals) @operator)
+((op_lt) @operator)
+((op_gt) @operator)
+((op_le) @operator)
+((op_ge) @operator)
+((op_lshift) @operator)
+((op_rshift) @operator)
+((op_bitwise_and) @operator)
+((op_bitwise_xor) @operator)
+((op_bitwise_or) @operator)
+((op_logical_and) @operator)
+((op_logical_or) @operator)
+
+
+[
+  (line_comment)
+  (block_comment)
+] @comment
+
+[
+  (doc_comment)
+] @comment.block.documentation
+
+
+((identifier) @type
+  (#match? @type "[A-Z]"))
+
+((scoped_identifier
+    name: (identifier) @type)
+ (#match? @type "^[A-Z]"))
+
+((identifier) @constant
+ (#match? @constant "^[A-Z][A-Z\\d_]*$"))
+
diff --git a/runtime/queries/spade/indents.scm b/runtime/queries/spade/indents.scm
new file mode 100644
index 000000000..dc30bdc3e
--- /dev/null
+++ b/runtime/queries/spade/indents.scm
@@ -0,0 +1,27 @@
+
+[
+  (unit_definition)
+  (struct_definition)
+  (enum_definition)
+  (enum_member)
+  (impl)
+  (mod)
+  (argument_list)
+  (let_binding)
+  (block)
+  (tuple_literal)
+  (array_literal)
+  (paren_expression)
+  (turbofish)
+  (generic_parameters)
+  (named_unpack)
+  (positional_unpack)
+  (tuple_pattern)
+] @indent
+
+[
+  "}"
+  "]"
+  ")"
+] @outdent
+
diff --git a/runtime/queries/strace/highlights.scm b/runtime/queries/strace/highlights.scm
index 4f54cb3e9..82ba70688 100644
--- a/runtime/queries/strace/highlights.scm
+++ b/runtime/queries/strace/highlights.scm
@@ -1,4 +1,4 @@
-(syscall) @function
+(syscall) @function.builtin
 (integer) @constant.numeric
 (pointer) @constant.numeric
 (value) @label
diff --git a/runtime/queries/sway/highlights.scm b/runtime/queries/sway/highlights.scm
index 98f4d4493..969ef7760 100644
--- a/runtime/queries/sway/highlights.scm
+++ b/runtime/queries/sway/highlights.scm
@@ -1,14 +1,87 @@
 ; -------
-; Tree-Sitter doesn't allow overrides in regards to captures,
-; though it is possible to affect the child node of a captured
-; node. Thus, the approach here is to flip the order so that
-; overrides are unnecessary.
+; Basic identifiers
 ; -------
 
+; We do not style ? as an operator on purpose as it allows styling ? differently, as many highlighters do. @operator.special might have been a better scope, but @special is already documented so the change would break themes (including the intent of the default theme)
+"?" @special
+
+(type_identifier) @type
+(identifier) @variable
+(field_identifier) @variable.other.member
+
 ; -------
-; Types
+; Operators
 ; -------
 
+[
+  "*"
+  "'"
+  "->"
+  "=>"
+  "<="
+  "="
+  "=="
+  "!"
+  "!="
+  "%"
+  "%="
+  "&"
+  "&="
+  "&&"
+  "|"
+  "|="
+  "||"
+  "^"
+  "^="
+  "*"
+  "*="
+  "-"
+  "-="
+  "+"
+  "+="
+  "/"
+  "/="
+  ">"
+  "<"
+  ">="
+  ">>"
+  "<<"
+  ">>="
+  "<<="
+  "@"
+  ".."
+  "..="
+  "'"
+] @operator
+
+; -------
+; Paths
+; -------
+
+(use_declaration
+  argument: (identifier) @namespace)
+(use_wildcard
+  (identifier) @namespace)
+(dep_item
+  name: (identifier) @namespace)
+(scoped_use_list
+  path: (identifier)? @namespace)
+(use_list
+  (identifier) @namespace)
+(use_as_clause
+  path: (identifier)? @namespace
+  alias: (identifier) @namespace)
+
+; ---
+; Remaining Paths
+; ---
+
+(scoped_identifier
+  path: (identifier)? @namespace
+  name: (identifier) @namespace)
+(scoped_type_identifier
+  path: (identifier) @namespace)
+
 ; ---
 ; Primitives
 ; ---
@@ -179,6 +252,10 @@
 ; -------
 ; Guess Other Types
 ; -------
+; Other PascalCase identifiers are assumed to be structs.
+
+((identifier) @type
+  (#match? @type "^[A-Z]"))
 
 ((identifier) @constant
  (#match? @constant "^[A-Z][A-Z\\d_]*$"))
@@ -190,40 +267,28 @@
 
 (call_expression
   function: [
-    ((identifier) @type.enum.variant
-      (#match? @type.enum.variant "^[A-Z]"))
+    ((identifier) @constructor
+      (#match? @constructor "^[A-Z]"))
     (scoped_identifier
-      name: ((identifier) @type.enum.variant
-        (#match? @type.enum.variant "^[A-Z]")))
+      name: ((identifier) @constructor
+        (#match? @constructor "^[A-Z]")))
   ])
 
 ; ---
-; Assume that types in match arms are enums and not
-; tuple structs. Same for `if let` expressions.
-; ---
-
-(match_pattern
-    (scoped_identifier
-      name: (identifier) @constructor))
-(tuple_struct_pattern
-    type: [
-      ((identifier) @constructor)
-      (scoped_identifier  
-        name: (identifier) @constructor)
-      ])
-(struct_pattern
-  type: [
-    ((type_identifier) @constructor)
-    (scoped_type_identifier
-      name: (type_identifier) @constructor)
-    ])
-
-; ---
-; Other PascalCase identifiers are assumed to be structs.
+; PascalCase identifiers under a path which is also PascalCase
+; are assumed to be constructors if they have methods or fields.
 ; ---
 
-((identifier) @type
-  (#match? @type "^[A-Z]"))
+(field_expression
+  value: (scoped_identifier
+    path: [
+      (identifier) @type
+      (scoped_identifier
+        name: (identifier) @type)
+    ]
+    name: (identifier) @constructor
+      (#match? @type "^[A-Z]")
+      (#match? @constructor "^[A-Z]")))
 
 ; -------
 ; Functions
@@ -251,86 +316,3 @@
 
 (function_signature_item
   name: (identifier) @function)
-
-; -------
-; Operators
-; -------
-
-[
-  "*"
-  "'"
-  "->"
-  "=>"
-  "<="
-  "="
-  "=="
-  "!"
-  "!="
-  "%"
-  "%="
-  "&"
-  "&="
-  "&&"
-  "|"
-  "|="
-  "||"
-  "^"
-  "^="
-  "*"
-  "*="
-  "-"
-  "-="
-  "+"
-  "+="
-  "/"
-  "/="
-  ">"
-  "<"
-  ">="
-  ">>"
-  "<<"
-  ">>="
-  "<<="
-  "@"
-  ".."
-  "..="
-  "'"
-] @operator
-
-; -------
-; Paths
-; -------
-
-(use_declaration
-  argument: (identifier) @namespace)
-(use_wildcard
-  (identifier) @namespace)
-(dep_item
-  name: (identifier) @namespace)
-(scoped_use_list
-  path: (identifier)? @namespace)
-(use_list
-  (identifier) @namespace)
-(use_as_clause
-  path: (identifier)? @namespace
-  alias: (identifier) @namespace)
-
-; ---
-; Remaining Paths
-; ---
-
-(scoped_identifier
-  path: (identifier)? @namespace
-  name: (identifier) @namespace)
-(scoped_type_identifier
-  path: (identifier) @namespace)
-
-; -------
-; Remaining Identifiers
-; -------
-
-"?" @special
-
-(type_identifier) @type
-(identifier) @variable
-(field_identifier) @variable.other.member
diff --git a/runtime/queries/swift/highlights.scm b/runtime/queries/swift/highlights.scm
index 42411d907..ecafde40a 100644
--- a/runtime/queries/swift/highlights.scm
+++ b/runtime/queries/swift/highlights.scm
@@ -4,9 +4,50 @@
   ["\\(" ")"] @punctuation.special)
 
 ["." ";" ":" "," ] @punctuation.delimiter
-["(" ")" "[" "]" "{" "}"] @punctuation.bracket
+["(" ")" "[" "]" "{" "}" "<" ">"] @punctuation.bracket
+
+; Operators
+[
+  "!"
+  "?"
+  "+"
+  "-"
+  "\\"
+  "*"
+  "/"
+  "%"
+  "="
+  "+="
+  "-="
+  "*="
+  "/="
+  "<"
+  ">"
+  "<="
+  ">="
+  "++"
+  "--"
+  "&"
+  "~"
+  "%="
+  "!="
+  "!=="
+  "=="
+  "==="
+  "??"
+
+  "->"
+
+  "..<"
+  "..."
+  (custom_operator)
+] @operator
+
+"?" @type
+(type_annotation "!" @type)
 
 ; Identifiers
+(simple_identifier) @variable
 (attribute) @variable
 (type_identifier) @type
 (self_expression) @variable.builtin
@@ -24,6 +65,7 @@
 ] @keyword
 
 (function_declaration (simple_identifier) @function.method)
+(protocol_function_declaration (simple_identifier) @function.method)
 (init_declaration ["init" @constructor])
 (deinit_declaration ["deinit" @constructor])
 
@@ -91,6 +133,9 @@
    (#match? @type "^[A-Z]"))
 (call_expression (simple_identifier) @keyword (#eq? @keyword "defer")) ; defer { ... }
 
+(navigation_suffix
+  (simple_identifier) @variable.other.member)
+
 (try_operator) @operator
 (try_operator ["try" @keyword])
 
@@ -147,48 +192,7 @@
 (integer_literal) @constant.numeric.integer
 (real_literal) @constant.numeric.float
 (boolean_literal) @constant.builtin.boolean
-"nil" @variable.builtin
-
-"?" @type
-(type_annotation "!" @type)
-
-(simple_identifier) @variable
-
-; Operators
-[
-  "!"
-  "?"
-  "+"
-  "-"
-  "*"
-  "/"
-  "%"
-  "="
-  "+="
-  "-="
-  "*="
-  "/="
-  "<"
-  ">"
-  "<="
-  ">="
-  "++"
-  "--"
-  "&"
-  "~"
-  "%="
-  "!="
-  "!=="
-  "=="
-  "==="
-  "??"
-
-  "->"
-
-  "..<"
-  "..."
-  (custom_operator)
-] @operator
+"nil" @constant.builtin
 
 (value_parameter_pack ["each" @keyword])
 (value_pack_expansion ["repeat" @keyword])
diff --git a/runtime/queries/swift/injections.scm b/runtime/queries/swift/injections.scm
index 0ac6cddfe..fb78129ac 100644
--- a/runtime/queries/swift/injections.scm
+++ b/runtime/queries/swift/injections.scm
@@ -4,3 +4,7 @@
 
 ((regex_literal) @injection.content
  (#set! injection.language "regex"))
+
+((comment) @injection.content
+ (#set! injection.language "comment")
+ (#set! injection.include-children))
diff --git a/runtime/queries/t32/highlights.scm b/runtime/queries/t32/highlights.scm
index 8a29cee21..bcfa3adde 100644
--- a/runtime/queries/t32/highlights.scm
+++ b/runtime/queries/t32/highlights.scm
@@ -81,6 +81,10 @@
   "."
 ] @punctuation.delimiter
 
+; HLL variables
+(identifier) @variable
+(hll_field_identifier) @variable.other.member
+
 
 ; Strings and others literal types
 (access_class) @constant.builtin
@@ -219,9 +223,5 @@
   command: (identifier) @keyword.control.loop)
 
 
-; HLL variables
-(identifier) @variable
-(hll_field_identifier) @variable.other.member
-
 
 (comment) @comment
diff --git a/runtime/queries/tablegen/highlights.scm b/runtime/queries/tablegen/highlights.scm
index 8ade5ba9a..0b7aaa20f 100644
--- a/runtime/queries/tablegen/highlights.scm
+++ b/runtime/queries/tablegen/highlights.scm
@@ -68,7 +68,9 @@
   "def"
   "defset"
   "defvar"
+  "deftype"
   "assert"
+  "dump"
 ] @keyword
 
 [
@@ -86,5 +88,3 @@
   "multiclass"
   "defm"
 ] @namespace
-
-(ERROR) @error
diff --git a/runtime/queries/tact/highlights.scm b/runtime/queries/tact/highlights.scm
index 53bf985b5..51b1ea9e4 100644
--- a/runtime/queries/tact/highlights.scm
+++ b/runtime/queries/tact/highlights.scm
@@ -9,40 +9,90 @@
   "@interface"
 ] @attribute
 
-; comment.line
-; ------------
+; operator
+; --------
 
-((comment) @comment.line
-  (#match? @comment.line "^//"))
+[
+  "-" "-="
+  "+" "+="
+  "*" "*="
+  "/" "/="
+  "%" "%="
+  "=" "=="
+  "!" "!=" "!!"
+  "<" "<=" "<<"
+  ">" ">=" ">>"
+  "&" "|"
+  "&&" "||"
+] @operator
 
-; comment.block
-; -------------
+; punctuation.bracket
+; -------------------
 
-(comment) @comment.block
+[
+  "(" ")"
+  "{" "}"
+] @punctuation.bracket
 
-; function.builtin
+; punctuation.delimiter
+; ---------------------
+
+[
+  ";"
+  ","
+  "."
+  ":"
+  "?"
+] @punctuation.delimiter
+
+; variable
+; --------
+
+(identifier) @variable
+
+; variable.builtin
 ; ----------------
 
-((identifier) @function.builtin
-  (#any-of? @function.builtin
-    "send" "sender" "require" "now"
-    "myBalance" "myAddress" "newAddress"
-    "contractAddress" "contractAddressExt"
-    "emit" "cell" "ton"
-    "beginString" "beginComment" "beginTailString" "beginStringFromBuilder" "beginCell" "emptyCell"
-    "randomInt" "random"
-    "checkSignature" "checkDataSignature" "sha256"
-    "min" "max" "abs" "pow"
-    "throw" "dump" "getConfigParam"
-    "nativeThrowWhen" "nativeThrowUnless" "nativeReserve"
-    "nativeRandomize" "nativeRandomizeLt" "nativePrepareRandom" "nativeRandom" "nativeRandomInterval")
-  (#is-not? local))
+(self) @variable.builtin
 
-; function.method
-; ---------------
+; variable.parameter
+; ------------------
 
-(method_call_expression
-  name: (identifier) @function.method)
+(parameter
+  name: (identifier) @variable.parameter)
+
+; variable.other.member
+; ---------------------
+
+(field
+  name: (identifier) @variable.other.member)
+
+(contract_body
+  (constant
+    name: (identifier) @variable.other.member))
+
+(trait_body
+  (constant
+    name: (identifier) @variable.other.member))
+
+(field_access_expression
+  name: (identifier) @variable.other.member)
+
+(lvalue (_) (_) @variable.other.member)
+
+(instance_argument
+  name: (identifier) @variable.other.member)
+
+; comment.block
+; -------------
+
+(comment) @comment.block
+
+; comment.line
+; ------------
+
+((comment) @comment.line
+  (#match? @comment.line "^//"))
 
 ; function
 ; --------
@@ -73,6 +123,30 @@
 (function
   name: (identifier) @function.method)
 
+; function.method
+; ---------------
+
+(method_call_expression
+  name: (identifier) @function.method)
+
+; function.builtin
+; ----------------
+
+((identifier) @function.builtin
+  (#any-of? @function.builtin
+    "send" "sender" "require" "now"
+    "myBalance" "myAddress" "newAddress"
+    "contractAddress" "contractAddressExt"
+    "emit" "cell" "ton"
+    "beginString" "beginComment" "beginTailString" "beginStringFromBuilder" "beginCell" "emptyCell"
+    "randomInt" "random"
+    "checkSignature" "checkDataSignature" "sha256"
+    "min" "max" "abs" "pow"
+    "throw" "dump" "getConfigParam"
+    "nativeThrowWhen" "nativeThrowUnless" "nativeReserve"
+    "nativeRandomize" "nativeRandomizeLt" "nativePrepareRandom" "nativeRandom" "nativeRandomInterval")
+  (#is-not? local))
+
 ; keyword.control.conditional
 ; ---------------------------
 
@@ -169,16 +243,21 @@
 (constant
   name: (identifier) @constant)
 
+; string
+; ------
+
+(string) @string
+
 ; string.special.path
 ; -------------------
 
 (import_statement
   library: (string) @string.special.path)
 
-; string
-; ------
+; type
+; ----
 
-(string) @string
+(type_identifier) @type
 
 ; type.builtin
 ; ------------
@@ -209,11 +288,6 @@
   (#eq? @type.builtin "SendParameters")
   (#is-not? local))
 
-; type
-; ----
-
-(type_identifier) @type
-
 ; constructor
 ; -----------
 
@@ -222,77 +296,3 @@
 
 (initOf
   name: (identifier) @constructor)
-
-; operator
-; --------
-
-[
-  "-" "-="
-  "+" "+="
-  "*" "*="
-  "/" "/="
-  "%" "%="
-  "=" "=="
-  "!" "!=" "!!"
-  "<" "<=" "<<"
-  ">" ">=" ">>"
-  "&" "|"
-  "&&" "||"
-] @operator
-
-; punctuation.bracket
-; -------------------
-
-[
-  "(" ")"
-  "{" "}"
-] @punctuation.bracket
-
-; punctuation.delimiter
-; ---------------------
-
-[
-  ";"
-  ","
-  "."
-  ":"
-  "?"
-] @punctuation.delimiter
-
-; variable.other.member
-; ---------------------
-
-(field
-  name: (identifier) @variable.other.member)
-
-(contract_body
-  (constant
-    name: (identifier) @variable.other.member))
-
-(trait_body
-  (constant
-    name: (identifier) @variable.other.member))
-
-(field_access_expression
-  name: (identifier) @variable.other.member)
-
-(lvalue (_) (_) @variable.other.member)
-
-(instance_argument
-  name: (identifier) @variable.other.member)
-
-; variable.parameter
-; ------------------
-
-(parameter
-  name: (identifier) @variable.parameter)
-
-; variable.builtin
-; ----------------
-
-(self) @variable.builtin
-
-; variable
-; --------
-
-(identifier) @variable
diff --git a/runtime/queries/tact/locals.scm b/runtime/queries/tact/locals.scm
index f1b3e8de5..f7a4115a7 100644
--- a/runtime/queries/tact/locals.scm
+++ b/runtime/queries/tact/locals.scm
@@ -1,5 +1,3 @@
-; See: https://tree-sitter.github.io/tree-sitter/syntax-highlighting#local-variables
-
 ; Scopes       @local.scope
 ; -------------------------
 
diff --git a/runtime/queries/teal/folds.scm b/runtime/queries/teal/folds.scm
new file mode 100644
index 000000000..e756719a4
--- /dev/null
+++ b/runtime/queries/teal/folds.scm
@@ -0,0 +1,15 @@
+[
+(do_statement)
+(numeric_for_statement)
+(generic_for_statement)
+(while_statement)
+(repeat_statement)
+(if_statement)
+(function_statement)
+(record_declaration)
+(interface_declaration)
+(enum_declaration)
+(anon_function)
+(table_constructor)
+] @fold
+
diff --git a/runtime/queries/teal/highlights.scm b/runtime/queries/teal/highlights.scm
new file mode 100644
index 000000000..0aa41b19a
--- /dev/null
+++ b/runtime/queries/teal/highlights.scm
@@ -0,0 +1,170 @@
+
+;; Primitives
+(boolean) @constant.builtin.boolean
+(comment) @comment
+(shebang_comment) @comment
+(identifier) @variable
+((identifier) @variable.builtin
+  (#eq? @variable.builtin "self"))
+(nil) @constant.builtin
+(number) @constant.numeric
+(string) @string
+(table_constructor ["{" "}"] @constructor)
+(varargs "..." @constant.builtin)
+[ "," "." ":" ";" ] @punctuation.delimiter
+
+(escape_sequence) @constant.character.escape
+(format_specifier) @constant.character.escape
+
+;; Basic statements/Keywords
+[ "if" "then" "elseif" "else" ] @keyword.control.conditional
+[ "for" "while" "repeat" "until" "do" ] @keyword.control.repeat
+[ "end" ] @keyword
+[ "in" ] @keyword.operator
+[ "local" ] @keyword.storage.type
+[ (break) (goto) ] @keyword.control
+[ "return" ] @keyword.control.return
+(label) @label
+
+;; Global isn't a real keyword, but it gets special treatment in these places
+(var_declaration "global" @keyword.storage.type)
+(type_declaration "global" @keyword.storage.type)
+(function_statement "global" @keyword.storage.type)
+(record_declaration "global" @keyword.storage.type)
+(interface_declaration "global" @keyword.storage.type)
+(enum_declaration "global" @keyword.storage.type)
+
+(macroexp_statement "macroexp" @keyword)
+
+;; Ops
+(bin_op (op) @operator)
+(unary_op (op) @operator)
+[ "=" "as" ] @operator
+
+;; Functions
+(function_statement
+  "function" @keyword.function
+  . name: (_) @function)
+(anon_function
+  "function" @keyword.function)
+(function_body "end" @keyword.function)
+
+(arg name: (identifier) @variable.parameter)
+
+(function_signature
+  (arguments
+    . (arg name: (identifier) @variable.builtin))
+  (#eq? @variable.builtin "self"))
+
+(typeargs
+  "<" @punctuation.bracket
+  . (_) @type.parameter
+  . ("," . (_) @type.parameter)*
+  . ">" @punctuation.bracket)
+
+(function_call
+  (identifier) @function . (arguments))
+(function_call
+  (index (_) key: (identifier) @function) . (arguments))
+(function_call
+  (method_index (_) key: (identifier) @function) . (arguments))
+
+;; Types
+
+; Contextual keywords in record bodies
+(record_declaration
+  . [ "record" ] @keyword.storage.type
+  name: (identifier) @type)
+(anon_record . "record" @keyword.storage.type)
+(record_body
+  (record_declaration
+    . [ "record" ] @keyword.storage.type
+    . name: (identifier) @type))
+(record_body
+  (enum_declaration
+    . [ "enum" ] @keyword.storage.type
+    . name: (identifier) @type.enum))
+(record_body
+  (interface_declaration
+    . [ "interface" ] @keyword.storage.type
+    . name: (identifier) @type))
+(record_body
+  (typedef
+    . "type" @keyword.storage.type
+    . name: (identifier) @type . "="))
+(record_body
+  (macroexp_declaration
+    . [ "macroexp" ] @keyword.storage.type))
+(record_body (metamethod "metamethod" @keyword.storage.modifier))
+(record_body (userdata) @keyword.storage.modifier)
+
+; Contextual keywords in interface bodies
+(interface_declaration
+  . [ "interface" ] @keyword.storage.type
+  name: (identifier) @type)
+(anon_interface . "interface" @keyword.storage.type)
+(interface_body
+  (record_declaration
+    . [ "record" ] @keyword.storage.type
+    . name: (identifier) @type))
+(interface_body
+  (enum_declaration
+    . [ "enum" ] @keyword.storage.type
+    . name: (identifier) @type.enum))
+(interface_body
+  (interface_declaration
+    . [ "interface" ] @keyword.storage.type
+    . name: (identifier) @type))
+(interface_body
+  (typedef
+    . "type" @keyword.storage.type
+    . name: (identifier) @type . "="))
+(interface_body
+  (macroexp_declaration
+    . [ "macroexp" ] @keyword.storage.type))
+(interface_body (metamethod "metamethod" @keyword.storage.modifier))
+(interface_body (userdata) @keyword.storage.modifier)
+
+(enum_declaration
+  "enum" @keyword.storage.type
+  name: (identifier) @type.enum)
+
+(type_declaration "type" @keyword.storage.type)
+(type_declaration (identifier) @type)
+(simple_type) @type
+(type_index) @type
+(type_union "|" @operator)
+(function_type "function" @type)
+
+;; The rest of it
+(var_declaration
+  declarators: (var_declarators
+      (var name: (identifier) @variable)))
+(var_declaration
+  declarators: (var_declarators
+    (var
+      "<" @punctuation.bracket
+      . attribute: (attribute) @attribute
+      . ">" @punctuation.bracket)))
+[ "(" ")" "[" "]" "{" "}" ] @punctuation.bracket
+
+;; Only highlight format specifiers in calls to string.format
+;; string.format('...')
+;(function_call
+;  called_object: (index
+;    (identifier) @base
+;    key: (identifier) @entry)
+;  arguments: (arguments .
+;    (string (format_specifier) @string.escape))
+;
+;  (#eq? @base "string")
+;  (#eq? @entry "format"))
+
+;; ('...'):format()
+;(function_call
+;  called_object: (method_index
+;    (string (format_specifier) @string.escape)
+;    key: (identifier) @func-name)
+;    (#eq? @func-name "format"))
+
+
diff --git a/runtime/queries/teal/locals.scm b/runtime/queries/teal/locals.scm
new file mode 100644
index 000000000..879aa71c1
--- /dev/null
+++ b/runtime/queries/teal/locals.scm
@@ -0,0 +1,25 @@
+
+(var_declaration
+  declarators: (var_declarators
+  (var (identifier)) @local.definition))
+
+(var_assignment
+  variables: (assignment_variables
+    (var (identifier) @local.definition)))
+
+(arg name: (identifier) @local.definition)
+
+(anon_function) @local.scope
+((function_statement
+  (function_name) @local.definition) @local.scope)
+
+(program) @local.scope
+(if_statement) @local.scope
+(generic_for_statement (for_body) @local.scope)
+(numeric_for_statement (for_body) @local.scope)
+(repeat_statement) @local.scope
+(while_statement (while_body) @local.scope)
+(do_statement) @local.scope
+
+(identifier) @local.reference
+
diff --git a/runtime/queries/tera/highlights.scm b/runtime/queries/tera/highlights.scm
new file mode 100644
index 000000000..744bacc9a
--- /dev/null
+++ b/runtime/queries/tera/highlights.scm
@@ -0,0 +1,225 @@
+; Variables
+;----------
+
+(identifier) @variable
+
+((identifier) @variable.builtin
+  (#any-of? @variable.builtin
+    "loop"
+    "__tera_context"))
+
+; Properties
+;-----------
+
+(member_expression
+  property: (identifier)? @variable.other.member)
+
+; Literals
+;-----------
+
+(string) @string
+
+(bool) @constant.builtin
+
+(number) @constant.numeric
+
+; Tokens
+;-----------
+
+[
+  "."
+  ","
+] @punctuation.delimiter
+
+[
+  "*"
+  "/"
+  "%"
+  "|"
+  "+"
+  "-"
+  "~"
+  "="
+  "=="
+  "!="
+  "<"
+  ">"
+  "<="
+  ">="
+] @operator
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{%"
+  "%}"
+  "-%}"
+  "{%-"
+  "}}"
+  "{{"
+  "-}}"
+  "{{-"
+  "::"
+] @punctuation.bracket
+
+; Tags
+;-----------
+
+(comment_tag) @comment
+
+; Keywords
+;-----------
+
+[
+  "if"
+  "elif"
+  "else"
+  "endif"
+] @keyword.control.conditional
+
+[
+  "for"
+  "endfor"
+] @keyword.control.repeat
+
+[
+  "include"
+  "import"
+  "extends"
+] @keyword.control.import
+
+[
+  "in"
+  "and"
+  "or"
+  "not"
+  "is"
+] @keyword.operator
+
+[
+  "break"
+  "continue"
+] @keyword.control.return
+
+[
+  "set"
+  "set_global"
+  "filter"
+  "endfilter"
+  "block"
+  "endblock"
+  "macro"
+  "endmacro"
+  "raw"
+  "endraw"
+  "as"
+] @keyword
+
+; Functions
+;-----------
+
+(macro_statement
+  name: (identifier) @function
+  (parameter_list
+    parameter: (identifier) @variable.parameter
+    (optional_parameter
+      name: (identifier) @variable.parameter)))
+
+(call_expression
+  scope: (identifier)? @namespace
+  name: (identifier) @function)
+
+(call_expression
+  name: (identifier) @function.builtin
+  (#any-of? @function.builtin
+    ; Functions - https://keats.github.io/tera/docs/#built-in-functions
+    "range"
+    "now"
+    "throw"
+    "get_random"
+    "get_env"))
+
+(test_expression
+  test: (identifier) @function)
+
+(test_expression
+  test: (identifier) @function.builtin
+  (#any-of? @function.builtin
+    ; Tests - https://keats.github.io/tera/docs/#built-in-tests
+    "defined"
+    "undefined"
+    "odd"
+    "even"
+    "string"
+    "number"
+    "divisibleby"
+    "iterable"
+    "object"
+    "starting_with"
+    "ending_with"
+    "containing"
+    "matching"))
+
+(filter_expression
+  filter: (identifier) @function.method)
+
+(filter_expression
+  filter: (identifier) @function.builtin
+  (#any-of? @function.builtin
+    ; Filters - https://keats.github.io/tera/docs/#built-in-filters
+    "lower"
+    "upper"
+    "wordcount"
+    "capitalize"
+    "replace"
+    "addslashes"
+    "slugify"
+    "title"
+    "trim"
+    "trim_start"
+    "trim_end"
+    "trim_start_matches"
+    "trim_end_matches"
+    "truncate"
+    "linebreaksbr"
+    "spaceless"
+    "indent"
+    "striptags"
+    "first"
+    "last"
+    "nth"
+    "join"
+    "length"
+    "reverse"
+    "sort"
+    "unique"
+    "slice"
+    "group_by"
+    "filter"
+    "map"
+    "concat"
+    "urlencode"
+    "urlencode_strict"
+    "abs"
+    "pluralize"
+    "round"
+    "filesizeformat"
+    "date"
+    "escape"
+    "escape_xml"
+    "safe"
+    "get"
+    "split"
+    "int"
+    "float"
+    "json_encode"
+    "as_str"
+    "default"))
+
+; Namespaces
+;-----------
+
+(import_statement
+  scope: (identifier) @namespace)
diff --git a/runtime/queries/tera/injections.scm b/runtime/queries/tera/injections.scm
new file mode 100644
index 000000000..2540c1f97
--- /dev/null
+++ b/runtime/queries/tera/injections.scm
@@ -0,0 +1,4 @@
+(frontmatter (content) @injection.content
+  (#set! injection.language "yaml")
+  (#set! injection.combined)
+)
diff --git a/runtime/queries/tera/locals.scm b/runtime/queries/tera/locals.scm
new file mode 100644
index 000000000..04b09cb00
--- /dev/null
+++ b/runtime/queries/tera/locals.scm
@@ -0,0 +1,7 @@
+(identifier) @local.reference
+(assignment_expression
+   left: (identifier) @local.definition)
+(macro_statement
+  (parameter_list
+    (identifier) @local.definition))
+(macro_statement) @local.scope
diff --git a/runtime/queries/textproto/highlights.scm b/runtime/queries/textproto/highlights.scm
new file mode 100644
index 000000000..766897f44
--- /dev/null
+++ b/runtime/queries/textproto/highlights.scm
@@ -0,0 +1,22 @@
+(string) @string
+
+(field_name) @variable.other.member
+
+(comment) @comment
+
+(number) @constant.numeric
+; covers e.g. booleans and "inf"
+(scalar_value (identifier)) @constant
+; Covers "-inf"
+(scalar_value (signed_identifier)) @constant.numeric
+
+[
+  (open_squiggly)
+  (close_squiggly)
+  (open_square)
+  (close_square)
+  (open_arrow)
+  (close_arrow)
+] @punctuation.bracket
+
+"," @punctuation.delimiter
diff --git a/runtime/queries/textproto/indents.scm b/runtime/queries/textproto/indents.scm
new file mode 100644
index 000000000..ebea3ff39
--- /dev/null
+++ b/runtime/queries/textproto/indents.scm
@@ -0,0 +1,11 @@
+[
+  (message_value)
+  (message_list)
+  (scalar_list)
+] @indent
+
+[
+  (close_arrow)
+  (close_square)
+  (close_squiggly)
+] @outdent
diff --git a/runtime/queries/textproto/textobjects.scm b/runtime/queries/textproto/textobjects.scm
new file mode 100644
index 000000000..9cc428c6a
--- /dev/null
+++ b/runtime/queries/textproto/textobjects.scm
@@ -0,0 +1,12 @@
+(message_field 
+  (_) @entry.inside) @entry.around
+
+(scalar_field 
+  (_) @entry.inside) @entry.around
+
+(message_list
+  (_) @entry.around)
+
+(scalar_list
+  (_) @entry.around)
+
diff --git a/runtime/queries/thrift/highlights.scm b/runtime/queries/thrift/highlights.scm
index 567c3f9dc..3db4b39c7 100644
--- a/runtime/queries/thrift/highlights.scm
+++ b/runtime/queries/thrift/highlights.scm
@@ -138,7 +138,7 @@
   "xsd_optional"
 ] @keyword
 
-; Extended Kewords
+; Extended Keywords
 [
   "package"
   "performs"
diff --git a/runtime/queries/tsq/folds.scm b/runtime/queries/tsq/folds.scm
new file mode 100644
index 000000000..47dd96512
--- /dev/null
+++ b/runtime/queries/tsq/folds.scm
@@ -0,0 +1,6 @@
+[
+  (named_node)
+  (predicate)
+  (grouping)
+  (list)
+] @fold
diff --git a/runtime/queries/tsq/highlights.scm b/runtime/queries/tsq/highlights.scm
index 5ef6bf4c8..4ef463a6b 100644
--- a/runtime/queries/tsq/highlights.scm
+++ b/runtime/queries/tsq/highlights.scm
@@ -1,50 +1,50 @@
-; mark the string passed #match? as a regex
-(((predicate_name) @function
-  (capture)
-  (string) @string.regexp)
- (#eq? @function "#match?"))
+((program
+  .
+  (comment)*
+  .
+  (comment) @keyword.import)
+  (#match? @keyword.import "^;+ *inherits *:"))
 
-; highlight inheritance comments
-(((comment) @keyword.directive)
- (#match? @keyword.directive "^; +inherits *:"))
+((parameters
+  (identifier) @constant.numeric)
+  (#match? @constant.numeric "^[-+]?[0-9]+(.[0-9]+)?$"))
+
+"_" @constant
+
+":" @punctuation.delimiter
 
 [
-  "("
-  ")"
   "["
   "]"
+  "("
+  ")"
 ] @punctuation.bracket
 
-":" @punctuation.delimiter
-"!" @operator
+"." @operator
 
-[
-  (one_or_more)
-  (zero_or_one)
-  (zero_or_more)
-] @operator
+(quantifier) @operator
 
-[
-  (wildcard_node)
-  (anchor)
-] @constant.builtin
+(comment) @comment
 
-[
-  (anonymous_leaf)
-  (string)
-] @string
+(negated_field
+  "!" @operator
+  (identifier) @variable.other.member)
 
-(comment) @comment
+(field_definition
+  name: (identifier) @variable.other.member)
 
-(field_name) @variable.other.member
+(named_node
+  name: (identifier) @tag)
 
-(capture) @label
+(predicate name: (identifier) @error)
+((predicate
+   "#" @function.builtin
+   name: (identifier) @function.builtin @_name
+   type: (predicate_type) @function.builtin)
+ (#any-of? @_name "eq" "not-eq" "match" "not-match" "any-of" "not-any-of" "is" "is-not" "not-same-line" "not-kind-eq" "set" "select-adjacent" "strip"))
 
-((predicate_name) @function
- (#any-of? @function "#eq?" "#match?" "#any-of?" "#not-any-of?" "#is?" "#is-not?" "#not-same-line?" "#not-kind-eq?" "#set!" "#select-adjacent!" "#strip!"))
-(predicate_name) @error
+(capture) @label
 
 (escape_sequence) @constant.character.escape
 
-(node_name) @tag
-(variable) @variable
+(string) @string
diff --git a/runtime/queries/tsq/injections.scm b/runtime/queries/tsq/injections.scm
index 644045570..9178ea5fc 100644
--- a/runtime/queries/tsq/injections.scm
+++ b/runtime/queries/tsq/injections.scm
@@ -1,8 +1,10 @@
 ((comment) @injection.content
- (#set! injection.language "comment"))
+  (#set! injection.language "comment"))
 
 ((predicate
-   (predicate_name) @_predicate
-   (string) @injection.content)
- (#eq? @_predicate "#match?")
- (#set! injection.language "regex"))
+  name: (identifier) @_name
+  parameters:
+    (parameters
+      (string (string_content) @injection.content)))
+  (#any-of? @_name "match" "not-match")
+  (#set! injection.language "regex"))
diff --git a/runtime/queries/tsx/highlights.scm b/runtime/queries/tsx/highlights.scm
index 721c56c74..83c7617f5 100644
--- a/runtime/queries/tsx/highlights.scm
+++ b/runtime/queries/tsx/highlights.scm
@@ -1,3 +1,3 @@
 ; See runtime/queries/ecma/README.md for more info.
 
-; inherits: _jsx,_typescript,ecma
+; inherits: ecma,_typescript,_jsx
diff --git a/runtime/queries/twig/highlights.scm b/runtime/queries/twig/highlights.scm
index 1ef8d06b9..6eca55725 100644
--- a/runtime/queries/twig/highlights.scm
+++ b/runtime/queries/twig/highlights.scm
@@ -41,11 +41,6 @@
     "="
 ] @punctuation.delimiter
 
-(interpolated_string [
-    "#{" 
-    "}"
-] @punctuation.delimiter)
-
 [
     "("
     ")"
@@ -58,3 +53,8 @@
     "}"
 ] @punctuation.bracket)
 
+(interpolated_string [
+    "#{"
+    "}"
+] @punctuation.delimiter)
+
diff --git a/runtime/queries/typescript/highlights.scm b/runtime/queries/typescript/highlights.scm
index 5b8c8f244..dbe6665a8 100644
--- a/runtime/queries/typescript/highlights.scm
+++ b/runtime/queries/typescript/highlights.scm
@@ -1,3 +1,3 @@
 ; See runtime/queries/ecma/README.md for more info.
 
-; inherits: _typescript,ecma
+; inherits: ecma,_typescript
diff --git a/runtime/queries/typespec/highlights.scm b/runtime/queries/typespec/highlights.scm
index 8b8aa4c3d..0b58a3efa 100644
--- a/runtime/queries/typespec/highlights.scm
+++ b/runtime/queries/typespec/highlights.scm
@@ -59,6 +59,10 @@
 
 "?" @punctuation.special
 
+; Identifiers
+
+(identifier_or_member_expression) @type
+
 ; Imports
 
 (import_statement
@@ -171,7 +175,3 @@
 ] @constant.numeric.integer
 
 (builtin_type) @type.builtin
-
-; Identifiers
-
-(identifier_or_member_expression) @type
diff --git a/runtime/queries/ungrammar/highlights.scm b/runtime/queries/ungrammar/highlights.scm
index cffbdbfdb..90514a0c5 100644
--- a/runtime/queries/ungrammar/highlights.scm
+++ b/runtime/queries/ungrammar/highlights.scm
@@ -1,5 +1,3 @@
-(ERROR) @error
-
 (line_comment) @comment
 
 (identifier) @variable
diff --git a/runtime/queries/unison/highlights.scm b/runtime/queries/unison/highlights.scm
index 711779295..eaf4c6bfa 100644
--- a/runtime/queries/unison/highlights.scm
+++ b/runtime/queries/unison/highlights.scm
@@ -9,32 +9,25 @@
 ;; Keywords
 [
   (kw_forall)
-  (type_kw)
   (kw_equals)
   (do)
+  (kw_let)
   (ability)
   (where)
 ] @keyword
 
 (kw_let) @keyword.function
-(type_kw) @keyword.storage.type
-(unique) @keyword.storage.modifier
+(type_kw) @keyword.storage.modifier
 (structural) @keyword.storage.modifier
 ("use") @keyword.control.import
-
-
-[
-  (type_constructor)
-] @constructor
+(unique) @keyword.storage.modifier
 
 [
   (operator)
   (pipe)
   (arrow_symbol)
-  (">")
   (or)
   (and)
-  (bang)
 ] @operator
 
 [
@@ -48,24 +41,62 @@
 
 (blank_pattern) @variable.builtin
 
+(pattern) @variable
+
+(use_clause) @keyword.import
+
 ;; Types
-(record_field name: (wordy_id) @variable.other.member type: (_) @type)
-(type_constructor (type_name (wordy_id) @constructor))
-(ability_declaration type_name: (wordy_id) @type type_arg: (wordy_id) @variable.parameter)
-(effect (wordy_id) @special) ;; NOTE: an effect is just like a type, but in signature we special case it
+(record_field
+  (field_name) @variable.other.member
+  type: (regular_identifier) @type)
+
+(type_name) @type
+
+(type_declaration
+  (regular_identifier) @type.enum.variant)
+
+(ability_name
+  (path)? @namespace
+  (regular_identifier) @type)
 
-;; Namespaces
+(ability_declaration
+  (ability_name) @type
+  (type_argument) @variable.parameter)
+
+(type_constructor) @constructor
+
+(constructor
+  (constructor_name) @constructor)
+
+(constructor
+  type: (regular_identifier) @type)
+
+(effect
+  (regular_identifier) @special) ; NOTE: an effect is a special type
+
+; Namespaces
 (path) @namespace
+
 (namespace) @namespace
 
-;; Terms
-(type_signature term_name: (path)? @variable term_name: (wordy_id) @variable)
-(type_signature (wordy_id) @type)
-(type_signature (term_type(delayed(wordy_id))) @type)
+; Terms
+(type_signature
+  term_name: (path) @namespace
+  term_name: (regular_identifier) @variable)
+
+(type_signature
+  term_name: (regular_identifier) @variable)
+
+(term_type) @type
 
-(term_definition param: (wordy_id) @variable.parameter)
+(term_definition
+  name: (path) @namespace)
 
-(function_application function_name: (path)? function_name: (wordy_id) @function)
+(term_definition
+  name: (regular_identifier) @variable)
+
+(term_definition
+  param: (regular_identifier) @variable.parameter)
 
 ;; Punctuation
 [
@@ -82,4 +113,6 @@
   "]"
 ] @punctuation.bracket
 
-(test_watch_expression (wordy_id) @keyword.directive)
+(watch_expression) @keyword.directive
+
+(test_watch_expression) @keyword.directive
diff --git a/runtime/queries/unison/indents.scm b/runtime/queries/unison/indents.scm
index 6cb15517c..9ebe26ced 100644
--- a/runtime/queries/unison/indents.scm
+++ b/runtime/queries/unison/indents.scm
@@ -1,11 +1,6 @@
 [
   (term_definition)
-  (type_declaration)
   (pattern)
-  (tuple_or_parenthesized)
-  (literal_list)
-  (tuple_pattern)
-  (function_application)
   (exp_if)
   (constructor)
   (delay_block)
diff --git a/runtime/queries/unison/textobjects.scm b/runtime/queries/unison/textobjects.scm
new file mode 100644
index 000000000..02a908368
--- /dev/null
+++ b/runtime/queries/unison/textobjects.scm
@@ -0,0 +1,15 @@
+(term_declaration) @function.around
+
+(type_declaration) @class.inside
+(record) @class.inside
+
+(comment) @comment.inside
+(comment)+ @comment.around
+
+(doc_block) @comment.around
+
+(literal_list) @entry.around
+
+(parenthesized_or_tuple_pattern) @entry.around
+
+(pattern) @entry.around
diff --git a/runtime/queries/uxntal/highlights.scm b/runtime/queries/uxntal/highlights.scm
index a6ff18528..25579bb31 100644
--- a/runtime/queries/uxntal/highlights.scm
+++ b/runtime/queries/uxntal/highlights.scm
@@ -11,5 +11,4 @@
 (relative_pad) @constant
 (label) @label
 (sub_label) @label
-(ERROR) @error
 ["[" "]" "{" "}"] @punctuation.bracket
diff --git a/runtime/queries/vala/highlights.scm b/runtime/queries/vala/highlights.scm
index 685cda13b..3d804cf8f 100644
--- a/runtime/queries/vala/highlights.scm
+++ b/runtime/queries/vala/highlights.scm
@@ -24,6 +24,7 @@
 (unqualified_type (symbol . (identifier) @type))
 (unqualified_type (symbol (symbol) @namespace (identifier) @type))
 
+(identifier) @variable
 (attribute) @variable.other.member
 (method_declaration (symbol (symbol) @type (identifier) @function))
 (method_declaration (symbol (identifier) @function))
@@ -41,7 +42,6 @@
 (parameter (identifier) @variable.parameter)
 (property_declaration (symbol (identifier) @variable.other.member))
 (field_declaration (identifier) @variable)
-(identifier) @variable
 [
  (this_access)
  (base_access)
diff --git a/runtime/queries/vento/highlights.scm b/runtime/queries/vento/highlights.scm
new file mode 100644
index 000000000..4b0ba563f
--- /dev/null
+++ b/runtime/queries/vento/highlights.scm
@@ -0,0 +1,13 @@
+(comment) @comment
+
+(keyword) @keyword
+
+(tag
+  [
+    "{{"
+    "{{-"
+    "}}"
+    "-}}"
+  ] @punctuation.bracket)
+
+"|>" @operator
diff --git a/runtime/queries/vento/injections.scm b/runtime/queries/vento/injections.scm
new file mode 100644
index 000000000..2df984012
--- /dev/null
+++ b/runtime/queries/vento/injections.scm
@@ -0,0 +1,6 @@
+((content) @injection.content
+  (#set! injection.language "html")
+  (#set! injection.combined))
+
+((code) @injection.content
+  (#set! injection.language "javascript"))
diff --git a/runtime/queries/verilog/highlights.scm b/runtime/queries/verilog/highlights.scm
index a194ac33b..de65cab07 100644
--- a/runtime/queries/verilog/highlights.scm
+++ b/runtime/queries/verilog/highlights.scm
@@ -307,5 +307,3 @@
   "("
   ")"
 ] @punctuation.bracket
-
-(ERROR) @error
diff --git a/runtime/queries/vhs/highlights.scm b/runtime/queries/vhs/highlights.scm
index a7e1af301..5e53584b8 100644
--- a/runtime/queries/vhs/highlights.scm
+++ b/runtime/queries/vhs/highlights.scm
@@ -40,6 +40,7 @@
 (float) @constant.numeric.float
 (integer) @constant.numeric.integer
 (comment) @comment
-[(path) (string) (json)] @string.special.path
+[(string) (json)] @string.special.path
+(path) @string.special.path
 (time) @string.special.symbol
 (boolean) @constant.builtin.boolean
diff --git a/runtime/queries/vue/highlights.scm b/runtime/queries/vue/highlights.scm
index f90ae4297..1d93832fb 100644
--- a/runtime/queries/vue/highlights.scm
+++ b/runtime/queries/vue/highlights.scm
@@ -6,9 +6,13 @@
 
 (attribute
   (attribute_name) @attribute
-  (quoted_attribute_value
-    (attribute_value) @string)
-)
+  [(attribute_value) (quoted_attribute_value)]? @string)
+ 
+(directive_attribute
+  (directive_name) @attribute
+  (directive_argument)? @attribute
+  (directive_modifiers)? @attribute
+  [(attribute_value) (quoted_attribute_value)]? @string) 
 
 (comment) @comment
 
@@ -18,4 +22,7 @@
   "</"
   "{{"
   "}}"
-] @punctuation.bracket
\ No newline at end of file
+  "/>" 
+] @punctuation.bracket
+"=" @punctuation.delimiter
+
diff --git a/runtime/queries/wgsl/highlights.scm b/runtime/queries/wgsl/highlights.scm
index 2817ea3a3..fe10c6849 100644
--- a/runtime/queries/wgsl/highlights.scm
+++ b/runtime/queries/wgsl/highlights.scm
@@ -89,6 +89,8 @@
   "~"
 ] @operator
 
+(identifier) @variable
+
 (function_declaration
   (identifier) @function)
 
@@ -112,6 +114,4 @@
 (attribute
   (identifier) @attribute)
 
-(identifier) @variable
-
 (comment) @comment
diff --git a/runtime/queries/wren/highlights.scm b/runtime/queries/wren/highlights.scm
index c37bc3bc5..3d934b36f 100644
--- a/runtime/queries/wren/highlights.scm
+++ b/runtime/queries/wren/highlights.scm
@@ -1,3 +1,13 @@
+(comment) @comment
+(string) @string
+(raw_string) @string
+(number) @constant.numeric.integer
+(name) @variable
+(field) @variable
+(static_field) @variable
+(null) @constant.builtin
+(boolean) @constant.builtin.boolean
+
 ((name) @variable.builtin
  (#match? @variable.builtin "^(Bool|Class|Fiber|Fn|List|Map|Null|Num|Object|Range|Sequence|String|System)$"))
 
@@ -9,15 +19,6 @@
 
 ((parameter) @variable.parameter)
 
-(comment) @comment
-(string) @string
-(raw_string) @string
-(number) @constant.numeric.integer
-(name) @variable
-(field) @variable
-(static_field) @variable
-(null) @constant.builtin
-(boolean) @constant.builtin.boolean
 
 (if_statement
 [
diff --git a/runtime/queries/yaml/highlights.scm b/runtime/queries/yaml/highlights.scm
index e4fed27a9..3c39cf1e6 100644
--- a/runtime/queries/yaml/highlights.scm
+++ b/runtime/queries/yaml/highlights.scm
@@ -1,13 +1,3 @@
-(block_mapping_pair
-  key: (flow_node [(double_quote_scalar) (single_quote_scalar)] @variable.other.member))
-(block_mapping_pair
-  key: (flow_node (plain_scalar (string_scalar) @variable.other.member)))
-
-(flow_mapping
-  (_ key: (flow_node [(double_quote_scalar) (single_quote_scalar)] @variable.other.member)))
-(flow_mapping
-  (_ key: (flow_node (plain_scalar (string_scalar) @variable.other.member))))
-
 (boolean_scalar) @constant.builtin.boolean
 (null_scalar) @constant.builtin
 (double_quote_scalar) @string
@@ -22,7 +12,16 @@
 (alias_name) @type
 (tag) @type
 (yaml_directive) @keyword
-(ERROR) @error
+
+(block_mapping_pair
+  key: (flow_node [(double_quote_scalar) (single_quote_scalar)] @variable.other.member))
+(block_mapping_pair
+  key: (flow_node (plain_scalar (string_scalar) @variable.other.member)))
+
+(flow_mapping
+  (_ key: (flow_node [(double_quote_scalar) (single_quote_scalar)] @variable.other.member)))
+(flow_mapping
+  (_ key: (flow_node (plain_scalar (string_scalar) @variable.other.member))))
 
 [
 ","
diff --git a/runtime/queries/yaml/injections.scm b/runtime/queries/yaml/injections.scm
index 46c4a9c0f..a16a945a9 100644
--- a/runtime/queries/yaml/injections.scm
+++ b/runtime/queries/yaml/injections.scm
@@ -20,7 +20,7 @@
 
 ; Modified for Helix from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/yaml/injections.scm
 
-;; Github actions: run
+;; GitHub actions: run
 ;; Gitlab CI: scripts, before_script, after_script
 ;; Buildkite: command, commands
 (block_mapping_pair
diff --git a/runtime/queries/yara/highlights.scm b/runtime/queries/yara/highlights.scm
new file mode 100644
index 000000000..f483215ec
--- /dev/null
+++ b/runtime/queries/yara/highlights.scm
@@ -0,0 +1,136 @@
+; Comments
+(comment) @comment
+
+; Keywords
+[
+  "global"
+  "import"
+  "private"
+] @constant.builtin
+
+[
+  "rule"
+] @function
+
+[
+  "meta"
+  "strings"
+  "condition"
+] @attribute
+
+; Operators
+[
+  "matches"
+  "contains"
+  "icontains"
+  "imatches"
+  "startswith"
+  "istartswith"
+  "endswith"
+  "iendswith"
+  "and"
+  "or"
+  "not"
+  "=="
+  "!="
+  "<"
+  ">"
+  ">="
+  "<="
+  "of"
+  "for"
+  "all"
+  "any"
+  "none"
+  "in"
+] @string.special
+
+; String modifiers
+[
+  "wide"
+  "ascii"
+  "nocase"
+  "fullword"
+  "xor"
+  "base64"
+  "base64wide"
+] @keyword.storage.modifier
+
+; Numbers and sizes
+(integer_literal) @constant.numeric
+(size_unit) @constant.numeric
+
+; Strings
+(double_quoted_string) @string
+(single_quoted_string) @string
+(escape_sequence) @constant.character.escape
+
+; Hex strings
+(hex_string) @string.special
+(hex_byte) @constant.numeric
+(hex_wildcard) @constant.builtin
+(hex_jump) @constant.numeric
+
+; Regular expressions
+(regex_string) @string.regexp
+(pattern) @string.regexp
+
+; Boolean literals
+[
+  "true"
+  "false"
+] @constant.builtin.boolean
+
+; Keywords and special identifiers
+[
+  "them"
+  "all"
+  "any"
+  "none"
+] @keyword.operator
+
+
+; String identifiers
+"$" @string.special.symbol
+(identifier) @string
+(string_identifier) @string.special.symbol
+
+; Built-ins
+[
+  (filesize_keyword)
+  (entrypoint_keyword)
+] @constant.builtin
+
+; Tags
+(tag_list
+  [(identifier) (tag)] @tag)
+
+; Punctuation and delimiters
+[
+  "="
+  ":"
+  "{"
+  "}"
+  "["
+  "]"
+  "("
+  ")"
+  "#"
+  "@"
+  ".."
+  "|"
+  ","
+  "!"
+  "/"
+  "\""
+  "'"
+  "*"
+] @string.special.symbol
+
+; Rule names
+(rule_definition
+  name: (identifier) @string.special)
+
+; Meta definitions
+(meta_definition
+  key: (identifier) @string.special)
diff --git a/runtime/queries/yara/injections.scm b/runtime/queries/yara/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/yara/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/yara/locals.scm b/runtime/queries/yara/locals.scm
new file mode 100644
index 000000000..16f8768a0
--- /dev/null
+++ b/runtime/queries/yara/locals.scm
@@ -0,0 +1,21 @@
+(rule_definition) @local.definition
+(string_identifier) @local.definition
+
+(for_expression
+  (string_identifier) @local.reference)
+
+(for_of_expression
+  (string_identifier) @local.reference)
+
+(of_expression
+  (string_set
+    (string_identifier) @local.reference))
+
+(string_count
+  (string_identifier) @local.reference)
+
+(string_offset
+  (string_identifier) @local.reference)
+
+(string_length
+  (string_identifier) @local.reference)
diff --git a/runtime/queries/yuck/highlights.scm b/runtime/queries/yuck/highlights.scm
index 70de4cbe6..35eee4ea6 100644
--- a/runtime/queries/yuck/highlights.scm
+++ b/runtime/queries/yuck/highlights.scm
@@ -1,6 +1,5 @@
-; Errors
-
-(ERROR) @error
+(ident) @variable
+(index) @variable
 
 ; Comments
 
@@ -64,6 +63,12 @@
 (function_call
   name: (ident) @function)
 
+; Tags
+
+; TODO apply to every symbol in list? I think it should probably only be applied to the first child of the list
+(list
+  (symbol) @tag)
+
 ; Variables
 
 (ident) @variable
@@ -94,14 +99,3 @@
 (loop_widget . "for" @keyword.control.repeat . (symbol) @variable . "in" @keyword.operator . (symbol) @variable)
 
 (loop_widget . "for" @keyword.control.repeat . (symbol) @variable . "in" @keyword.operator)
-
-; Tags
-
-; TODO apply to every symbol in list? I think it should probably only be applied to the first child of the list
-(list
-  (symbol) @tag)
-
-; Other stuff that has not been caught by the previous queries yet
-
-(ident) @variable
-(index) @variable
diff --git a/runtime/queries/zig/highlights.scm b/runtime/queries/zig/highlights.scm
index d6b1f95a2..07960d187 100644
--- a/runtime/queries/zig/highlights.scm
+++ b/runtime/queries/zig/highlights.scm
@@ -1,220 +1,290 @@
-[
-  (container_doc_comment)
-  (doc_comment)
-] @comment.documentation
+; Variables
 
-[
-  (line_comment)
-] @comment.line
+(identifier) @variable
 
-;; assume TitleCase is a type
-(
-  [
-    variable_type_function: (IDENTIFIER)
-    field_access: (IDENTIFIER)
-    parameter: (IDENTIFIER)
-  ] @type
-  (#match? @type "^[A-Z]([a-z]+[A-Za-z0-9]*)+$")
-)
-
-;; assume camelCase is a function
-(
-  [
-    variable_type_function: (IDENTIFIER)
-    field_access: (IDENTIFIER)
-    parameter: (IDENTIFIER)
-  ] @function
-  (#match? @function "^[a-z]+([A-Z][a-z0-9]*)+$")
-)
-
-;; assume all CAPS_1 is a constant
-(
-  [
-    variable_type_function: (IDENTIFIER)
-    field_access: (IDENTIFIER)
-  ] @constant
-  (#match? @constant "^[A-Z][A-Z_0-9]+$")
-)
+; Parameters
 
-;; _
-(
-  (IDENTIFIER) @variable.builtin
-  (#eq? @variable.builtin "_")
-)
+(parameter
+  name: (identifier) @variable.parameter)
 
-;; C Pointers [*c]T
-(PtrTypeStart "c" @variable.builtin)
+(payload
+  (identifier) @variable.parameter)
 
-[
-  variable: (IDENTIFIER)
-  variable_type_function: (IDENTIFIER)
-] @variable
+; Types
 
-parameter: (IDENTIFIER) @variable.parameter
+(parameter
+  type: (identifier) @type)
+
+((identifier) @type
+  (#match? @type "^[A-Z_][a-zA-Z0-9_]*"))
+
+(variable_declaration
+  (identifier) @type
+  "="
+  [
+    (struct_declaration)
+    (enum_declaration)
+    (union_declaration)
+    (opaque_declaration)
+  ])
 
 [
-  field_member: (IDENTIFIER)
-  field_access: (IDENTIFIER)
-] @variable.other.member
+  (builtin_type)
+  "anyframe"
+] @type.builtin
+
+; Constants
+
+((identifier) @constant
+  (#match? @constant "^[A-Z][A-Z_0-9]+$"))
 
 [
-  function_call: (IDENTIFIER)
-  function: (IDENTIFIER)
-] @function
+  "null"
+  "unreachable"
+  "undefined"
+] @constant.builtin
 
-exception: "!" @keyword.control.exception
+(field_expression
+  .
+  member: (identifier) @constant)
 
-field_constant: (IDENTIFIER) @constant
+(enum_declaration
+  (container_field
+    type: (identifier) @constant))
 
-(BUILTINIDENTIFIER) @function.builtin
+; Labels
 
-((BUILTINIDENTIFIER) @keyword.control.import
-  (#any-of? @keyword.control.import "@import" "@cImport"))
+(block_label
+  (identifier) @label)
 
-(INTEGER) @constant.numeric.integer
+(break_label
+  (identifier) @label)
 
-(FLOAT) @constant.numeric.float
+; Fields
 
-[
-  (LINESTRING)
-  (STRINGLITERALSINGLE)
-] @string
+(field_initializer
+  .
+  (identifier) @variable.other.member)
 
-(CHAR_LITERAL) @constant.character
-(EscapeSequence) @constant.character.escape
-(FormatSequence) @string.special
+(field_expression
+  (_)
+  member: (identifier) @variable.other.member)
 
-[
-  "anytype"
-  "anyframe"
-  (BuildinTypeExpr)
-] @type.builtin
+(field_expression
+  (_)
+  member: (identifier) @type (#match? @type "^[A-Z_][a-zA-Z0-9_]*"))
 
-(BreakLabel (IDENTIFIER) @label)
-(BlockLabel (IDENTIFIER) @label)
+(field_expression
+  (_)
+  member: (identifier) @constant (#match? @constant "^[A-Z][A-Z_0-9]+$"))
 
-[
-  "true"
-  "false"
-] @constant.builtin.boolean
+(container_field
+  name: (identifier) @variable.other.member)
 
-[
-  "undefined"
-  "unreachable"
-  "null"
-] @constant.builtin
+(initializer_list
+  (assignment_expression
+      left: (field_expression
+              .
+              member: (identifier) @variable.other.member)))
 
-[
-  "else"
-  "if"
-  "switch"
-] @keyword.control.conditional
+; Functions
 
-[
-  "for"
-  "while"
-] @keyword.control.repeat
+(builtin_identifier) @function.builtin
+
+(call_expression
+  function: (identifier) @function)
+
+(call_expression
+  function: (field_expression
+    member: (identifier) @function.method))
+
+(function_declaration
+  name: (identifier) @function)
+
+; Modules
+
+(variable_declaration
+  (_)
+  (builtin_function
+    (builtin_identifier) @keyword.control.import
+    (#any-of? @keyword.control.import "@import" "@cImport")))
+
+(variable_declaration
+  (_)
+  (field_expression
+    object: (builtin_function
+      (builtin_identifier) @keyword.control.import
+      (#any-of? @keyword.control.import "@import" "@cImport"))))
+
+; Builtins
 
 [
-  "or"
-  "and"
-  "orelse"
-] @keyword.operator
+  "c"
+  "..."
+] @variable.builtin
+
+((identifier) @variable.builtin
+  (#eq? @variable.builtin "_"))
+
+(calling_convention
+  (identifier) @variable.builtin)
+
+; Keywords
 
 [
-  "enum"
-] @type.enum
+  "asm"
+  "test"
+] @keyword
 
 [
+  "error"
+  "const"
+  "var"
   "struct"
   "union"
-  "packed"
+  "enum"
   "opaque"
-  "export"
-  "extern"
-  "linksection"
 ] @keyword.storage.type
 
+; todo: keyword.coroutine
 [
-  "const"
-  "var"
-  "threadlocal"
-  "allowzero"
-  "volatile"
-  "align"
-] @keyword.storage.modifier
+  "async"
+  "await"
+  "suspend"
+  "nosuspend"
+  "resume"
+] @keyword
 
-[
-  "try"
-  "error"
-  "catch"
-] @keyword.control.exception
+"fn" @keyword.function
 
 [
-  "fn"
-] @keyword.function
+  "and"
+  "or"
+  "orelse"
+] @keyword.operator
 
 [
-  "test"
-] @keyword
+  "try"
+  "unreachable"
+  "return"
+] @keyword.control.return
 
 [
-  "pub"
-  "usingnamespace"
-] @keyword.control.import
+  "if"
+  "else"
+  "switch"
+  "catch"
+] @keyword.control.conditional
 
 [
-  "return"
+  "for"
+  "while"
   "break"
   "continue"
-] @keyword.control.return
+] @keyword.control.repeat
+
+[
+  "usingnamespace"
+  "export"
+] @keyword.control.import
 
 [
   "defer"
   "errdefer"
-  "async"
-  "nosuspend"
-  "await"
-  "suspend"
-  "resume"
-] @function.macro
+] @keyword.control.exception
 
 [
-  "comptime"
+  "volatile"
+  "allowzero"
+  "noalias"
+  "addrspace"
+  "align"
+  "callconv"
+  "linksection"
+  "pub"
   "inline"
   "noinline"
-  "asm"
-  "callconv"
-  "noalias"
-] @keyword.directive
+  "extern"
+  "comptime"
+  "packed"
+  "threadlocal"
+] @keyword.storage.modifier
+
+; Operator
 
 [
-  (CompareOp)
-  (BitwiseOp)
-  (BitShiftOp)
-  (AdditionOp)
-  (AssignOp)
-  (MultiplyOp)
-  (PrefixOp)
+  "="
+  "*="
+  "*%="
+  "*|="
+  "/="
+  "%="
+  "+="
+  "+%="
+  "+|="
+  "-="
+  "-%="
+  "-|="
+  "<<="
+  "<<|="
+  ">>="
+  "&="
+  "^="
+  "|="
+  "!"
+  "~"
+  "-"
+  "-%"
+  "&"
+  "=="
+  "!="
+  ">"
+  ">="
+  "<="
+  "<"
+  "&"
+  "^"
+  "|"
+  "<<"
+  ">>"
+  "<<|"
+  "+"
+  "++"
+  "+%"
+  "-%"
+  "+|"
+  "-|"
   "*"
+  "/"
+  "%"
   "**"
-  "->"
-  ".?"
+  "*%"
+  "*|"
+  "||"
   ".*"
+  ".?"
   "?"
+  ".."
 ] @operator
 
-[
-  ";"
-  "."
-  ","
-  ":"
-] @punctuation.delimiter
+; Literals
+
+(character) @constant.character
 
 [
-  ".."
-  "..."
-] @punctuation.special
+  (string)
+  (multiline_string)
+] @string
+
+(integer) @constant.numeric.integer
+
+(float) @constant.numeric.float
+
+(boolean) @constant.builtin.boolean
+
+(escape_sequence) @constant.character.escape
+
+; Punctuation
 
 [
   "["
@@ -223,9 +293,22 @@
   ")"
   "{"
   "}"
-  (Payload "|")
-  (PtrPayload "|")
-  (PtrIndexPayload "|")
 ] @punctuation.bracket
 
-(ERROR) @keyword.control.exception
+[
+  ";"
+  "."
+  ","
+  ":"
+  "=>"
+  "->"
+] @punctuation.delimiter
+
+(payload "|" @punctuation.bracket)
+
+; Comments
+
+(comment) @comment.line
+
+((comment) @comment.block.documentation
+  (#match? @comment.block.documentation "^//!"))
diff --git a/runtime/queries/zig/indents.scm b/runtime/queries/zig/indents.scm
index d460214e1..8bc5e7a8d 100644
--- a/runtime/queries/zig/indents.scm
+++ b/runtime/queries/zig/indents.scm
@@ -1,13 +1,7 @@
 [
-  (AsmExpr)
-  (AssignExpr)
-  (Block)
-  (BlockExpr)
-  (ContainerDecl)
-  (ErrorUnionExpr)
-  (InitList)
-  (SwitchExpr)
-  (TestDecl)
+  (block)
+  (switch_expression)
+  (initializer_list)
 ] @indent
 
 [
diff --git a/runtime/queries/zig/injections.scm b/runtime/queries/zig/injections.scm
index 3df958971..2f0e58eb6 100644
--- a/runtime/queries/zig/injections.scm
+++ b/runtime/queries/zig/injections.scm
@@ -1,2 +1,2 @@
-([(line_comment) (doc_comment)] @injection.content
- (#set! injection.language "comment"))
+((comment) @injection.content
+  (#set! injection.language "comment"))
diff --git a/runtime/queries/zig/textobjects.scm b/runtime/queries/zig/textobjects.scm
index 5c4ebd862..243d1294d 100644
--- a/runtime/queries/zig/textobjects.scm
+++ b/runtime/queries/zig/textobjects.scm
@@ -1,23 +1,22 @@
-(Decl (FnProto)
-  (_) @function.inside) @function.around
+(function_declaration
+  body: (_) @function.inside) @function.around
 
-(TestDecl (_) @test.inside) @test.around
+(test_declaration (_) (block) @test.inside) @test.around
 
 ; matches all of: struct, enum, union
 ; this unfortunately cannot be split up because
 ; of the way struct "container" types are defined
-(Decl (VarDecl (ErrorUnionExpr (SuffixExpr (ContainerDecl
-    (_) @class.inside))))) @class.around
+(variable_declaration (identifier) (struct_declaration
+    (_) @class.inside)) @class.around
 
-(Decl (VarDecl (ErrorUnionExpr (SuffixExpr (ErrorSetDecl
-    (_) @class.inside))))) @class.around
+(variable_declaration (identifier) (enum_declaration
+    (_) @class.inside)) @class.around
 
-(ParamDeclList
+(variable_declaration (identifier) (enum_declaration
+    (_) @class.inside)) @class.around
+
+(parameters
   ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
 
-[
-  (doc_comment)
-  (line_comment)
-] @comment.inside
-(line_comment)+ @comment.around
-(doc_comment)+ @comment.around
+(comment) @comment.inside
+(comment)+ @comment.around
diff --git a/runtime/themes/adwaita-light.toml b/runtime/themes/adwaita-light.toml
new file mode 100644
index 000000000..5bbbaf68d
--- /dev/null
+++ b/runtime/themes/adwaita-light.toml
@@ -0,0 +1,110 @@
+inherits="adwaita-dark"
+"attribute" = "orange_5"
+
+"type" = "teal_4"
+"type.builtin" = "teal_4"
+
+"constructor" = "blue_4"
+
+"constant" = "violet_4"
+"constant.builtin" = { fg = "violet_4", modifiers = ["bold"] }
+"constant.character" = "teal_5"
+"constant.numeric" = { fg = "teal_5", modifiers = ["bold"] }
+"constant.character.escape" = "violet_4"
+
+"string" = "teal_3"
+"string.regexp" = "purple_4"
+"string.special" = "blue_4"
+
+"comment" = "light_6"
+
+"variable" = "dark_5"
+"variable.parameter" = "orange_4"
+"variable.builtin" = "orange_4"
+"variable.other" = "teal_4"
+"variable.other.member" = "teal_5"
+
+"label" = "purple_4"
+
+"punctuation" = "dark_4"
+"punctuation.delimiter" = "dark_4"
+"punctuation.bracket" = "dark_4"
+"punctuation.special" = "red_5"
+
+"keyword" = { fg = "orange_4", modifiers = ["bold"] }
+"keyword.control" = { fg = "orange_4", modifiers = ["bold"] }
+"keyword.operator" = "purple_4"
+"keyword.directive" = { fg = "orange_4", modifiers = ["bold"] }
+"keyword.function" = "orange_4"
+"keyword.storage" = { fg = "orange_4", modifiers = ["bold"] }
+
+"operator" = "purple_4"
+
+"function" = "blue_4"
+"function.builtin" = "blue_4"
+"function.macro" = { fg = "blue_4", modifiers = ["bold"] }
+"function.special" = { fg = "blue_4", modifiers = ["bold"] }
+
+"tag" = "teal_4"
+
+"namespace" = "orange_4"
+
+"markup" = "dark_4"
+"markup.heading" = { fg = "teal_4", modifiers = ["bold"] }
+"markup.list" = { fg = "orange_4", modifiers = ["bold"] }
+"markup.bold" = { fg = "dark_4", modifiers = ["bold"] }
+"markup.italic" = { fg = "dark_4", modifiers = ["italic"] }
+"markup.link" = { fg = "blue_5", modifiers = ["underlined"] }
+"markup.quote" = { fg = "dark_3", modifiers = ["italic"] }
+"diff.plus" = "teal_5"
+"diff.minus" = "red_3"
+"diff.delta" = "orange_5"
+"diff.delta.moved" = "orange_4"
+
+"ui.background" = { fg = "dark_4", bg = "light_1" }
+"ui.background.separator" = { fg = "split_and_borders", bg = "light_2" }
+"ui.cursor" = { fg = "light_2", bg = "dark_5" }
+"ui.cursor.insert" = { fg = "light_2", bg = "dark_4" }
+"ui.cursor.primary.insert" = { fg = "light_2", bg = "yellow_5" }
+"ui.cursor.select" = { fg = "light_2", bg = "dark_5" }
+"ui.cursor.match" = { fg = "light_2", bg = "blue_1" }
+"ui.cursor.primary" = { fg = "light_2", bg = "dark_6" }
+"ui.linenr" = "light_5"
+"ui.linenr.selected" = { fg = "dark_2", bg = "light_3", modifiers = [
+  "bold",
+] }
+"ui.statusline" = { fg = "dark_4", bg = "light_4" }
+"ui.statusline.inactive" = { fg = "dark_3", bg = "light_3" }
+"ui.statusline.insert" = { fg = "light_5", bg = "teal_3" }
+"ui.statusline.select" = { fg = "light_4", bg = "blue_3" }
+"ui.popup" = { bg = "light_3" }
+"ui.window" = "split_and_borders"
+"ui.help" = { bg = "light_3" }
+"ui.text" = "dark_4"
+"ui.virtual" = "light_1"
+"ui.virtual.ruler" = { bg = "light_5"}
+"ui.menu" = { fg = "dark_4", bg = "light_3" }
+"ui.menu.selected" = { fg = "dark_4", bg = "blue_1" }
+"ui.menu.scroll" = { fg = "dark_6", bg = "light_3" }
+"ui.selection" = { bg = "blue_0" }
+"ui.selection.primary" = { bg = "blue_0" }
+"ui.cursorline.primary" = { bg = "light_3" }
+"ui.virtual.whitespace" = "light_7"
+
+"warning" = "yellow_4"
+"error" = "red_5"
+"info" = "purple_3"
+"hint" = "blue_3"
+
+"diagnostic.hint" = { fg = "blue_4", modifiers = ["dim"] }
+"diagnostic.info" = { fg = "purple_4", modifiers = ["dim"] }
+"diagnostic.error" = { fg = "red_5", modifiers = ["underlined"] }
+"diagnostic.warning" = { fg = "yellow_4", modifiers = ["underlined"] }
+"diagnostic.unnecessary" = { modifiers = ["dim"] }
+"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
+
+"ui.bufferline" = { fg = "light_7", bg = "light_2" }
+"ui.bufferline.active" = { fg = "dark_4", bg = "light_4", modifiers = ["bold"]}
+
+[palette]
+blue_0 = "#d3e4f9"
diff --git a/runtime/themes/ao.toml b/runtime/themes/ao.toml
index 7313d9fa5..9d0ec92b7 100644
--- a/runtime/themes/ao.toml
+++ b/runtime/themes/ao.toml
@@ -39,7 +39,7 @@
 "diff.minus" = { fg = "red" }
 "diff.delta" = { fg = "brown" }
 
-# MARKUP, SYNAX HIGHLIGHTING AND INTERFACE HYBRID
+# MARKUP, SYNTAX HIGHLIGHTING AND INTERFACE HYBRID
 "markup.heading" = { fg = "blaze_orange" }
 "markup.heading.1" = { fg = "crystal_blue", modifiers = ["bold"] }
 "markup.heading.2" = { fg = "sky_blue", modifiers = ["bold"] }
diff --git a/runtime/themes/autumn.toml b/runtime/themes/autumn.toml
index 7e9b3a7e1..d7d9c00bd 100644
--- a/runtime/themes/autumn.toml
+++ b/runtime/themes/autumn.toml
@@ -68,8 +68,10 @@
 "ui.statusline.select" = { fg = "my_gray7", bg = "my_black", modifiers = ["bold"] }
 "ui.text.focus" = "my_white1"
 "ui.text" = "my_white1"
-"ui.virtual.inlay-hint" = { fg = "my_gray4", bg="my_black", modifiers = ["normal"] }
-"ui.virtual.inlay-hint.parameter" = { fg = "my_gray4", modifiers = ["normal"] }
+# Invalid modifier: "normal". See 'https://github.com/helix-editor/helix/issues/5709'
+"ui.virtual.inlay-hint" = { fg = "my_gray4", bg="my_black" } #, modifiers = ["normal"] }
+# "ui.virtual.inlay-hint.parameter" = { fg = "my_gray4", modifiers = ["normal"] }
+"ui.virtual.inlay-hint.parameter" = "my_gray4"
 "ui.virtual.inlay-hint.type" = { fg = "my_gray4", modifiers = ["italic"] }
 "ui.virtual.jump-label" = { fg = "my_yellow2", modifiers = ["bold"] }
 "ui.virtual.ruler" = { bg = "my_gray1" }
diff --git a/runtime/themes/bogster.toml b/runtime/themes/bogster.toml
index f7d08daa9..9d360e821 100644
--- a/runtime/themes/bogster.toml
+++ b/runtime/themes/bogster.toml
@@ -59,8 +59,10 @@
 "ui.text.focus" = { fg = "bogster-fg1", modifiers= ["bold"] }
 "ui.virtual.whitespace" = "bogster-base5"
 "ui.virtual.ruler" = { bg = "bogster-base0" }
+"ui.virtual.jump-label" = { fg = "bogster-base0", bg = "bogster-yellow", modifiers = [ "bold" ] }
 
-"ui.selection" = { bg = "bogster-base3" }
+"ui.selection" = { bg = "bogster-base2" }
+"ui.selection.primary" = { bg = "bogster-base3" }
 "ui.cursor.match" = { fg = "bogster-base3", bg = "bogster-orange" }
 "ui.cursor" = { fg = "bogster-base5", modifiers = ["reversed"] }
 
diff --git a/runtime/themes/carbonfox.toml b/runtime/themes/carbonfox.toml
new file mode 100644
index 000000000..12e812955
--- /dev/null
+++ b/runtime/themes/carbonfox.toml
@@ -0,0 +1,50 @@
+# Author: github.com/ETCaton
+# License: MIT License
+# Carbonfox
+#
+# Based on Helix's Nightfox port with changes to align it to Nightfox's Carbonfox theme
+# Any 'custom' colors are replicating the result of the linear color blending done in the original
+# Neovim theme.
+# https://github.com/EdenEast/nightfox.nvim/blob/d3e8b1acc095baf57af81bb5e89fe7c4359eb619/lua/nightfox/lib/color.lua#L236-L247
+
+inherits = 'nightfox'
+
+# DIAGNOSTICS
+# For brevity: All blends here are a blend between bg1 and the fg value with factor of 0.15
+"warning"  = { fg = "magenta", bg = "#2f2939" }
+"error.bg" = "#361f29"
+"info.bg"  = "#252c39"
+"hint"     = { fg = "orange", bg = "#1c3433" }
+
+[palette]
+black          = "#282828"
+red            = "#ee5396"
+red-dim        = "#ca4780"
+green          = "#25be6a"
+green-dim      = "#1fa25a"
+yellow         = "#08bdba"
+yellow-bright  = "#2dc7c4"
+blue           = "#78a9ff"
+blue-bright    = "#8cb6ff"
+blue-dim       = "#6690d9"
+magenta        = "#be95ff"
+magenta-bright = "#c8a5ff"
+cyan           = "#33b1ff"
+cyan-bright    = "#52bdff"
+cyan-dim       = "#2b96d9"
+orange         = "#3ddbd9"
+orange-bright  = "#5ae0df"
+pink           = "#ff7eb6"
+pink-bright    = "#ff91c1"
+# spec
+bg0            = "#0c0c0c"
+bg1            = "#161616"
+bg2            = "#252525"
+bg3            = "#353535"
+bg4            = "#535353"
+fg0            = "#f9fbff"
+fg1            = "#f2f4f8"
+fg2            = "#b6b8bb"
+fg3            = "#7b7c7e"
+sel0           = "#2a2a2a"
+sel1           = "#525253"
diff --git a/runtime/themes/catppuccin_mocha.toml b/runtime/themes/catppuccin_mocha.toml
index 3c030762e..8cb17f64d 100644
--- a/runtime/themes/catppuccin_mocha.toml
+++ b/runtime/themes/catppuccin_mocha.toml
@@ -1,3 +1,4 @@
+# NOTE: For contributors looking to modify the theme, please submit a pull request at https://github.com/catppuccin/helix instead of updating this file. Changes are frequently synchronized from the catppuccin/helix theme repository.
 # Syntax highlighting
 # -------------------
 "attribute" = "yellow"
@@ -21,7 +22,7 @@
 "variable" = "text"
 "variable.parameter" = { fg = "maroon", modifiers = ["italic"] }
 "variable.builtin" = "red"
-"variable.other.member" = "teal"
+"variable.other.member" = "blue"
 
 "label" = "sapphire" # used for lifetimes
 
@@ -50,6 +51,8 @@
 "markup.heading.5" = "pink"
 "markup.heading.6" = "teal"
 "markup.list" = "mauve"
+"markup.list.unchecked" = "overlay2"
+"markup.list.checked" = "green"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
 "markup.link.url" = { fg = "blue", modifiers = ["italic", "underlined"] }
@@ -84,6 +87,7 @@
 "ui.text" = "text"
 "ui.text.focus" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
 "ui.text.inactive" = { fg = "overlay1" }
+"ui.text.directory" = { fg = "blue" }
 
 "ui.virtual" = "overlay0"
 "ui.virtual.ruler" = { bg = "surface0" }
@@ -112,6 +116,7 @@
 "ui.menu" = { fg = "overlay2", bg = "surface0" }
 "ui.menu.selected" = { fg = "text", bg = "surface1", modifiers = ["bold"] }
 
+"diagnostic.unnecessary" = { modifiers = ["dim"] }
 "diagnostic.error" = { underline = { color = "red", style = "curl" } }
 "diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
 "diagnostic.info" = { underline = { color = "sky", style = "curl" } }
diff --git a/runtime/themes/darcula.toml b/runtime/themes/darcula.toml
index 7e0907c09..5b83afba8 100644
--- a/runtime/themes/darcula.toml
+++ b/runtime/themes/darcula.toml
@@ -28,6 +28,8 @@
 "ui.virtual.jump-label" = { fg = "lightblue", modifiers = ["italic", "bold"] }
 "ui.bufferline" = { fg = "grey04", bg = "grey00" }
 "ui.bufferline.active" = { fg = "grey07", bg = "grey02" }
+"ui.picker.header.column" = { fg = "grey05", modifiers = ["italic", "bold"] }
+"ui.picker.header.column.active" = { fg = "grey05", bg = "grey03", modifiers = ["italic", "bold"] }
 
 "operator" = "grey05"
 "variable" = "white"
diff --git a/runtime/themes/dark_plus.toml b/runtime/themes/dark_plus.toml
index 813eebf3c..28ec163d6 100644
--- a/runtime/themes/dark_plus.toml
+++ b/runtime/themes/dark_plus.toml
@@ -24,7 +24,7 @@
 "operator"                  = "text"
 "punctuation"               = "text"
 "punctuation.delimiter"     = "text"
-"special"                   = "text"
+"special"                   = "light_blue"
 "string"                    = "orange"
 "string.regexp"             = "gold"
 "tag"                       = "blue2"
@@ -72,11 +72,14 @@
 "ui.bufferline.background"   = { bg = "background" }
 "ui.text"                    = { fg = "text" }
 "ui.text.focus"              = { fg = "white" }
+"ui.text.directory"          = { fg = "blue2" }
+"ui.text.inactive"           = { fg = "dark_gray" }
 "ui.virtual.whitespace"      = { fg = "#3e3e3d" }
+"ui.virtual.wrap"            = { fg = "#3e3e3d" }
 "ui.virtual.ruler"           = { bg = "borders" }
 "ui.virtual.indent-guide"    = { fg = "dark_gray4" }
 "ui.virtual.inlay-hint"      = { fg = "dark_gray5"}
-"ui.virtual.jump-label"      = { fg = "dark_gray", modifiers = ["bold"] }
+"ui.virtual.jump-label"      = { fg = "yellow", modifiers = ["bold"] }
 "ui.highlight.frameline"     = { bg = "#4b4b18" }
 "ui.debug.active"            = { fg = "#ffcc00" }
 "ui.debug.breakpoint"        = { fg = "#e51400" }
diff --git a/runtime/themes/dracula.toml b/runtime/themes/dracula.toml
index c1a9a12bc..bb4a38d5e 100644
--- a/runtime/themes/dracula.toml
+++ b/runtime/themes/dracula.toml
@@ -118,6 +118,7 @@
 "ui.statusline.select"            = { fg    = "black",           bg = "cyan",          modifiers = ["bold"] }
 "ui.text"                         = { fg    = "foreground"                                                  }
 "ui.text.focus"                   = { fg    = "cyan"                                                        }
+"ui.text.directory"               = { fg    = "cyan"                                                        }
 "ui.virtual.indent-guide"         = { fg    = "indent"                                                      }
 "ui.virtual.inlay-hint"           = { fg    = "cyan"                                                        }
 "ui.virtual.inlay-hint.parameter" = { fg    = "cyan",            modifiers = ["italic", "dim"]              }
diff --git a/runtime/themes/dracula_at_night.toml b/runtime/themes/dracula_at_night.toml
index 55f261539..ac75199d9 100644
--- a/runtime/themes/dracula_at_night.toml
+++ b/runtime/themes/dracula_at_night.toml
@@ -42,6 +42,7 @@
 "ui.statusline.select" = { fg = "background_dark", bg = "purple" }
 "ui.text" = { fg = "foreground" }
 "ui.text.focus" = { fg = "cyan" }
+"ui.text.directory" = { fg = "cyan" }
 "ui.window" = { fg = "foreground" }
 "ui.virtual.jump-label" = { fg = "pink", modifiers = ["bold"] }
 "ui.virtual.ruler" = { bg = "background_dark" }
diff --git a/runtime/themes/eiffel.toml b/runtime/themes/eiffel.toml
new file mode 100644
index 000000000..ba0f5c60d
--- /dev/null
+++ b/runtime/themes/eiffel.toml
@@ -0,0 +1,180 @@
+## Author: mesmere <95945959+mesmere@users.noreply.github.com>
+## Original design by Ian Joyner
+
+"attribute" = { fg = "markup", modifiers = ["italic"] }
+"comment" = "comments"
+"comment.block" = "comments"
+"comment.block.documentation" = "comments"
+"comment.line" = "comments"
+#"constant" = ""
+"constant.builtin" = { fg = "builtins", modifiers = ["italic"] }
+"constant.character" = "strings"
+"constant.character.escape" = "symbols"
+"constant.numeric" = { fg = "constants_numeric", modifiers = ["italic"] }
+"constructor" = { modifiers = ["italic"] }
+"function" = { fg = "members" }
+"function.builtin" = "builtins"
+"function.macro" = "preprocessor"
+"function.method" = { fg = "members", modifiers = ["italic"] }
+#"function.method.private" = ""
+"function.special" = "preprocessor"
+"keyword" = { fg = "ui_text" }
+"keyword.control" = { fg = "keywords", modifiers = ["bold"] }
+"keyword.directive" = { fg = "preprocessor", modifiers = ["bold"] }
+#"keyword.function" = ""
+"keyword.operator" = { fg = "operators", modifiers = ["italic"] }
+#"keyword.storage" = ""
+#"label" = ""
+#"namespace" = ""
+"operator" = { fg = "operators", modifiers = ["bold"] }
+#"punctuation" = ""
+#"punctuation.bracket" = ""
+#"punctuation.delimiter" = ""
+"punctuation.special" = "strings"
+#"special" = ""
+"string" = "strings"
+"string.regexp" = "symbols"
+"string.special" = "symbols"
+"tag" = "markup"
+"type" = { modifiers = ["italic"] }
+#"type.builtin" = ""
+#"type.enum" = ""
+#"type.parameter" = ""
+#"variable" = ""
+"variable.builtin" = "builtins"
+"variable.other.member" = { fg = "members", modifiers = ["italic"] }
+#"variable.other.member.private" = ""
+#"variable.parameter" = ""
+"markup" = "markup"
+"markup.heading" = { fg = "markup_headings", modifiers = ["bold"] }
+#"markup.heading.marker" = ""
+"markup.list" = "markup_lists"
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { fg = "strings", underline.style = "line" } # Match HTML href/src attributes.
+#"markup.link.label" = ""
+"markup.link.text" = "ui_text"
+"markup.quote" = { fg = "black", modifiers = ["italic"] }
+"markup.raw" = "strings"
+#"markup.raw.inline" = ""
+#"markup.raw.block" = ""
+
+"diff.delta" = "diff_delta"
+"diff.minus" = "diff_minus"
+"diff.plus" = "diff_plus"
+
+"ui.background" = { bg = "ui_background" }
+#"ui.background.separator" = ""
+"ui.bufferline" = { fg = "ui_text_dim", bg = "ui_background_accent" }
+"ui.bufferline.active" = { fg = "ui_text", bg = "ui_background_accent" }
+"ui.bufferline.background" = { bg = "ui_background_accent" }
+#"ui.cursor" = { modifiers = ['reversed'] }
+"ui.cursor.insert" = { bg = "ui_mode_insert_accent" }
+"ui.cursor.match" = { modifiers = ['reversed'] }
+"ui.cursor.normal" = { bg = "ui_mode_normal_accent" }
+"ui.cursor.select" = { bg = "ui_mode_select_accent" }
+#"ui.cursor.primary" = ""
+"ui.cursor.primary.insert" = { bg = "ui_mode_insert" }
+#"ui.cursor.primary.match" = ""
+"ui.cursor.primary.normal" = { bg = "ui_mode_normal" }
+"ui.cursor.primary.select" = { bg = "ui_mode_select" }
+"ui.cursorcolumn.primary" = { bg = "ui_background_accent" }
+#"ui.cursorcolumn.secondary" = ""
+"ui.cursorline.primary" = { bg = "ui_background_accent" }
+#"ui.cursorline.secondary" = ""
+"ui.debug.active" = { fg = "ui_debug_breakpoint" }
+"ui.debug.breakpoint" = { fg = "ui_debug_breakpoint" }
+"ui.gutter" = { bg = "ui_background" }
+"ui.gutter.selected" = { bg = "ui_background_accent" }
+"ui.help" = { fg = "ui_text", bg = "ui_menu" }
+"ui.highlight" = { fg = "ui_highlight_line_text", bg = "ui_highlight_line" } # fg is not respected https://github.com/helix-editor/helix/issues/11141 
+"ui.highlight.frameline" = { fg = "ui_highlight_line_text", bg = "ui_highlight_line" }
+"ui.linenr" = "ui_text_dim"
+"ui.linenr.selected" = { fg = "ui_text_dim", bg = "ui_background_accent" }
+"ui.menu" = { fg = "ui_menu_text", bg = "ui_menu" }
+"ui.menu.scroll" = { fg = "ui_menu_handle", bg = "ui_menu_selected" }
+"ui.menu.selected" = { fg = "ui_text", bg = "ui_menu_selected" }
+#"ui.picker" = { fg = "ui_text", bg = "ui_menu" } # Styling the picker is currently unsupported.
+"ui.picker.header" = { bg = "ui_background_accent" }
+"ui.picker.header.column" = "ui_text"
+"ui.picker.header.column.active" = { fg = "ui_text", modifiers = ["bold"], underline = { style = "line" } }
+"ui.popup" = { fg = "ui_text", bg = "ui_background_accent" }
+"ui.popup.info" = { fg = "ui_text", bg = "ui_menu" }
+"ui.selection" = { bg = "ui_selection" }
+#"ui.selection.primary" = { bg = "ui_selection", underline.style = "line" }
+"ui.statusline" = { fg = "ui_text", bg = "ui_background_accent" }
+#"ui.statusline.inactive" = { fg = "", bg = "" }
+"ui.statusline.insert" = { fg = "ui_mode_insert_text", bg = "ui_mode_insert", modifiers = ["bold"] } 
+"ui.statusline.normal" = { fg = "ui_mode_normal_text", bg = "ui_mode_normal", modifiers = ["bold"] }
+"ui.statusline.select" = { fg = "ui_mode_select_text", bg = "ui_mode_select", modifiers = ["bold"] }
+"ui.text" = "ui_text"
+"ui.text.focus" = { fg = "ui_text", modifiers = ["bold"] }
+"ui.text.inactive" = "ui_text_dim"
+#"ui.text.info" = ""
+"ui.virtual.indent-guide" = "ui_text_dim"
+"ui.virtual.inlay-hint" = "ui_text_dim"
+#"ui.virtual.inlay-hint.parameter" = ""
+#"ui.virtual.inlay-hint.type" = ""
+"ui.virtual.jump-label" = { fg = "white", bg = "ui_jumplabel", modifiers = ["bold"] }
+"ui.virtual.ruler" = { bg = "ui_background_accent" }
+"ui.virtual.whitespace" = "ui_text_dim"
+"ui.virtual.wrap" = "ui_text_dim"
+"ui.window" = "ui_split_line"
+
+info = { fg = 'ui_diagnostic_info' }
+hint = { fg = 'ui_diagnostic_hint', modifiers = ['bold'] }
+warning = { fg = 'ui_diagnostic_warning', modifiers = ['bold'] }
+error = { fg = 'ui_diagnostic_error', modifiers = ['bold'] }
+
+"diagnostic.info" = { fg = "ui_diagnostic_info", underline = { style = "curl", color = "ui_diagnostic_info" } }
+"diagnostic.hint" = { fg = "ui_diagnostic_hint", underline = { style = "curl", color = "ui_diagnostic_hint" } }
+"diagnostic.warning" = { fg = "ui_diagnostic_warning", underline = { style = "curl", color = "ui_diagnostic_warning" } }
+"diagnostic.error" = { fg = "ui_diagnostic_error", underline = { style = "curl", color = "ui_diagnostic_error" } }
+"diagnostic.unnecessary" = { modifiers = ["dim"] }
+"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
+
+[palette]
+builtins = "#585cf6"
+comments = "#00b418"
+constants_numeric = "#cd0000"
+diff_delta = "#0000a2"
+diff_minus = "#990000"
+diff_plus = "#00b418"
+keywords = "#0100b6"
+markup = "#1c02ff"
+markup_headings = "#0c07ff"
+markup_lists = "#b90690"
+members = "#0206ff"
+operators = "#0100b6"
+preprocessor = "#0c450d"
+strings = "#d80800"
+symbols = "#26b31a"
+ui_background = "#ffffff"
+ui_background_accent = "#ededed"
+ui_highlight_line = "#0100b6"
+ui_highlight_line_text = "#ffffff"
+ui_debug_breakpoint = "#990000"
+ui_diagnostic_error = "#990000"
+ui_diagnostic_hint = "#06960e"
+ui_diagnostic_info = "#808080"
+ui_diagnostic_warning = "#fafa28"
+ui_jumplabel = "#990000"
+ui_menu = "#c3dcff"
+ui_menu_selected = "#a3bcdf"
+ui_menu_handle = "#839cbf"
+ui_menu_text = "#000000"
+ui_mode_insert = "#009608"
+ui_mode_insert_accent = "#73e678"
+ui_mode_insert_text = "#ffffff"
+ui_mode_normal = "#444444" 
+ui_mode_normal_accent = "#cccccc"
+ui_mode_normal_text = "#ffffff"
+ui_mode_select = "#000096" 
+ui_mode_select_accent = "#7373e6"
+ui_mode_select_text = "#ffffff"
+ui_selection = "#c3dcff"
+ui_split_line = "#000000"
+ui_statusline = "#000000"
+ui_text = "#000000"
+ui_text_dim = "#808080"
diff --git a/runtime/themes/emacs.toml b/runtime/themes/emacs.toml
index c60afe99e..dfd55e07b 100644
--- a/runtime/themes/emacs.toml
+++ b/runtime/themes/emacs.toml
@@ -68,7 +68,8 @@
 "ui.menu.selected" = { fg = "dark_red", bg = "light_blue" }
 "ui.selection" = { bg = "lightgoldenrod1" }
 "ui.selection.primary" = { bg = "lightgoldenrod2" }
-"ui.virtual.whitespace" = "highlight"
+# Malformed ANSI: highlight. See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.virtual.whitespace" = "highlight"
 "ui.virtual.ruler" = { bg = "gray95" }
 "ui.virtual.inlay-hint" = { fg = "gray75" }
 "ui.cursorline.primary" = { bg = "darkseagreen2" }
diff --git a/runtime/themes/everforest_dark.toml b/runtime/themes/everforest_dark.toml
index eed60df3f..f21cee8b1 100644
--- a/runtime/themes/everforest_dark.toml
+++ b/runtime/themes/everforest_dark.toml
@@ -94,6 +94,7 @@
 "ui.window" = { fg = "bg4", bg = "bg_dim" }
 "ui.help" = { fg = "fg", bg = "bg2" }
 "ui.text" = "fg"
+"ui.text.directory" = { fg = "green" }
 "ui.text.focus" = "fg"
 "ui.menu" = { fg = "fg", bg = "bg3" }
 "ui.menu.selected" = { fg = "bg0", bg = "green" }
diff --git a/runtime/themes/everforest_light.toml b/runtime/themes/everforest_light.toml
index 04482c89d..450f3e461 100644
--- a/runtime/themes/everforest_light.toml
+++ b/runtime/themes/everforest_light.toml
@@ -93,6 +93,7 @@
 "ui.window" = { fg = "bg4", bg = "bg_dim" }
 "ui.help" = { fg = "fg", bg = "bg2" }
 "ui.text" = "fg"
+"ui.text.directory" = { fg = "green" }
 "ui.text.focus" = "fg"
 "ui.menu" = { fg = "fg", bg = "bg3" }
 "ui.menu.selected" = { fg = "bg0", bg = "green" }
diff --git a/runtime/themes/flatwhite.toml b/runtime/themes/flatwhite.toml
index cc8f536cb..1da203502 100644
--- a/runtime/themes/flatwhite.toml
+++ b/runtime/themes/flatwhite.toml
@@ -61,8 +61,11 @@
 "ui.virtual" = { fg = "base5", bg = "base6" }
 "ui.virtual.whitespace" = { fg = "base5" }
 "ui.virtual.ruler" = { bg = "base6" }
-"ui.virtual.inlay-hint" = { fg = "base4", modifiers = ["normal"] }
-"ui.virtual.inlay-hint.parameter" = { fg = "base3", modifiers = ["normal"] }
+# Invalid modifier: "normal". See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.virtual.inlay-hint" = { fg = "base4", modifiers = ["normal"] }
+# "ui.virtual.inlay-hint.parameter" = { fg = "base3", modifiers = ["normal"] }
+"ui.virtual.inlay-hint" = "base4"
+"ui.virtual.inlay-hint.parameter" = "base3"
 "ui.virtual.inlay-hint.type" = { fg = "base3", modifiers = ["italic"] }
 
 "ui.linenr" = { bg = "base6" }
diff --git a/runtime/themes/flexoki_light.toml b/runtime/themes/flexoki_light.toml
index 8badd9222..5f8604e9f 100644
--- a/runtime/themes/flexoki_light.toml
+++ b/runtime/themes/flexoki_light.toml
@@ -26,6 +26,8 @@
 "ui.menu.selected" = { bg = "ui", fg = "tx" }
 "ui.debug" = { fg = "or", bg = "bg" }
 "ui.highlight.frameline" = { bg = "ye" }
+"ui.bufferline" = { fg = "tx-2", bg = "bg-2"}                      
+"ui.bufferline.active" = { fg = "ye", bg = "bg-2" }                          
 "diagnostic.hint" = { underline = { color = "bl", style = "curl" } }
 "diagnostic.info" = { underline = { color = "bl", style = "curl" } }
 "diagnostic.warning" = { underline = { color = "ye", style = "curl" } }
@@ -36,7 +38,6 @@
 "info" = { fg = "ye", modifiers = ["bold"] }
 "warning" = { fg = "or", modifiers = ["bold"] }
 "error" = { fg = "re", modifiers = ["bold"] }
-
 "attribute" = "ye"
 "type" = "ye"
 "constructor" = "gr"
@@ -62,7 +63,6 @@
 "function" = "or"
 "tag" = "bl"
 "namespace" = "re"
-
 "markup.heading" = "or"
 "markup.list" = "ye"
 "markup.bold" = { fg = "or", modifiers = ["bold"] }
@@ -88,6 +88,7 @@ ui = "#E6E4D9"
 bg-2 = "#F2F0E5"
 bg = "#FFFCF0"
 
+
 re = "#AF3029"
 or = "#BC5215"
 ye = "#AD8301"
diff --git a/runtime/themes/github_dark.toml b/runtime/themes/github_dark.toml
index e98032108..c0f89cc81 100644
--- a/runtime/themes/github_dark.toml
+++ b/runtime/themes/github_dark.toml
@@ -59,6 +59,7 @@ label = "scale.red.3"
 "ui.text" = { fg = "fg.muted" }
 "ui.text.focus" = { fg = "fg.default" }
 "ui.text.inactive" = "fg.subtle"
+"ui.text.directory" = { fg = "scale.blue.2" }
 "ui.virtual" = { fg = "scale.gray.6" }
 "ui.virtual.ruler" = { bg = "canvas.subtle" }
 "ui.virtual.jump-label" = { fg = "scale.red.2", modifiers = ["bold"] }
diff --git a/runtime/themes/github_light.toml b/runtime/themes/github_light.toml
index cd3f1e5d1..6fa79c7d6 100644
--- a/runtime/themes/github_light.toml
+++ b/runtime/themes/github_light.toml
@@ -59,6 +59,7 @@ label = "scale.red.5"
 "ui.text" = { fg = "fg.muted" }
 "ui.text.focus" = { fg = "fg.default" }
 "ui.text.inactive" = "fg.subtle"
+"ui.text.directory" = { fg = "scale.blue.4" }
 "ui.virtual" = { fg = "scale.gray.2" }
 "ui.virtual.ruler" = { bg = "canvas.subtle" }
 
diff --git a/runtime/themes/gruber-darker.toml b/runtime/themes/gruber-darker.toml
index 4737f52f7..856743ecd 100644
--- a/runtime/themes/gruber-darker.toml
+++ b/runtime/themes/gruber-darker.toml
@@ -54,6 +54,7 @@
 "ui.window" = { fg = "bg1" }
 "ui.help" = { bg = "bg1", fg = "fg0" }
 "ui.text" = { fg = "fg0" }
+"ui.text.directory" = { fg = "niagara0", modifiers = ["bold"] }
 "ui.text.focus" = { bg = "bg5", modifiers = ["bold"] }
 "ui.selection" = { bg = "bg2" }
 "ui.selection.primary" = { bg = "bg5" }
@@ -67,6 +68,7 @@
 "ui.virtual.ruler" = { bg = "bg1" }
 "ui.virtual.inlay-hint" = { fg = "bg7" }
 "ui.virtual.wrap" = { fg = "bg2" }
+"ui.virtual.jump-label" = { fg = "red3", modifiers = ["bold"] }
 
 "diagnostic.warning" = { underline = { color = "orange1", style = "dashed" } }
 "diagnostic.error" = { underline = { color = "red3", style = "dashed" } }
diff --git a/runtime/themes/gruvbox.toml b/runtime/themes/gruvbox.toml
index e91b6f322..933b63125 100644
--- a/runtime/themes/gruvbox.toml
+++ b/runtime/themes/gruvbox.toml
@@ -106,6 +106,7 @@
 "ui.statusline.select" = { fg = "bg1", bg = "orange1", modifiers = ["bold"] }
 
 "ui.text" = { fg = "fg1" }
+"ui.text.directory" = { fg = "blue1" }
 "ui.virtual.inlay-hint" = { fg = "gray" }
 "ui.virtual.jump-label" = { fg = "purple0", modifiers = ["bold"] }
 "ui.virtual.ruler" = { bg = "bg1" }
diff --git a/runtime/themes/hex_lavender.toml b/runtime/themes/hex_lavender.toml
index d7c54be69..b14f3cafd 100644
--- a/runtime/themes/hex_lavender.toml
+++ b/runtime/themes/hex_lavender.toml
@@ -1,13 +1,15 @@
+# Author : portalsurfer <https://github.com/PORTALSURFER>
+
 inherits = "hex_steel"
 
 [palette]
 t1 = "#0e0e0d"
-t2 = "#121311"
+t2 = "#181a17"
 t3 = "#2b3444"
 t4 = "#61586f"
 t5 = "#686e73"
 t6 = "#878480"
-t7 = "#897dca"
+t7 = "#8e80de"
 t8 = "#7b89a3"
 t9 = "#bcb6ba"
 t10 = "#9db2b8"
@@ -20,12 +22,20 @@ highlight_three = "#29bbff"
 black = "#000000"
 
 selection = "#290019"
+selection_fg = "#958e9a"
 
-comment = "#9aacfe"
+comment = "#404768"
 comment_doc = "#0affa9"
 
 error = "#ff0900"
 warning = "#ffbf00"
 display = "#57ff89"
 info = "#dad7d5"
-#
+
+hints = "#44273f"
+ruler  = "#1c1f1b"
+
+diff_minus = "#ff4000"
+diff_delta = "#0078bd"
+diff_plus = "#c9d400"
+diff_delta_moved = "#0048bd"
\ No newline at end of file
diff --git a/runtime/themes/hex_poison.toml b/runtime/themes/hex_poison.toml
new file mode 100644
index 000000000..0d6e13eee
--- /dev/null
+++ b/runtime/themes/hex_poison.toml
@@ -0,0 +1,41 @@
+# Author : portalsurfer <https://github.com/PORTALSURFER>
+
+inherits = "hex_steel"
+
+[palette]
+t1 = "#121211"
+t2 = "#1e1f1b"
+t3 = "#4c513a"
+t4 = "#5a6052"
+t5 = "#6f6d6f"
+t8 = "#7e808a"
+t7 = "#b1b354"
+t10 = "#6fa197"
+t9 = "#3f4a4e"
+t6 = "#98acaa"
+t11 = "#6fd7a8"
+
+highlight = "#ff2e5f"
+highlight_two = "#0affa9"
+highlight_three = "#d7ff52"
+
+black = "#000000"
+
+selection = "#290019"
+selection_fg = "#c8e732"
+
+comment = "#396884"
+comment_doc = "#234048"
+
+error = "#c73500"
+warning = "#dcbb00"
+display = "#57ff89"
+info = "#dad7d5"
+
+hints = "#313d3c"
+ruler  = "#21221e"
+
+diff_minus = "#ff4000"
+diff_delta = "#16a7c7"
+diff_plus = "#c9d400"
+diff_delta_moved = "#0048bd"
\ No newline at end of file
diff --git a/runtime/themes/hex_steel.toml b/runtime/themes/hex_steel.toml
index fb4fc1fd8..d133cf7f3 100644
--- a/runtime/themes/hex_steel.toml
+++ b/runtime/themes/hex_steel.toml
@@ -1,14 +1,16 @@
+# Author : portalsurfer <https://github.com/PORTALSURFER>
+
 "comment" = { fg = "comment" }
 "comment.block.documentation" = { bg = "comment_doc", modifiers = ["italic"] }
 
 "constant" = { fg = "t11" }
 "function" = { fg = "t10" }
-"function.method" = { fg = "t10" }
+"function.method" = { fg = "t7" }
 "function.macro" = { fg = "t7" }
 "keyword.storage.modifier" = { fg = "t7" }
 "keyword.control.import" = { fg = "t8" }
 "keyword.control" = { fg = "t8" }
-"keyword.function" = { fg = "t7" }
+"keyword.function" = { fg = "t11" }
 "keyword" = { fg = "t6" }
 "operator" = { fg = "t8" }
 "punctuation" = { fg = "t9" }
@@ -18,6 +20,8 @@
 "type" = { fg = "t8", modifiers = ["bold"] }
 "namespace" = { fg = "t6", modifiers = ["bold"] }
 "variable" = { fg = "t4" }
+"variable.parameter" = { fg = "t6" } 
+"variable.other.member" = { fg = "t3" } 
 "label" = { fg = "t4" }
 
 "diff.plus" = { fg = "diff_plus" }
@@ -25,10 +29,12 @@
 "diff.delta.moved" = { fg = "diff_delta_moved" }
 "diff.minus" = { fg = "diff_minus" }
 
-"ui.cursor.insert" = { fg = "t2", bg = "highlight" }
-"ui.cursor.select" = { fg = "t2", bg = "highlight_two" }
-"ui.cursor" = { fg = "t1", bg = "highlight_three" }
-"ui.cursor.match" = { fg = "highlight", bg = "selection", modifiers = ["bold"] }
+"ui.cursor.primary.insert" = { fg = "t2", bg = "highlight" }
+"ui.cursor.primary.select" = { fg = "t2", bg = "highlight_two" }
+"ui.cursor.primary" = { fg = "t1", bg = "highlight_three" }
+"ui.cursor.match" = { fg = "highlight", bg = "t1", modifiers = ["bold"] }
+"ui.cursorline.primary" = { bg = "ruler" }
+"ui.cursorline.secondary" = { bg = "ruler" }
 
 "ui.linenr" = { fg = "t3", bg = "t2" }
 "ui.linenr.selected" = { fg = "highlight_three", bg = "t2" }
@@ -42,10 +48,7 @@
 "ui.popup" = { fg = "t4", bg = "t1" }
 "ui.window" = { fg = "t4" }
 
-"ui.selection.primary" = { bg = "selection" }
-"ui.selection" = { bg = "selection" }
-
-"ui.cursorline.primary" = { bg = "t1" }
+"ui.selection" = { fg = "selection_fg", bg = "selection" }
 
 "ui.statusline" = { fg = "t4", bg = "t1" }
 "ui.statusline.inactive" = { fg = "t4", bg = "t1" }
@@ -55,17 +58,20 @@
 
 "ui.text" = { fg = "t4" }
 "ui.text.focus" = { fg = "highlight_three", modifiers = ["bold"] }
-#
-"ui.virtual.ruler" = { bg = "t1" }
+
+"ui.virtual.ruler" = { bg = "ruler" }
 "ui.virtual.indent-guide" = { fg = "t3" }
 "ui.virtual.whitespace" = { fg = "t3" }
+"ui.virtual.jump-label" = { fg = "t11", modifiers = ["bold"] }
+"ui.virtual.inlay-hint" = { fg = "hints", modifiers = ["bold"] }
+
+"ui.bufferline" = { fg = "t3", bg = "t1" }
+"ui.bufferline.active" = { fg = "t7", bg = "t2" }
 
 "diagnostic.error" = { underline = { color = "error", style = "curl" } }
 "diagnostic.warning" = { underline = { color = "warning", style = "curl" } }
 "diagnostic.info" = { underline = { color = "info", style = "curl" } }
 "diagnostic.hint" = { underline = { color = "display", style = "curl" } }
-"diagnostic.unnecessary" = { modifiers = ["dim"] }
-"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
 
 "error" = { fg = "error", modifiers = ["bold"] }
 "warning" = { fg = "warning", modifiers = ["bold"] }
@@ -73,14 +79,14 @@
 "hint" = { fg = "display", modifiers = ["bold"] }
 "special" = { fg = "t7", modifiers = ["bold"] }
 
-"markup.heading" = { fg = "t4" }
-"markup.list" = { fg = "t4" }
+"markup.heading" = { fg = "t7" }
+"markup.list" = { fg = "t7" }
 "markup.bold" = { fg = "t4" }
 "markup.italic" = { fg = "t4" }
 "markup.strikethrough" = { fg = "t4", modifiers = ["crossed_out"] }
-"markup.link.url" = { fg = "t4", modifiers = ["underlined"] }
-"markup.link.text" = { fg = "t4" }
-"markup.quote" = { fg = "t4" }
+"markup.link.url" = { fg = "t11", modifiers = ["underlined"] }
+"markup.link.text" = { fg = "t11" }
+"markup.quote" = { fg = "t5" }
 "markup.raw" = { fg = "t4" }
 
 [palette]
@@ -93,25 +99,28 @@ t6 = "#6e8789"
 t7 = "#d85c60"
 t8 = "#9bc1bb"
 t9 = "#b5c5c5"
-t10 = "#c0d0ce"
+t10 = "#c3c3bd"
 t11 = "#f78c5e"
 
-highlight = "#3f36f2"
+highlight = "#f23672"
 highlight_two = "#f69c3c"
 highlight_three = "#d4d987"
 
-selection = "#032d4a"
+selection = "#4a9aa6"
+selection_fg = "#080a0b"
 
 black = "#000000"
-comment = "#d4d987"
+comment = "#654642"
 comment_doc = "#234048"
+hints = "#31353c"
+ruler  = "#222320"
 
-error = "#ff0900"
+error = "#ff4000"
 warning = "#ffbf00"
 display = "#42baff"
 info = "#dad7d5"
 
-diff_minus = "#ff0900"
+diff_minus = "#ff4000"
 diff_delta = "#0078bd"
-diff_plus = "#87a800"
+diff_plus = "#c9d400"
 diff_delta_moved = "#0048bd"
diff --git a/runtime/themes/hex_toxic.toml b/runtime/themes/hex_toxic.toml
index 33bfa6e5f..33f51185b 100644
--- a/runtime/themes/hex_toxic.toml
+++ b/runtime/themes/hex_toxic.toml
@@ -1,3 +1,5 @@
+# Author : portalsurfer <https://github.com/PORTALSURFER>
+
 inherits = "hex_steel"
 
 [palette]
@@ -19,12 +21,21 @@ highlight_three = "#f8ed8b"
 
 black = "#000000"
 
-selection = "#382e1e"
+selection = "#b10656"
+selection_fg = "#101719"
 
-comment = "#61bdd1"
+comment = "#417e8c"
 comment_doc = "#234048"
 
 error = "#ff0900"
 warning = "#ffbf00"
 display = "#57ff89"
 info = "#dad7d5"
+
+hints = "#39515c"
+ruler  = "#1e3039"
+
+diff_minus = "#ff4000"
+diff_delta = "#0078bd"
+diff_plus = "#c9d400"
+diff_delta_moved = "#0048bd"
\ No newline at end of file
diff --git a/runtime/themes/horizon-dark.toml b/runtime/themes/horizon-dark.toml
index e51ec09f5..d8d181291 100644
--- a/runtime/themes/horizon-dark.toml
+++ b/runtime/themes/horizon-dark.toml
@@ -33,7 +33,7 @@ tag = "red"
 "ui.selection" = { bg = "selection" }
 "ui.virtual.indent-guide" = { fg = "gray" }
 "ui.virtual.whitespace" = { fg = "light-gray" }
-"ui.virtual.ruler" = { bg ="dark-bg" }
+"ui.virtual.ruler" = { bg = "dark-bg" }
 "ui.statusline" = { bg = "dark-bg", fg = "light-gray" }
 "ui.popup" = { bg = "dark-bg", fg = "orange" }
 "ui.help" = { bg = "dark-bg", fg = "orange" }
@@ -43,6 +43,8 @@ tag = "red"
 "ui.bufferline" = { bg = "dark-bg", fg = "light-gray" }
 "ui.bufferline.active" = { bg = "dark-bg", fg = "orange" }
 "ui.virtual.jump-label" = { fg = "pink", modifiers = ["bold"] }
+"ui.picker.header.column" = { fg = "orange", underline.style = "line" }
+"ui.picker.header.column.active" = { fg = "purple", modifiers = ["bold"], underline.style = "line" }
 
 # Diagnostics
 "diagnostic" = { underline = { style = "curl" } }
diff --git a/runtime/themes/iceberg-dark.toml b/runtime/themes/iceberg-dark.toml
index b6e0cf522..08d2fd971 100644
--- a/runtime/themes/iceberg-dark.toml
+++ b/runtime/themes/iceberg-dark.toml
@@ -68,6 +68,7 @@
 "ui.cursor.normal" = { bg = "gray" }
 "ui.cursor.primary" = { modifiers = ["reversed"] }
 "ui.cursor.select" = { bg = "gray" }
+"ui.cursorline.primary" = { bg = "linenr_bg" }
 "ui.gutter" = { fg = "linenr_fg", bg = "linenr_bg" }
 "ui.help" = { fg = "background_fg", bg = "cursorlinenr_bg" }
 "ui.linenr" = { fg = "linenr_fg", bg = "linenr_bg" }
diff --git a/runtime/themes/iroaseta.toml b/runtime/themes/iroaseta.toml
index a26293d62..0683e790d 100644
--- a/runtime/themes/iroaseta.toml
+++ b/runtime/themes/iroaseta.toml
@@ -39,7 +39,7 @@
 "diff.minus" = { fg = "red" }
 "diff.delta" = { fg = "brown" }
 
-# MARKUP, SYNAX HIGHLIGHTING AND INTERFACE HYBRID
+# MARKUP, SYNTAX HIGHLIGHTING AND INTERFACE HYBRID
 "markup.heading" = { fg = "blaze_orange" }
 "markup.heading.1" = { fg = "crystal_blue", modifiers = ["bold"] }
 "markup.heading.2" = { fg = "sky_blue", modifiers = ["bold"] }
diff --git a/runtime/themes/kanagawa.toml b/runtime/themes/kanagawa.toml
index dabece68d..8d5a80eef 100644
--- a/runtime/themes/kanagawa.toml
+++ b/runtime/themes/kanagawa.toml
@@ -25,7 +25,8 @@
 "ui.statusline.normal" = { fg = "sumiInk0", bg = "crystalBlue", modifiers = ["bold"] }
 "ui.statusline.insert" = { fg = "sumiInk0", bg = "autumnGreen", modifiers = ["bold"] }
 "ui.statusline.select" = { fg = "sumiInk0", bg = "oniViolet", modifiers = ["bold"] }
-"ui.statusline.separator" = { fg = "", bg = "" }
+# Malformed ANSI: "". See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.statusline.separator" = { fg = "", bg = "" }
 
 "ui.bufferline" = { fg = "fujiGray", bg = "sumiInk0" }
 "ui.bufferline.active" = { fg = "oldWhite", bg = "sumiInk0" }
diff --git a/runtime/themes/licenses/carbonfox.license b/runtime/themes/licenses/carbonfox.license
new file mode 100644
index 000000000..4f446e776
--- /dev/null
+++ b/runtime/themes/licenses/carbonfox.license
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2021 James Simpson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
\ No newline at end of file
diff --git a/runtime/themes/material_deep_ocean.toml b/runtime/themes/material_deep_ocean.toml
index 8b1e3c861..76041d07d 100644
--- a/runtime/themes/material_deep_ocean.toml
+++ b/runtime/themes/material_deep_ocean.toml
@@ -60,6 +60,7 @@
 
 "ui.background" = { bg = "bg", fg = "text" }
 "ui.text" = { fg = "text" }
+"ui.text.directory" = { fg = "blue" }
 
 "ui.statusline" = { bg = "bg", fg = "text" }
 "ui.statusline.inactive" = { bg = "bg", fg = "disabled" }
diff --git a/runtime/themes/modus_operandi.toml b/runtime/themes/modus_operandi.toml
index 362f97778..c0c76a3da 100644
--- a/runtime/themes/modus_operandi.toml
+++ b/runtime/themes/modus_operandi.toml
@@ -1,6 +1,6 @@
 # Author: Alexis Mousset <contact@amousset.me>
 # Adapted from https://protesilaos.com/emacs/modus-themes, by Protesilaos Stavrou
-# Version 4.4.0
+# Version 4.6.0
 #
 
 # Syntax highlighting
@@ -72,9 +72,10 @@ punctuation = "fg-dim"
 
 "ui.popup" = { fg = "fg-main", bg = "bg-dim" }
 "ui.window" = { fg = "fg-dim" }
-"ui.help" = { fg = "fg-main", bg = "bg-dim" }
+"ui.help" = { fg = "fg-main", bg = "bg-active" }
 "ui.gutter" = { bg = "bg-dim" }
 "ui.text" = "fg-main"
+"ui.text.directory" = "blue"
 "ui.text.focus" = { fg = "fg-main", bg = "bg-completion", modifiers = ["bold"] }
 "ui.text.inactive" = { fg = "fg-dim" }
 "ui.virtual" = "bg-active"
diff --git a/runtime/themes/modus_operandi_deuteranopia.toml b/runtime/themes/modus_operandi_deuteranopia.toml
index 27f19a7ad..24d460f6d 100644
--- a/runtime/themes/modus_operandi_deuteranopia.toml
+++ b/runtime/themes/modus_operandi_deuteranopia.toml
@@ -2,7 +2,7 @@
 # modus_operandi.toml variant
 #
 # This variant is optimized for users with red-green color deficiency (deuteranopia)
-# Version 4.4.0
+# Version 4.6.0
 
 inherits = "modus_operandi"
 
diff --git a/runtime/themes/modus_operandi_tinted.toml b/runtime/themes/modus_operandi_tinted.toml
index 1f285361b..63c74f2a1 100644
--- a/runtime/themes/modus_operandi_tinted.toml
+++ b/runtime/themes/modus_operandi_tinted.toml
@@ -1,6 +1,6 @@
 # Author: Alexis Mousset <contact@amousset.me>
 # modus_operandi.toml variant
-# Version 4.4.0
+# Version 4.6.0
 
 inherits = "modus_operandi"
 
diff --git a/runtime/themes/modus_operandi_tritanopia.toml b/runtime/themes/modus_operandi_tritanopia.toml
index 49d40e931..90fa59f6c 100644
--- a/runtime/themes/modus_operandi_tritanopia.toml
+++ b/runtime/themes/modus_operandi_tritanopia.toml
@@ -2,7 +2,7 @@
 # modus_operandi.toml variant
 #
 # This variant is optimized for users with blue-yellow color deficiency (tritanopia)
-# Version 4.4.0
+# Version 4.6.0
 
 inherits = "modus_operandi"
 
diff --git a/runtime/themes/modus_vivendi.toml b/runtime/themes/modus_vivendi.toml
index 952683ee7..5868f4f86 100644
--- a/runtime/themes/modus_vivendi.toml
+++ b/runtime/themes/modus_vivendi.toml
@@ -1,7 +1,7 @@
 # Author: Matous Dzivjak <matousdzivjak@gmail.com>
 # Adapted from https://protesilaos.com/emacs/modus-themes, by Protesilaos Stavrou
 # Source: https://github.com/protesilaos/modus-themes/blob/main/modus-vivendi-theme.el
-# Version 4.4.0
+# Version 4.6.0
 
 # Syntax highlighting
 # -------------------
@@ -75,9 +75,10 @@ punctuation = "fg-dim"
 
 "ui.popup" = { fg = "fg-main", bg = "bg-dim" }
 "ui.window" = { fg = "fg-dim" }
-"ui.help" = { fg = "fg-main", bg = "bg-dim" }
+"ui.help" = { fg = "fg-main", bg = "bg-active" }
 "ui.gutter" = { bg = "bg-dim" }
 "ui.text" = "fg-main"
+"ui.text.directory" = "blue-cooler"
 "ui.text.focus" = { fg = "fg-main", bg = "bg-completion", modifiers = ["bold"] }
 "ui.text.inactive" = { fg = "fg-dim" }
 "ui.virtual" = "bg-active"
@@ -124,7 +125,7 @@ bg-inactive = "#303030"
 # Common accent foregrounds
 red = "#ff5f59"
 red-warmer = "#ff6b55"
-red-cooler = "#ff7f9f"
+red-cooler = "#ff7f86"
 red-faint = "#ff9580"
 red-intense = "#ff5f5f"
 green = "#44bc44"
diff --git a/runtime/themes/modus_vivendi_deuteranopia.toml b/runtime/themes/modus_vivendi_deuteranopia.toml
index 294196f31..a787359e0 100644
--- a/runtime/themes/modus_vivendi_deuteranopia.toml
+++ b/runtime/themes/modus_vivendi_deuteranopia.toml
@@ -1,7 +1,7 @@
 # Author: Matous Dzivjak <matousdzivjak@gmail.com>
 # Adapted from https://protesilaos.com/emacs/modus-themes, by Protesilaos Stavrou
 # Source: https://github.com/protesilaos/modus-themes/blob/main/modus-vivendi-deuteranopia-theme.el
-# Version 4.3.0
+# Version 4.6.0
 
 inherits = "modus_vivendi"
 
@@ -37,7 +37,7 @@ border = "#646464"
 # Common accent foregrounds
 red = "#ff5f59"
 red-warmer = "#ff6b55"
-red-cooler = "#ff7f9f"
+red-cooler = "#ff7f86"
 red-faint = "#ff9580"
 red-intense = "#ff5f5f"
 green = "#44bc44"
diff --git a/runtime/themes/modus_vivendi_tinted.toml b/runtime/themes/modus_vivendi_tinted.toml
index 2f9e2bb19..c7f9f76f3 100644
--- a/runtime/themes/modus_vivendi_tinted.toml
+++ b/runtime/themes/modus_vivendi_tinted.toml
@@ -1,7 +1,7 @@
 # Author: Matous Dzivjak <matousdzivjak@gmail.com>
 # Adapted from: https://protesilaos.com/emacs/modus-themes, by Protesilaos Stavrou
 # Source: https://github.com/protesilaos/modus-themes/blob/main/modus-vivendi-tinted-theme.el
-# Version 4.4.0
+# Version 4.6.0
 
 inherits = "modus_vivendi"
 
@@ -23,7 +23,7 @@ border = "#61647a"
 # Common accent foregrounds
 red = "#ff5f59"
 red-warmer = "#ff6b55"
-red-cooler = "#ff7f9f"
+red-cooler = "#ff7f86"
 red-faint = "#ff9f80"
 red-intense = "#ff5f5f"
 green = "#44bc44"
diff --git a/runtime/themes/modus_vivendi_tritanopia.toml b/runtime/themes/modus_vivendi_tritanopia.toml
index 7d8569d23..89cbee75e 100644
--- a/runtime/themes/modus_vivendi_tritanopia.toml
+++ b/runtime/themes/modus_vivendi_tritanopia.toml
@@ -1,7 +1,7 @@
 # Author: Matous Dzivjak <matousdzivjak@gmail.com>
 # Adapted from https://protesilaos.com/emacs/modus-themes, by Protesilaos Stavrou
 # Source: https://github.com/protesilaos/modus-themes/blob/main/modus-vivendi-tritanopia-theme.el
-# Version 4.3.0
+# Version 4.6.0
 
 inherits = "modus_vivendi"
 
@@ -51,7 +51,7 @@ border = "#646464"
 # Common accent foregrounds
 red = "#ff5f59"
 red-warmer = "#ff6740"
-red-cooler = "#ff6f9f"
+red-cooler = "#ff7f86"
 red-faint = "#ff9070"
 red-intense = "#ff5f5f"
 green = "#44bc44"
diff --git a/runtime/themes/monokai.toml b/runtime/themes/monokai.toml
index b0faac154..dfa7040ce 100644
--- a/runtime/themes/monokai.toml
+++ b/runtime/themes/monokai.toml
@@ -1,5 +1,7 @@
 # Author: Shafkath Shuhan <shafkathshuhannyc@gmail.com>
 
+"tag" = { fg = "tag" }
+
 "namespace" = { fg = "type" }
 "module" = { fg = "type" }
 
@@ -79,7 +81,8 @@
 "ui.statusline" = { fg = "active_text", bg = "#414339" }
 "ui.statusline.inactive" = { fg = "active_text", bg = "#75715e" }
 
-"ui.bufferline" = { fg = "grey2", bg = "bg3" }
+# Malformed ANSI: grey2, bg3. See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.bufferline" = { fg = "grey2", bg = "bg3" }
 "ui.bufferline.active" = { fg = "active_text", bg = "selection", modifiers = [
   "bold",
 ] }
@@ -115,3 +118,4 @@ cursor = "#a6a6a6"
 inactive_cursor = "#878b91"
 widget = "#1e1f1c"
 selection = "#414339"
+tag = "#F92672"
diff --git a/runtime/themes/monokai_aqua.toml b/runtime/themes/monokai_aqua.toml
index 0cb9300d0..b818a09e7 100644
--- a/runtime/themes/monokai_aqua.toml
+++ b/runtime/themes/monokai_aqua.toml
@@ -8,9 +8,12 @@ inherits = "monokai"
 
 "type" = { fg = "type", modifiers = ["bold"] }
 
-"ui.statusline.normal" = { fg = "light-black", bg = "cyan" }
-"ui.statusline.insert" = { fg = "light-black", bg = "green" }
-"ui.statusline.select" = { fg = "light-black", bg = "purple" }
+# Malformed ANSI: light-black, purple. See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.statusline.normal" = { fg = "light-black", bg = "cyan" }
+"ui.statusline.normal" = { bg = "cyan" }
+# "ui.statusline.insert" = { fg = "light-black", bg = "green" }
+"ui.statusline.insert" = { bg = "green" }
+# "ui.statusline.select" = { fg = "light-black", bg = "purple" }
 
 "ui.virtual.jump-label" = { fg = "cyan", modifiers = ["bold"] }
 
diff --git a/runtime/themes/naysayer.toml b/runtime/themes/naysayer.toml
index d85f31e2d..60bd2f5ec 100644
--- a/runtime/themes/naysayer.toml
+++ b/runtime/themes/naysayer.toml
@@ -14,7 +14,8 @@
 "ui.virtual" = "indent"
 "ui.virtual.ruler" = { bg = "line-fg" }
 "ui.cursor.match" = { bg = "cyan" }
-"ui.cursor" = { bg = "white" }
+"ui.cursor" = { bg = "#777777" }
+"ui.cursor.primary" = { bg = "white" }
 "ui.debug" = { fg = "orange" }
 "ui.highlight.frameline" = { bg = "#da8581" }
 "ui.help" = { fg = "text", bg = "bg" }
diff --git a/runtime/themes/nightfox.toml b/runtime/themes/nightfox.toml
index 62db82c00..7d05a9b29 100644
--- a/runtime/themes/nightfox.toml
+++ b/runtime/themes/nightfox.toml
@@ -12,6 +12,7 @@
 "ui.gutter" = { fg = "fg3" } # Left gutter for diagnostics and breakpoints.
 
 "ui.text" = { fg = "fg1" } # Default text color.
+"ui.text.directory" = { fg = "blue-bright" } # Directory names in prompt completion.
 "ui.text.focus" = { bg = "sel1", fg = "fg1" } # Selection highlight in buffer-picker or file-picker.
 "ui.text.info" = { fg = "fg2", bg = "sel0" } # Info popup contents (space mode menu).
 
diff --git a/runtime/themes/noctis.toml b/runtime/themes/noctis.toml
index 5846576ed..678658aaa 100644
--- a/runtime/themes/noctis.toml
+++ b/runtime/themes/noctis.toml
@@ -7,7 +7,7 @@
 
 'property' = { fg = "red" } # Regex group names.
 "warning" = { fg ="yellow", modifiers = ["bold"] } # Editor warnings.
-"error" = { fg = "red", modifiers = ["bold"] } # Editor errors, like mis-typing a command.
+"error" = { fg = "red", modifiers = ["bold"] } # Editor errors, like mistyping a command.
 "info" = { fg = "mid-blue" } # Code diagnostic info in gutter (LSP).
 # ? Difference between info and hint ?
 "hint" = { fg = "light-green", modifiers = ["bold"] } # Code diagnostics hint in gutter (LSP).
diff --git a/runtime/themes/onedark.toml b/runtime/themes/onedark.toml
index 7cdeac095..818b8c946 100644
--- a/runtime/themes/onedark.toml
+++ b/runtime/themes/onedark.toml
@@ -15,6 +15,7 @@
 "keyword.control" = { fg = "purple" }
 "keyword.control.import" = { fg = "red" }
 "keyword.directive" = { fg = "purple" }
+"keyword.storage" = { fg = "purple" }
 "label" = { fg = "purple" }
 "namespace" = { fg = "blue" }
 "operator" = { fg = "purple" }
diff --git a/runtime/themes/onedarker.toml b/runtime/themes/onedarker.toml
index ffa3ae2dc..221b394b0 100644
--- a/runtime/themes/onedarker.toml
+++ b/runtime/themes/onedarker.toml
@@ -74,9 +74,9 @@
 
 "ui.statusline" = { fg = "white", bg = "light-black" }
 "ui.statusline.inactive" = { fg = "light-gray", bg = "light-black" }
-"ui.statusline.normal" = { fg = "light-black", bg = "purple" }
-"ui.statusline.insert" = { fg = "light-black", bg = "green" }
-"ui.statusline.select" = { fg = "light-black", bg = "cyan" }
+"ui.statusline.normal" = { fg = "light-black", bg = "purple", modifiers = ["bold"] }
+"ui.statusline.insert" = { fg = "light-black", bg = "green", modifiers = ["bold"] }
+"ui.statusline.select" = { fg = "light-black", bg = "cyan", modifiers = ["bold"] }
 
 "ui.bufferline" = { fg = "light-gray", bg = "light-black" }
 "ui.bufferline.active" = { fg = "light-black", bg = "blue", underline = { color = "light-black", style = "line" } }
diff --git a/runtime/themes/onelight.toml b/runtime/themes/onelight.toml
index e395716dd..b812670d5 100644
--- a/runtime/themes/onelight.toml
+++ b/runtime/themes/onelight.toml
@@ -91,13 +91,14 @@
 "markup.quote" = { fg = "grey" }
 "markup.raw" = { fg = "brown" }
 "markup.raw.inline" = { fg = "green" }
-"markup.raw.block" = { fg = "grey" }
+"markup.raw.block" = { fg = "brown" }
 
 "diff" = { fg = "red" }
 "diff.plus" = { fg = "green" }
 "diff.minus" = { fg = "red" }
 "diff.delta" = { fg = "cyan" }
 "diff.delta.moved" = { fg = "cyan" }
+"diff.delta.conflict" = {fg = "blue"}
 
 "ui.background" = { bg = "white" }
 "ui.background.separator" = { bg = "white" }
@@ -133,6 +134,7 @@
 "ui.text.focus" = { fg = "red", bg = "grey-300", modifiers = ["bold"] }
 "ui.text.inactive" = { fg = "grey" }
 "ui.text.info" = { fg = "black" }
+"ui.text.directory" = { fg = "blue", underline = { style = "line" } }
 
 "ui.virtual" = { fg = "grey-500" }
 "ui.virtual.ruler" = { bg = "grey-200" }
@@ -159,6 +161,9 @@
 
 "ui.highlight" = { bg = "grey-300" }
 
+"ui.picker.header" = { fg = "purple"}
+"ui.picker.header.active" = { fg = "blue"}
+
 "diagnostic.info" = { underline = { color = "blue", style = "dotted" } }
 "diagnostic.hint" = { underline = { color = "green", style = "dashed" } }
 "diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
@@ -171,6 +176,8 @@
 "warning" = { fg = "yellow", modifiers = ["bold"] }
 "error" = { fg = "red", modifiers = ["bold"] }
 
+"tabstop" = { modifiers = ["italic"], bg = "grey-300" }
+
 [palette]
 white = "#FAFAFA"
 yellow = "#FF6F00"
diff --git a/runtime/themes/rose_pine.toml b/runtime/themes/rose_pine.toml
index 9a5ba450e..ae88bdc54 100644
--- a/runtime/themes/rose_pine.toml
+++ b/runtime/themes/rose_pine.toml
@@ -36,6 +36,7 @@
 "ui.text" = { fg = "text" }
 "ui.text.focus" = { bg = "overlay" }
 "ui.text.info" = { fg = "subtle" }
+"ui.text.directory" = { fg = "iris" }
 
 "ui.virtual.jump-label" = { fg = "love", modifiers = ["bold"] }
 "ui.virtual.ruler" = { bg = "overlay" }
diff --git a/runtime/themes/seoul256-dark-hard.toml b/runtime/themes/seoul256-dark-hard.toml
new file mode 100644
index 000000000..fa918d29a
--- /dev/null
+++ b/runtime/themes/seoul256-dark-hard.toml
@@ -0,0 +1,16 @@
+# Seoul256 Dark Hard
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+inherits = "seoul256-dark"
+
+"ui.background" = { bg = "gray1" }
+"ui.gutter" = { bg = "gray2" }
+"ui.cursorline.primary" = { bg = "gray" }
+"ui.gutter.selected" = { bg = "gray" }
+"ui.linenr.selected" = { bg = "gray", fg = "magenta", modifiers = ["bold"] }
+"ui.virtual.inlay-hint" = { fg = "gray4", modifiers = ["bold"] }
+
+"ui.help" = { bg = "gray" }
+"ui.popup" = { bg = "gray" }
+"ui.menu" = { bg = "gray" }
diff --git a/runtime/themes/seoul256-dark-soft.toml b/runtime/themes/seoul256-dark-soft.toml
new file mode 100644
index 000000000..548d0c182
--- /dev/null
+++ b/runtime/themes/seoul256-dark-soft.toml
@@ -0,0 +1,15 @@
+# Seoul256 Dark Soft
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+inherits = "seoul256-dark"
+
+"ui.background" = { bg = "gray8" }
+"ui.gutter" = { bg = "gray6" }
+"ui.cursorline.primary" = { bg = "gray5" }
+"ui.gutter.selected" = { bg = "gray5" }
+"ui.linenr.selected" = { bg = "gray5", fg = "magenta", modifiers = ["bold"] }
+
+"ui.help" = { bg = "gray5" }
+"ui.popup" = { bg = "gray5" }
+"ui.menu" = { bg = "gray5" }
diff --git a/runtime/themes/seoul256-dark.toml b/runtime/themes/seoul256-dark.toml
new file mode 100644
index 000000000..df9d43df0
--- /dev/null
+++ b/runtime/themes/seoul256-dark.toml
@@ -0,0 +1,161 @@
+# Seoul256 Dark
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+# Syntax highlighting configuration
+"attribute" = { fg = "yellow" }
+"comment" = { fg = "green1" }
+"constant" = { fg = "blue5" }
+"constant.numeric" = { fg = "yellow1" }
+"constant.builtin.boolean" = { fg = "purple" }
+"constant.character.escape" = { fg = "salmon" }
+"constructor" = { fg = "yellow" }
+"function" = { fg = "yellow2" }
+"function.builtin" = { fg = "blue1" }
+"function.method" = { fg = "salmon" }
+"function.macro" = { fg = "yellow2" }
+"keyword" = { fg = "mauve" }
+"label" = { fg = "magenta" }
+"namespace" = { fg = "cyan" }
+"operator" = { fg = "yellow3" }
+"punctuation" = { fg = "brown" }
+"special" = { fg = "yellow2" }
+"string" = { fg = "blue" }
+"type" = { fg = "yellow" }
+"type.builtin" = { fg = "salmon" }
+"variable" = { fg = "white" }
+"variable.builtin" = { fg = "salmon" }
+"variable.parameter" = { fg = "white" }
+"variable.other.member" = { fg = "white" }
+
+"markup.heading" = { fg = "salmon2", modifiers = ["bold"] }
+"markup.raw.inline" = { fg = "green" }
+"markup.bold" = { fg = "yellow1", modifiers = ["bold"] }
+"markup.italic" = { fg = "magenta1", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.list" = { fg = "salmon" }
+"markup.quote" = { fg = "yellow" }
+"markup.link.url" = { fg = "cyan", modifiers = ["underlined"] }
+"markup.link.text" = { fg = "salmon2" }
+
+"diff.plus" = { fg = "green3" }
+"diff.delta" = { fg = "blue1" }
+"diff.minus" = { fg = "magenta3" }
+
+"diagnostic.info".underline = { color = "cyan", style = "curl" }
+"diagnostic.hint".underline = { color = "green1", style = "curl" }
+"diagnostic.warning".underline = { color = "yellow1", style = "curl" }
+"diagnostic.error".underline = { color = "red", style = "curl" }
+"diagnostic.unnecessary" = { modifiers = ["dim"] }
+"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
+"info" = { fg = "blue2", modifiers = ["bold"] }
+"hint" = { fg = "blue3", modifiers = ["bold"] }
+"warning" = { fg = "yellow", modifiers = ["bold"] }
+"error" = { fg = "red", modifiers = ["bold"] }
+
+"ui.background" = { bg = "gray4" }
+"ui.gutter" = { bg = "gray5" }
+"ui.gutter.selected" = { bg = "gray3" }
+"ui.virtual" = { fg = "gray6" }
+"ui.virtual.indent-guide" = { fg = "gray6" }
+"ui.virtual.whitespace" = { fg = "gray6" }
+"ui.virtual.ruler" = { bg = "gray5" }
+"ui.virtual.inlay-hint" = { fg = "gray9", modifiers = ["bold"] }
+"ui.virtual.jump-label" = { fg = "red", modifiers = ["bold"] }
+
+"ui.cursor" = { fg = "white", modifiers = ["reversed"] }
+"ui.cursor.primary" = { fg = "white", modifiers = ["reversed"] }
+"ui.cursor.match" = { bg = "gray4", modifiers = ["underlined"] }
+"ui.cursor.insert" = { fg = "blue1" }
+
+"ui.selection" = { bg = "magenta2" }
+"ui.selection.primary" = { bg = "blue4" }
+"ui.cursorline.primary" = { bg = "gray3" }
+
+"ui.highlight" = { bg = "gray5" }
+"ui.highlight.frameline" = { bg = "red" }
+
+"ui.linenr" = { fg = "yellow4" }
+"ui.linenr.selected" = { bg = "gray3", fg = "magenta", modifiers = ["bold"] }
+
+"ui.statusline" = { fg = "magenta2", bg = "yellow2" }
+"ui.statusline.inactive" = { fg = "gray6", bg = "black" }
+"ui.statusline.normal" = { fg = "black", bg = "blue2" }
+"ui.statusline.insert" = { fg = "black", bg = "green2" }
+"ui.statusline.select" = { fg = "black", bg = "magenta" }
+
+"ui.text" = { fg = "white" }
+"ui.text.focus" = { fg = "white", bg = "magenta2", modifiers = ["bold"] }
+
+"ui.help" = { fg = "white", bg = "gray3" }
+"ui.popup" = { fg = "white", bg = "gray3" }
+"ui.window" = { fg = "white" }
+"ui.menu" = { fg = "white", bg = "gray3" }
+"ui.menu.selected" = { fg = "white", bg = "magenta2" }
+"ui.menu.scroll" = { fg = "gray7", bg = "gray6" }
+
+"ui.debug" = { fg = "red" }
+
+# Colors (Seoul256)
+[palette]
+black = '#000000'    # Black
+black1 = '#14161B'
+red = '#d70000'      # Red
+green = '#afd75f'    # Greenish Yellow
+green1 = '#5f875f'   # Greenish Gray
+green2 = '#5f8700'   # Green
+green3 = '#87af87'
+green4 = '#5f5f00'
+yellow = '#d8af5f'   # Yellow
+yellow1 = '#ffd787'  # Bright Yellow
+yellow2 = '#d7d7af'  # Yellowish
+yellow3 = '#d7d787'  # Yellow Dim
+yellow4 = '#87875f'  # Olive
+yellow5 = '#6B5300'
+blue = '#87afaf'     # Light Blue
+blue1 = '#5f87d7'    # Bright Blue
+blue2 = '#5f5f87'    # Blue
+blue3 = '#a6dbff'    # Lightest Blue
+blue4 = '#005f5f'    # Blue Green
+blue5 = '#5fafaf'    # Dark Blue
+blue6 = '#008787'
+magenta = '#af5f5f'  # Magenta
+magenta1 = '#af5f87' # Soft Magenta
+magenta2 = '#875f5f' # Dark Magenta
+magenta3 = '#d7005f' # Darker Magenta
+cyan = '#87d7d7'     # Bright Cyan
+cyan1 = '#afd7d7'
+white = '#d0d0d0'    # White
+white1 = '#dadada'   # White
+purple = '#8787af'   # Purple
+brown = '#af875f'    # Brownish
+brown1 = '#875f00'   # Brownish
+orange = '#ff5f00'   # Orange
+salmon = '#ffaf87'   # Salmon
+salmon1 = '#d78787'  # Salmon Bright
+salmon2 = '#d7afaf'  # Salmon Light
+salmon3 = '#d7875f'  # Yellowish
+mauve = '#d75f87'    # Mauve
+
+gray = '#121212'     # Very Dark Gray
+gray1 = '#1c1c1c'    # Darker Gray
+gray2 = '#262626'    # Dark Gray
+gray3 = '#303030'    # Dark Medium Gray
+gray4 = '#3a3a3a'    # Medium Gray
+gray5 = '#444444'    # Lighter Medium Gray
+gray6 = '#585858'    # Light Gray
+gray7 = '#626262'    # Lighter Gray
+gray8 = '#4e4e4e'    # Even Lighter Gray
+gray9 = '#5f5f5f'
+gray10 = '#c6c6c6'
+gray11 = '#eeeeee'
+gray12 = '#e4e4e4'
+gray13 = '#bcbcbc'
+
+# 233 = '#121212' 
+# 234 = '#1c1c1c'
+# 235 = '#262626'
+# 236 = '#303030'
+# 237 = '#3a3a3a' # Default
+# 238 = '#444444'
+# 239 = '#4e4e4e'
diff --git a/runtime/themes/seoul256-light-hard.toml b/runtime/themes/seoul256-light-hard.toml
new file mode 100644
index 000000000..c1f92fac1
--- /dev/null
+++ b/runtime/themes/seoul256-light-hard.toml
@@ -0,0 +1,16 @@
+# Seoul256 Light Hard
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+inherits = "seoul256-light"
+
+"ui.background" = { bg = "gray11" }
+"ui.cursor.match" = { bg = "gray10", modifiers = ["underlined"] }
+"ui.gutter" = { bg = "white1" }
+"ui.cursorline.primary" = { bg = "gray12" }
+"ui.gutter.selected" = { bg = "gray12" }
+"ui.linenr.selected" = { bg = "gray12", fg = "magenta", modifiers = ["bold"] }
+
+"ui.help" = { fg = "black1", bg = "gray12" }
+"ui.popup" = { fg = "black1", bg = "gray12" }
+"ui.menu" = { fg = "black1", bg = "gray12" }
diff --git a/runtime/themes/seoul256-light-soft.toml b/runtime/themes/seoul256-light-soft.toml
new file mode 100644
index 000000000..0a25bb696
--- /dev/null
+++ b/runtime/themes/seoul256-light-soft.toml
@@ -0,0 +1,16 @@
+# Seoul256 Light Soft
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+inherits = "seoul256-light"
+
+"ui.background" = { bg = "white" }
+"ui.cursor.match" = { bg = "gray13", modifiers = ["underlined"] }
+"ui.gutter" = { bg = "gray13" }
+"ui.cursorline.primary" = { bg = "gray10" }
+"ui.gutter.selected" = { bg = "gray10" }
+"ui.linenr.selected" = { bg = "gray10", fg = "magenta", modifiers = ["bold"] }
+
+"ui.help" = { fg = "black1", bg = "gray10" }
+"ui.popup" = { fg = "black1", bg = "gray10" }
+"ui.menu" = { fg = "black1", bg = "gray10" }
diff --git a/runtime/themes/seoul256-light.toml b/runtime/themes/seoul256-light.toml
new file mode 100644
index 000000000..4f45a9d02
--- /dev/null
+++ b/runtime/themes/seoul256-light.toml
@@ -0,0 +1,51 @@
+# Seoul256 Light
+# Author : EricHenry
+# Original Creator: https://github.com/junegunn/seoul256.vim
+
+inherits = "seoul256-dark"
+
+"constructor" = { fg = "brown1" }
+"constant.numeric" = { fg = "magenta2" }
+"constant.builtin.boolean" = { fg = "mauve" }
+"constant.character.escape" = { fg = "salmon3" }
+"function" = { fg = "green4" }
+"function.builtin" = { fg = "blue1" }
+"function.method" = { fg = "salmon" }
+"function.macro" = { fg = "green4" }
+"namespace" = { fg = "blue4" }
+"operator" = { fg = "brown1" }
+"punctuation" = { fg = "brown1" }
+"special" = { fg = "green4" } 
+"string" = { fg = "blue6" }
+"type" = { fg = "brown1" }
+"type.builtin" = { fg = "salmon3" }
+"variable" = { fg = "black1" }
+"variable.builtin" = { fg = "salmon3" }
+"variable.parameter" = { fg = "black1" }
+"variable.other.member" = { fg = "black1" }
+
+"diagnostic.info".underline = { color = "green1", style = "curl" }
+"info" = { fg = "green1", modifiers = ["bold"] }
+"hint" = { fg = "blue", modifiers = ["bold"] }
+"warning" = { fg = "yellow5", modifiers = ["bold"] }
+
+"ui.background" = { bg = "white1" }
+"ui.cursor" = { fg = "gray4", modifiers = ["reversed"] }
+"ui.cursor.primary" = { fg = "gray4", modifiers = ["reversed"] }
+"ui.cursor.match" = { bg = "gray13", modifiers = ["underlined"] }
+"ui.cursor.insert" = { fg = "blue1" }
+"ui.cursorline.primary" = { bg = "white" }
+"ui.gutter" = { bg = "gray10" }
+"ui.gutter.selected" = { bg = "white" }
+"ui.linenr.selected" = { bg = "white", fg = "magenta", modifiers = ["bold"] }
+"ui.virtual.inlay-hint" = { fg = "gray6", modifiers = ["bold"] }
+
+"ui.selection" = { bg = "yellow2" }
+"ui.selection.primary" = { bg = "cyan1" }
+
+"ui.text" = { fg = "black1" }
+
+"ui.help" = { fg = "black1", bg = "white" }
+"ui.popup" = { fg = "black1", bg = "white" }
+"ui.menu" = { fg = "black1", bg = "white" }
+
diff --git a/runtime/themes/serika-dark.toml b/runtime/themes/serika-dark.toml
index eb8d6c839..10ceacd15 100644
--- a/runtime/themes/serika-dark.toml
+++ b/runtime/themes/serika-dark.toml
@@ -53,6 +53,7 @@
 "ui.virtual.whitespace" = "bg2"
 "ui.virtual.ruler" = { bg = "grey2" } 
 "ui.virtual.inlay-hint" = { fg = "grey2", modifiers = ["italic"] }
+"ui.virtual.jump-label" = { fg = "nasty-red", modifiers = ["bold"] }
 
 "hint" = "blue"
 "info" = "aqua"
diff --git a/runtime/themes/snazzy.toml b/runtime/themes/snazzy.toml
index 09d0cdd57..2a1d9a351 100644
--- a/runtime/themes/snazzy.toml
+++ b/runtime/themes/snazzy.toml
@@ -1,119 +1,125 @@
 # Author : Timothy DeHerrera <tim@nrdxp.dev>
 "comment".fg = "comment"
 
-"constant".fg = "purple"
-"constant.builtin".fg = "olive"
-"constant.character".fg = "carnation"
+"constant.builtin".fg          = "olive"
 "constant.character.escape".fg = "magenta"
-"constant.numeric".fg = "cyan"
-"constant.numeric.float".fg = "red"
+"constant.character".fg        = "carnation"
+"constant".fg                  = "purple"
+"constant.numeric".fg          = "cyan"
+"constant.numeric.float".fg    = "red"
 
-"function".fg = "green"
 "function.builtin".fg = "sand"
-"function.macro".fg = "blue"
-"function.method".fg = "opal"
+"function".fg         = "green"
+"function.macro".fg   = "blue"
+"function.method".fg  = "opal"
 
-"keyword" = { fg = "magenta", modifiers = ["bold"] }
-"keyword.operator" = { fg = "coral", modifiers = ["bold"] }
-"keyword.function" = { fg = "lilac", modifiers = ["bold"] }
-"keyword.control" = { fg = "carnation", modifiers = ["bold"]}
+"keyword"                   = { fg = "magenta", modifiers = ["bold"] }
+"keyword.control"           = { fg = "carnation", modifiers = ["bold"] }
 "keyword.control.exception" = { fg = "red", modifiers = ["bold"] }
-"keyword.storage" = { fg = "coral", modifiers = ["bold"] }
+"keyword.function"          = { fg = "lilac", modifiers = ["bold"] }
+"keyword.operator"          = { fg = "coral", modifiers = ["bold"] }
+"keyword.storage"           = { fg = "coral", modifiers = ["bold"] }
 
 "operator".fg = "coral"
 
-"punctuation".fg = "magenta"
+"punctuation.bracket".fg   = "foreground"
 "punctuation.delimiter".fg = "coral"
-"punctuation.bracket".fg = "foreground"
+"punctuation".fg           = "magenta"
 
-"string".fg = "yellow"
+"attribute".fg      = "opal"
+"string".fg         = "yellow"
+"string.regexp".fg  = "red"
 "string.special".fg = "blue"
-"string.regexp".fg = "red"
-"tag".fg = "carnation"
-"attribute".fg = "opal"
+"tag".fg            = "carnation"
 
-"type".fg = "opal"
-"type.variant".fg = "sand"
-"type.builtin".fg = "yellow"
+"type.builtin".fg      = "yellow"
 "type.enum.variant".fg = "sand"
+"type".fg              = "opal"
+"type.variant".fg      = "sand"
 
-"variable".fg = "cyan"
-"variable.builtin".fg = "olive"
+"variable.builtin".fg      = "olive"
+"variable".fg              = "cyan"
 "variable.other.member".fg = "lilac"
-"variable.parameter" = { fg ="blue", modifiers = ["italic"] }
+"variable.parameter"       = { fg = "blue", modifiers = ["italic"] }
 
-"namespace".fg = "olive"
 "constructor".fg = "sand"
-"special".fg = "magenta"
-"label".fg = "magenta"
+"label".fg       = "magenta"
+"namespace".fg   = "olive"
+"special".fg     = "magenta"
 
-"diff.plus".fg = "green"
 "diff.delta".fg = "blue"
 "diff.minus".fg = "red"
-
-"ui.background" = { fg = "foreground", bg = "background" }
-"ui.cursor" =  { fg = "background", bg = "blue", modifiers = ["dim"] }
-"ui.cursor.match" = { fg = "green", modifiers = ["underlined"] }
-"ui.cursor.primary" = { fg = "background", bg = "cyan", modifiers = ["dim"] }
-"ui.help" = { fg = "foreground", bg = "background_dark" }
-"ui.linenr" = { fg = "comment" }
-"ui.linenr.selected" = { fg = "foreground" }
-"ui.menu" = { fg = "foreground", bg = "background_dark" }
-"ui.menu.selected" = { fg = "cyan", bg = "background_dark" }
-"ui.popup" = { fg = "foreground", bg = "background_dark" }
-"ui.selection" = { bg = "secondary_highlight" }
-"ui.selection.primary" = { bg = "primary_highlight" }
-"ui.cursorline" = { bg = "background_dark" }
-"ui.statusline" = { fg = "foreground", bg = "background_dark" }
-"ui.statusline.inactive" = { fg = "comment", bg = "background_dark" }
-"ui.statusline.insert" = { fg = "olive", bg = "background_dark" }
-"ui.statusline.normal" = { fg = "opal", bg = "background_dark" }
-"ui.statusline.select" = { fg = "carnation", bg = "background_dark" }
-"ui.text" = { fg = "foreground" }
-"ui.text.focus" = { fg = "cyan" }
-"ui.window" = { fg = "foreground" }
-"ui.virtual.whitespace" = { fg = "comment" }
+"diff.plus".fg  = "green"
+
+"ui.background"           = { fg = "foreground", bg = "background" }
+"ui.cursor"               = { fg = "background", bg = "blue", modifiers = ["dim"] }
+"ui.cursor.match"         = { fg = "green", modifiers = ["underlined"] }
+"ui.cursor.primary"       = { fg = "background", bg = "cyan", modifiers = ["dim"] }
+"ui.cursorline"           = { bg = "background_dark" }
+"ui.help"                 = { fg = "foreground", bg = "background_dark" }
+"ui.linenr"               = { fg = "comment" }
+"ui.linenr.selected"      = { fg = "foreground" }
+"ui.menu"                 = { fg = "foreground", bg = "background_dark" }
+"ui.menu.selected"        = { fg = "cyan", bg = "background_dark" }
+"ui.popup"                = { fg = "foreground", bg = "background_dark" }
+"ui.selection"            = { bg = "secondary_highlight" }
+"ui.selection.primary"    = { bg = "primary_highlight" }
+"ui.statusline"           = { fg = "foreground", bg = "background_dark" }
+"ui.statusline.inactive"  = { fg = "comment", bg = "background_dark" }
+"ui.statusline.insert"    = { fg = "olive", bg = "background_dark" }
+"ui.statusline.normal"    = { fg = "opal", bg = "background_dark" }
+"ui.statusline.select"    = { fg = "carnation", bg = "background_dark" }
+"ui.text"                 = { fg = "foreground" }
+"ui.text.focus"           = { fg = "cyan" }
 "ui.virtual.indent-guide" = { fg = "opal" }
-"ui.virtual.ruler" = { bg = "background_dark" }
+"ui.virtual.ruler"        = { bg = "background_dark" }
+"ui.virtual.inlay-hint" =   { bg = "background_dark", fg = "comment" }
+"ui.virtual.whitespace"   = { fg = "comment" }
+"ui.window"               = { fg = "foreground" }
 
-"error" = { fg = "red" }
+"error"   = { fg = "red" }
 "warning" = { fg = "cyan" }
 
+"diagnostic"             = { underline = { style = "line", color = "coral" }, bg = "cyan" }
+"diagnostic.deprecated"  = { modifiers = ["crossed_out"] }
+"diagnostic.error"       = { underline = { style = "curl", color = "red" } }
+"diagnostic.hint"        = { underline = { style = "line", color = "cyan" } }
+"diagnostic.info"        = { underline = { style = "line" } }
 "diagnostic.unnecessary" = { modifiers = ["dim"] }
-"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
-
-"markup.heading" = { fg = "purple", modifiers = ["bold"] }
-"markup.link.label" = { fg = "blue", modifiers = ["italic"] }
-"markup.list" = "cyan"
-"markup.bold" = { fg = "blue", modifiers = ["bold"] }
-"markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"diagnostic.warning"     = { underline = { style = "curl", color = "yellow" } }
+
+"markup.bold"          = { fg = "blue", modifiers = ["bold"] }
+"markup.heading"       = { fg = "purple", modifiers = ["bold"] }
+"markup.italic"        = { fg = "yellow", modifiers = ["italic"] }
+"markup.link.label"    = { fg = "blue", modifiers = ["italic"] }
+"markup.link.text"     = "magenta"
+"markup.link.url"      = "cyan"
+"markup.list"          = "cyan"
+"markup.quote"         = { fg = "yellow", modifiers = ["italic"] }
+"markup.raw"           = { fg = "foreground" }
 "markup.strikethrough" = { modifiers = ["crossed_out"] }
-"markup.link.url" = "cyan"
-"markup.link.text" = "magenta"
-"markup.quote" = { fg = "yellow", modifiers = ["italic"] }
-"markup.raw" = { fg = "foreground" }
 
 [palette]
-background = "#282a36"
-background_dark = "#21222c"
-primary_highlight = "#800049"
+background          = "#282a36"
+background_dark     = "#21222c"
+comment             = "#a39e9b"
+foreground          = "#eff0eb"
+primary_highlight   = "#800049"
 secondary_highlight = "#4d4f66"
-foreground = "#eff0eb"
-comment = "#a39e9b"
 
 # main colors
-red = "#ff5c57"
-blue = "#57c7ff"
-yellow = "#f3f99d"
-green = "#5af78e"
-purple = "#bd93f9"
-cyan = "#9aedfe"
+blue    = "#57c7ff"
+cyan    = "#9aedfe"
+green   = "#5af78e"
 magenta = "#ff6ac1"
+purple  = "#bd93f9"
+red     = "#ff5c57"
+yellow  = "#f3f99d"
 
 # aux colors
-lilac = "#c9c5fb"
-coral = "#f97c7c"
-sand = "#ffab6f"
 carnation = "#f99fc6"
-olive = "#b6d37c"
-opal = "#b1d7c7"
+coral     = "#f97c7c"
+lilac     = "#c9c5fb"
+olive     = "#b6d37c"
+opal      = "#b1d7c7"
+sand      = "#ffab6f"
diff --git a/runtime/themes/spacebones_light.toml b/runtime/themes/spacebones_light.toml
index 7870f67ca..1d744019b 100644
--- a/runtime/themes/spacebones_light.toml
+++ b/runtime/themes/spacebones_light.toml
@@ -63,7 +63,7 @@
 "ui.window" = { bg = "bg1" }
 "ui.help" = { bg = "bg1", fg = "fg1" }
 "ui.text" = { fg = "fg1" }
-"ui.text.focus" = { fg = "fg1" }
+"ui.text.focus" = { fg = "fg1", modifiers = ["bold"] }
 "ui.selection" = { bg = "hl2" }
 "ui.selection.primary" = { bg = "hl1" }
 "ui.cursor.primary" = { modifiers = ["reversed"] }
diff --git a/runtime/themes/sunset.toml b/runtime/themes/sunset.toml
new file mode 100644
index 000000000..ec3aca8f5
--- /dev/null
+++ b/runtime/themes/sunset.toml
@@ -0,0 +1,160 @@
+# Sunset
+# Author : Egor Afanasin <afanasin.egor@gmail.com>
+# Repo: https://github.com/pithecantrope/sunset
+
+# Syntax highlighting
+# ----------------------------------------------------------------
+attribute = "rose"
+
+type = "rose"
+"type.builtin" = { fg = "rose", modifiers = ["italic"] }
+
+constructor = "wood"
+
+constant = "fire"
+"constant.builtin"   = { fg = "fire", modifiers = ["italic"] }
+"constant.character" = "wood"
+"constant.character.escape" = "pink"
+"constant.numeric"   = "wood"
+
+string = "grass"
+"string.regexp"  = "pink"
+"string.special" = "rose"
+"string.special.symbol" = "fire"
+
+comment = { fg = "cmnt", modifiers = ["italic"] }
+"comment.block.documentation" = "grass"
+
+variable = "text"
+"variable.builtin" = { fg = "sky", modifiers = ["italic"] }
+# TODO: variable.parameter
+"variable.other.member" = "mud"
+
+label = "sky"
+
+punctuation = "cmnt"
+"punctuation.special" = "wine"
+
+keyword = "sun"
+"keyword.control.return"    = { fg = "sun", modifiers = ["italic"] }
+"keyword.control.exception" = { fg = "sun", modifiers = ["italic"] }
+"keyword.directive" = "sky"
+
+operator = "wine"
+
+function = "peach"
+"function.builtin" = { fg = "peach", modifiers = ["italic"] }
+"function.macro"   = "pink"
+
+tag = "peach"
+
+namespace = { fg = "pink", modifiers = ["italic"] }
+
+special = "sky"
+
+# Editor interface
+# ----------------------------------------------------------------
+"markup.heading.marker" = "sun"
+"markup.heading.1" = "attn"
+"markup.heading.2" = "fire"
+"markup.heading.3" = "rose"
+"markup.heading.4" = "peach"
+"markup.heading.5" = "wine"
+"markup.heading.6" = "grass"
+
+"markup.list" = "wood"
+
+"markup.bold"          = { modifiers = ["bold"] }
+"markup.italic"        = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+
+"markup.link.url"   = { fg = "sky", underline.style = "line" }
+"markup.link.label" = { fg = "sky", modifiers = ["italic"] }
+"markup.link.text"  = "mud"
+
+"markup.quote" = "grass"
+
+"markup.raw"   = "pink"
+
+"diff.plus"  = "grass"
+"diff.minus" = "attn"
+"diff.delta" = "sky"
+
+# User interface
+# ----------------------------------------------------------------
+"ui.background" = { fg = "text", bg = "base" }
+
+"ui.cursor" = { modifiers = ["reversed"] }
+"ui.cursor.match" = { fg = "attn", modifiers = ["bold"] }
+
+# TODO: ui.debug
+
+"ui.linenr" = "block"
+"ui.linenr.selected" = "cmnt"
+
+"ui.statusline" = { bg = "block" }
+"ui.statusline.inactive" = { fg = "cmnt" }
+"ui.statusline.normal"   = { fg = "block", bg = "sun",  modifiers = ["bold"] }
+"ui.statusline.insert"   = { fg = "block", bg = "grass", modifiers = ["bold"] }
+"ui.statusline.select"   = { fg = "block", bg = "wine",  modifiers = ["bold"] }
+
+"ui.bufferline" = { fg = "cmnt", bg = "block" }
+"ui.bufferline.active" = "sun"
+
+"ui.popup" = { fg = "text", bg = "base" }
+"ui.popup.info" = { fg = "text", bg = "block" }
+
+"ui.window" = { fg = "block", modifiers = ["bold"] }
+
+"ui.help" = { fg = "text", bg = "block" }
+
+"ui.text" = { fg = "text", bg = "base" }
+"ui.text.directory" = "sky"
+"ui.text.focus"     = "sun"
+"ui.text.inactive"  = { fg = "cmnt", modifiers = ["italic"] }
+"ui.text.info"      = { bg = "block" }
+
+"ui.virtual" = { fg = "block" }
+"ui.virtual.ruler"        = { bg = "block" }
+"ui.virtual.indent-guide" = "sel"
+"ui.virtual.jump-label"   = { fg = "attn", modifiers = ["bold"] }
+
+"ui.menu" = { fg = "text", bg = "base" }
+"ui.menu.selected" = { bg = "sel" }
+"ui.menu.scroll"   = "sel"
+
+"ui.selection" = { bg = "sel" }
+
+"ui.highlight" = { bg = "sel" }
+
+error   = "attn"
+warning = "fire"
+info    = "pink"
+hint    = "sky"
+
+diagnostic = { underline.style = "line" }
+
+[palette]
+# Reddish
+fire  = "#EE7711"
+rose  = "#EE7777"
+peach = "#EEBB77"
+pink  = "#EEAAAA"
+wood  = "#997755"
+
+# Greenish
+grass = "#66CC33"
+mud   = "#BBCC77"
+sun   = "#EEEE11"
+
+# Bluish
+sky  = "#77AAAA"
+wine = "#775599"
+
+# Ui
+base  = "#111111"
+block = "#222222"
+sel   = "#333333"
+cmnt  = "#777777"
+text  = "#EEEEEE"
+attn  = "#EE1111"
diff --git a/runtime/themes/tokyonight.toml b/runtime/themes/tokyonight.toml
index 4e53e03b8..08e7ce3ae 100644
--- a/runtime/themes/tokyonight.toml
+++ b/runtime/themes/tokyonight.toml
@@ -89,6 +89,7 @@ hint = { fg = "hint" }
 "ui.text.focus" = { bg = "bg-focus" }
 "ui.text.inactive" = { fg = "comment", modifiers = ["italic"] }
 "ui.text.info" = { bg = "bg-menu", fg = "fg" }
+"ui.text.directory" = { fg = "cyan" }
 "ui.virtual.ruler" = { bg = "fg-gutter" }
 "ui.virtual.whitespace" = { fg = "fg-gutter" }
 "ui.virtual.inlay-hint" = {  bg = "bg-inlay", fg = "teal" }
diff --git a/runtime/themes/vintage.toml b/runtime/themes/vintage.toml
new file mode 100644
index 000000000..d4afbea31
--- /dev/null
+++ b/runtime/themes/vintage.toml
@@ -0,0 +1,102 @@
+# Vintage Theme for the Helix Editor
+# Author: rojebd<roniellberrios@gmail.com>
+# Repo: https://github.com/rojebd/vintage
+# This theme is vintage inspired
+# Info: I made this theme one afternoon because my bus was late and I stayed home :)
+
+attribute = "#a7bf67" 
+keyword = "#A4A2B4"  
+"keyword.directive" = "light-gray" 
+namespace = "#7095bf" 
+punctuation = "white" 
+"punctuation.delimiter" = "white"
+operator = "muddy" 
+special = "pink" 
+"variable.other.member" = "green" 
+variable = "green" 
+"variable.parameter" = "light-green" 
+"variable.builtin" = "light-green" 
+type = "#efbe4c" 
+"type.builtin" = "#efbe4c" 
+constructor = "#c19ef7" 
+function = "muddy" 
+"function.macro" = "muddy" 
+"function.builtin" = "#db985e" 
+tag = "#d37a78" 
+comment = "light-gray" 
+constant = "#A5C4D4" 
+"constant.builtin" = "bright-yellow" 
+string = "#d6a560" 
+"constant.numeric" = "#b577b0" 
+"constant.character.escape" = "#c95c56" 
+label = "#abcc8a" 
+
+"markup.heading" = "bright-pink" 
+"markup.bold" = { fg = "markdown-bold", modifiers = ["bold"] } 
+"markup.italic" = { fg = "markdown-italic", modifiers = ["italic"] } 
+"markup.strikethrough" = { fg = "bright-pink", modifiers = ["crossed_out", "bold"] } 
+"markup.link.url" = { fg = "blueish", modifiers = ["underlined"] } 
+"markup.link.text" = "orange" 
+"markup.raw" = "gray" 
+
+"diff.plus" =  { fg = "bright-green", modifiers = ["bold"] }
+"diff.minus" = { fg = "redish",       modifiers = ["bold"] }
+"diff.delta" = { fg = "blueish",      modifiers = ["bold"] }
+
+"ui.background" = { bg = "background" } 
+"ui.background.separator" = { fg = "white" } 
+"ui.linenr" = { fg = "#747575" } 
+"ui.linenr.selected" = { fg = "#c7dddd" } 
+"ui.statusline" = { fg = "black", bg = "gray" } 
+"ui.statusline.inactive" = { fg = "gray", bg = "#3c3836" } 
+"ui.popup" = { bg = "#3b3b3d" } 
+"ui.window" = { fg = "yellow" } 
+"ui.help" = { bg = "#35353a", fg = "light-gray" } 
+
+"ui.text" = { fg = "light-gray" } 
+"ui.text.focus" = { fg = "#83c679" } 
+"ui.text.inactive" = "#93a56f" 
+"ui.virtual" = { fg = "yellow" } 
+"ui.virtual.indent-guide" = { fg = "#5b5b5a" } 
+"ui.virtual.ruler" = { bg = "#363638" }
+
+"ui.selection" = { fg = "white", bg = "gray" } 
+"ui.selection.primary" = { fg = "white", bg = "gray" } 
+"ui.cursor.match" = { fg = "white", bg = "gray" } 
+"ui.cursor" = { modifiers = ["reversed"] } 
+"ui.cursorline.primary" = { bg = "#3b3b3f" } 
+
+"ui.debug" = { fg = "#634450" } 
+"ui.debug.breakpoint" = { fg = "redish" } 
+"ui.debug.active" = { fg = "blueish" } 
+"ui.menu" = { fg = "gray", bg = "black" } 
+"ui.menu.selected" = { fg = "black", bg = "gray" } 
+
+"diagnostic.hint" = { underline = { color = "bright-yellow", style = "curl" } } 
+"diagnostic.info" = { underline = { color = "bright-yellow", style = "curl" } }  
+"diagnostic.warning" = { underline = { color = "bright-yellow", style = "curl" } } 
+"diagnostic.error" = { underline = { color = "bright-pink", style = "curl" } } 
+
+warning = "bright-yellow" 
+error = "bright-pink" 
+info = "bright-yellow" 
+hint = "bright-yellow" 
+
+[palette]
+bright-pink = "#DE6468"
+background = "#1f1f21"
+green = "#778e61"
+light-green = "#9B9B7A"
+brown = "#BAA587"
+pink = "#D9AE94"
+yellow = "#F1DCA7"
+bright-yellow = "#FFCB69"
+orange = "#E8AC65"
+muddy = "#D08C60"
+markdown-italic = "#80a552"
+markdown-bold = "#6faa75"
+dark-brown = "#B58463"
+purple-ish = "#997B66"
+bright-green = "#4F6F52"
+blueish = "#3876BF"
+redish = "#B80000"
diff --git a/runtime/themes/voxed.toml b/runtime/themes/voxed.toml
index c2be9afef..fff0bfbaf 100644
--- a/runtime/themes/voxed.toml
+++ b/runtime/themes/voxed.toml
@@ -1,3 +1,9 @@
+# Voxed theme for the Helix Editor
+# Author: rojebd<roniellberrios@gmail.com>
+# Repo: https://github.com/rojebd/voxed
+# Version: 1.0
+# Info: This is a theme I made one afternoon because I was bored
+
 attribute = "buff"
 keyword = "sglow"
 "keyword.directive" = "defineish" 
@@ -43,6 +49,7 @@ label = "yellow"
 "ui.background.separator" = { fg = "sglow" }
 "ui.linenr" = { fg = "light-grey", modifiers = ["italic"] }
 "ui.linenr.selected" = { fg = "bpink", modifiers = ["bold"] }
+
 "ui.statusline" = { fg = "black", bg = "light-grey", modifiers = ["bold"] }
 "ui.statusline.inactive" = { fg = "black", bg = "bgrey-two" }
 "ui.popup" = { fg = "bgrey", bg = "#25262B" }
@@ -54,7 +61,8 @@ label = "yellow"
 "ui.text.inactive" = "bgrey"
 "ui.virtual" = { fg = "blue" }
 "ui.virtual.ruler" = { bg = "bgrey-two" }
-"ui.virtual.indent-guide" = { fg = "bpink" }
+"ui.virtual.indent-guide" = { fg = "gray" }
+
 
 "ui.selection" = { bg = "maize" }
 "ui.selection.primary" = { fg = "white", bg = "bgrey" }
@@ -62,7 +70,8 @@ label = "yellow"
 "ui.cursor.insert" = { bg = "white" }
 "ui.cursor.match" = { fg = "#212121", bg = "#6C6999" }
 "ui.cursor" = { bg = "bgrey-two", modifiers = ["reversed"] }
-"ui.cursorline.primary" = { bg = "white" }
+"ui.cursorline.primary" = { bg = "#44414c" }
+
 "ui.highlight" = { bg = "white" }
 "ui.highlight.frameline" = { bg = "#634450" }
 "ui.debug" = { fg = "#634450" }
@@ -75,8 +84,6 @@ label = "yellow"
 "diagnostic.info" = { underline = { color = "sglow", style = "curl" } }
 "diagnostic.warning" = { underline = { color = "redish", style = "curl" } }
 "diagnostic.error" = { underline = { color = "bpink", style = "curl" } }
-"diagnostic.unnecessary" = { modifiers = ["dim"] }
-"diagnostic.deprecated" = { modifiers = ["crossed_out"] }
 
 warning = "bpink"
 error = "bsienna"
diff --git a/runtime/themes/yo.toml b/runtime/themes/yo.toml
new file mode 100644
index 000000000..55c805204
--- /dev/null
+++ b/runtime/themes/yo.toml
@@ -0,0 +1,125 @@
+# Author: Michael McClintock <michael.mcclintock@hey.com>
+# License: MIT
+
+# Yo - Themes for Helix inspired by Zenbones & Alabaster with Radix Colors.
+# https://github.com/mrmcc3/yo-theme-helix
+
+# background/text
+"ui.background" = { fg = "p11", bg = "p2" }
+"ui.background.separator" = { fg = "p7" }
+"ui.text" = { fg = "p11" }
+"ui.text.focus" = { fg = "p12", modifiers = ["bold"] }
+
+# popups/menus
+"ui.window" = { fg = "p7" }
+"ui.popup" = { fg = "p12", bg = "p4" }
+"ui.popup.info" = { fg = "p12", bg = "p2" }
+"ui.text.info" = { fg = "p12", bg = "p2" }
+"ui.help" = { fg = "p12", bg = "p2" }
+"ui.menu" = { fg = "p11", bg = "p4" }
+"ui.menu.selected" = { fg = "p12", modifiers = ["bold"] }
+"ui.menu.scroll" = { fg = "p8", bg = "p4" }
+"ui.picker.header.column" = { underline.style = "line" }
+
+# cursor/selection
+"ui.cursor" = { fg = "p2", bg = "p11" }
+"ui.cursor.insert" = { fg = "p2", bg = "keyword" }
+"ui.cursor.select" = { fg = "p2", bg = "p12" }
+"ui.cursor.match" = { fg = "p12", modifiers = ["bold"] }
+"ui.cursor.primary" = { fg = "p2", bg = "p11", modifiers = ["bold"] }
+"ui.cursor.primary.insert" = { fg = "p2", bg = "keyword", modifiers = ["bold"] }
+"ui.cursor.primary.select" = { fg = "p2", bg = "p12", modifiers = ["bold"] }
+"ui.selection" = { bg = "p4" }
+"ui.selection.primary" = { bg = "p5" }
+"ui.cursorline.primary" = { bg = "p3" }
+"ui.cursorcolumn.primary" = { bg = "p3" }
+
+# line numbers / diff
+"ui.linenr" = { fg = "p7" }
+"ui.linenr.selected" = { fg = "p11" }
+diff = { fg = "p8" }
+
+# bufferline/statusline
+"ui.bufferline" = { fg = "p11", bg = "p4" }
+"ui.bufferline.active" = { fg = "p2", bg = "p11" }
+"ui.statusline" = { fg = "p11", bg = "p4" }
+"ui.statusline.inactive" = { fg = "p11", bg = "p2" }
+"ui.statusline.normal" = { fg = "p2", bg = "p11" }
+"ui.statusline.insert" = { fg = "p2", bg = "keyword" }
+"ui.statusline.select" = { fg = "p2", bg = "p12" }
+"ui.statusline.separator" = { fg = "p7" }
+
+# virtual
+"ui.virtual" = { fg = "p6" }
+"ui.virtual.ruler" = { bg = "p3" }
+"ui.virtual.inlay-hint" = { fg = "p7", underline.style = "dotted" }
+"ui.virtual.jump-label" = { fg = "p12", modifiers = [
+  "bold",
+], underline = { style = "curl", color = "info" } }
+
+# diagnostics
+error = { fg = "error", modifiers = ["bold"] }
+warning = { fg = "warning", modifiers = ["bold"] }
+info = { fg = "info", modifiers = ["bold"] }
+hint = { fg = "info", modifiers = ["bold"] }
+"diagnostic.error" = { fg = "error", modifiers = ["bold"] }
+"diagnostic.warning" = { fg = "warning", modifiers = ["bold"] }
+"diagnostic.info" = { fg = "info", modifiers = ["bold"] }
+"diagnostic.hint" = { fg = "info", modifiers = ["bold"] }
+# "diagnostic.unnecessary" = {}
+# "diagnostic.deprecated" = {}
+
+# code
+comment = { fg = "info" }
+keyword = { fg = "keyword" }
+operator = { fg = "keyword" }
+string = { fg = "string" }
+constant = { fg = "constant" }
+"string.special.symbol" = { fg = "constant" }
+variable = { fg = "p10" }
+namespace = { fg = "p10" }
+punctuation = { fg = "p9" }
+"punctuation.delimiter" = { fg = "p8" }
+function = { fg = "p11" }
+attribute = { fg = "p10" }
+tag = { fg = "keyword" }
+label = { fg = "p12" }
+constructor = { fg = "p12" }
+type = { fg = "p12" }
+
+# markup
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.heading" = { fg = "p12", modifiers = ["bold"] }
+"markup.heading.marker" = { fg = "p8" }
+"markup.list" = { fg = "p8" }
+"markup.link.url" = { underline.style = "line" }
+"markup.link.label" = { underline.style = "dotted" }
+# "markup.link.text" = {}
+"markup.quote" = { fg = "p10" }
+# "markup.raw" = {}
+
+[palette] # https://www.radix-ui.com/colors
+
+# grayDark
+p1 = "#111111"
+p2 = "#191919"
+p3 = "#222222"
+p4 = "#2a2a2a"
+p5 = "#313131"
+p6 = "#3a3a3a"
+p7 = "#484848"
+p8 = "#606060"
+p9 = "#6e6e6e"
+p10 = "#7b7b7b"
+p11 = "#b4b4b4"
+p12 = "#eeeeee"
+
+error = "#ec5d5e"   # redDark-10
+warning = "#ff801f" # orangeDark-10
+info = "#3b9eff"    # blueDark-10
+
+string = "#33b074"   # greenDark-10
+constant = "#9a5cd0" # purpleDark-10
+keyword = "#ae8c7e"  # bronzeDark-10
diff --git a/runtime/themes/yo_berry.toml b/runtime/themes/yo_berry.toml
new file mode 100644
index 000000000..1aaac1a92
--- /dev/null
+++ b/runtime/themes/yo_berry.toml
@@ -0,0 +1,31 @@
+# Author: Michael McClintock <michael.mcclintock@hey.com>
+# License: MIT
+
+# Yo - Themes for Helix inspired by Zenbones & Alabaster with Radix Colors.
+# https://github.com/mrmcc3/yo-theme-helix
+
+inherits = "yo"
+
+[palette]
+
+# mauveDark
+p1 = "#121113"
+p2 = "#1a191b"
+p3 = "#232225"
+p4 = "#2b292d"
+p5 = "#323035"
+p6 = "#3c393f"
+p7 = "#49474e"
+p8 = "#625f69"
+p9 = "#6f6d78"
+p10 = "#7c7a85"
+p11 = "#b5b2bc"
+p12 = "#eeeef0"
+
+error = "#ee518a"   # crimsonDark-10
+warning = "#ffff57" # yellowDark-10
+info = "#3b9eff"    # blueDark-10
+
+string = "#0eb39e"   # teal-10
+constant = "#b658c4" # plum-10
+keyword = "#9eb1ff"  # indigo-11
diff --git a/runtime/themes/yo_light.toml b/runtime/themes/yo_light.toml
new file mode 100644
index 000000000..15c149184
--- /dev/null
+++ b/runtime/themes/yo_light.toml
@@ -0,0 +1,34 @@
+# Author: Michael McClintock <michael.mcclintock@hey.com>
+# License: MIT
+
+# Yo - Themes for Helix inspired by Zenbones & Alabaster with Radix Colors.
+# https://github.com/mrmcc3/yo-theme-helix
+
+inherits = "yo"
+
+"ui.virtual.inlay-hint" = { fg = "p8", underline.style = "dotted" }
+"markup.quote" = { fg = "p9" }
+
+[palette]
+
+# gray
+p1 = "#fcfcfc"
+p2 = "#f9f9f9"
+p3 = "#f0f0f0"
+p4 = "#e8e8e8"
+p5 = "#e0e0e0"
+p6 = "#d9d9d9"
+p7 = "#cecece"
+p8 = "#bbbbbb"
+p9 = "#8d8d8d"
+p10 = "#838383"
+p11 = "#646464"
+p12 = "#202020"
+
+error = "#dc3e42"   # red-10
+warning = "#ef5f00" # orange-10
+info = "#0588f0"    # blue-10
+
+string = "#2b9a66"   # green-10
+constant = "#8347b9" # purple-10
+keyword = "#957468"  # bronze-10
diff --git a/runtime/themes/zed_onedark.toml b/runtime/themes/zed_onedark.toml
index 74db8f75c..160320de1 100644
--- a/runtime/themes/zed_onedark.toml
+++ b/runtime/themes/zed_onedark.toml
@@ -61,7 +61,8 @@
 "ui.cursor" = { fg = "white", modifiers = ["reversed"] }
 "ui.cursor.primary" = { fg = "white", modifiers = ["reversed"] }
 "ui.cursor.match" = { fg = "blue", modifiers = ["underlined"] }
-"ui.cursor.insert" = { fg = "dark-blue" }
+# Malformed ANSI: dark-blue. See 'https://github.com/helix-editor/helix/issues/5709'
+# "ui.cursor.insert" = { fg = "dark-blue" }
 
 "ui.selection" = { bg = "faint-gray" }
 "ui.selection.primary" = { bg = "#293b5bff" }
diff --git a/runtime/tutor b/runtime/tutor
index 98b9f3af1..f94e2a202 100644
--- a/runtime/tutor
+++ b/runtime/tutor
@@ -391,8 +391,8 @@
  --> 6) Sugar is sweet,
  --> 7) And so are you.
 
- Note : X works similarly to x although it doesn't extend to
-      subsequent lines. X on an empty line does nothing.
+ Note: X works similarly to x although it doesn't extend to
+       subsequent lines. X on an empty line does nothing.
 
 =================================================================
 =                   3.8 COLLAPSING SELECTIONS                   =
@@ -411,8 +411,8 @@
  --> This is an error-free line with words to move around in.
 
  Note: This works the same in Select mode.
- Note: Another related command is Alt-; which flips selections.
-
+ Note: Another related command is Alt-; which flips the direction
+       of the selection (flips the selection's cursor and anchor).
 
 
 
@@ -1223,7 +1223,7 @@ letters! that is not good grammar. you can fix this.
  to the matching ). You can do the same on the line below: for example
  move to ], and press mm to jump to [ .
 
- --> you can (jump between matching parenthesis)
+ --> you can (jump between matching parentheses)
  --> or between matching [ square brackets ]
  --> now { you know the drill: this works with brackets too }
 
@@ -1238,19 +1238,19 @@ letters! that is not good grammar. you can fix this.
  pair of brackets or other delimiters. In the lines below:
 
  - move to the --> line, put your cursor in normal mode at any
- location between the parenthesis, for example at 'x', and press
- mi( or mi) to select the whole content inside the parenthesis
- (parenthesis excluded). As usual, you can then do anything you want
+ location between the parentheses, for example at 'x', and press
+ mi( or mi) to select the whole content inside the parentheses
+ (parentheses excluded). As usual, you can then do anything you want
  with the selection (for example, press c to change it)
 
- --> outside and (inside x parenthesis) - and outside again
+ --> outside and (inside x parentheses) - and outside again
 
  Test below that you can do the same with [], or {}, or with
  nested combinations of these (this will act on the immediately
  surrounding matching pair). This also works with "" and similar
 
  --> test [ with square brackets ] !
- --> try ( with nested [ pairs of ( parenthesis) and "brackets" ])
+ --> try ( with nested [ pairs of ( parentheses) and "brackets" ])
 
 =================================================================
 =               12.3 USING MATCH MODE SELECT AROUND             =
@@ -1284,7 +1284,7 @@ letters! that is not good grammar. you can fix this.
  move in normal mode the cursor to the start of select, then enter
  selection mode with v , then select the 4 next words with 4e ),
   * ii) press ms( or ms) to surround the selection with a pair of
- parenthesis.
+ parentheses.
 
  --> so, select all of this, and surround it with ()
 
@@ -1304,9 +1304,9 @@ letters! that is not good grammar. you can fix this.
  command. On the line below, move the cursor anywhere
  within the pair of (), for example to the 'x', then from there,
  in normal mode, press md( or md) to delete the surrounding
- pair of parenthesis.
+ pair of parentheses.
 
- --> delete (the x pair of parenthesis) from within!
+ --> delete (the x pair of parentheses) from within!
 
  You can naturally delete other kinds of surroundings:
 
@@ -1462,7 +1462,7 @@ letters! that is not good grammar. you can fix this.
 
  Still from hello2, press Ctrl-w H to swap with the split on the
  left: now hello2 is on the left and the tutor is on the top
- right. After Ctrl-w you can use HJKL to split with the buffer
+ right. After Ctrl-w you can use HJKL to swap with the buffer
  on the left / below / above / on the right.
 
  Move back to the tutor split, and press Ctrl-w o to only keep
diff --git a/rust-toolchain.toml b/rust-toolchain.toml
index 7c7cb7f41..70e85c40b 100644
--- a/rust-toolchain.toml
+++ b/rust-toolchain.toml
@@ -1,3 +1,3 @@
 [toolchain]
-channel = "1.74.0"
+channel = "1.76.0"
 components = ["rustfmt", "rust-src", "clippy"]
diff --git a/theme.toml b/theme.toml
index c1e5883d0..2139c8bfd 100644
--- a/theme.toml
+++ b/theme.toml
@@ -27,6 +27,7 @@ string = "silver"
 "constant.character.escape" = "honey"
 # used for lifetimes
 label = "honey"
+tabstop = { modifiers = ["italic"], bg = "bossanova" }
 
 "markup.heading" = "lilac"
 "markup.bold" = { modifiers = ["bold"] }
@@ -55,6 +56,7 @@ label = "honey"
 "ui.text" = { fg = "lavender" }
 "ui.text.focus" = { fg = "white" }
 "ui.text.inactive" = "sirocco"
+"ui.text.directory" = { fg = "lilac" }
 "ui.virtual" = { fg = "comet" }
 "ui.virtual.ruler" = { bg = "bossanova" }
 "ui.virtual.jump-label" = { fg = "apricot", modifiers = ["bold"] }
diff --git a/xtask/src/docgen.rs b/xtask/src/docgen.rs
index 18c145d50..2b58e7329 100644
--- a/xtask/src/docgen.rs
+++ b/xtask/src/docgen.rs
@@ -1,12 +1,17 @@
 use crate::helpers;
 use crate::path;
 use crate::DynError;
+
+use helix_term::commands::MappableCommand;
 use helix_term::commands::TYPABLE_COMMAND_LIST;
 use helix_term::health::TsFeature;
+use helix_view::document::Mode;
+
 use std::collections::HashSet;
 use std::fs;
 
 pub const TYPABLE_COMMANDS_MD_OUTPUT: &str = "typable-cmd.md";
+pub const STATIC_COMMANDS_MD_OUTPUT: &str = "static-cmd.md";
 pub const LANG_SUPPORT_MD_OUTPUT: &str = "lang-support.md";
 
 fn md_table_heading(cols: &[String]) -> String {
@@ -48,6 +53,68 @@ pub fn typable_commands() -> Result<String, DynError> {
     Ok(md)
 }
 
+pub fn static_commands() -> Result<String, DynError> {
+    let mut md = String::new();
+    let keymap = helix_term::keymap::default();
+    let keymaps = [
+        ("normal", keymap[&Mode::Normal].reverse_map()),
+        ("select", keymap[&Mode::Select].reverse_map()),
+        ("insert", keymap[&Mode::Insert].reverse_map()),
+    ];
+
+    md.push_str(&md_table_heading(&[
+        "Name".to_owned(),
+        "Description".to_owned(),
+        "Default keybinds".to_owned(),
+    ]));
+
+    for cmd in MappableCommand::STATIC_COMMAND_LIST {
+        let keymap_strings: Vec<_> = keymaps
+            .iter()
+            .map(|(mode, keymap)| {
+                let bindings = keymap
+                    .get(cmd.name())
+                    .map(|bindings| {
+                        let mut bind_strings: Vec<_> = bindings
+                            .iter()
+                            .map(|bind| {
+                                let keys = &bind
+                                    .iter()
+                                    .map(|key| key.key_sequence_format())
+                                    .collect::<String>()
+                                    // escape | so it doesn't get rendered as a column separator
+                                    .replace('|', "\\|");
+                                format!("`` {} ``", keys)
+                            })
+                            .collect();
+                        // sort for stable output. sorting by length puts simple
+                        // keybindings first and groups similar keys together
+                        bind_strings.sort_by_key(|s| (s.len(), s.to_owned()));
+                        bind_strings.join(", ")
+                    })
+                    .unwrap_or_default();
+
+                (mode, bindings)
+            })
+            .collect();
+
+        let keymap_string = keymap_strings
+            .iter()
+            .filter(|(_, bindings)| !bindings.is_empty())
+            .map(|(mode, bindings)| format!("{}: {}", mode, bindings))
+            .collect::<Vec<_>>()
+            .join(", ");
+
+        md.push_str(&md_table_row(&[
+            md_mono(cmd.name()),
+            cmd.doc().to_owned(),
+            keymap_string,
+        ]));
+    }
+
+    Ok(md)
+}
+
 pub fn lang_features() -> Result<String, DynError> {
     let mut md = String::new();
     let ts_features = TsFeature::all();
@@ -59,7 +126,7 @@ pub fn lang_features() -> Result<String, DynError> {
             .map(|t| t.long_title().to_string())
             .collect::<Vec<_>>(),
     );
-    cols.push("Default LSP".to_owned());
+    cols.push("Default language servers".to_owned());
 
     md.push_str(&md_table_heading(&cols));
     let config = helpers::lang_config();
diff --git a/xtask/src/main.rs b/xtask/src/main.rs
index aba5c4499..39de89182 100644
--- a/xtask/src/main.rs
+++ b/xtask/src/main.rs
@@ -2,19 +2,24 @@
 mod helpers;
 mod path;
 mod querycheck;
+mod theme_check;
 
 use std::{env, error::Error};
 
 type DynError = Box<dyn Error>;
 
 pub mod tasks {
-    use crate::docgen::{lang_features, typable_commands, write};
-    use crate::docgen::{LANG_SUPPORT_MD_OUTPUT, TYPABLE_COMMANDS_MD_OUTPUT};
+    use crate::docgen::{lang_features, static_commands, typable_commands, write};
+    use crate::docgen::{
+        LANG_SUPPORT_MD_OUTPUT, STATIC_COMMANDS_MD_OUTPUT, TYPABLE_COMMANDS_MD_OUTPUT,
+    };
     use crate::querycheck::query_check;
+    use crate::theme_check::theme_check;
     use crate::DynError;
 
     pub fn docgen() -> Result<(), DynError> {
         write(TYPABLE_COMMANDS_MD_OUTPUT, &typable_commands()?);
+        write(STATIC_COMMANDS_MD_OUTPUT, &static_commands()?);
         write(LANG_SUPPORT_MD_OUTPUT, &lang_features()?);
         Ok(())
     }
@@ -23,6 +28,10 @@ pub fn querycheck() -> Result<(), DynError> {
         query_check()
     }
 
+    pub fn themecheck() -> Result<(), DynError> {
+        theme_check()
+    }
+
     pub fn print_help() {
         println!(
             "
@@ -43,6 +52,7 @@ fn main() -> Result<(), DynError> {
         Some(t) => match t.as_str() {
             "docgen" => tasks::docgen()?,
             "query-check" => tasks::querycheck()?,
+            "theme-check" => tasks::themecheck()?,
             invalid => return Err(format!("Invalid task name: {}", invalid).into()),
         },
     };
diff --git a/xtask/src/path.rs b/xtask/src/path.rs
index 62d884f2e..cf8e8792e 100644
--- a/xtask/src/path.rs
+++ b/xtask/src/path.rs
@@ -11,8 +11,16 @@ pub fn book_gen() -> PathBuf {
     project_root().join("book/src/generated/")
 }
 
+pub fn runtime() -> PathBuf {
+    project_root().join("runtime")
+}
+
 pub fn ts_queries() -> PathBuf {
-    project_root().join("runtime/queries")
+    runtime().join("queries")
+}
+
+pub fn themes() -> PathBuf {
+    runtime().join("themes")
 }
 
 pub fn lang_config() -> PathBuf {
diff --git a/xtask/src/theme_check.rs b/xtask/src/theme_check.rs
new file mode 100644
index 000000000..a2719ede8
--- /dev/null
+++ b/xtask/src/theme_check.rs
@@ -0,0 +1,33 @@
+use helix_view::theme::Loader;
+
+use crate::{path, DynError};
+
+pub fn theme_check() -> Result<(), DynError> {
+    let theme_names = [
+        vec!["default".to_string(), "base16_default".to_string()],
+        Loader::read_names(&path::themes()),
+    ]
+    .concat();
+    let loader = Loader::new(&[path::runtime()]);
+    let mut errors_present = false;
+
+    for name in theme_names {
+        let (_, warnings) = loader.load_with_warnings(&name).unwrap();
+
+        if !warnings.is_empty() {
+            errors_present = true;
+            println!("Theme '{name}' loaded with errors:");
+            for warning in warnings {
+                println!("\t* {}", warning);
+            }
+        }
+    }
+
+    match errors_present {
+        true => Err("Errors found when loading bundled themes".into()),
+        false => {
+            println!("Theme check successful!");
+            Ok(())
+        }
+    }
+}
