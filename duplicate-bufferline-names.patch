diff --git a/.cargo/config.toml b/.cargo/config.toml
index 5d6155669..b016eca31 100644
--- a/.cargo/config.toml
+++ b/.cargo/config.toml
@@ -1,3 +1,3 @@
 [alias]
 xtask = "run --package xtask --"
-integration-test = "test --features integration --workspace --test integration"
+integration-test = "test --features integration --profile integration --workspace --test integration"
diff --git a/.github/ISSUE_TEMPLATE/bug_report.yaml b/.github/ISSUE_TEMPLATE/bug_report.yaml
index c67deb690..47fd3fe8a 100644
--- a/.github/ISSUE_TEMPLATE/bug_report.yaml
+++ b/.github/ISSUE_TEMPLATE/bug_report.yaml
@@ -32,7 +32,7 @@ body:
     id: helix-log
     attributes:
       label: Helix log
-      description: See `hx -h` for log file path
+      description: See `hx -h` for log file path. If you can reproduce the issue run `RUST_BACKTRACE=1 hx -vv` to generate a more detailed log file.
       value: |
         <details><summary>~/.cache/helix/helix.log</summary>
 
@@ -61,7 +61,8 @@ body:
       label: Helix Version
       description: >
         Helix version (`hx -V` if using a release, `git describe` if building
-        from master)
-      placeholder: "helix 0.6.0 (c0dbd6dc)"
+        from master).
+        **Make sure that you are using the [latest helix release](https://github.com/helix-editor/helix/releases) or a newer master build**
+      placeholder: "helix 22.12 (5eaa6d97)"
     validations:
       required: true
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index deeff80e1..d7d7d47e0 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -4,24 +4,17 @@ on:
   push:
     branches:
       - master
+  merge_group:
   schedule:
     - cron: '00 01 * * *'
 
 jobs:
   check:
-    name: Check
+    name: Check (msrv)
     runs-on: ubuntu-latest
-    strategy:
-      matrix:
-        rust: [stable, msrv]
     steps:
       - name: Checkout sources
         uses: actions/checkout@v3
-
-      - name: Use MSRV rust toolchain
-        if: matrix.rust == 'msrv'
-        run: cp .github/workflows/msrv-rust-toolchain.toml rust-toolchain.toml
-
       - name: Install stable toolchain
         uses: helix-editor/rust-toolchain@v1
         with:
@@ -44,10 +37,7 @@ jobs:
         uses: actions/checkout@v3
 
       - name: Install stable toolchain
-        uses: helix-editor/rust-toolchain@v1
-        with:
-          profile: minimal
-          override: true
+        uses: dtolnay/rust-toolchain@1.65
 
       - uses: Swatinem/rust-cache@v2
 
@@ -76,10 +66,8 @@ jobs:
         uses: actions/checkout@v3
 
       - name: Install stable toolchain
-        uses: helix-editor/rust-toolchain@v1
+        uses: dtolnay/rust-toolchain@1.65
         with:
-          profile: minimal
-          override: true
           components: rustfmt, clippy
 
       - uses: Swatinem/rust-cache@v2
@@ -103,13 +91,13 @@ jobs:
         uses: actions/checkout@v3
 
       - name: Install stable toolchain
-        uses: helix-editor/rust-toolchain@v1
-        with:
-          profile: minimal
-          override: true
+        uses: dtolnay/rust-toolchain@1.65
 
       - uses: Swatinem/rust-cache@v2
 
+      - name: Validate queries
+        run: cargo xtask query-check
+
       - name: Generate docs
         run: cargo xtask docgen
 
@@ -120,20 +108,3 @@ jobs:
             || (echo "Run 'cargo xtask docgen', commit the changes and push again" \
             && exit 1)
 
-  queries:
-    name: Tree-sitter queries
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout sources
-        uses: actions/checkout@v3
-
-      - name: Install stable toolchain
-        uses: helix-editor/rust-toolchain@v1
-        with:
-          profile: minimal
-          override: true
-
-      - uses: Swatinem/rust-cache@v2
-
-      - name: Generate docs
-        run: cargo xtask query-check
diff --git a/.github/workflows/cachix.yml b/.github/workflows/cachix.yml
index 200356787..7d2f734aa 100644
--- a/.github/workflows/cachix.yml
+++ b/.github/workflows/cachix.yml
@@ -14,7 +14,7 @@ jobs:
       uses: actions/checkout@v3
 
     - name: Install nix
-      uses: cachix/install-nix-action@v18
+      uses: cachix/install-nix-action@v20
 
     - name: Authenticate with Cachix
       uses: cachix/cachix-action@v12
diff --git a/.github/workflows/msrv-rust-toolchain.toml b/.github/workflows/msrv-rust-toolchain.toml
deleted file mode 100644
index b169d31e6..000000000
--- a/.github/workflows/msrv-rust-toolchain.toml
+++ /dev/null
@@ -1,3 +0,0 @@
-[toolchain]
-channel = "1.61.0"
-components = ["rustfmt", "rust-src"]
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index c242f0894..b509ff9e0 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -26,10 +26,7 @@ jobs:
         uses: actions/checkout@v3
 
       - name: Install stable toolchain
-        uses: helix-editor/rust-toolchain@v1
-        with:
-          profile: minimal
-          override: true
+        uses: dtolnay/rust-toolchain@stable
 
       - uses: Swatinem/rust-cache@v2
 
@@ -47,6 +44,16 @@ jobs:
   dist:
     name: Dist
     needs: [fetch-grammars]
+    env:
+      # For some builds, we use cross to test on 32-bit and big-endian
+      # systems.
+      CARGO: cargo
+      # When CARGO is set to CROSS, this is set to `--target matrix.target`.
+      TARGET_FLAGS:
+      # When CARGO is set to CROSS, TARGET_DIR includes matrix.target.
+      TARGET_DIR: ./target
+      # Emit backtraces on panics.
+      RUST_BACKTRACE: 1
     runs-on: ${{ matrix.os }}
     strategy:
       fail-fast: false # don't fail other jobs if one fails
@@ -54,17 +61,17 @@ jobs:
         build: [x86_64-linux, x86_64-macos, x86_64-windows] #, x86_64-win-gnu, win32-msvc
         include:
         - build: x86_64-linux
-          os: ubuntu-20.04
+          os: ubuntu-latest
           rust: stable
           target: x86_64-unknown-linux-gnu
           cross: false
         - build: aarch64-linux
-          os: ubuntu-20.04
+          os: ubuntu-latest
           rust: stable
           target: aarch64-unknown-linux-gnu
           cross: true
         - build: riscv64-linux
-          os: ubuntu-20.04
+          os: ubuntu-latest
           rust: stable
           target: riscv64gc-unknown-linux-gnu
           cross: true
@@ -74,10 +81,11 @@ jobs:
           target: x86_64-apple-darwin
           cross: false
         - build: x86_64-windows
-          os: windows-2019
+          os: windows-latest
           rust: stable
           target: x86_64-pc-windows-msvc
           cross: false
+        # 23.03: build issues
         - build: aarch64-macos
           os: macos-latest
           rust: stable
@@ -106,13 +114,17 @@ jobs:
           mkdir -p runtime/grammars/sources
           tar xJf grammars/grammars.tar.xz -C runtime/grammars/sources
 
+      # The rust-toolchain action ignores rust-toolchain.toml files.
+      # Removing this before building with cargo ensures that the rust-toolchain
+      # is considered the same between installation and usage.
+      - name: Remove the rust-toolchain.toml file
+        run: rm rust-toolchain.toml
+
       - name: Install ${{ matrix.rust }} toolchain
-        uses: actions-rs/toolchain@v1
+        uses: dtolnay/rust-toolchain@master
         with:
-          profile: minimal
           toolchain: ${{ matrix.rust }}
           target: ${{ matrix.target }}
-          override: true
 
       # Install a pre-release version of Cross
       # TODO: We need to pre-install Cross because we need cross-rs/cross#591 to
@@ -120,15 +132,20 @@ jobs:
       #       0.3.0, which includes cross-rs/cross#591, is released.
       - name: Install Cross
         if: "matrix.cross"
-        run: cargo install cross --git https://github.com/cross-rs/cross.git --rev 47df5c76e7cba682823a0b6aa6d95c17b31ba63a
+        run: |
+          cargo install cross --git https://github.com/cross-rs/cross.git --rev 47df5c76e7cba682823a0b6aa6d95c17b31ba63a
+          echo "CARGO=cross" >> $GITHUB_ENV
+        # echo "TARGET_FLAGS=--target ${{ matrix.target }}" >> $GITHUB_ENV
+        # echo "TARGET_DIR=./target/${{ matrix.target }}" >> $GITHUB_ENV
+
+      - name: Show command used for Cargo
+        run: |
+          echo "cargo command is: ${{ env.CARGO }}"
+          echo "target flag is: ${{ env.TARGET_FLAGS }}"
 
       - name: Run cargo test
-        uses: actions-rs/cargo@v1
         if: "!matrix.skip_tests"
-        with:
-          use-cross: ${{ matrix.cross }}
-          command: test
-          args: --release --locked --target ${{ matrix.target }} --workspace
+        run: ${{ env.CARGO }} test --release --locked --target ${{ matrix.target }} --workspace
 
       - name: Set profile.release.strip = true
         shell: bash
@@ -139,16 +156,16 @@ jobs:
           EOF
 
       - name: Build release binary
-        uses: actions-rs/cargo@v1
-        with:
-          use-cross: ${{ matrix.cross }}
-          command: build
-          args: --release --locked --target ${{ matrix.target }}
+        run: ${{ env.CARGO }} build --release --locked --target ${{ matrix.target }}
 
       - name: Build AppImage
         shell: bash
         if: matrix.build == 'aarch64-linux' || matrix.build == 'x86_64-linux'
         run: |
+          # Required as of 22.x https://github.com/AppImage/AppImageKit/wiki/FUSE
+          sudo add-apt-repository universe
+          sudo apt install libfuse2
+
           mkdir dist
 
           name=dev
@@ -238,7 +255,7 @@ jobs:
                   exe=".exe"
               fi
               pkgname=helix-$GITHUB_REF_NAME-$platform
-              mkdir $pkgname
+              mkdir -p $pkgname
               cp $source/LICENSE $source/README.md $pkgname
               mkdir $pkgname/contrib
               cp -r $source/contrib/completion $pkgname/contrib
diff --git a/CHANGELOG.md b/CHANGELOG.md
index dc91c9ff3..01184571e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,276 @@
+# 23.03 (2023-03-31)
+
+23.03 brings some long-awaited and exciting features. Thank you to everyone involved! This release saw changes from 102 contributors.
+
+For the full log, check out the [git log](https://github.com/helix-editor/helix/compare/22.12..23.03).
+Also check out the [release notes](https://helix-editor.com/news/release-23-03-highlights/) for more commentary on larger features.
+
+Breaking changes:
+
+- Select diagnostic range in `goto_*_diag` commands ([#4713](https://github.com/helix-editor/helix/pull/4713), [#5164](https://github.com/helix-editor/helix/pull/5164), [#6193](https://github.com/helix-editor/helix/pull/6193))
+- Remove jump behavior from `increment`/`decrement` ([#4123](https://github.com/helix-editor/helix/pull/4123), [#5929](https://github.com/helix-editor/helix/pull/5929))
+- Select change range in `goto_*_change` commands ([#5206](https://github.com/helix-editor/helix/pull/5206))
+- Split file modification indicator from filename statusline elements ([#4731](https://github.com/helix-editor/helix/pull/4731), [#6036](https://github.com/helix-editor/helix/pull/6036))
+- Jump to symbol ranges in LSP goto commands ([#5986](https://github.com/helix-editor/helix/pull/5986))
+- Workspace detection now stops at the first `.helix/` directory (merging multiple `.helix/languages.toml` configurations is no longer supported) ([#5748](https://github.com/helix-editor/helix/pull/5748))
+
+Features:
+
+- Dynamic workspace symbol picker ([#5055](https://github.com/helix-editor/helix/pull/5055))
+- Soft-wrap ([#5420](https://github.com/helix-editor/helix/pull/5420), [#5786](https://github.com/helix-editor/helix/pull/5786), [#5893](https://github.com/helix-editor/helix/pull/5893), [#6142](https://github.com/helix-editor/helix/pull/6142), [#6440](https://github.com/helix-editor/helix/pull/6440))
+- Initial support for LSP snippet completions ([#5864](https://github.com/helix-editor/helix/pull/5864), [b1f7528](https://github.com/helix-editor/helix/commit/b1f7528), [#6263](https://github.com/helix-editor/helix/pull/6263), [bbf4800](https://github.com/helix-editor/helix/commit/bbf4800), [90348b8](https://github.com/helix-editor/helix/commit/90348b8), [f87299f](https://github.com/helix-editor/helix/commit/f87299f), [#6371](https://github.com/helix-editor/helix/pull/6371), [9fe3adc](https://github.com/helix-editor/helix/commit/9fe3adc))
+- Add a statusline element for showing the current version control HEAD ([#5682](https://github.com/helix-editor/helix/pull/5682))
+- Display LSP type hints ([#5420](https://github.com/helix-editor/helix/pull/5420), [#5934](https://github.com/helix-editor/helix/pull/5934), [#6312](https://github.com/helix-editor/helix/pull/6312))
+- Enable the Kitty keyboard protocol on terminals with support ([#4939](https://github.com/helix-editor/helix/pull/4939), [#6170](https://github.com/helix-editor/helix/pull/6170), [#6194](https://github.com/helix-editor/helix/pull/6194), [#6438](https://github.com/helix-editor/helix/pull/6438))
+- Add a statusline element for the basename of the current file ([#5318](https://github.com/helix-editor/helix/pull/5318))
+- Add substring matching syntax for the picker ([#5658](https://github.com/helix-editor/helix/pull/5658))
+- Support LSP `textDocument/prepareRename` ([#6103](https://github.com/helix-editor/helix/pull/6103))
+- Allow multiple runtime directories with priorities ([#5411](https://github.com/helix-editor/helix/pull/5411))
+- Allow configuring whether to insert or replace completions ([#5728](https://github.com/helix-editor/helix/pull/5728))
+- Allow per-workspace config file `.helix/config.toml` ([#5748](https://github.com/helix-editor/helix/pull/5748))
+- Add `workspace-lsp-roots` config option to support multiple LSP roots for use with monorepos ([#5748](https://github.com/helix-editor/helix/pull/5748))
+
+Commands:
+
+- `:pipe-to` which pipes selections into a shell command and ignores output ([#4931](https://github.com/helix-editor/helix/pull/4931))
+- `merge_consecutive_selections` (`A-_`) combines all consecutive selections ([#5047](https://github.com/helix-editor/helix/pull/5047))
+- `rotate_view_reverse` which focuses the previous view ([#5356](https://github.com/helix-editor/helix/pull/5356))
+- `goto_declaration` (`gD`, requires LSP) which jumps to a symbol's declaration ([#5646](https://github.com/helix-editor/helix/pull/5646))
+- `file_picker_in_current_buffer_directory` ([#4666](https://github.com/helix-editor/helix/pull/4666))
+- `:character-info` which shows information about the character under the cursor ([#4000](https://github.com/helix-editor/helix/pull/4000))
+- `:toggle-option` for toggling config options at runtime ([#4085](https://github.com/helix-editor/helix/pull/4085))
+- `dap_restart` for restarting a debug session in DAP ([#5651](https://github.com/helix-editor/helix/pull/5651))
+- `:lsp-stop` to stop the language server of the current buffer ([#5964](https://github.com/helix-editor/helix/pull/5964))
+- `:reset-diff-change` for resetting a diff hunk to its original text ([#4974](https://github.com/helix-editor/helix/pull/4974))
+- `:config-open-workspace` for opening the config file local to the current workspace ([#5748](https://github.com/helix-editor/helix/pull/5748))
+
+Usability improvements:
+
+- Remove empty detail section in completion menu when LSP doesn't send details ([#4902](https://github.com/helix-editor/helix/pull/4902))
+- Pass client information on LSP initialization ([#4904](https://github.com/helix-editor/helix/pull/4904))
+- Allow specifying environment variables for language servers in language config ([#4004](https://github.com/helix-editor/helix/pull/4004))
+- Allow detached git worktrees to be recognized as root paths ([#5097](https://github.com/helix-editor/helix/pull/5097))
+- Improve error message handling for theme loading failures ([#5073](https://github.com/helix-editor/helix/pull/5073))
+- Print the names of binaries required for LSP/DAP in health-check ([#5195](https://github.com/helix-editor/helix/pull/5195))
+- Improve sorting in the picker in cases of ties ([#5169](https://github.com/helix-editor/helix/pull/5169))
+- Add theming for prompt suggestions ([#5104](https://github.com/helix-editor/helix/pull/5104))
+- Open a file picker when using `:open` on directories ([#2707](https://github.com/helix-editor/helix/pull/2707), [#5278](https://github.com/helix-editor/helix/pull/5278))
+- Reload language config with `:config-reload` ([#5239](https://github.com/helix-editor/helix/pull/5239), [#5381](https://github.com/helix-editor/helix/pull/5381), [#5431](https://github.com/helix-editor/helix/pull/5431))
+- Improve indent queries for python when the tree is errored ([#5332](https://github.com/helix-editor/helix/pull/5332))
+- Picker: Open files without closing the picker with `A-ret` ([#4435](https://github.com/helix-editor/helix/pull/4435))
+- Allow theming cursors by primary/secondary and by mode ([#5130](https://github.com/helix-editor/helix/pull/5130))
+- Allow configuration of the minimum width for the line-numbers gutter ([#4724](https://github.com/helix-editor/helix/pull/4724), [#5696](https://github.com/helix-editor/helix/pull/5696))
+- Use filename completer for `:run-shell-command` command ([#5729](https://github.com/helix-editor/helix/pull/5729))
+- Surround with line-endings with `ms<ret>` ([#4571](https://github.com/helix-editor/helix/pull/4571))
+- Hide duplicate symlinks in file pickers ([#5658](https://github.com/helix-editor/helix/pull/5658))
+- Tabulate buffer picker contents ([#5777](https://github.com/helix-editor/helix/pull/5777))
+- Add an option to disable LSP ([#4425](https://github.com/helix-editor/helix/pull/4425))
+- Short-circuit tree-sitter and word object motions ([#5851](https://github.com/helix-editor/helix/pull/5851))
+- Add exit code to failed command message ([#5898](https://github.com/helix-editor/helix/pull/5898))
+- Make `m` textobject look for pairs enclosing selections ([#3344](https://github.com/helix-editor/helix/pull/3344))
+- Negotiate LSP position encoding ([#5894](https://github.com/helix-editor/helix/pull/5894), [a48d1a4](https://github.com/helix-editor/helix/commit/a48d1a4))
+- Display deprecated LSP completions with strikethrough ([#5932](https://github.com/helix-editor/helix/pull/5932))
+- Add JSONRPC request ID to failed LSP/DAP request log messages ([#6010](https://github.com/helix-editor/helix/pull/6010), [#6018](https://github.com/helix-editor/helix/pull/6018))
+- Ignore case when filtering LSP completions ([#6008](https://github.com/helix-editor/helix/pull/6008))
+- Show current language when no arguments are passed to `:set-language` ([#5895](https://github.com/helix-editor/helix/pull/5895))
+- Refactor and rewrite all book documentation ([#5534](https://github.com/helix-editor/helix/pull/5534))
+- Separate diagnostic picker message and code ([#6095](https://github.com/helix-editor/helix/pull/6095))
+- Add a config option to bypass undercurl detection ([#6253](https://github.com/helix-editor/helix/pull/6253))
+- Only complete appropriate arguments for typed commands ([#5966](https://github.com/helix-editor/helix/pull/5966))
+- Discard outdated LSP diagnostics ([3c9d5d0](https://github.com/helix-editor/helix/commit/3c9d5d0))
+- Discard outdated LSP workspace edits ([b6a4927](https://github.com/helix-editor/helix/commit/b6a4927))
+- Run shell commands asynchronously ([#6373](https://github.com/helix-editor/helix/pull/6373))
+- Show diagnostic codes in LSP diagnostic messages ([#6378](https://github.com/helix-editor/helix/pull/6378))
+- Highlight the current line in a DAP debug session ([#5957](https://github.com/helix-editor/helix/pull/5957))
+- Hide signature help if it overlaps with the completion menu ([#5523](https://github.com/helix-editor/helix/pull/5523), [7a69c40](https://github.com/helix-editor/helix/commit/7a69c40))
+
+Fixes:
+
+- Fix behavior of `auto-completion` flag for completion-on-trigger ([#5042](https://github.com/helix-editor/helix/pull/5042))
+- Reset editor mode when changing buffers ([#5072](https://github.com/helix-editor/helix/pull/5072))
+- Respect scrolloff settings in mouse movements ([#5255](https://github.com/helix-editor/helix/pull/5255))
+- Avoid trailing `s` when only one file is opened ([#5189](https://github.com/helix-editor/helix/pull/5189))
+- Fix erroneous indent between closers of auto-pairs ([#5330](https://github.com/helix-editor/helix/pull/5330))
+- Expand `~` when parsing file paths in `:open` ([#5329](https://github.com/helix-editor/helix/pull/5329))
+- Fix theme inheritance for default themes ([#5218](https://github.com/helix-editor/helix/pull/5218))
+- Fix `extend_line` with a count when the current line(s) are selected ([#5288](https://github.com/helix-editor/helix/pull/5288))
+- Prompt: Fix autocompletion for paths containing periods ([#5175](https://github.com/helix-editor/helix/pull/5175))
+- Skip serializing JSONRPC params if params is null ([#5471](https://github.com/helix-editor/helix/pull/5471))
+- Fix interaction with the `xclip` clipboard provider ([#5426](https://github.com/helix-editor/helix/pull/5426))
+- Fix undo/redo execution from the command palette ([#5294](https://github.com/helix-editor/helix/pull/5294))
+- Fix highlighting of non-block cursors ([#5575](https://github.com/helix-editor/helix/pull/5575))
+- Fix panic when nooping in `join_selections` and `join_selections_space` ([#5423](https://github.com/helix-editor/helix/pull/5423))
+- Fix selecting a changed file in global search ([#5639](https://github.com/helix-editor/helix/pull/5639))
+- Fix initial syntax highlight layer sort order ([#5196](https://github.com/helix-editor/helix/pull/5196))
+- Fix UTF-8 length handling for shellwords ([#5738](https://github.com/helix-editor/helix/pull/5738))
+- Remove C-j and C-k bindings from the completion menu ([#5070](https://github.com/helix-editor/helix/pull/5070))
+- Always commit to history when pasting ([#5790](https://github.com/helix-editor/helix/pull/5790))
+- Properly handle LSP position encoding ([#5711](https://github.com/helix-editor/helix/pull/5711))
+- Fix infinite loop in `copy_selection_on_prev_line` ([#5888](https://github.com/helix-editor/helix/pull/5888))
+- Fix completion popup positioning ([#5842](https://github.com/helix-editor/helix/pull/5842))
+- Fix a panic when uncommenting a line with only a comment token ([#5933](https://github.com/helix-editor/helix/pull/5933))
+- Fix panic in `goto_window_center` at EOF ([#5987](https://github.com/helix-editor/helix/pull/5987))
+- Ignore invalid file URIs sent by a language server ([#6000](https://github.com/helix-editor/helix/pull/6000))
+- Decode LSP URIs for the workspace diagnostics picker ([#6016](https://github.com/helix-editor/helix/pull/6016))
+- Fix incorrect usages of `tab_width` with `indent_width` ([#5918](https://github.com/helix-editor/helix/pull/5918))
+- DAP: Send Disconnect if the Terminated event is received ([#5532](https://github.com/helix-editor/helix/pull/5532))
+- DAP: Validate key and index exist when requesting variables ([#5628](https://github.com/helix-editor/helix/pull/5628))
+- Check LSP renaming support before prompting for rename text ([#6257](https://github.com/helix-editor/helix/pull/6257))
+- Fix indent guide rendering ([#6136](https://github.com/helix-editor/helix/pull/6136))
+- Fix division by zero panic ([#6155](https://github.com/helix-editor/helix/pull/6155))
+- Fix lacking space panic ([#6109](https://github.com/helix-editor/helix/pull/6109))
+- Send error replies for malformed and unhandled LSP requests ([#6058](https://github.com/helix-editor/helix/pull/6058))
+- Fix table column calculations for dynamic pickers ([#5920](https://github.com/helix-editor/helix/pull/5920))
+- Skip adding jumplist entries for `:<n>` line number previews ([#5751](https://github.com/helix-editor/helix/pull/5751))
+- Fix completion race conditions ([#6173](https://github.com/helix-editor/helix/pull/6173))
+- Fix `shrink_selection` with multiple cursors ([#6093](https://github.com/helix-editor/helix/pull/6093))
+- Fix indentation calculation for lines with mixed tabs/spaces ([#6278](https://github.com/helix-editor/helix/pull/6278))
+- No-op `client/registerCapability` LSP requests ([#6258](https://github.com/helix-editor/helix/pull/6258))
+- Send the STOP signal to all processes in the process group ([#3546](https://github.com/helix-editor/helix/pull/3546))
+- Fix workspace edit client capabilities declaration ([7bf168d](https://github.com/helix-editor/helix/commit/7bf168d))
+- Fix highlighting in picker results with multiple columns ([#6333](https://github.com/helix-editor/helix/pull/6333))
+- Canonicalize paths before stripping the current dir as a prefix ([#6290](https://github.com/helix-editor/helix/pull/6290))
+- Fix truncation behavior for long path names in the file picker ([#6410](https://github.com/helix-editor/helix/pull/6410), [67783dd](https://github.com/helix-editor/helix/commit/67783dd))
+- Fix theme reloading behavior in `:config-reload` ([ab819d8](https://github.com/helix-editor/helix/commit/ab819d8))
+
+Themes:
+
+- Update `serika` ([#5038](https://github.com/helix-editor/helix/pull/5038), [#6344](https://github.com/helix-editor/helix/pull/6344))
+- Update `flatwhite` ([#5036](https://github.com/helix-editor/helix/pull/5036), [#6323](https://github.com/helix-editor/helix/pull/6323))
+- Update `autumn` ([#5051](https://github.com/helix-editor/helix/pull/5051), [#5397](https://github.com/helix-editor/helix/pull/5397), [#6280](https://github.com/helix-editor/helix/pull/6280), [#6316](https://github.com/helix-editor/helix/pull/6316))
+- Update `acme` ([#5019](https://github.com/helix-editor/helix/pull/5019), [#5486](https://github.com/helix-editor/helix/pull/5486), [#5488](https://github.com/helix-editor/helix/pull/5488))
+- Update `gruvbox` themes ([#5066](https://github.com/helix-editor/helix/pull/5066), [#5333](https://github.com/helix-editor/helix/pull/5333), [#5540](https://github.com/helix-editor/helix/pull/5540), [#6285](https://github.com/helix-editor/helix/pull/6285), [#6295](https://github.com/helix-editor/helix/pull/6295))
+- Update `base16_transparent` ([#5105](https://github.com/helix-editor/helix/pull/5105))
+- Update `dark_high_contrast` ([#5105](https://github.com/helix-editor/helix/pull/5105))
+- Update `dracula` ([#5236](https://github.com/helix-editor/helix/pull/5236), [#5627](https://github.com/helix-editor/helix/pull/5627), [#6414](https://github.com/helix-editor/helix/pull/6414))
+- Update `monokai_pro_spectrum` ([#5250](https://github.com/helix-editor/helix/pull/5250), [#5602](https://github.com/helix-editor/helix/pull/5602))
+- Update `rose_pine` ([#5267](https://github.com/helix-editor/helix/pull/5267), [#5489](https://github.com/helix-editor/helix/pull/5489), [#6384](https://github.com/helix-editor/helix/pull/6384))
+- Update `kanagawa` ([#5273](https://github.com/helix-editor/helix/pull/5273), [#5571](https://github.com/helix-editor/helix/pull/5571), [#6085](https://github.com/helix-editor/helix/pull/6085))
+- Update `emacs` ([#5334](https://github.com/helix-editor/helix/pull/5334))
+- Add `github` themes ([#5353](https://github.com/helix-editor/helix/pull/5353), [efeec12](https://github.com/helix-editor/helix/commit/efeec12))
+    - Dark themes: `github_dark`, `github_dark_colorblind`, `github_dark_dimmed`, `github_dark_high_contrast`, `github_dark_tritanopia`
+    - Light themes: `github_light`, `github_light_colorblind`, `github_light_dimmed`, `github_light_high_contrast`, `github_light_tritanopia`
+- Update `solarized` variants ([#5445](https://github.com/helix-editor/helix/pull/5445), [#6327](https://github.com/helix-editor/helix/pull/6327))
+- Update `catppuccin` variants ([#5404](https://github.com/helix-editor/helix/pull/5404), [#6107](https://github.com/helix-editor/helix/pull/6107), [#6269](https://github.com/helix-editor/helix/pull/6269), [#6464](https://github.com/helix-editor/helix/pull/6464))
+- Use curly underlines in built-in themes ([#5419](https://github.com/helix-editor/helix/pull/5419))
+- Update `zenburn` ([#5573](https://github.com/helix-editor/helix/pull/5573))
+- Rewrite `snazzy` ([#3971](https://github.com/helix-editor/helix/pull/3971))
+- Add `monokai_aqua` ([#5578](https://github.com/helix-editor/helix/pull/5578))
+- Add `markup.strikethrough` to existing themes ([#5619](https://github.com/helix-editor/helix/pull/5619))
+- Update `sonokai` ([#5440](https://github.com/helix-editor/helix/pull/5440))
+- Update `onedark` ([#5755](https://github.com/helix-editor/helix/pull/5755))
+- Add `ayu_evolve` ([#5638](https://github.com/helix-editor/helix/pull/5638), [#6028](https://github.com/helix-editor/helix/pull/6028), [#6225](https://github.com/helix-editor/helix/pull/6225))
+- Add `jellybeans` ([#5719](https://github.com/helix-editor/helix/pull/5719))
+- Update `fleet_dark` ([#5605](https://github.com/helix-editor/helix/pull/5605), [#6266](https://github.com/helix-editor/helix/pull/6266), [#6324](https://github.com/helix-editor/helix/pull/6324), [#6375](https://github.com/helix-editor/helix/pull/6375))
+- Add `darcula-solid` ([#5778](https://github.com/helix-editor/helix/pull/5778))
+- Remove text background from monokai themes ([#6009](https://github.com/helix-editor/helix/pull/6009))
+- Update `pop_dark` ([#5992](https://github.com/helix-editor/helix/pull/5992), [#6208](https://github.com/helix-editor/helix/pull/6208), [#6227](https://github.com/helix-editor/helix/pull/6227), [#6292](https://github.com/helix-editor/helix/pull/6292))
+- Add `everblush` ([#6086](https://github.com/helix-editor/helix/pull/6086))
+- Add `adwaita-dark` ([#6042](https://github.com/helix-editor/helix/pull/6042), [#6342](https://github.com/helix-editor/helix/pull/6342))
+- Update `papercolor` ([#6162](https://github.com/helix-editor/helix/pull/6162))
+- Update `onelight` ([#6192](https://github.com/helix-editor/helix/pull/6192), [#6276](https://github.com/helix-editor/helix/pull/6276))
+- Add `molokai` ([#6260](https://github.com/helix-editor/helix/pull/6260))
+- Update `ayu` variants ([#6329](https://github.com/helix-editor/helix/pull/6329))
+- Update `tokyonight` variants ([#6349](https://github.com/helix-editor/helix/pull/6349))
+- Update `nord` variants ([#6376](https://github.com/helix-editor/helix/pull/6376))
+
+New languages:
+
+- BibTeX ([#5064](https://github.com/helix-editor/helix/pull/5064))
+- Mermaid.js ([#5147](https://github.com/helix-editor/helix/pull/5147))
+- Crystal ([#4993](https://github.com/helix-editor/helix/pull/4993), [#5205](https://github.com/helix-editor/helix/pull/5205))
+- MATLAB/Octave ([#5192](https://github.com/helix-editor/helix/pull/5192))
+- `tfvars` (uses HCL) ([#5396](https://github.com/helix-editor/helix/pull/5396))
+- Ponylang ([#5416](https://github.com/helix-editor/helix/pull/5416))
+- DHall ([1f6809c](https://github.com/helix-editor/helix/commit/1f6809c))
+- Sagemath ([#5649](https://github.com/helix-editor/helix/pull/5649))
+- MSBuild ([#5793](https://github.com/helix-editor/helix/pull/5793))
+- pem ([#5797](https://github.com/helix-editor/helix/pull/5797))
+- passwd ([#4959](https://github.com/helix-editor/helix/pull/4959))
+- hosts ([#4950](https://github.com/helix-editor/helix/pull/4950), [#5914](https://github.com/helix-editor/helix/pull/5914))
+- uxntal ([#6047](https://github.com/helix-editor/helix/pull/6047))
+- Yuck ([#6064](https://github.com/helix-editor/helix/pull/6064), [#6242](https://github.com/helix-editor/helix/pull/6242))
+- GNU gettext PO ([#5996](https://github.com/helix-editor/helix/pull/5996))
+- Sway ([#6023](https://github.com/helix-editor/helix/pull/6023))
+- NASM ([#6068](https://github.com/helix-editor/helix/pull/6068))
+- PRQL ([#6126](https://github.com/helix-editor/helix/pull/6126))
+- reStructuredText ([#6180](https://github.com/helix-editor/helix/pull/6180))
+- Smithy ([#6370](https://github.com/helix-editor/helix/pull/6370))
+- VHDL ([#5826](https://github.com/helix-editor/helix/pull/5826))
+- Rego (OpenPolicy Agent) ([#6415](https://github.com/helix-editor/helix/pull/6415))
+- Nim ([#6123](https://github.com/helix-editor/helix/pull/6123))
+
+Updated languages and queries:
+
+- Use diff syntax for patch files ([#5085](https://github.com/helix-editor/helix/pull/5085))
+- Add Haskell textobjects ([#5061](https://github.com/helix-editor/helix/pull/5061))
+- Fix commonlisp configuration ([#5091](https://github.com/helix-editor/helix/pull/5091))
+- Update Scheme ([bae890d](https://github.com/helix-editor/helix/commit/bae890d))
+- Add indent queries for Bash ([#5149](https://github.com/helix-editor/helix/pull/5149))
+- Recognize `c++` as a C++ extension ([#5183](https://github.com/helix-editor/helix/pull/5183))
+- Enable HTTP server in `metals` (Scala) config ([#5551](https://github.com/helix-editor/helix/pull/5551))
+- Change V-lang language server to `v ls` from `vls` ([#5677](https://github.com/helix-editor/helix/pull/5677))
+- Inject comment grammar into Nix ([#5208](https://github.com/helix-editor/helix/pull/5208))
+- Update Rust highlights ([#5238](https://github.com/helix-editor/helix/pull/5238), [#5349](https://github.com/helix-editor/helix/pull/5349))
+- Fix HTML injection within Markdown ([#5265](https://github.com/helix-editor/helix/pull/5265))
+- Fix comment token for godot ([#5276](https://github.com/helix-editor/helix/pull/5276))
+- Expand injections for Vue ([#5268](https://github.com/helix-editor/helix/pull/5268))
+- Add `.bash_aliases` as a Bash file-type ([#5347](https://github.com/helix-editor/helix/pull/5347))
+- Fix comment token for sshclientconfig ([#5351](https://github.com/helix-editor/helix/pull/5351))
+- Update Prisma ([#5417](https://github.com/helix-editor/helix/pull/5417))
+- Update C++ ([#5457](https://github.com/helix-editor/helix/pull/5457))
+- Add more file-types for Python ([#5593](https://github.com/helix-editor/helix/pull/5593))
+- Update tree-sitter-scala ([#5576](https://github.com/helix-editor/helix/pull/5576))
+- Add an injection regex for Lua ([#5606](https://github.com/helix-editor/helix/pull/5606))
+- Add `build.gradle` to java roots configuration ([#5641](https://github.com/helix-editor/helix/pull/5641))
+- Add Hub PR files to markdown file-types ([#5634](https://github.com/helix-editor/helix/pull/5634))
+- Add an external formatter configuration for Cue ([#5679](https://github.com/helix-editor/helix/pull/5679))
+- Add injections for builders and writers to Nix ([#5629](https://github.com/helix-editor/helix/pull/5629))
+- Update tree-sitter-xml to fix whitespace parsing ([#5685](https://github.com/helix-editor/helix/pull/5685))
+- Add `Justfile` to the make file-types configuration ([#5687](https://github.com/helix-editor/helix/pull/5687))
+- Update tree-sitter-sql and highlight queries ([#5683](https://github.com/helix-editor/helix/pull/5683), [#5772](https://github.com/helix-editor/helix/pull/5772))
+- Use the bash grammar and queries for env language ([#5720](https://github.com/helix-editor/helix/pull/5720))
+- Add podspec files to ruby file-types ([#5811](https://github.com/helix-editor/helix/pull/5811))
+- Recognize `.C` and `.H` file-types as C++ ([#5808](https://github.com/helix-editor/helix/pull/5808))
+- Recognize plist and mobileconfig files as XML ([#5863](https://github.com/helix-editor/helix/pull/5863))
+- Fix `select` indentation in Go ([#5713](https://github.com/helix-editor/helix/pull/5713))
+- Check for external file modifications when writing ([#5805](https://github.com/helix-editor/helix/pull/5805))
+- Recognize containerfiles as dockerfile syntax ([#5873](https://github.com/helix-editor/helix/pull/5873))
+- Update godot grammar and queries ([#5944](https://github.com/helix-editor/helix/pull/5944), [#6186](https://github.com/helix-editor/helix/pull/6186))
+- Improve DHall highlights ([#5959](https://github.com/helix-editor/helix/pull/5959))
+- Recognize `.env.dist` and `source.env` as env language ([#6003](https://github.com/helix-editor/helix/pull/6003))
+- Update tree-sitter-git-rebase ([#6030](https://github.com/helix-editor/helix/pull/6030), [#6094](https://github.com/helix-editor/helix/pull/6094))
+- Improve SQL highlights ([#6041](https://github.com/helix-editor/helix/pull/6041))
+- Improve markdown highlights and inject LaTeX ([#6100](https://github.com/helix-editor/helix/pull/6100))
+- Add textobject queries for Elm ([#6084](https://github.com/helix-editor/helix/pull/6084))
+- Recognize graphql schema file type ([#6159](https://github.com/helix-editor/helix/pull/6159))
+- Improve highlighting in comments ([#6143](https://github.com/helix-editor/helix/pull/6143))
+- Improve highlighting for JavaScript/TypeScript/ECMAScript languages ([#6205](https://github.com/helix-editor/helix/pull/6205))
+- Improve PHP highlights ([#6203](https://github.com/helix-editor/helix/pull/6203), [#6250](https://github.com/helix-editor/helix/pull/6250), [#6299](https://github.com/helix-editor/helix/pull/6299))
+- Improve Go highlights ([#6204](https://github.com/helix-editor/helix/pull/6204))
+- Highlight unchecked sqlx functions as SQL in Rust ([#6256](https://github.com/helix-editor/helix/pull/6256))
+- Improve Erlang highlights ([cdd6c8d](https://github.com/helix-editor/helix/commit/cdd6c8d))
+- Improve Nix highlights ([fb4d703](https://github.com/helix-editor/helix/commit/fb4d703))
+- Improve gdscript highlights ([#6311](https://github.com/helix-editor/helix/pull/6311))
+- Improve Vlang highlights ([#6279](https://github.com/helix-editor/helix/pull/6279))
+- Improve Makefile highlights ([#6339](https://github.com/helix-editor/helix/pull/6339))
+- Remove auto-pair for `'` in OCaml ([#6381](https://github.com/helix-editor/helix/pull/6381))
+- Fix indents in switch statements in ECMA languages ([#6369](https://github.com/helix-editor/helix/pull/6369))
+- Recognize xlb and storyboard file-types as XML ([#6407](https://github.com/helix-editor/helix/pull/6407))
+- Recognize cts and mts file-types as TypeScript ([#6424](https://github.com/helix-editor/helix/pull/6424))
+- Recognize SVG file-type as XML ([#6431](https://github.com/helix-editor/helix/pull/6431))
+- Add theme scopes for (un)checked list item markup scopes ([#6434](https://github.com/helix-editor/helix/pull/6434))
+- Update git commit grammar and add the comment textobject ([#6439](https://github.com/helix-editor/helix/pull/6439), [#6493](https://github.com/helix-editor/helix/pull/6493))
+- Recognize ARB file-type as JSON ([#6452](https://github.com/helix-editor/helix/pull/6452))
+- Inject markdown into markdown strings in Julia ([#6489](https://github.com/helix-editor/helix/pull/6489))
+
+Packaging:
+
+- Fix Nix flake devShell for darwin hosts ([#5368](https://github.com/helix-editor/helix/pull/5368))
+- Add Appstream metadata file to `contrib/` ([#5643](https://github.com/helix-editor/helix/pull/5643))
+- Increase the MSRV to 1.65 ([#5570](https://github.com/helix-editor/helix/pull/5570), [#6185](https://github.com/helix-editor/helix/pull/6185))
+- Expose the Nix flake's `wrapper` ([#5994](https://github.com/helix-editor/helix/pull/5994))
+
 # 22.12 (2022-12-06)
 
 This is a great big release filled with changes from a 99 contributors. A big _thank you_ to you all!
diff --git a/Cargo.lock b/Cargo.lock
index b204214fc..26448c425 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -21,9 +21,9 @@ dependencies = [
 
 [[package]]
 name = "ahash"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bf6ccdb167abbf410dcb915cabd428929d7f6a04980b54a11f26a39f1c7f7107"
+checksum = "2c99f64d1e06488f620f932677e24bc6e2897582980441ae90a671415bd7ec2f"
 dependencies = [
  "cfg-if",
  "getrandom",
@@ -51,24 +51,15 @@ dependencies = [
 
 [[package]]
 name = "anyhow"
-version = "1.0.66"
+version = "1.0.70"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "216261ddc8289130e551ddcd5ce8a064710c0d064a4d2895c67151c92b5443f6"
+checksum = "7de8ce5e0f9f8d88245311066a578d72b7af3e7088f32783804676302df237e4"
 
 [[package]]
 name = "arc-swap"
-version = "1.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "983cd8b9d4b02a6dc6ffa557262eb5858a27a0038ffffe21a0f133eaa819a164"
-
-[[package]]
-name = "atoi"
-version = "1.0.0"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d7c57d12312ff59c811c0643f4d80830505833c9ffaebd193d819392b265be8e"
-dependencies = [
- "num-traits",
-]
+checksum = "bddcadddf5e9015d310179a59bb28c4d4b9920ad0f11e8e14dbadf654890c9a6"
 
 [[package]]
 name = "autocfg"
@@ -83,21 +74,16 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
 [[package]]
-name = "bstr"
-version = "0.2.17"
+name = "bitflags"
+version = "2.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ba3569f383e8f1598449f1a423e72e99569137b47740b1da11ef19af3d5c3223"
-dependencies = [
- "lazy_static",
- "memchr",
- "regex-automata",
-]
+checksum = "487f1e0fcbe47deb8b0574e646def1c903389d95241dd1bbcc6ce4a715dfc0c1"
 
 [[package]]
 name = "bstr"
-version = "1.0.1"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fca0852af221f458706eb0725c03e4ed6c46af9ac98e6a689d5e634215d594dd"
+checksum = "c3d4260bcc2e8fc9df1eac4919a720effeb63a3f0952f5bf4944adfa18897f09"
 dependencies = [
  "memchr",
  "once_cell",
@@ -107,28 +93,18 @@ dependencies = [
 
 [[package]]
 name = "btoi"
-version = "0.4.2"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97c0869a9faa81f8bbf8102371105d6d0a7b79167a04c340b04ab16892246a11"
+checksum = "9dd6407f73a9b8b6162d8a2ef999fe6afd7cc15902ebf42c5cd296addf17e0ad"
 dependencies = [
  "num-traits",
 ]
 
 [[package]]
 name = "bumpalo"
-version = "3.11.1"
+version = "3.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba"
-
-[[package]]
-name = "byte-unit"
-version = "4.0.17"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "581ad4b3d627b0c09a0ccb2912148f839acaca0b93cf54cbe42b6c674e86079c"
-dependencies = [
- "serde",
- "utf8-width",
-]
+checksum = "0d261e256854913907f67ed06efbc3338dfe6179796deefc1ff763fc1aee5535"
 
 [[package]]
 name = "bytecount"
@@ -138,15 +114,9 @@ checksum = "2c676a478f63e9fa2dd5368a42f28bba0d6c560b775f38583c8bbaa7fcd67c9c"
 
 [[package]]
 name = "bytes"
-version = "1.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dfb24e866b15a1af2a1b663f10c6b6b8f397a84aadb828f12e5b289ec23a3a3c"
-
-[[package]]
-name = "bytesize"
-version = "1.1.0"
+version = "1.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6c58ec36aac5066d5ca17df51b3e70279f5670a72102f5752cb7e7c856adfc70"
+checksum = "89b2fd2a0dcf38d7971e2194b6b6eebab45ae01067456a7fd93d5547a61b70be"
 
 [[package]]
 name = "cassowary"
@@ -154,20 +124,11 @@ version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "df8670b8c7b9dae1793364eafadf7239c40d669904660c5960d74cfd80b46a53"
 
-[[package]]
-name = "castaway"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a17ed5635fc8536268e5d4de1e22e81ac34419e5f052d4d51f4e01dcc263fcc"
-dependencies = [
- "rustversion",
-]
-
 [[package]]
 name = "cc"
-version = "1.0.77"
+version = "1.0.79"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4"
+checksum = "50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f"
 
 [[package]]
 name = "cfg-if"
@@ -188,9 +149,9 @@ dependencies = [
 
 [[package]]
 name = "chrono"
-version = "0.4.23"
+version = "0.4.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "16b0a3d9ed01224b22057780a37bb8c5dbfe1be8ba48678e7bf57ec4b385411f"
+checksum = "4e3c5919066adf22df73762e50cffcde3a758f2a848b113b586d1f86728b673b"
 dependencies = [
  "iana-time-zone",
  "num-integer",
@@ -200,9 +161,9 @@ dependencies = [
 
 [[package]]
 name = "clipboard-win"
-version = "4.4.2"
+version = "4.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4ab1b92798304eedc095b53942963240037c0516452cb11aeba709d420b2219"
+checksum = "7191c27c2357d9b7ef96baac1773290d4ca63b24205b82a3fd8a0637afcf0362"
 dependencies = [
  "error-code",
  "str-buf",
@@ -211,9 +172,9 @@ dependencies = [
 
 [[package]]
 name = "clru"
-version = "0.5.0"
+version = "0.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "218d6bd3dde8e442a975fa1cd233c0e5fded7596bccfe39f58eca98d22421e0a"
+checksum = "b8191fa7302e03607ff0e237d4246cc043ff5b3cb9409d995172ba3bea16b807"
 
 [[package]]
 name = "codespan-reporting"
@@ -225,17 +186,6 @@ dependencies = [
  "unicode-width",
 ]
 
-[[package]]
-name = "compact_str"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5138945395949e7dfba09646dc9e766b548ff48e23deb5246890e6b64ae9e1b9"
-dependencies = [
- "castaway",
- "itoa",
- "ryu",
-]
-
 [[package]]
 name = "content_inspector"
 version = "0.2.4"
@@ -260,22 +210,13 @@ dependencies = [
  "cfg-if",
 ]
 
-[[package]]
-name = "crossbeam-utils"
-version = "0.8.14"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f"
-dependencies = [
- "cfg-if",
-]
-
 [[package]]
 name = "crossterm"
-version = "0.25.0"
+version = "0.26.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e64e6c0fbe2c17357405f7c758c1ef960fce08bdfb2c03d88d2a18d7e09c4b67"
+checksum = "a84cda67535339806297f1b331d6dd6320470d2a0fe65381e79ee9e156dd3d13"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "crossterm_winapi",
  "futures-core",
  "libc",
@@ -297,9 +238,9 @@ dependencies = [
 
 [[package]]
 name = "cxx"
-version = "1.0.82"
+version = "1.0.94"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d4a41a86530d0fe7f5d9ea779916b7cadd2d4f9add748b99c2c029cbbdfaf453"
+checksum = "f61f1b6389c3fe1c316bf8a4dccc90a38208354b330925bce1f74a6c4756eb93"
 dependencies = [
  "cc",
  "cxxbridge-flags",
@@ -309,9 +250,9 @@ dependencies = [
 
 [[package]]
 name = "cxx-build"
-version = "1.0.82"
+version = "1.0.94"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "06416d667ff3e3ad2df1cd8cd8afae5da26cf9cec4d0825040f88b5ca659a2f0"
+checksum = "12cee708e8962df2aeb38f594aae5d827c022b6460ac71a7a3e2c3c2aae5a07b"
 dependencies = [
  "cc",
  "codespan-reporting",
@@ -319,37 +260,24 @@ dependencies = [
  "proc-macro2",
  "quote",
  "scratch",
- "syn",
+ "syn 2.0.11",
 ]
 
 [[package]]
 name = "cxxbridge-flags"
-version = "1.0.82"
+version = "1.0.94"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "820a9a2af1669deeef27cb271f476ffd196a2c4b6731336011e0ba63e2c7cf71"
+checksum = "7944172ae7e4068c533afbb984114a56c46e9ccddda550499caa222902c7f7bb"
 
 [[package]]
 name = "cxxbridge-macro"
-version = "1.0.82"
+version = "1.0.94"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a08a6e2fcc370a089ad3b4aaf54db3b1b4cee38ddabce5896b33eb693275f470"
+checksum = "2345488264226bf682893e25de0769f3360aac9957980ec49361b083ddaa5bc5"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
-]
-
-[[package]]
-name = "dashmap"
-version = "5.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "907076dfda823b0b36d2a1bb5f90c96660a5bbcd7729e10727f07858f22c4edc"
-dependencies = [
- "cfg-if",
- "hashbrown 0.12.3",
- "lock_api",
- "once_cell",
- "parking_lot_core",
+ "syn 2.0.11",
 ]
 
 [[package]]
@@ -393,17 +321,23 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "dunce"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0bd4b30a6560bbd9b4620f4de34c3f14f60848e58a9b7216801afcb4c7b31c3c"
+
 [[package]]
 name = "either"
-version = "1.8.0"
+version = "1.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "90e5c1c8368803113bf0c9584fc495a58b86dc8a29edbf8fe877d21d9507e797"
+checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
 
 [[package]]
 name = "encoding_rs"
-version = "0.8.31"
+version = "0.8.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9852635589dc9f9ea1b6fe9f05b50ef208c85c834a562f0c6abb1c475736ec2b"
+checksum = "071a31f4ee85403370b58aca746f01041ede6f0da2730960ad001edc2b71b394"
 dependencies = [
  "cfg-if",
 ]
@@ -417,6 +351,27 @@ dependencies = [
  "encoding_rs",
 ]
 
+[[package]]
+name = "errno"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "50d6a0976c999d473fe89ad888d5a284e55366d9dc9038b1ba2aa15128c4afa0"
+dependencies = [
+ "errno-dragonfly",
+ "libc",
+ "windows-sys",
+]
+
+[[package]]
+name = "errno-dragonfly"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
+dependencies = [
+ "cc",
+ "libc",
+]
+
 [[package]]
 name = "error-code"
 version = "2.3.1"
@@ -440,31 +395,31 @@ dependencies = [
 
 [[package]]
 name = "fastrand"
-version = "1.8.0"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a7a407cfaa3385c4ae6b23e84623d48c2798d06e3e6a1878f7f59f17b3f86499"
+checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
 dependencies = [
  "instant",
 ]
 
 [[package]]
 name = "fern"
-version = "0.6.1"
+version = "0.6.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3bdd7b0849075e79ee9a1836df22c717d1eba30451796fdc631b04565dd11e2a"
+checksum = "d9f0c14694cbd524c8720dd69b0e3179344f04ebb5f90f2e4a440c6ea3b2f1ee"
 dependencies = [
  "log",
 ]
 
 [[package]]
 name = "filetime"
-version = "0.2.18"
+version = "0.2.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b9663d381d07ae25dc88dbdf27df458faa83a9b25336bcac83d5e452b5fc9d3"
+checksum = "8a3de6e8d11b22ff9edc6d916f890800597d60f8b2da1caf2955c274638d6412"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "windows-sys",
 ]
 
@@ -495,15 +450,15 @@ dependencies = [
 
 [[package]]
 name = "futures-core"
-version = "0.3.25"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "04909a7a7e4633ae6c4a9ab280aeb86da1236243a77b694a49eacd659a4bd3ac"
+checksum = "4bca583b7e26f571124fe5b7561d49cb2868d79116cfa0eefce955557c6fee8c"
 
 [[package]]
 name = "futures-executor"
-version = "0.3.25"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7acc85df6714c176ab5edf386123fafe217be88c0840ec11f199441134a074e2"
+checksum = "ccecee823288125bd88b4d7f565c9e58e41858e47ab72e8ea2d64e93624386e0"
 dependencies = [
  "futures-core",
  "futures-task",
@@ -512,15 +467,15 @@ dependencies = [
 
 [[package]]
 name = "futures-task"
-version = "0.3.25"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2ffb393ac5d9a6eaa9d3fdf37ae2776656b706e200c8e16b1bdb227f5198e6ea"
+checksum = "76d3d132be6c0e6aa1534069c705a74a5997a356c0dc2f86a47765e5617c5b65"
 
 [[package]]
 name = "futures-util"
-version = "0.3.25"
+version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "197676987abd2f9cadff84926f410af1c183608d36641465df73ae8211dc65d6"
+checksum = "26b01e40b772d54cf6c6d721c1d1abd0647a0106a12ecaa1c186273392a69533"
 dependencies = [
  "futures-core",
  "futures-task",
@@ -550,75 +505,117 @@ dependencies = [
 ]
 
 [[package]]
-name = "git-actor"
-version = "0.14.1"
+name = "gix"
+version = "0.43.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c256ea71cc1967faaefdaad15f334146b7c806f12460dcafd3afed845c8c78dd"
+dependencies = [
+ "gix-actor",
+ "gix-attributes",
+ "gix-config",
+ "gix-credentials",
+ "gix-date",
+ "gix-diff",
+ "gix-discover",
+ "gix-features",
+ "gix-glob",
+ "gix-hash",
+ "gix-hashtable",
+ "gix-index",
+ "gix-lock",
+ "gix-mailmap",
+ "gix-object",
+ "gix-odb",
+ "gix-pack",
+ "gix-path",
+ "gix-prompt",
+ "gix-ref",
+ "gix-refspec",
+ "gix-revision",
+ "gix-sec",
+ "gix-tempfile",
+ "gix-traverse",
+ "gix-url",
+ "gix-validate",
+ "gix-worktree",
+ "log",
+ "once_cell",
+ "signal-hook",
+ "smallvec",
+ "thiserror",
+ "unicode-normalization",
+]
+
+[[package]]
+name = "gix-actor"
+version = "0.19.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac9fb99c934ed45a62d9ae1e7b21949f2d869d1b82a07dcbf16ed61daa665870"
+checksum = "dc22b0cdc52237667c301dd7cdc6ead8f8f73c9f824e9942c8ebd6b764f6c0bf"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "btoi",
- "git-date",
+ "gix-date",
  "itoa",
  "nom",
- "quick-error",
+ "thiserror",
 ]
 
 [[package]]
-name = "git-attributes"
-version = "0.6.0"
+name = "gix-attributes"
+version = "0.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "82e98446a2bf0eb5c8f29fa828d6529510a6fadeb59ce14ca98e58fa7e1e0199"
+checksum = "2231a25934a240d0a4b6f4478401c73ee81d8be52de0293eedbc172334abf3e1"
 dependencies = [
- "bstr 1.0.1",
- "compact_str",
- "git-features",
- "git-glob",
- "git-path",
- "git-quote",
+ "bstr",
+ "gix-features",
+ "gix-glob",
+ "gix-path",
+ "gix-quote",
  "thiserror",
  "unicode-bom",
 ]
 
 [[package]]
-name = "git-bitmap"
-version = "0.2.0"
+name = "gix-bitmap"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44304093ac66a0ada1b243c15c3a503a165a1d0f50bec748f4e5a9b84a0d0722"
+checksum = "024bca0c7187517bda5ea24ab148c9ca8208dd0c3e2bea88cdb2008f91791a6d"
 dependencies = [
- "quick-error",
+ "thiserror",
 ]
 
 [[package]]
-name = "git-chunk"
-version = "0.4.0"
+name = "gix-chunk"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3090baa2f4a3fe488a9b3e31090b83259aaf930bf0634af34c18117274f8f1a8"
+checksum = "b0d39583cab06464b8bf73b3f1707458270f0e7383cb24c3c9c1a16e6f792978"
 dependencies = [
  "thiserror",
 ]
 
 [[package]]
-name = "git-command"
-version = "0.2.0"
+name = "gix-command"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a6b98a6312fef79b326c0a6e15d576c2bd30f7f9d0b7964998d166049e0d7b9e"
+checksum = "b2c6f75c1e0f924de39e750880a6e21307194bb1ab773efe3c7d2d787277f8ab"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
 ]
 
 [[package]]
-name = "git-config"
-version = "0.12.0"
+name = "gix-config"
+version = "0.20.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bd1d13179bcf3dd68e83404f91a8d01c618f54eb97ef36c68ee5e6f30183a681"
+checksum = "7fbad5ce54a8fc997acc50febd89ec80fa6e97cb7f8d0654cb229936407489d8"
 dependencies = [
- "bstr 1.0.1",
- "git-config-value",
- "git-features",
- "git-glob",
- "git-path",
- "git-ref",
- "git-sec",
+ "bstr",
+ "gix-config-value",
+ "gix-features",
+ "gix-glob",
+ "gix-path",
+ "gix-ref",
+ "gix-sec",
+ "log",
  "memchr",
  "nom",
  "once_cell",
@@ -628,125 +625,137 @@ dependencies = [
 ]
 
 [[package]]
-name = "git-config-value"
-version = "0.9.0"
+name = "gix-config-value"
+version = "0.10.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64561e9700f1fc737fa3c1c4ea55293be70dba98e45c54cf3715cb180f37a566"
+checksum = "d09154c0c8677e4da0ec35e896f56ee3e338e741b9599fae06075edd83a4081c"
 dependencies = [
- "bitflags",
- "bstr 1.0.1",
- "git-path",
+ "bitflags 1.3.2",
+ "bstr",
+ "gix-path",
  "libc",
  "thiserror",
 ]
 
 [[package]]
-name = "git-credentials"
-version = "0.7.0"
+name = "gix-credentials"
+version = "0.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "621dd60288ae7b8f80bb0704f46d4d2b76fc1ec980a7804e48b02d94a927e331"
+checksum = "750b684197374518ea057e0a0594713e07683faa0a3f43c0f93d97f64130ad8d"
 dependencies = [
- "bstr 1.0.1",
- "git-command",
- "git-config-value",
- "git-path",
- "git-prompt",
- "git-sec",
- "git-url",
+ "bstr",
+ "gix-command",
+ "gix-config-value",
+ "gix-path",
+ "gix-prompt",
+ "gix-sec",
+ "gix-url",
  "thiserror",
 ]
 
 [[package]]
-name = "git-date"
-version = "0.3.0"
+name = "gix-date"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e33db9f4462b565a33507aee113f3383bf16b988d2c573f07691e34302b7aa0a"
+checksum = "b96271912ce39822501616f177dea7218784e6c63be90d5f36322ff3a722aae2"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "itoa",
  "thiserror",
  "time",
 ]
 
 [[package]]
-name = "git-diff"
-version = "0.23.0"
+name = "gix-diff"
+version = "0.28.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "82f77407381267be95f1b26acfb32007258af342ee61729bb4271b1869bf5bb2"
+checksum = "103a0fa79b0d438f5ecb662502f052e530ace4fe1fe8e1c83c0c6da76d728e67"
 dependencies = [
- "git-hash",
- "git-object",
+ "gix-hash",
+ "gix-object",
  "imara-diff",
  "thiserror",
 ]
 
 [[package]]
-name = "git-discover"
-version = "0.9.0"
+name = "gix-discover"
+version = "0.16.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2c2cfd1272824b126c6997ef479a71288d00fae14dc5144dfc48658f4dd24fbe"
+checksum = "6eba8ba458cb8f4a6c33409b0fe650b1258655175a7ffd1d24fafd3ed31d880b"
 dependencies = [
- "bstr 1.0.1",
- "git-hash",
- "git-path",
- "git-ref",
- "git-sec",
+ "bstr",
+ "dunce",
+ "gix-hash",
+ "gix-path",
+ "gix-ref",
+ "gix-sec",
  "thiserror",
 ]
 
 [[package]]
-name = "git-features"
-version = "0.24.1"
+name = "gix-features"
+version = "0.28.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d7bdbe755d2129bc609437b6b18af1116f146128dda6070c15c0aa50201ac17c"
+checksum = "0b76f9a80f6dd7be66442ae86e1f534effad9546676a392acc95e269d0c21c22"
 dependencies = [
  "crc32fast",
  "flate2",
- "git-hash",
+ "gix-hash",
  "libc",
  "once_cell",
  "prodash",
- "quick-error",
  "sha1_smol",
+ "thiserror",
  "walkdir",
 ]
 
 [[package]]
-name = "git-glob"
-version = "0.5.0"
+name = "gix-glob"
+version = "0.5.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ef858611602fce54b51e45671ca72f07fe6a3c0e24a0539c66b75dfd4d84bd77"
+checksum = "93e43efd776bc543f46f0fd0ca3d920c37af71a764a16f2aebd89765e9ff2993"
 dependencies = [
- "bitflags",
- "bstr 1.0.1",
+ "bitflags 1.3.2",
+ "bstr",
 ]
 
 [[package]]
-name = "git-hash"
-version = "0.10.1"
+name = "gix-hash"
+version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1532d82bf830532f8d545c5b7b568e311e3593f16cf7ee9dd0ce03c74b12b99d"
+checksum = "0c0c5a9f4d621d4f4ea046bb331df5c746ca735b8cae5b234cc2be70ee4dbef0"
 dependencies = [
  "hex",
  "thiserror",
 ]
 
 [[package]]
-name = "git-index"
-version = "0.9.1"
+name = "gix-hashtable"
+version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a87c32d2e012ee316d4037b2151e5893599379ff1fc2c6adb36d2d4d1c461e2c"
+checksum = "9609c1b8f36f12968e6a6098f7cdb52004f7d42d570f47a2d6d7c16612f19acb"
 dependencies = [
- "atoi",
- "bitflags",
- "bstr 1.0.1",
+ "gix-hash",
+ "hashbrown 0.13.2",
+ "parking_lot",
+]
+
+[[package]]
+name = "gix-index"
+version = "0.15.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "717ab601ece7921f59fe86849dbe27d44a46ebb883b5885732c4f30df4996177"
+dependencies = [
+ "bitflags 1.3.2",
+ "bstr",
+ "btoi",
  "filetime",
- "git-bitmap",
- "git-features",
- "git-hash",
- "git-lock",
- "git-object",
- "git-traverse",
+ "gix-bitmap",
+ "gix-features",
+ "gix-hash",
+ "gix-lock",
+ "gix-object",
+ "gix-traverse",
  "itoa",
  "memmap2",
  "smallvec",
@@ -754,39 +763,39 @@ dependencies = [
 ]
 
 [[package]]
-name = "git-lock"
-version = "3.0.0"
+name = "gix-lock"
+version = "5.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89e4f05b8a68c3a5dd83a6651c76be384e910fe283072184fdab9d77f87ccec2"
+checksum = "41b80172055c5d8017a48ddac5cc7a95421c00211047db0165c97853c4f05194"
 dependencies = [
  "fastrand",
- "git-tempfile",
- "quick-error",
+ "gix-tempfile",
+ "thiserror",
 ]
 
 [[package]]
-name = "git-mailmap"
-version = "0.6.0"
+name = "gix-mailmap"
+version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "480eecdfaf1bfd05973678520d182dc07afa25b133db18c52575fb65b782b7ba"
+checksum = "2b66aea5e52875cd4915f4957a6f4b75831a36981e2ec3f5fad9e370e444fe1a"
 dependencies = [
- "bstr 1.0.1",
- "git-actor",
- "quick-error",
+ "bstr",
+ "gix-actor",
+ "thiserror",
 ]
 
 [[package]]
-name = "git-object"
-version = "0.23.0"
+name = "gix-object"
+version = "0.28.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ce0f14f9cd8f0782e843898a2fb7b0c2f5a6e37bd4cdff4409bb8ec698597dad"
+checksum = "8df068db9180ee935fbb70504848369e270bdcb576b05c0faa8b9fd3b86fc017"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "btoi",
- "git-actor",
- "git-features",
- "git-hash",
- "git-validate",
+ "gix-actor",
+ "gix-features",
+ "gix-hash",
+ "gix-validate",
  "hex",
  "itoa",
  "nom",
@@ -795,41 +804,39 @@ dependencies = [
 ]
 
 [[package]]
-name = "git-odb"
-version = "0.37.0"
+name = "gix-odb"
+version = "0.43.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "13493da6cf0326454215414d29f933a1e26bdba3b9b60ad8cdcbe06f0639584b"
+checksum = "e83af2e3e36005bfe010927f0dff41fb5acc3e3d89c6f1174135b3a34086bda2"
 dependencies = [
  "arc-swap",
- "git-features",
- "git-hash",
- "git-object",
- "git-pack",
- "git-path",
- "git-quote",
+ "gix-features",
+ "gix-hash",
+ "gix-object",
+ "gix-pack",
+ "gix-path",
+ "gix-quote",
  "parking_lot",
  "tempfile",
  "thiserror",
 ]
 
 [[package]]
-name = "git-pack"
-version = "0.27.0"
+name = "gix-pack"
+version = "0.33.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa8391cbf293f0f8ffbb5e324f25741f5e1e2d35fb87b89ab222a025661e0454"
+checksum = "9401911c7fe032ad7b31c6a6b5be59cb283d1d6c999417a8215056efe6d635f3"
 dependencies = [
- "bytesize",
  "clru",
- "dashmap",
- "git-chunk",
- "git-diff",
- "git-features",
- "git-hash",
- "git-object",
- "git-path",
- "git-tempfile",
- "git-traverse",
- "hash_hasher",
+ "gix-chunk",
+ "gix-diff",
+ "gix-features",
+ "gix-hash",
+ "gix-hashtable",
+ "gix-object",
+ "gix-path",
+ "gix-tempfile",
+ "gix-traverse",
  "memmap2",
  "parking_lot",
  "smallvec",
@@ -837,218 +844,175 @@ dependencies = [
 ]
 
 [[package]]
-name = "git-path"
-version = "0.6.0"
+name = "gix-path"
+version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f60cbc13bc0fdd95df5f4b80437197e2853116792894b1bf38d1a6b4a64f8c9"
+checksum = "32370dce200bb951df013e03dff35b4233fc7a89458642b047629b91734a7e19"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "thiserror",
 ]
 
 [[package]]
-name = "git-prompt"
-version = "0.2.0"
+name = "gix-prompt"
+version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "21c6aaeb3f0f8de91f5e0eb950282c6508e05babcedef768db5a6f085d6e5242"
+checksum = "0f3034d4d935aef2c7bf719aaa54b88c520e82413118d886ae880a31d5bdee57"
 dependencies = [
- "git-command",
- "git-config-value",
+ "gix-command",
+ "gix-config-value",
  "nix",
  "parking_lot",
  "thiserror",
 ]
 
 [[package]]
-name = "git-quote"
-version = "0.4.0"
+name = "gix-quote"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1dd11f4e7f251ab297545faa4c5a4517f4985a43b9c16bf96fa49107f58e837f"
+checksum = "a282f5a8d9ee0b09ec47390ac727350c48f2f5c76d803cd8da6b3e7ad56e0bcb"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "btoi",
- "quick-error",
+ "thiserror",
 ]
 
 [[package]]
-name = "git-ref"
-version = "0.20.0"
+name = "gix-ref"
+version = "0.27.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "22484043921e699edc170415789f1b882c8f3546e1fbbc447a0043ef07e088c4"
+checksum = "e4e909396ed3b176823991ccc391c276ae2a015e54edaafa3566d35123cfac9d"
 dependencies = [
- "git-actor",
- "git-features",
- "git-hash",
- "git-lock",
- "git-object",
- "git-path",
- "git-tempfile",
- "git-validate",
+ "gix-actor",
+ "gix-features",
+ "gix-hash",
+ "gix-lock",
+ "gix-object",
+ "gix-path",
+ "gix-tempfile",
+ "gix-validate",
  "memmap2",
  "nom",
  "thiserror",
 ]
 
 [[package]]
-name = "git-refspec"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac2e8f36e7d5d48903b60051dfb75aedfc4ea9ba66bdffa7a9081e8d276b0107"
-dependencies = [
- "bstr 1.0.1",
- "git-hash",
- "git-revision",
- "git-validate",
- "smallvec",
- "thiserror",
-]
-
-[[package]]
-name = "git-repository"
-version = "0.29.0"
+name = "gix-refspec"
+version = "0.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a89cec253dd3fba44694f7468d907506a52d0055850ecd7d84f4bac07f00e73f"
+checksum = "aba332462bda2e8efeae4302b39a6ed01ad56ef772fd5b7ef197cf2798294d65"
 dependencies = [
- "byte-unit",
- "clru",
- "git-actor",
- "git-attributes",
- "git-config",
- "git-credentials",
- "git-date",
- "git-diff",
- "git-discover",
- "git-features",
- "git-glob",
- "git-hash",
- "git-index",
- "git-lock",
- "git-mailmap",
- "git-object",
- "git-odb",
- "git-pack",
- "git-path",
- "git-prompt",
- "git-ref",
- "git-refspec",
- "git-revision",
- "git-sec",
- "git-tempfile",
- "git-traverse",
- "git-url",
- "git-validate",
- "git-worktree",
- "log",
- "once_cell",
- "signal-hook",
+ "bstr",
+ "gix-hash",
+ "gix-revision",
+ "gix-validate",
  "smallvec",
  "thiserror",
- "unicode-normalization",
 ]
 
 [[package]]
-name = "git-revision"
-version = "0.7.0"
+name = "gix-revision"
+version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e629289b0d7f7f2f2e46248527f5cac838e6a7cb9507eab06fc8473082db6cb6"
+checksum = "b12fc4bbc3161a5b2d68079fce93432cef8771ff88ca017abb01187fddfc41a1"
 dependencies = [
- "bstr 1.0.1",
- "git-date",
- "git-hash",
- "git-object",
- "hash_hasher",
+ "bstr",
+ "gix-date",
+ "gix-hash",
+ "gix-hashtable",
+ "gix-object",
  "thiserror",
 ]
 
 [[package]]
-name = "git-sec"
-version = "0.5.0"
+name = "gix-sec"
+version = "0.6.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ecb370efde58da72827909292284b5c5b885e0621a342515a36976b0b3bf660"
+checksum = "e8ffa5bf0772f9b01de501c035b6b084cf9b8bb07dec41e3afc6a17336a65f47"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "dirs",
- "git-path",
+ "gix-path",
  "libc",
- "windows",
+ "windows 0.43.0",
 ]
 
 [[package]]
-name = "git-tempfile"
-version = "3.0.0"
+name = "gix-tempfile"
+version = "5.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a6bb4dee86c8cae5a078cfaac3b004ef99c31548ed86218f23a7ff9b4b74f3be"
+checksum = "c2ceb30a610e3f5f2d5f9a5114689fde507ba9417705a8cf3429604275b2153c"
 dependencies = [
- "dashmap",
  "libc",
  "once_cell",
+ "parking_lot",
  "signal-hook",
  "signal-hook-registry",
  "tempfile",
 ]
 
 [[package]]
-name = "git-traverse"
-version = "0.19.0"
+name = "gix-traverse"
+version = "0.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2d2746935c92d252e24f9d345e0a981510596faceb7edae821b9e4c8c35c285b"
+checksum = "dd9a4a07bb22168dc79c60e1a6a41919d198187ca83d8a5940ad8d7122a45df3"
 dependencies = [
- "git-hash",
- "git-object",
- "hash_hasher",
+ "gix-hash",
+ "gix-hashtable",
+ "gix-object",
  "thiserror",
 ]
 
 [[package]]
-name = "git-url"
-version = "0.11.0"
+name = "gix-url"
+version = "0.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7dbd91c55b1b03a833ff8278776fed272918cd61cd48efe9a97ad1fea7ef93ec"
+checksum = "b6a22b4b32ad14d68f7b7fb6458fa58d44b01797d94c1b8f4db2d9c7b3c366b5"
 dependencies = [
- "bstr 1.0.1",
- "git-features",
- "git-path",
+ "bstr",
+ "gix-features",
+ "gix-path",
  "home",
  "thiserror",
  "url",
 ]
 
 [[package]]
-name = "git-validate"
-version = "0.7.0"
+name = "gix-validate"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cdf83bae632fc064ca938ebfb987364d9083b7f98b1476805f0a2d5eebb48686"
+checksum = "7bd629d3680773e1785e585d76fd4295b740b559cad9141517300d99a0c8c049"
 dependencies = [
- "bstr 1.0.1",
+ "bstr",
  "thiserror",
 ]
 
 [[package]]
-name = "git-worktree"
-version = "0.9.0"
+name = "gix-worktree"
+version = "0.15.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2eae0e0b1050208e611d5fac0d8366b29ef3f83849767ff9c4bcf570f0d5dc2b"
+checksum = "54ec9a000b4f24af706c3cc680c7cda235656cbe3216336522f5692773b8a301"
 dependencies = [
- "bstr 1.0.1",
- "git-attributes",
- "git-features",
- "git-glob",
- "git-hash",
- "git-index",
- "git-object",
- "git-path",
+ "bstr",
+ "gix-attributes",
+ "gix-features",
+ "gix-glob",
+ "gix-hash",
+ "gix-index",
+ "gix-object",
+ "gix-path",
  "io-close",
  "thiserror",
 ]
 
 [[package]]
 name = "globset"
-version = "0.4.9"
+version = "0.4.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a1e17342619edbc21a964c2afbeb6c820c6a2560032872f397bb97ea127bd0a"
+checksum = "029d74589adefde59de1a0c4f4732695c32805624aec7b68d91503d4dba79afc"
 dependencies = [
  "aho-corasick",
- "bstr 0.2.17",
+ "bstr",
  "fnv",
  "log",
  "regex",
@@ -1056,21 +1020,21 @@ dependencies = [
 
 [[package]]
 name = "grep-matcher"
-version = "0.1.5"
+version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6d27563c33062cd33003b166ade2bb4fd82db1fd6a86db764dfdad132d46c1cc"
+checksum = "3902ca28f26945fe35cad349d776f163981d777fee382ccd6ef451126f51b319"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "grep-regex"
-version = "0.1.10"
+version = "0.1.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1345f8d33c89f2d5b081f2f2a41175adef9fd0bed2fea6a26c96c2deb027e58e"
+checksum = "997598b41d53a37a2e3fc5300d5c11d825368c054420a9c65125b8fe1078463f"
 dependencies = [
  "aho-corasick",
- "bstr 0.2.17",
+ "bstr",
  "grep-matcher",
  "log",
  "regex",
@@ -1080,11 +1044,11 @@ dependencies = [
 
 [[package]]
 name = "grep-searcher"
-version = "0.1.10"
+version = "0.1.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "48852bd08f9b4eb3040ecb6d2f4ade224afe880a9a0909c5563cc59fa67932cc"
+checksum = "5601c4b9f480f0c9ebb40b1f6cbf447b8a50c5369223937a6c5214368c58779f"
 dependencies = [
- "bstr 0.2.17",
+ "bstr",
  "bytecount",
  "encoding_rs",
  "encoding_rs_io",
@@ -1093,12 +1057,6 @@ dependencies = [
  "memmap2",
 ]
 
-[[package]]
-name = "hash_hasher"
-version = "2.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "74721d007512d0cb3338cd20f0654ac913920061a4c4d0d8708edb3f2a698c0c"
-
 [[package]]
 name = "hashbrown"
 version = "0.12.3"
@@ -1110,26 +1068,28 @@ dependencies = [
 
 [[package]]
 name = "hashbrown"
-version = "0.13.1"
+version = "0.13.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33ff8ae62cd3a9102e5637afc8452c55acf3844001bd5374e0b0bd7b6616c038"
+checksum = "43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e"
 dependencies = [
- "ahash 0.8.2",
+ "ahash 0.8.3",
 ]
 
 [[package]]
 name = "helix-core"
 version = "0.6.0"
 dependencies = [
- "ahash 0.8.2",
+ "ahash 0.8.3",
  "arc-swap",
- "bitflags",
+ "bitflags 2.0.2",
  "chrono",
+ "dunce",
  "encoding_rs",
  "etcetera",
- "hashbrown 0.13.1",
+ "hashbrown 0.13.2",
  "helix-loader",
  "imara-diff",
+ "indoc",
  "log",
  "once_cell",
  "quickcheck",
@@ -1188,8 +1148,10 @@ dependencies = [
  "futures-util",
  "helix-core",
  "helix-loader",
+ "helix-parsec",
  "log",
  "lsp-types",
+ "parking_lot",
  "serde",
  "serde_json",
  "thiserror",
@@ -1198,6 +1160,10 @@ dependencies = [
  "which",
 ]
 
+[[package]]
+name = "helix-parsec"
+version = "0.6.0"
+
 [[package]]
 name = "helix-term"
 version = "0.6.0"
@@ -1221,6 +1187,7 @@ dependencies = [
  "helix-view",
  "ignore",
  "indoc",
+ "libc",
  "log",
  "once_cell",
  "pulldown-cmark",
@@ -1240,11 +1207,13 @@ dependencies = [
 name = "helix-tui"
 version = "0.6.0"
 dependencies = [
- "bitflags",
+ "bitflags 2.0.2",
  "cassowary",
  "crossterm",
  "helix-core",
  "helix-view",
+ "log",
+ "once_cell",
  "serde",
  "termini",
  "unicode-segmentation",
@@ -1254,7 +1223,9 @@ dependencies = [
 name = "helix-vcs"
 version = "0.6.0"
 dependencies = [
- "git-repository",
+ "anyhow",
+ "arc-swap",
+ "gix",
  "helix-core",
  "imara-diff",
  "log",
@@ -1269,7 +1240,7 @@ version = "0.6.0"
 dependencies = [
  "anyhow",
  "arc-swap",
- "bitflags",
+ "bitflags 2.0.2",
  "chardetng",
  "clipboard-win",
  "crossterm",
@@ -1280,8 +1251,10 @@ dependencies = [
  "helix-lsp",
  "helix-tui",
  "helix-vcs",
+ "libc",
  "log",
  "once_cell",
+ "parking_lot",
  "serde",
  "serde_json",
  "slotmap",
@@ -1294,13 +1267,19 @@ dependencies = [
 
 [[package]]
 name = "hermit-abi"
-version = "0.1.19"
+version = "0.2.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
+checksum = "ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7"
 dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "hermit-abi"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286"
+
 [[package]]
 name = "hex"
 version = "0.4.3"
@@ -1316,24 +1295,18 @@ dependencies = [
  "winapi",
 ]
 
-[[package]]
-name = "human_format"
-version = "1.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "86cce260d758a9aa3d7c4b99d55c815a540f8a37514ba6046ab6be402a157cb0"
-
 [[package]]
 name = "iana-time-zone"
-version = "0.1.53"
+version = "0.1.55"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64c122667b287044802d6ce17ee2ddf13207ed924c712de9a66a5814d5b64765"
+checksum = "716f12fbcfac6ffab0a5e9ec51d0a0ff70503742bb2dc7b99396394c9dc323f0"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
  "iana-time-zone-haiku",
  "js-sys",
  "wasm-bindgen",
- "winapi",
+ "windows 0.47.0",
 ]
 
 [[package]]
@@ -1358,11 +1331,10 @@ dependencies = [
 
 [[package]]
 name = "ignore"
-version = "0.4.18"
+version = "0.4.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "713f1b139373f96a2e0ce3ac931cd01ee973c3c5dd7c40c0c2efe96ad2b6751d"
+checksum = "dbe7873dab538a9a44ad79ede1faf5f30d49f9a5c883ddbab48bce81b64b7492"
 dependencies = [
- "crossbeam-utils",
  "globset",
  "lazy_static",
  "log",
@@ -1380,15 +1352,25 @@ version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e98c1d0ad70fc91b8b9654b1f33db55e59579d3b3de2bffdced0fdb810570cb8"
 dependencies = [
- "ahash 0.8.2",
+ "ahash 0.8.3",
+ "hashbrown 0.12.3",
+]
+
+[[package]]
+name = "indexmap"
+version = "1.9.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
+dependencies = [
+ "autocfg",
  "hashbrown 0.12.3",
 ]
 
 [[package]]
 name = "indoc"
-version = "1.0.7"
+version = "2.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "adab1eaa3408fb7f0c777a73e7465fd5656136fc93b670eb6df3c88c2c1344e3"
+checksum = "9f2cb48b81b1dc9f39676bf99f5499babfec7cd8fe14307f7b3d747208fb5690"
 
 [[package]]
 name = "instant"
@@ -1409,17 +1391,28 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "io-lifetimes"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09270fd4fa1111bc614ed2246c7ef56239a3063d5be0d1ec3b589c505d400aeb"
+dependencies = [
+ "hermit-abi 0.3.1",
+ "libc",
+ "windows-sys",
+]
+
 [[package]]
 name = "itoa"
-version = "1.0.4"
+version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc"
+checksum = "453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6"
 
 [[package]]
 name = "js-sys"
-version = "0.3.60"
+version = "0.3.61"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "49409df3e3bf0856b916e2ceaca09ee28e6871cf7d9ce97a692cacfdb2a25a47"
+checksum = "445dde2150c55e483f3d8416706b97ec8e8237c307e5b7b4b8dd15e6af2a0730"
 dependencies = [
  "wasm-bindgen",
 ]
@@ -1432,9 +1425,9 @@ checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
 
 [[package]]
 name = "libc"
-version = "0.2.137"
+version = "0.2.140"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89"
+checksum = "99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c"
 
 [[package]]
 name = "libloading"
@@ -1448,13 +1441,19 @@ dependencies = [
 
 [[package]]
 name = "link-cplusplus"
-version = "1.0.7"
+version = "1.0.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9272ab7b96c9046fbc5bc56c06c117cb639fe2d509df0c421cad82d2915cf369"
+checksum = "ecd207c9c713c34f95a097a5b029ac2ce6010530c7b49d7fea24d977dede04f5"
 dependencies = [
  "cc",
 ]
 
+[[package]]
+name = "linux-raw-sys"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd550e73688e6d578f0ac2119e32b797a327631a42f9433e59d02e139c8df60d"
+
 [[package]]
 name = "lock_api"
 version = "0.4.9"
@@ -1476,11 +1475,11 @@ dependencies = [
 
 [[package]]
 name = "lsp-types"
-version = "0.93.2"
+version = "0.94.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9be6e9c7e2d18f651974370d7aff703f9513e0df6e464fd795660edc77e6ca51"
+checksum = "0b63735a13a1f9cd4f4835223d828ed9c2e35c8c5e61837774399f558b6a1237"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "serde",
  "serde_json",
  "serde_repr",
@@ -1495,9 +1494,9 @@ checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
 
 [[package]]
 name = "memmap2"
-version = "0.5.8"
+version = "0.5.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b182332558b18d807c4ce1ca8ca983b34c3ee32765e47b3f0f69b90355cc1dc"
+checksum = "83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327"
 dependencies = [
  "libc",
 ]
@@ -1519,9 +1518,9 @@ dependencies = [
 
 [[package]]
 name = "mio"
-version = "0.8.5"
+version = "0.8.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5d732bc30207a6423068df043e3d02e0735b155ad7ce1a6f76fe2baa5b158de"
+checksum = "5b9d9a46eff5b4ff64b45a9e316a6d1e0bc719ef429cbec4dc630684212bfdf9"
 dependencies = [
  "libc",
  "log",
@@ -1531,21 +1530,21 @@ dependencies = [
 
 [[package]]
 name = "nix"
-version = "0.25.0"
+version = "0.26.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e322c04a9e3440c327fca7b6c8a63e6890a32fa2ad689db972425f07e0d22abb"
+checksum = "bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a"
 dependencies = [
- "autocfg",
- "bitflags",
+ "bitflags 1.3.2",
  "cfg-if",
  "libc",
+ "static_assertions",
 ]
 
 [[package]]
 name = "nom"
-version = "7.1.1"
+version = "7.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a8903e5a29a317527874d0402f867152a3d21c908bb0b933e416c65e301d4c36"
+checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
 dependencies = [
  "memchr",
  "minimal-lexical",
@@ -1572,11 +1571,11 @@ dependencies = [
 
 [[package]]
 name = "num_cpus"
-version = "1.14.0"
+version = "1.15.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f6058e64324c71e02bc2b150e4f3bc8286db6c83092132ffa3f6b1eab0f9def5"
+checksum = "0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b"
 dependencies = [
- "hermit-abi",
+ "hermit-abi 0.2.6",
  "libc",
 ]
 
@@ -1591,9 +1590,9 @@ dependencies = [
 
 [[package]]
 name = "once_cell"
-version = "1.16.0"
+version = "1.17.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860"
+checksum = "b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3"
 
 [[package]]
 name = "parking_lot"
@@ -1607,13 +1606,13 @@ dependencies = [
 
 [[package]]
 name = "parking_lot_core"
-version = "0.9.4"
+version = "0.9.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0"
+checksum = "9069cbb9f99e3a5083476ccb29ceb1de18b9118cafa53e90c9551235de2b9521"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "smallvec",
  "windows-sys",
 ]
@@ -1638,22 +1637,18 @@ checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.47"
+version = "1.0.54"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725"
+checksum = "e472a104799c74b514a57226160104aa483546de37e839ec50e3c2e41dd87534"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "prodash"
-version = "21.1.0"
+version = "23.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7e13d7bd38cdab08b3a8b780cedcc54238c84fdca4084eb188807b308bcf11e6"
-dependencies = [
- "bytesize",
- "human_format",
-]
+checksum = "9516b775656bc3e8985e19cd4b8c0c0de045095074e453d2c0a513b5f978392d"
 
 [[package]]
 name = "pulldown-cmark"
@@ -1661,17 +1656,11 @@ version = "0.9.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "memchr",
  "unicase",
 ]
 
-[[package]]
-name = "quick-error"
-version = "2.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a993555f31e5a609f617c12db6250dedcac1b0a85076912c436e6fc9b2c8e6a3"
-
 [[package]]
 name = "quickcheck"
 version = "1.0.3"
@@ -1683,9 +1672,9 @@ dependencies = [
 
 [[package]]
 name = "quote"
-version = "1.0.21"
+version = "1.0.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179"
+checksum = "4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc"
 dependencies = [
  "proc-macro2",
 ]
@@ -1714,7 +1703,16 @@ version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
+dependencies = [
+ "bitflags 1.3.2",
 ]
 
 [[package]]
@@ -1724,15 +1722,15 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b033d837a7cf162d7993aded9304e30a83213c648b6e389db233191f891e5c2b"
 dependencies = [
  "getrandom",
- "redox_syscall",
+ "redox_syscall 0.2.16",
  "thiserror",
 ]
 
 [[package]]
 name = "regex"
-version = "1.7.0"
+version = "1.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e076559ef8e241f2ae3479e36f97bd5741c0330689e217ad51ce2c76808b868a"
+checksum = "8b1f693b24f6ac912f4893ef08244d70b6067480d2f1a46e950c9691e6749d1d"
 dependencies = [
  "aho-corasick",
  "memchr",
@@ -1747,40 +1745,39 @@ checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
 
 [[package]]
 name = "regex-syntax"
-version = "0.6.28"
+version = "0.6.29"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "456c603be3e8d448b072f410900c09faf164fbce2d480456f50eea6e25f9c848"
-
-[[package]]
-name = "remove_dir_all"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7"
-dependencies = [
- "winapi",
-]
+checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
 
 [[package]]
 name = "ropey"
-version = "1.5.1-alpha"
+version = "1.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "917e62c0dee8926492dd13164b3cefaad2b0e03ab49f48c0d41635797a7409b3"
+checksum = "53ce7a2c43a32e50d666e33c5a80251b31147bb4b49024bcab11fb6f20c671ed"
 dependencies = [
  "smallvec",
  "str_indices",
 ]
 
 [[package]]
-name = "rustversion"
-version = "1.0.9"
+name = "rustix"
+version = "0.37.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97477e48b4cf8603ad5f7aaf897467cf42ab4218a38ef76fb14c2d6773a6d6a8"
+checksum = "0e78cc525325c06b4a7ff02db283472f3c042b7ff0c391f96c6d5ac6f4f91b75"
+dependencies = [
+ "bitflags 1.3.2",
+ "errno",
+ "io-lifetimes",
+ "libc",
+ "linux-raw-sys",
+ "windows-sys",
+]
 
 [[package]]
 name = "ryu"
-version = "1.0.11"
+version = "1.0.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09"
+checksum = "f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041"
 
 [[package]]
 name = "same-file"
@@ -1799,35 +1796,35 @@ checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
 
 [[package]]
 name = "scratch"
-version = "1.0.2"
+version = "1.0.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c8132065adcfd6e02db789d9285a0deb2f3fcb04002865ab67d5fb103533898"
+checksum = "1792db035ce95be60c3f8853017b3999209281c24e2ba5bc8e59bf97a0c590c1"
 
 [[package]]
 name = "serde"
-version = "1.0.149"
+version = "1.0.159"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "256b9932320c590e707b94576e3cc1f7c9024d0ee6612dfbcf1cb106cbe8e055"
+checksum = "3c04e8343c3daeec41f58990b9d77068df31209f2af111e059e9fe9646693065"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.149"
+version = "1.0.159"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b4eae9b04cbffdfd550eb462ed33bc6a1b68c935127d008b27444d08380f94e4"
+checksum = "4c614d17805b093df4b147b51339e7e44bf05ef59fba1e45d83500bcfb4d8585"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.11",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.89"
+version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "020ff22c755c2ed3f8cf162dbb41a7268d934702f3ed3631656ea597e08fc3db"
+checksum = "d721eca97ac802aa7777b701877c8004d950fc142651367300d21c1cc0194744"
 dependencies = [
  "itoa",
  "ryu",
@@ -1836,13 +1833,22 @@ dependencies = [
 
 [[package]]
 name = "serde_repr"
-version = "0.1.9"
+version = "0.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1fe39d9fbb0ebf5eb2c7cb7e2a47e4f462fad1379f1166b8ae49ad9eae89a7ca"
+checksum = "bcec881020c684085e55a25f7fd888954d56609ef363479dc5a1305eb0d40cab"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.11",
+]
+
+[[package]]
+name = "serde_spanned"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0efd8caf556a6cebd3b285caf480045fcc1ac04f6bd786b09a6f11af30c4fcf4"
+dependencies = [
+ "serde",
 ]
 
 [[package]]
@@ -1853,9 +1859,9 @@ checksum = "ae1a47186c03a32177042e55dbc5fd5aee900b8e0069a8d70fba96a9375cd012"
 
 [[package]]
 name = "signal-hook"
-version = "0.3.14"
+version = "0.3.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a253b5e89e2698464fc26b545c9edceb338e18a89effeeecfea192c3025be29d"
+checksum = "732768f1176d21d09e076c23a93123d40bba92d50c4058da34d45c8de8e682b9"
 dependencies = [
  "libc",
  "signal-hook-registry",
@@ -1874,9 +1880,9 @@ dependencies = [
 
 [[package]]
 name = "signal-hook-registry"
-version = "1.4.0"
+version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e51e73328dc4ac0c7ccbda3a494dfa03df1de2f46018127f60c693f2648455b0"
+checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
 dependencies = [
  "libc",
 ]
@@ -1895,9 +1901,9 @@ dependencies = [
 
 [[package]]
 name = "slab"
-version = "0.4.7"
+version = "0.4.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4614a76b2a8be0058caa9dbbaf66d988527d86d003c11a94fbd335d7661edcef"
+checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
 dependencies = [
  "autocfg",
 ]
@@ -1936,9 +1942,9 @@ checksum = "f67ad224767faa3c7d8b6d91985b78e70a1324408abcb1cfcc2be4c06bc06043"
 
 [[package]]
 name = "socket2"
-version = "0.4.7"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02e2d2db9033d13a1567121ddd7a095ee144db4e1ca1b1bda3419bc0da294ebd"
+checksum = "64a4a911eed85daf18834cfaa86a79b7d266ff93ff5ba14005426219480ed662"
 dependencies = [
  "libc",
  "winapi",
@@ -1958,15 +1964,26 @@ checksum = "9e08d8363704e6c71fc928674353e6b7c23dcea9d82d7012c8faf2a3a025f8d0"
 
 [[package]]
 name = "str_indices"
-version = "0.4.0"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f026164926842ec52deb1938fae44f83dfdb82d0a5b0270c5bd5935ab74d6dd"
+
+[[package]]
+name = "syn"
+version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9d9199fa80c817e074620be84374a520062ebac833f358d74b37060ce4a0f2c0"
+checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
 
 [[package]]
 name = "syn"
-version = "1.0.104"
+version = "2.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4ae548ec36cf198c0ef7710d3c230987c2d6d7bd98ad6edc0274462724c585ce"
+checksum = "21e3787bb71465627110e7d87ed4faaa36c1f61042ee67badb9e2ef173accc40"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -1975,23 +1992,22 @@ dependencies = [
 
 [[package]]
 name = "tempfile"
-version = "3.3.0"
+version = "3.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5cdb1ef4eaeeaddc8fbd371e5017057064af0911902ef36b39801f67cc6d79e4"
+checksum = "b9fbec84f381d5795b08656e4912bec604d162bff9291d6189a78f4c8ab87998"
 dependencies = [
  "cfg-if",
  "fastrand",
- "libc",
- "redox_syscall",
- "remove_dir_all",
- "winapi",
+ "redox_syscall 0.3.5",
+ "rustix",
+ "windows-sys",
 ]
 
 [[package]]
 name = "termcolor"
-version = "1.1.3"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755"
+checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
 dependencies = [
  "winapi-util",
 ]
@@ -2018,30 +2034,31 @@ dependencies = [
 
 [[package]]
 name = "thiserror"
-version = "1.0.37"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "10deb33631e3c9018b9baf9dcbbc4f737320d2b576bac10f6aefa048fa407e3e"
+checksum = "978c9a314bd8dc99be594bc3c175faaa9794be04a5a5e153caba6915336cebac"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.37"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "982d17546b47146b28f7c22e3d08465f6b8903d0ea13c1660d9d84a6e7adcdbb"
+checksum = "f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.11",
 ]
 
 [[package]]
 name = "thread_local"
-version = "1.1.4"
+version = "1.1.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180"
+checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
 dependencies = [
+ "cfg-if",
  "once_cell",
 ]
 
@@ -2056,9 +2073,9 @@ dependencies = [
 
 [[package]]
 name = "time"
-version = "0.3.17"
+version = "0.3.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376"
+checksum = "cd0cbfecb4d19b5ea75bb31ad904eb5b9fa13f21079c3b92017ebdf4999a5890"
 dependencies = [
  "itoa",
  "libc",
@@ -2076,9 +2093,9 @@ checksum = "2e153e1f1acaef8acc537e68b44906d2db6436e2b35ac2c6b42640fff91f00fd"
 
 [[package]]
 name = "time-macros"
-version = "0.2.6"
+version = "0.2.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d967f99f534ca7e495c575c62638eebc2898a8c84c119b89e250477bc4ba16b2"
+checksum = "fd80a657e71da814b8e5d60d3374fc6d35045062245d80224748ae522dd76f36"
 dependencies = [
  "time-core",
 ]
@@ -2094,20 +2111,19 @@ dependencies = [
 
 [[package]]
 name = "tinyvec_macros"
-version = "0.1.0"
+version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c"
+checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.22.0"
+version = "1.27.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d76ce4a75fb488c605c54bf610f221cea8b0dafb53333c1a67e8ee199dcd2ae3"
+checksum = "d0de47a4eecbe11f498978a9b29d792f0d2692d1dd003650c24c76510e3bc001"
 dependencies = [
  "autocfg",
  "bytes",
  "libc",
- "memchr",
  "mio",
  "num_cpus",
  "parking_lot",
@@ -2115,25 +2131,25 @@ dependencies = [
  "signal-hook-registry",
  "socket2",
  "tokio-macros",
- "winapi",
+ "windows-sys",
 ]
 
 [[package]]
 name = "tokio-macros"
-version = "1.8.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9724f9a975fb987ef7a3cd9be0350edcbe130698af5b8f7a631e23d42d052484"
+checksum = "61a573bdc87985e9d6ddeed1b3d864e8a302c847e40d647746df2f1de209d1ce"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 2.0.11",
 ]
 
 [[package]]
 name = "tokio-stream"
-version = "0.1.11"
+version = "0.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d660770404473ccd7bc9f8b28494a811bc18542b915c0855c51e8f419d5223ce"
+checksum = "8fb52b74f05dbf495a8fba459fdc331812b96aa086d9eb78101fa0d4569c3313"
 dependencies = [
  "futures-core",
  "pin-project-lite",
@@ -2142,18 +2158,43 @@ dependencies = [
 
 [[package]]
 name = "toml"
-version = "0.5.9"
+version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8d82e1a7758622a465f8cee077614c73484dac5b836c02ff6a40d5d1010324d7"
+checksum = "b403acf6f2bb0859c93c7f0d967cb4a75a7ac552100f9322faf64dc047669b21"
 dependencies = [
  "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "toml_edit",
+]
+
+[[package]]
+name = "toml_datetime"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3ab8ed2edee10b50132aed5f331333428b011c99402b5a534154ed15746f9622"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "toml_edit"
+version = "0.19.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "239410c8609e8125456927e6707163a3b1fdb40561e4b803bc041f466ccfdc13"
+dependencies = [
+ "indexmap",
+ "serde",
+ "serde_spanned",
+ "toml_datetime",
+ "winnow",
 ]
 
 [[package]]
 name = "tree-sitter"
-version = "0.20.9"
+version = "0.20.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d4423c784fe11398ca91e505cdc71356b07b1a924fc8735cfab5333afe3e18bc"
+checksum = "e747b1f9b7b931ed39a548c1fae149101497de3c1fc8d9e18c62c1a66c683d3d"
 dependencies = [
  "cc",
  "regex",
@@ -2170,9 +2211,9 @@ dependencies = [
 
 [[package]]
 name = "unicode-bidi"
-version = "0.3.8"
+version = "0.3.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992"
+checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
 
 [[package]]
 name = "unicode-bom"
@@ -2188,9 +2229,9 @@ checksum = "2281c8c1d221438e373249e065ca4989c4c36952c211ff21a0ee91c44a3869e7"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.5"
+version = "1.0.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3"
+checksum = "e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4"
 
 [[package]]
 name = "unicode-linebreak"
@@ -2213,9 +2254,9 @@ dependencies = [
 
 [[package]]
 name = "unicode-segmentation"
-version = "1.10.0"
+version = "1.10.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a"
+checksum = "1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36"
 
 [[package]]
 name = "unicode-width"
@@ -2235,12 +2276,6 @@ dependencies = [
  "serde",
 ]
 
-[[package]]
-name = "utf8-width"
-version = "0.1.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5190c9442dcdaf0ddd50f37420417d219ae5261bbf5db120d0f9bab996c9cba1"
-
 [[package]]
 name = "version_check"
 version = "0.9.4"
@@ -2249,12 +2284,11 @@ checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
 
 [[package]]
 name = "walkdir"
-version = "2.3.2"
+version = "2.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56"
+checksum = "36df944cda56c7d8d8b7496af378e6b16de9284591917d307c9b4d313c44e698"
 dependencies = [
  "same-file",
- "winapi",
  "winapi-util",
 ]
 
@@ -2266,9 +2300,9 @@ checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.83"
+version = "0.2.84"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eaf9f5aceeec8be17c128b2e93e031fb8a4d469bb9c4ae2d7dc1888b26887268"
+checksum = "31f8dcbc21f30d9b8f2ea926ecb58f6b91192c17e9d33594b3df58b2007ca53b"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
@@ -2276,24 +2310,24 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.83"
+version = "0.2.84"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c8ffb332579b0557b52d268b91feab8df3615f265d5270fec2a8c95b17c1142"
+checksum = "95ce90fd5bcc06af55a641a86428ee4229e44e07033963a2290a8e241607ccb9"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn",
+ "syn 1.0.109",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.83"
+version = "0.2.84"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "052be0f94026e6cbc75cdefc9bae13fd6052cdcaf532fa6c45e7ae33a1e6c810"
+checksum = "4c21f77c0bedc37fd5dc21f897894a5ca01e7bb159884559461862ae90c0b4c5"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -2301,28 +2335,28 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.83"
+version = "0.2.84"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c"
+checksum = "2aff81306fcac3c7515ad4e177f521b5c9a15f2b08f4e32d823066102f35a5f6"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn",
+ "syn 1.0.109",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.83"
+version = "0.2.84"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1c38c045535d93ec4f0b4defec448e4291638ee608530863b1e2ba115d4fff7f"
+checksum = "0046fef7e28c3804e5e38bfa31ea2a0f73905319b677e57ebe37e49358989b5d"
 
 [[package]]
 name = "which"
-version = "4.3.0"
+version = "4.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1c831fbbee9e129a8cf93e7747a82da9d95ba8e16621cae60ec2cdc849bacb7b"
+checksum = "2441c784c52b289a054b7201fc93253e288f094e2f4be9058343127c4226a269"
 dependencies = [
  "either",
  "libc",
@@ -2362,117 +2396,159 @@ checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 
 [[package]]
 name = "windows"
-version = "0.40.0"
+version = "0.43.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "04662ed0e3e5630dfa9b26e4cb823b817f1a9addda855d973a9458c236556244"
+dependencies = [
+ "windows_aarch64_gnullvm 0.42.2",
+ "windows_aarch64_msvc 0.42.2",
+ "windows_i686_gnu 0.42.2",
+ "windows_i686_msvc 0.42.2",
+ "windows_x86_64_gnu 0.42.2",
+ "windows_x86_64_gnullvm 0.42.2",
+ "windows_x86_64_msvc 0.42.2",
+]
+
+[[package]]
+name = "windows"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e30acc718a52fb130fec72b1cb5f55ffeeec9253e1b785e94db222178a6acaa1"
+checksum = "2649ff315bee4c98757f15dac226efe3d81927adbb6e882084bb1ee3e0c330a7"
 dependencies = [
- "windows_aarch64_gnullvm 0.40.0",
- "windows_aarch64_msvc 0.40.0",
- "windows_i686_gnu 0.40.0",
- "windows_i686_msvc 0.40.0",
- "windows_x86_64_gnu 0.40.0",
- "windows_x86_64_gnullvm 0.40.0",
- "windows_x86_64_msvc 0.40.0",
+ "windows-targets 0.47.0",
 ]
 
 [[package]]
 name = "windows-sys"
-version = "0.42.0"
+version = "0.45.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
+dependencies = [
+ "windows-targets 0.42.2",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7"
+checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
 dependencies = [
- "windows_aarch64_gnullvm 0.42.0",
- "windows_aarch64_msvc 0.42.0",
- "windows_i686_gnu 0.42.0",
- "windows_i686_msvc 0.42.0",
- "windows_x86_64_gnu 0.42.0",
- "windows_x86_64_gnullvm 0.42.0",
- "windows_x86_64_msvc 0.42.0",
+ "windows_aarch64_gnullvm 0.42.2",
+ "windows_aarch64_msvc 0.42.2",
+ "windows_i686_gnu 0.42.2",
+ "windows_i686_msvc 0.42.2",
+ "windows_x86_64_gnu 0.42.2",
+ "windows_x86_64_gnullvm 0.42.2",
+ "windows_x86_64_msvc 0.42.2",
+]
+
+[[package]]
+name = "windows-targets"
+version = "0.47.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2f8996d3f43b4b2d44327cd71b7b0efd1284ab60e6e9d0e8b630e18555d87d3e"
+dependencies = [
+ "windows_aarch64_gnullvm 0.47.0",
+ "windows_aarch64_msvc 0.47.0",
+ "windows_i686_gnu 0.47.0",
+ "windows_i686_msvc 0.47.0",
+ "windows_x86_64_gnu 0.47.0",
+ "windows_x86_64_gnullvm 0.47.0",
+ "windows_x86_64_msvc 0.47.0",
 ]
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3caa4a1a16561b714323ca6b0817403738583033a6a92e04c5d10d4ba37ca10"
+checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e"
+checksum = "831d567d53d4f3cb1db332b68e6e2b6260228eb4d99a777d8b2e8ed794027c90"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "328973c62dfcc50fb1aaa8e7100676e0b642fe56bac6bafff3327902db843ab4"
+checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4"
+checksum = "6a42d54a417c60ce4f0e31661eed628f0fa5aca73448c093ec4d45fab4c51cdf"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "aa5b09fad70f0df85dea2ac2a525537e415e2bf63ee31cf9b8e263645ee9f3c1"
+checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7"
+checksum = "c1925beafdbb22201a53a483db861a5644123157c1c3cee83323a2ed565d71e3"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a1ad4031c1a98491fa195d8d43d7489cb749f135f2e5c4eed58da094bd0d876"
+checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246"
+checksum = "3a8ef8f2f1711b223947d9b69b596cf5a4e452c930fb58b6fc3fdae7d0ec6b31"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "520ff37edd72da8064b49d2281182898e17f0688ae9f4070bca27e4b5c162ac7"
+checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed"
+checksum = "7acaa0c2cf0d2ef99b61c308a0c3dbae430a51b7345dedec470bd8f53f5a3642"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "046e5b82215102c44fd75f488f1b9158973d02aa34d06ed85c23d6f5520a2853"
+checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028"
+checksum = "e5a0628f71be1d11e17ca4a0e9e15b3a5180f6fbf1c2d55e3ba3f850378052c1"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.40.0"
+version = "0.42.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2a0c9c6df55dd1bfa76e131cef44bdd8ec9c819ef3611f04dfe453fd5bfeda28"
+checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.42.0"
+version = "0.47.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5"
+checksum = "9d6e62c256dc6d40b8c8707df17df8d774e60e39db723675241e7c15e910bce7"
+
+[[package]]
+name = "winnow"
+version = "0.4.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ae8970b36c66498d8ff1d66685dc86b91b29db0c7739899012f63a63814b4b28"
+dependencies = [
+ "memchr",
+]
 
 [[package]]
 name = "xtask"
diff --git a/Cargo.toml b/Cargo.toml
index ecf6848e0..c63518897 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -8,6 +8,7 @@ members = [
   "helix-dap",
   "helix-loader",
   "helix-vcs",
+  "helix-parsec",
   "xtask",
 ]
 
@@ -25,3 +26,9 @@ lto = "fat"
 codegen-units = 1
 # strip = "debuginfo" # TODO: or strip = true
 opt-level = 3
+
+[profile.integration]
+inherits = "test"
+package.helix-core.opt-level = 2
+package.helix-tui.opt-level = 2
+package.helix-term.opt-level = 2
diff --git a/README.md b/README.md
index b06e82227..cba52a7a1 100644
--- a/README.md
+++ b/README.md
@@ -45,92 +45,10 @@ # Features
 
 # Installation
 
-Packages are available for various distributions (see [Installation docs](https://docs.helix-editor.com/install.html)).
-
-If you would like to build from source:
-
-```shell
-git clone https://github.com/helix-editor/helix
-cd helix
-cargo install --path helix-term
-```
-
-This will install the `hx` binary to `$HOME/.cargo/bin` and build tree-sitter grammars in `./runtime/grammars`.
-
-Helix needs its runtime files so make sure to copy/symlink the `runtime/` directory into the
-config directory (for example `~/.config/helix/runtime` on Linux/macOS, or `%AppData%/helix/runtime` on Windows).
-
-| OS                   | Command                                          |
-| -------------------- | ------------------------------------------------ |
-| Windows (Cmd)        | `xcopy /e /i runtime %AppData%\helix\runtime`    |
-| Windows (PowerShell) | `xcopy /e /i runtime $Env:AppData\helix\runtime` |
-| Linux / macOS        | `ln -s $PWD/runtime ~/.config/helix/runtime`     |
-
-Starting with Windows Vista you can also create symbolic links on Windows. Note that this requires
-elevated privileges - i.e. PowerShell or Cmd must be run as administrator.
-
-**PowerShell:**
-
-```powershell
-New-Item -ItemType SymbolicLink -Target "runtime" -Path "$Env:AppData\helix\runtime"
-```
-
-**Cmd:**
-
-```cmd
-cd %appdata%\helix
-mklink /D runtime "<helix-repo>\runtime"
-```
-
-The runtime location can be overridden via the `HELIX_RUNTIME` environment variable.
-
-> NOTE: if `HELIX_RUNTIME` is set prior to calling `cargo install --path helix-term`,
-> tree-sitter grammars will be built in `$HELIX_RUNTIME/grammars`.
-
-If you plan on keeping the repo locally, an alternative to copying/symlinking
-runtime files is to set `HELIX_RUNTIME=/path/to/helix/runtime`
-(`HELIX_RUNTIME=$PWD/runtime` if you're in the helix repo directory).
-
-Packages already solve this for you by wrapping the `hx` binary with a wrapper
-that sets the variable to the install dir.
-
-> NOTE: running via cargo also doesn't require setting explicit `HELIX_RUNTIME` path, it will automatically
-> detect the `runtime` directory in the project root.
-
-If you want to customize your `languages.toml` config,
-tree-sitter grammars may be manually fetched and built with `hx --grammar fetch` and `hx --grammar build`.
-
-In order to use LSP features like auto-complete, you will need to
-[install the appropriate Language Server](https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers)
-for a language.
+[Installation documentation](https://docs.helix-editor.com/install.html).
 
 [![Packaging status](https://repology.org/badge/vertical-allrepos/helix.svg)](https://repology.org/project/helix/versions)
 
-## Adding Helix to your desktop environment
-
-If installing from source, to use Helix in desktop environments that supports [XDG desktop menu](https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html), including Gnome and KDE, copy the provided `.desktop` file to the correct folder:
-
-```bash
-cp contrib/Helix.desktop ~/.local/share/applications
-```
-
-To use another terminal than the default, you will need to modify the `.desktop` file. For example, to use `kitty`:
-
-```bash
-sed -i "s|Exec=hx %F|Exec=kitty hx %F|g" ~/.local/share/applications/Helix.desktop
-sed -i "s|Terminal=true|Terminal=false|g" ~/.local/share/applications/Helix.desktop
-```
-
-Please note: there is no icon for Helix yet, so the system default will be used.
-
-## macOS
-
-Helix can be installed on macOS through homebrew:
-
-```
-brew install helix
-```
-
 # Contributing
 
 Contributing guidelines can be found [here](./docs/CONTRIBUTING.md).
diff --git a/VERSION b/VERSION
index e70b3aebd..35371314c 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-22.12
\ No newline at end of file
+23.03
\ No newline at end of file
diff --git a/base16_theme.toml b/base16_theme.toml
index 63fc2f790..268a38df6 100644
--- a/base16_theme.toml
+++ b/base16_theme.toml
@@ -7,6 +7,7 @@
 "ui.linenr.selected" = { fg = "white", bg = "black", modifiers = ["bold"] }
 "ui.selection" = { fg = "black", bg = "blue" }
 "ui.selection.primary" = { fg = "white", bg = "blue" }
+"ui.text.inactive" = { fg = "gray" }
 "comment" = { fg = "gray" }
 "ui.statusline" = { fg = "black", bg = "white" }
 "ui.statusline.inactive" = { fg = "gray", bg = "white" }
diff --git a/book/src/SUMMARY.md b/book/src/SUMMARY.md
index eaf0c4f48..6e780b87f 100644
--- a/book/src/SUMMARY.md
+++ b/book/src/SUMMARY.md
@@ -6,13 +6,13 @@ # Summary
 - [Usage](./usage.md)
   - [Keymap](./keymap.md)
   - [Commands](./commands.md)
-  - [Language Support](./lang-support.md)
+  - [Language support](./lang-support.md)
 - [Migrating from Vim](./from-vim.md)
 - [Configuration](./configuration.md)
   - [Themes](./themes.md)
-  - [Key Remapping](./remapping.md)
+  - [Key remapping](./remapping.md)
   - [Languages](./languages.md)
 - [Guides](./guides/README.md)
-  - [Adding Languages](./guides/adding_languages.md)
-  - [Adding Textobject Queries](./guides/textobject.md)
-  - [Adding Indent Queries](./guides/indent.md)
+  - [Adding languages](./guides/adding_languages.md)
+  - [Adding textobject queries](./guides/textobject.md)
+  - [Adding indent queries](./guides/indent.md)
diff --git a/book/src/commands.md b/book/src/commands.md
index d9a113866..047a30a91 100644
--- a/book/src/commands.md
+++ b/book/src/commands.md
@@ -1,5 +1,5 @@
 # Commands
 
-Command mode can be activated by pressing `:`, similar to Vim. Built-in commands:
+Command mode can be activated by pressing `:`. The built-in commands are:
 
 {{#include ./generated/typable-cmd.md}}
diff --git a/book/src/configuration.md b/book/src/configuration.md
index 0890d2832..4c8ff0647 100644
--- a/book/src/configuration.md
+++ b/book/src/configuration.md
@@ -2,10 +2,10 @@ # Configuration
 
 To override global configuration parameters, create a `config.toml` file located in your config directory:
 
-* Linux and Mac: `~/.config/helix/config.toml`
-* Windows: `%AppData%\helix\config.toml`
+- Linux and Mac: `~/.config/helix/config.toml`
+- Windows: `%AppData%\helix\config.toml`
 
-> Hint: You can easily open the config file by typing `:config-open` within Helix normal mode.
+>  You can easily open the config file by typing `:config-open` within Helix normal mode.
 
 Example config:
 
@@ -25,12 +25,13 @@ # Configuration
 hidden = false
 ```
 
-You may also specify a file to use for configuration with the `-c` or
-`--config` CLI argument: `hx -c path/to/custom-config.toml`.
+You can use a custom configuration file by specifying it with the `-c` or
+`--config` command line argument, for example `hx -c path/to/custom-config.toml`.
+Additionally, you can reload the configuration file by sending the USR1
+signal to the Helix process on Unix operating systems, such as by using the command `pkill -USR1 hx`.
 
-It is also possible to trigger configuration file reloading by sending the `USR1`
-signal to the helix process, e.g. via `pkill -USR1 hx`. This is only supported 
-on unix operating systems.
+Finally, you can have a `config.toml` local to a project by putting it under a `.helix` directory in your repository.
+Its settings will be merged with the configuration directory `config.toml` and the built-in configuration.
 
 ## Editor
 
@@ -38,25 +39,29 @@ ### `[editor]` Section
 
 | Key | Description | Default |
 |--|--|---------|
-| `scrolloff` | Number of lines of padding around the edge of the screen when scrolling. | `5` |
-| `mouse` | Enable mouse mode. | `true` |
-| `middle-click-paste` | Middle click paste support. | `true` |
-| `scroll-lines` | Number of lines to scroll per scroll wheel step. | `3` |
-| `shell` | Shell to use when running external commands. | Unix: `["sh", "-c"]`<br/>Windows: `["cmd", "/C"]` |
-| `line-number` | Line number display: `absolute` simply shows each line's number, while `relative` shows the distance from the current line. When unfocused or in insert mode, `relative` will still show absolute line numbers. | `absolute` |
-| `cursorline` | Highlight all lines with a cursor. | `false` |
-| `cursorcolumn` | Highlight all columns with a cursor. | `false` |
+| `scrolloff` | Number of lines of padding around the edge of the screen when scrolling | `5` |
+| `mouse` | Enable mouse mode | `true` |
+| `middle-click-paste` | Middle click paste support | `true` |
+| `scroll-lines` | Number of lines to scroll per scroll wheel step | `3` |
+| `shell` | Shell to use when running external commands | Unix: `["sh", "-c"]`<br/>Windows: `["cmd", "/C"]` |
+| `line-number` | Line number display: `absolute` simply shows each line's number, while `relative` shows the distance from the current line. When unfocused or in insert mode, `relative` will still show absolute line numbers | `absolute` |
+| `cursorline` | Highlight all lines with a cursor | `false` |
+| `cursorcolumn` | Highlight all columns with a cursor | `false` |
 | `gutters` | Gutters to display: Available are `diagnostics` and `diff` and `line-numbers` and `spacer`, note that `diagnostics` also includes other features like breakpoints, 1-width padding will be inserted if gutters is non-empty | `["diagnostics", "spacer", "line-numbers", "spacer", "diff"]` |
-| `auto-completion` | Enable automatic pop up of auto-completion. | `true` |
-| `auto-format` | Enable automatic formatting on save. | `true` |
-| `auto-save` | Enable automatic saving on focus moving away from Helix. Requires [focus event support](https://github.com/helix-editor/helix/wiki/Terminal-Support) from your terminal. | `false` |
-| `idle-timeout` | Time in milliseconds since last keypress before idle timers trigger. Used for autocompletion, set to 0 for instant. | `400` |
+| `auto-completion` | Enable automatic pop up of auto-completion | `true` |
+| `auto-format` | Enable automatic formatting on save | `true` |
+| `auto-save` | Enable automatic saving on the focus moving away from Helix. Requires [focus event support](https://github.com/helix-editor/helix/wiki/Terminal-Support) from your terminal | `false` |
+| `idle-timeout` | Time in milliseconds since last keypress before idle timers trigger. Used for autocompletion, set to 0 for instant | `400` |
 | `completion-trigger-len` | The min-length of word under cursor to trigger autocompletion | `2` |
-| `auto-info` | Whether to display infoboxes | `true` |
-| `true-color` | Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative. | `false` |
-| `rulers` | List of column positions at which to display the rulers. Can be overridden by language specific `rulers` in `languages.toml` file. | `[]` |
+| `completion-replace` | Set to `true` to make completions always replace the entire word and not just the part before the cursor | `false` |
+| `auto-info` | Whether to display info boxes | `true` |
+| `true-color` | Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative | `false` |
+| `undercurl` | Set to `true` to override automatic detection of terminal undercurl support in the event of a false negative | `false` |
+| `rulers` | List of column positions at which to display the rulers. Can be overridden by language specific `rulers` in `languages.toml` file | `[]` |
 | `bufferline` | Renders a line at the top of the editor displaying open buffers. Can be `always`, `never` or `multiple` (only shown if more than one buffer is in use) | `never` |
 | `color-modes` | Whether to color the mode indicator with different colors depending on the mode itself | `false` |
+| `text-width` | Maximum line length. Used for the `:reflow` command and soft-wrapping if `soft-wrap.wrap_at_text_width` is set | `80` |
+| `workspace-lsp-roots` | Directories relative to the workspace root that are treated as LSP roots. Should only be set in `.helix/config.toml` | `[]` |
 
 ### `[editor.statusline]` Section
 
@@ -97,6 +102,8 @@ ### `[editor.statusline]` Section
 | `mode` | The current editor mode (`mode.normal`/`mode.insert`/`mode.select`) |
 | `spinner` | A progress spinner indicating LSP activity |
 | `file-name` | The path/name of the opened file |
+| `file-base-name` | The basename of the opened file |
+| `file-modification-indicator` | The indicator to show whether the file is modified (a `[+]` appears when there are unsaved changes) |
 | `file-encoding` | The encoding of the opened file if it differs from UTF-8 |
 | `file-line-ending` | The file line endings (CRLF or LF) |
 | `total-line-numbers` | The total line numbers of the opened file |
@@ -109,23 +116,31 @@ ### `[editor.statusline]` Section
 | `position-percentage` | The cursor position as a percentage of the total number of lines |
 | `separator` | The string defined in `editor.statusline.separator` (defaults to `""`) |
 | `spacer` | Inserts a space between elements (multiple/contiguous spacers may be specified) |
+| `version-control` | The current branch name or detached commit hash of the opened workspace |
 
 ### `[editor.lsp]` Section
 
 | Key                   | Description                                                 | Default |
 | ---                   | -----------                                                 | ------- |
+| `enable`              | Enables LSP integration. Setting to false will completely disable language servers regardless of language settings.| `true` |
 | `display-messages`    | Display LSP progress messages below statusline[^1]          | `false` |
 | `auto-signature-help` | Enable automatic popup of signature help (parameter hints)  | `true`  |
+| `display-inlay-hints` | Display inlay hints[^2]                                     | `false` |
 | `display-signature-help-docs` | Display docs under signature help popup             | `true`  |
+| `snippets`      | Enables snippet completions. Requires a server restart (`:lsp-restart`) to take effect after `:config-reload`/`:set`. | `true`  |
 
 [^1]: By default, a progress spinner is shown in the statusline beside the file path.
+[^2]: You may also have to activate them in the LSP config for them to appear, not just in Helix.
+      Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances, please report any bugs you see so we can fix them!
 
 ### `[editor.cursor-shape]` Section
 
-Defines the shape of cursor in each mode. Note that due to limitations
-of the terminal environment, only the primary cursor can change shape.
+Defines the shape of cursor in each mode.
 Valid values for these options are `block`, `bar`, `underline`, or `hidden`.
 
+>  Due to limitations of the terminal environment, only the primary cursor can
+> change shape.
+
 | Key      | Description                                | Default |
 | ---      | -----------                                | ------- |
 | `normal` | Cursor shape in [normal mode][normal mode] | `block` |
@@ -138,23 +153,22 @@ ### `[editor.cursor-shape]` Section
 
 ### `[editor.file-picker]` Section
 
-Sets options for file picker and global search. All but the last key listed in
-the default file-picker configuration below are IgnoreOptions: whether hidden
-files and files listed within ignore files are ignored by (not visible in) the
-helix file picker and global search. There is also one other key, `max-depth`
-available, which is not defined by default.
+Set options for file picker and global search. Ignoring a file means it is
+not visible in the Helix file picker and global search.
 
 All git related options are only enabled in a git repository.
 
 | Key | Description | Default |
 |--|--|---------|
-|`hidden` | Enables ignoring hidden files. | true
-|`parents` | Enables reading ignore files from parent directories. | true
-|`ignore` | Enables reading `.ignore` files. | true
-|`git-ignore` | Enables reading `.gitignore` files. | true
-|`git-global` | Enables reading global .gitignore, whose path is specified in git's config: `core.excludefile` option. | true
-|`git-exclude` | Enables reading `.git/info/exclude` files. | true
-|`max-depth` | Set with an integer value for maximum depth to recurse. | Defaults to `None`.
+|`hidden` | Enables ignoring hidden files | true
+|`follow-links` | Follow symlinks instead of ignoring them | true
+|`deduplicate-links` | Ignore symlinks that point at files already shown in the picker | true
+|`parents` | Enables reading ignore files from parent directories | true
+|`ignore` | Enables reading `.ignore` files | true
+|`git-ignore` | Enables reading `.gitignore` files | true
+|`git-global` | Enables reading global `.gitignore`, whose path is specified in git's config: `core.excludefile` option | true
+|`git-exclude` | Enables reading `.git/info/exclude` files | true
+|`max-depth` | Set with an integer value for maximum depth to recurse | Defaults to `None`.
 
 ### `[editor.auto-pairs]` Section
 
@@ -206,7 +220,7 @@ ### `[editor.search]` Section
 
 | Key | Description | Default |
 |--|--|---------|
-| `smart-case` | Enable smart case regex searching (case insensitive unless pattern contains upper case characters) | `true` |
+| `smart-case` | Enable smart case regex searching (case-insensitive unless pattern contains upper case characters) | `true` |
 | `wrap-around`| Whether the search should wrap after depleting the matches | `true` |
 
 ### `[editor.whitespace]` Section
@@ -215,7 +229,7 @@ ### `[editor.whitespace]` Section
 
 | Key | Description | Default |
 |-----|-------------|---------|
-| `render` | Whether to render whitespace. May either be `"all"` or `"none"`, or a table with sub-keys `space`, `tab`, and `newline`. | `"none"` |
+| `render` | Whether to render whitespace. May either be `"all"` or `"none"`, or a table with sub-keys `space`, `nbsp`, `tab`, and `newline` | `"none"` |
 | `characters` | Literal characters to use when rendering whitespace. Sub-keys may be any of `tab`, `space`, `nbsp`, `newline` or `tabpad` | See example below |
 
 Example
@@ -243,7 +257,7 @@ ### `[editor.indent-guides]` Section
 
 | Key           | Description                                             | Default |
 | ---           | ---                                                     | ---     |
-| `render`      | Whether to render indent guides.                        | `false` |
+| `render`      | Whether to render indent guides                         | `false` |
 | `character`   | Literal character to use for rendering the indent guide | ``     |
 | `skip-levels` | Number of indent levels to skip                         | `0`     |
 
@@ -255,3 +269,77 @@ ### `[editor.indent-guides]` Section
 character = "" # Some characters that work well: "", "", "", ""
 skip-levels = 1
 ```
+
+### `[editor.gutters]` Section
+
+For simplicity, `editor.gutters` accepts an array of gutter types, which will
+use default settings for all gutter components.
+
+```toml
+[editor]
+gutters = ["diff", "diagnostics", "line-numbers", "spacer"]
+```
+
+To customize the behavior of gutters, the `[editor.gutters]` section must
+be used. This section contains top level settings, as well as settings for
+specific gutter components as subsections.
+
+| Key      | Description                    | Default                                                       |
+| ---      | ---                            | ---                                                           |
+| `layout` | A vector of gutters to display | `["diagnostics", "spacer", "line-numbers", "spacer", "diff"]` |
+
+Example:
+
+```toml
+[editor.gutters]
+layout = ["diff", "diagnostics", "line-numbers", "spacer"]
+```
+
+#### `[editor.gutters.line-numbers]` Section
+
+Options for the line number gutter
+
+| Key         | Description                             | Default |
+| ---         | ---                                     | ---     |
+| `min-width` | The minimum number of characters to use | `3`     |
+
+Example:
+
+```toml
+[editor.gutters.line-numbers]
+min-width = 1
+```
+
+#### `[editor.gutters.diagnostics]` Section
+
+Currently unused
+
+#### `[editor.gutters.diff]` Section
+
+Currently unused
+
+#### `[editor.gutters.spacer]` Section
+
+Currently unused
+
+### `[editor.soft-wrap]` Section
+
+Options for soft wrapping lines that exceed the view width:
+
+| Key                  | Description                                                  | Default |
+| ---                  | ---                                                          | ---     |
+| `enable`             | Whether soft wrapping is enabled.                            | `false` |
+| `max-wrap`           | Maximum free space left at the end of the line.              | `20`    |
+| `max-indent-retain`  | Maximum indentation to carry over when soft wrapping a line. | `40`    |
+| `wrap-indicator`     | Text inserted before soft wrapped lines, highlighted with `ui.virtual.wrap` | ` `    |
+| `wrap-at-text-width` | Soft wrap at `text-width` instead of using the full viewport size. | `false` |
+
+Example:
+
+```toml
+[editor.soft-wrap]
+enable = true
+max-wrap = 25 # increase value to reduce forced mid-word wrapping
+max-indent-retain = 0
+wrap-indicator = ""  # set wrap-indicator to "" to hide it
+```
diff --git a/book/src/generated/lang-support.md b/book/src/generated/lang-support.md
index 4dca81047..3f56dd606 100644
--- a/book/src/generated/lang-support.md
+++ b/book/src/generated/lang-support.md
@@ -2,7 +2,7 @@
 | --- | --- | --- | --- | --- |
 | astro |  |  |  |  |
 | awk |  |  |  | `awk-language-server` |
-| bash |  |  |  | `bash-language-server` |
+| bash |  |  |  | `bash-language-server` |
 | bass |  |  |  | `bass` |
 | beancount |  |  |  |  |
 | bibtex |  |  |  | `texlab` |
@@ -10,17 +10,20 @@
 | c |  |  |  | `clangd` |
 | c-sharp |  |  |  | `OmniSharp` |
 | cairo |  |  |  |  |
+| capnp |  |  |  |  |
 | clojure |  |  |  | `clojure-lsp` |
 | cmake |  |  |  | `cmake-language-server` |
 | comment |  |  |  |  |
 | common-lisp |  |  |  | `cl-lsp` |
 | cpon |  |  |  |  |
 | cpp |  |  |  | `clangd` |
+| crystal |  |  |  |  |
 | css |  |  |  | `vscode-css-language-server` |
 | cue |  |  |  | `cuelsp` |
 | d |  |  |  | `serve-d` |
 | dart |  |  |  | `dart` |
 | devicetree |  |  |  |  |
+| dhall |  |  |  | `dhall-lsp-server` |
 | diff |  |  |  |  |
 | dockerfile |  |  |  | `docker-langserver` |
 | dot |  |  |  | `dot-language-server` |
@@ -28,7 +31,7 @@
 | eex |  |  |  |  |
 | ejs |  |  |  |  |
 | elixir |  |  |  | `elixir-ls` |
-| elm |  |  |  | `elm-language-server` |
+| elm |  |  |  | `elm-language-server` |
 | elvish |  |  |  | `elvish` |
 | env |  |  |  |  |
 | erb |  |  |  |  |
@@ -36,9 +39,9 @@
 | esdl |  |  |  |  |
 | fish |  |  |  |  |
 | fortran |  |  |  | `fortls` |
-| gdscript |  |  |  |  |
+| gdscript |  |  |  |  |
 | git-attributes |  |  |  |  |
-| git-commit |  |  |  |  |
+| git-commit |  |  |  |  |
 | git-config |  |  |  |  |
 | git-ignore |  |  |  |  |
 | git-rebase |  |  |  |  |
@@ -54,7 +57,9 @@
 | haskell |  |  |  | `haskell-language-server-wrapper` |
 | hcl |  |  |  | `terraform-ls` |
 | heex |  |  |  | `elixir-ls` |
+| hosts |  |  |  |  |
 | html |  |  |  | `vscode-html-language-server` |
+| hurl |  |  |  |  |
 | idris |  |  |  | `idris2-lsp` |
 | iex |  |  |  |  |
 | ini |  |  |  |  |
@@ -64,7 +69,7 @@
 | json |  |  |  | `vscode-json-language-server` |
 | jsonnet |  |  |  | `jsonnet-language-server` |
 | jsx |  |  |  | `typescript-language-server` |
-| julia |  |  |  | `julia` |
+| julia |  |  |  | `julia` |
 | kdl |  |  |  |  |
 | kotlin |  |  |  | `kotlin-language-server` |
 | latex |  |  |  | `texlab` |
@@ -77,9 +82,14 @@
 | make |  |  |  |  |
 | markdown |  |  |  | `marksman` |
 | markdown.inline |  |  |  |  |
+| matlab |  |  |  |  |
+| mermaid |  |  |  |  |
 | meson |  |  |  |  |
 | mint |  |  |  | `mint` |
+| msbuild |  |  |  |  |
+| nasm |  |  |  |  |
 | nickel |  |  |  | `nls` |
+| nim |  |  |  | `nimlangserver` |
 | nix |  |  |  | `nil` |
 | nu |  |  |  |  |
 | ocaml |  |  |  | `ocamllsp` |
@@ -88,45 +98,58 @@
 | openscad |  |  |  | `openscad-lsp` |
 | org |  |  |  |  |
 | pascal |  |  |  | `pasls` |
+| passwd |  |  |  |  |
+| pem |  |  |  |  |
 | perl |  |  |  |  |
 | php |  |  |  | `intelephense` |
+| po |  |  |  |  |
+| ponylang |  |  |  |  |
 | prisma |  |  |  | `prisma-language-server` |
 | prolog |  |  |  | `swipl` |
 | protobuf |  |  |  |  |
+| prql |  |  |  |  |
 | purescript |  |  |  | `purescript-language-server` |
 | python |  |  |  | `pylsp` |
 | qml |  |  |  | `qmlls` |
 | r |  |  |  | `R` |
 | racket |  |  |  | `racket` |
 | regex |  |  |  |  |
+| rego |  |  |  | `regols` |
 | rescript |  |  |  | `rescript-language-server` |
 | rmarkdown |  |  |  | `R` |
+| robot |  |  |  | `robotframework_ls` |
 | ron |  |  |  |  |
+| rst |  |  |  |  |
 | ruby |  |  |  | `solargraph` |
 | rust |  |  |  | `rust-analyzer` |
+| sage |  |  |  |  |
 | scala |  |  |  | `metals` |
 | scheme |  |  |  |  |
 | scss |  |  |  | `vscode-css-language-server` |
 | slint |  |  |  | `slint-lsp` |
+| smithy |  |  |  | `cs` |
 | sml |  |  |  |  |
 | solidity |  |  |  | `solc` |
 | sql |  |  |  |  |
 | sshclientconfig |  |  |  |  |
 | starlark |  |  |  |  |
 | svelte |  |  |  | `svelteserver` |
+| sway |  |  |  | `forc` |
 | swift |  |  |  | `sourcekit-lsp` |
 | tablegen |  |  |  |  |
 | task |  |  |  |  |
-| tfvars |  |  |  | `terraform-ls` |
+| tfvars |  |  |  | `terraform-ls` |
 | toml |  |  |  | `taplo` |
 | tsq |  |  |  |  |
 | tsx |  |  |  | `typescript-language-server` |
 | twig |  |  |  |  |
 | typescript |  |  |  | `typescript-language-server` |
 | ungrammar |  |  |  |  |
-| v |  |  |  | `vls` |
+| uxntal |  |  |  |  |
+| v |  |  |  | `v` |
 | vala |  |  |  | `vala-language-server` |
 | verilog |  |  |  | `svlangserver` |
+| vhdl |  |  |  | `vhdl_ls` |
 | vhs |  |  |  |  |
 | vue |  |  |  | `vls` |
 | wast |  |  |  |  |
@@ -136,4 +159,5 @@
 | xit |  |  |  |  |
 | xml |  |  |  |  |
 | yaml |  |  |  | `yaml-language-server` |
+| yuck |  |  |  |  |
 | zig |  |  |  | `zls` |
diff --git a/book/src/generated/typable-cmd.md b/book/src/generated/typable-cmd.md
index 66e6ac039..9d15b83c9 100644
--- a/book/src/generated/typable-cmd.md
+++ b/book/src/generated/typable-cmd.md
@@ -43,11 +43,13 @@
 | `:change-current-directory`, `:cd` | Change the current working directory. |
 | `:show-directory`, `:pwd` | Show the current working directory. |
 | `:encoding` | Set encoding. Based on `https://encoding.spec.whatwg.org`. |
+| `:character-info`, `:char` | Get info about the character under the primary cursor. |
 | `:reload` | Discard changes and reload from the source file. |
 | `:reload-all` | Discard changes and reload all documents from the source files. |
 | `:update` | Write changes only if the file has been modified. |
 | `:lsp-workspace-command` | Open workspace command picker |
 | `:lsp-restart` | Restarts the Language Server that is in use by the current doc |
+| `:lsp-stop` | Stops the Language Server that is in use by the current doc |
 | `:tree-sitter-scopes` | Display tree sitter scopes, primarily for theming and development. |
 | `:debug-start`, `:dbg` | Start a debug session from a given template with given parameters. |
 | `:debug-remote`, `:dbg-tcp` | Connect to a debug adapter by TCP address and start a debugging session from a given template with given parameters. |
@@ -58,8 +60,9 @@
 | `:hsplit-new`, `:hnew` | Open a scratch buffer in a horizontal split. |
 | `:tutor` | Open the tutorial. |
 | `:goto`, `:g` | Goto line number. |
-| `:set-language`, `:lang` | Set the language of current buffer. |
+| `:set-language`, `:lang` | Set the language of current buffer (show current language if no value specified). |
 | `:set-option`, `:set` | Set a config option at runtime.<br>For example to disable smart case search, use `:set search.smart-case false`. |
+| `:toggle-option`, `:toggle` | Toggle a boolean config option at runtime.<br>For example to toggle smart case search, use `:toggle search.smart-case`. |
 | `:get-option`, `:get` | Get the current value of a config option. |
 | `:sort` | Sort ranges in selection. |
 | `:rsort` | Sort ranges in selection in reverse order. |
@@ -67,9 +70,11 @@
 | `:tree-sitter-subtree`, `:ts-subtree` | Display tree sitter subtree under cursor, primarily for debugging queries. |
 | `:config-reload` | Refresh user config. |
 | `:config-open` | Open the user config.toml file. |
+| `:config-open-workspace` | Open the workspace config.toml file. |
 | `:log-open` | Open the helix log file. |
 | `:insert-output` | Run shell command, inserting output before each selection. |
 | `:append-output` | Run shell command, appending output after each selection. |
 | `:pipe` | Pipe each selection to the shell command. |
 | `:pipe-to` | Pipe each selection to the shell command, ignoring output. |
 | `:run-shell-command`, `:sh` | Run a shell command |
+| `:reset-diff-change`, `:diffget`, `:diffg` | Reset the diff change at the cursor position. |
diff --git a/book/src/guides/README.md b/book/src/guides/README.md
index e0c44ce7d..c25768e68 100644
--- a/book/src/guides/README.md
+++ b/book/src/guides/README.md
@@ -1,4 +1,4 @@
 # Guides
 
 This section contains guides for adding new language server configurations,
-tree-sitter grammars, textobject queries, etc.
+tree-sitter grammars, textobject queries, and other similar items.
diff --git a/book/src/guides/adding_languages.md b/book/src/guides/adding_languages.md
index 6598b9bf7..b92af4028 100644
--- a/book/src/guides/adding_languages.md
+++ b/book/src/guides/adding_languages.md
@@ -1,45 +1,52 @@
-# Adding languages
+# Adding new languages to Helix
+
+In order to add a new language to Helix, you will need to follow the steps
+below.
 
 ## Language configuration
 
-To add a new language, you need to add a `[[language]]` entry to the
-`languages.toml` (see the [language configuration section]).
+1. Add a new `[[language]]` entry in the `languages.toml` file and provide the
+   necessary configuration for the new language. For more information on
+   language configuration, refer to the
+   [language configuration section](../languages.md) of the documentation.
+2. If you are adding a new language or updating an existing language server
+   configuration, run the command `cargo xtask docgen` to update the
+   [Language Support](../lang-support.md) documentation.
 
-When adding a new language or Language Server configuration for an existing
-language, run `cargo xtask docgen` to add the new configuration to the
-[Language Support][lang-support] docs before creating a pull request.
-When adding a Language Server configuration, be sure to update the
-[Language Server Wiki][install-lsp-wiki] with installation notes.
+>  If you are adding a new Language Server configuration, make sure to update
+> the
+> [Language Server Wiki](https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers)
+> with the installation instructions.
 
 ## Grammar configuration
 
-If a tree-sitter grammar is available for the language, add a new `[[grammar]]`
-entry to `languages.toml`.
-
-You may use the `source.path` key rather than `source.git` with an absolute path
-to a locally available grammar for testing, but switch to `source.git` before
-submitting a pull request.
+1. If a tree-sitter grammar is available for the new language, add a new
+   `[[grammar]]` entry to the `languages.toml` file.
+2. If you are testing the grammar locally, you can use the `source.path` key
+   with an absolute path to the grammar. However, before submitting a pull
+   request, make sure to switch to using `source.git`.
 
 ## Queries
 
-For a language to have syntax-highlighting and indentation among
-other things, you have to add queries. Add a directory for your
-language with the path `runtime/queries/<name>/`. The tree-sitter
-[website](https://tree-sitter.github.io/tree-sitter/syntax-highlighting#queries)
-gives more info on how to write queries.
-
-> NOTE: When evaluating queries, the first matching query takes
-precedence, which is different from other editors like Neovim where
-the last matching query supersedes the ones before it. See
-[this issue][neovim-query-precedence] for an example.
-
-## Common Issues
-
-- If you get errors when running after switching branches, you may have to update the tree-sitter grammars. Run `hx --grammar fetch` to fetch the grammars and `hx --grammar build` to build any out-of-date grammars.
-
-- If a parser is segfaulting or you want to remove the parser, make sure to remove the compiled parser in `runtime/grammar/<name>.so`
-
-[language configuration section]: ../languages.md
-[neovim-query-precedence]: https://github.com/helix-editor/helix/pull/1170#issuecomment-997294090
-[install-lsp-wiki]: https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers
-[lang-support]: ../lang-support.md
+1. In order to provide syntax highlighting and indentation for the new language,
+   you will need to add queries.
+2. Create a new directory for the language with the path
+   `runtime/queries/<name>/`.
+3. Refer to the
+   [tree-sitter website](https://tree-sitter.github.io/tree-sitter/syntax-highlighting#queries)
+   for more information on writing queries.
+
+>  In Helix, the first matching query takes precedence when evaluating
+> queries, which is different from other editors such as Neovim where the last
+> matching query supersedes the ones before it. See
+> [this issue](https://github.com/helix-editor/helix/pull/1170#issuecomment-997294090)
+> for an example.
+
+## Common issues
+
+- If you encounter errors when running Helix after switching branches, you may
+  need to update the tree-sitter grammars. Run the command `hx --grammar fetch`
+  to fetch the grammars and `hx --grammar build` to build any out-of-date
+  grammars.
+- If a parser is causing a segfault, or you want to remove it, make sure to
+  remove the compiled parser located at `runtime/grammars/<name>.so`.
diff --git a/book/src/guides/indent.md b/book/src/guides/indent.md
index 0e2592897..b660d7857 100644
--- a/book/src/guides/indent.md
+++ b/book/src/guides/indent.md
@@ -1,4 +1,4 @@
-# Adding Indent Queries
+# Adding indent queries
 
 Helix uses tree-sitter to correctly indent new lines. This requires
 a tree-sitter grammar and an `indent.scm` query file placed in
@@ -36,7 +36,7 @@ ## Scopes
   (#set! "scope" "all"))
 ```
 
-## Capture Types
+## Capture types
 
 - `@indent` (default scope `tail`):
 Increase the indent level by 1. Multiple occurrences in the same line
diff --git a/book/src/guides/textobject.md b/book/src/guides/textobject.md
index 8a2173547..405f11c1b 100644
--- a/book/src/guides/textobject.md
+++ b/book/src/guides/textobject.md
@@ -1,14 +1,14 @@
-# Adding Textobject Queries
+# Adding textobject queries
 
-Textobjects that are language specific ([like functions, classes, etc][textobjects])
-require an accompanying tree-sitter grammar and a `textobjects.scm` query file
+Helix supports textobjects that are language specific, such as functions, classes, etc.
+These textobjects require an accompanying tree-sitter grammar and a `textobjects.scm` query file
 to work properly. Tree-sitter allows us to query the source code syntax tree
 and capture specific parts of it. The queries are written in a lisp dialect.
 More information on how to write queries can be found in the [official tree-sitter
 documentation][tree-sitter-queries].
 
 Query files should be placed in `runtime/queries/{language}/textobjects.scm`
-when contributing. Note that to test the query files locally you should put
+when contributing to Helix. Note that to test the query files locally you should put
 them under your local runtime directory (`~/.config/helix/runtime` on Linux
 for example).
 
@@ -28,9 +28,9 @@ # Adding Textobject Queries
 
 [Example query files][textobject-examples] can be found in the helix GitHub repository.
 
-## Queries for Textobject Based Navigation
+## Queries for textobject based navigation
 
-[Tree-sitter based navigation][textobjects-nav] is done using captures in the
+Tree-sitter based navigation in Helix is done using captures in the
 following order:
 
 - `object.movement`
@@ -38,12 +38,10 @@ ## Queries for Textobject Based Navigation
 - `object.inside`
 
 For example if a `function.around` capture has been already defined for a language
-in it's `textobjects.scm` file, function navigation should also work automatically.
+in its `textobjects.scm` file, function navigation should also work automatically.
 `function.movement` should be defined only if the node captured by `function.around`
 doesn't make sense in a navigation context.
 
-[textobjects]: ../usage.md#textobjects
-[textobjects-nav]: ../usage.md#tree-sitter-textobject-based-navigation
 [tree-sitter-queries]: https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax
 [tree-sitter-captures]: https://tree-sitter.github.io/tree-sitter/using-parsers#capturing-nodes
 [textobject-examples]: https://github.com/search?q=repo%3Ahelix-editor%2Fhelix+filename%3Atextobjects.scm&type=Code&ref=advsearch&l=&l=
diff --git a/book/src/install.md b/book/src/install.md
index 44f13584e..a0e24de72 100644
--- a/book/src/install.md
+++ b/book/src/install.md
@@ -1,167 +1,250 @@
-# Installation
-
-We provide pre-built binaries on the [GitHub Releases page](https://github.com/helix-editor/helix/releases).
+# Installing Helix
+
+<!--toc:start-->
+- [Pre-built binaries](#pre-built-binaries)
+- [Linux, macOS, Windows and OpenBSD packaging status](#linux-macos-windows-and-openbsd-packaging-status)
+- [Linux](#linux)
+  - [Ubuntu](#ubuntu)
+  - [Fedora/RHEL](#fedorarhel)
+  - [Arch Linux community](#arch-linux-community)
+  - [NixOS](#nixos)
+  - [AppImage](#appimage)
+- [macOS](#macos)
+  - [Homebrew Core](#homebrew-core)
+- [Windows](#windows)
+  - [Scoop](#scoop)
+  - [Chocolatey](#chocolatey)
+  - [MSYS2](#msys2)
+- [Building from source](#building-from-source)
+  - [Configuring Helix's runtime files](#configuring-helixs-runtime-files)
+  - [Validating the installation](#validating-the-installation)
+  - [Configure the desktop shortcut](#configure-the-desktop-shortcut)
+<!--toc:end-->
+
+To install Helix, follow the instructions specific to your operating system.
+Note that:
+
+- To get the latest nightly version of Helix, you need to
+  [build from source](#building-from-source).
+
+- To take full advantage of Helix, install the language servers for your
+  preferred programming languages. See the
+  [wiki](https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers)
+  for instructions.
+
+## Pre-built binaries
+
+Download pre-built binaries from the
+[GitHub Releases page](https://github.com/helix-editor/helix/releases). Add the binary to your system's `$PATH` to use it from the command
+line.
+
+## Linux, macOS, Windows and OpenBSD packaging status
+
+Helix is available for Linux, macOS and Windows via the official repositories listed below.
 
 [![Packaging status](https://repology.org/badge/vertical-allrepos/helix.svg)](https://repology.org/project/helix/versions)
 
-## OSX
+## Linux
 
-Helix is available in homebrew-core:
+The following third party repositories are available:
 
-```
-brew install helix
+### Ubuntu
+
+Helix is available via [Maveonair's PPA](https://launchpad.net/~maveonair/+archive/ubuntu/helix-editor):
+
+```sh
+sudo add-apt-repository ppa:maveonair/helix-editor
+sudo apt update
+sudo apt install helix
 ```
 
-## Linux
+### Fedora/RHEL
 
-### NixOS
+Helix is available via `copr`:
 
-A [flake](https://nixos.wiki/wiki/Flakes) containing the package is available in
-the project root. The flake can also be used to spin up a reproducible development
-shell for working on Helix with `nix develop`.
+```sh
+sudo dnf copr enable varlad/helix
+sudo dnf install helix
+```
 
-Flake outputs are cached for each push to master using
-[Cachix](https://www.cachix.org/). The flake is configured to
-automatically make use of this cache assuming the user accepts
-the new settings on first use.
+### Arch Linux community
 
-If you are using a version of Nix without flakes enabled you can
-[install Cachix cli](https://docs.cachix.org/installation); `cachix use helix` will
-configure Nix to use cached outputs when possible.
+Releases are available in the `community` repository:
 
-### Arch Linux
+```sh
+sudo pacman -S helix
+```
+Additionally, a [helix-git](https://aur.archlinux.org/packages/helix-git/) package is available
+in the AUR, which builds the master branch.
 
-Releases are available in the `community` repository.
+### NixOS
 
-A [helix-git](https://aur.archlinux.org/packages/helix-git/) package is also available on the AUR, which builds the master branch.
+Helix is available as a [flake](https://nixos.wiki/wiki/Flakes) in the project
+root. Use `nix develop` to spin up a reproducible development shell. Outputs are
+cached for each push to master using [Cachix](https://www.cachix.org/). The
+flake is configured to automatically make use of this cache assuming the user
+accepts the new settings on first use.
 
-### Fedora Linux
+If you are using a version of Nix without flakes enabled,
+[install Cachix CLI](https://docs.cachix.org/installation) and use
+`cachix use helix` to configure Nix to use cached outputs when possible.
 
-You can install the COPR package for Helix via
+### AppImage
 
+Install Helix using [AppImage](https://appimage.org/).
+Download Helix AppImage from the [latest releases](https://github.com/helix-editor/helix/releases/latest) page.
+
+```sh
+chmod +x helix-*.AppImage # change permission for executable mode
+./helix-*.AppImage # run helix
 ```
-sudo dnf copr enable varlad/helix
-sudo dnf install helix
-```
+ 
+## macOS
 
-### Void Linux
+### Homebrew Core
 
-```
-sudo xbps-install helix
+```sh
+brew install helix
 ```
 
 ## Windows
 
-Helix can be installed using [Scoop](https://scoop.sh/), [Chocolatey](https://chocolatey.org/)
+Install on Windows using [Scoop](https://scoop.sh/), [Chocolatey](https://chocolatey.org/)
 or [MSYS2](https://msys2.org/).
 
-**Scoop:**
+### Scoop
 
-```
+```sh
 scoop install helix
 ```
 
-**Chocolatey:**
+### Chocolatey
 
-```
+```sh
 choco install helix
 ```
 
-**MSYS2:**
+### MSYS2
 
-```
-pacman -S mingw-w64-i686-helix
+For 64-bit Windows 8.1 or above:
+
+```sh
+pacman -S mingw-w64-ucrt-x86_64-helix
 ```
 
-or
+## Building from source
 
-```
-pacman -S mingw-w64-x86_64-helix
+Clone the repository:
+
+```sh
+git clone https://github.com/helix-editor/helix
+cd helix
 ```
 
-or
+Compile from source:
 
-```
-pacman -S mingw-w64-ucrt-x86_64-helix
+```sh
+cargo install --path helix-term --locked
 ```
 
-## Build from source
+This command will create the `hx` executable and construct the tree-sitter
+grammars in the local `runtime` folder. To build the tree-sitter grammars requires
+a c++ compiler to be installed, for example `gcc-c++`.
 
-```
-git clone https://github.com/helix-editor/helix
-cd helix
-cargo install --path helix-term
-```
+>  If you are using the musl-libc instead of glibc the following environment variable must be set during the build
+> to ensure tree-sitter grammars can be loaded correctly:
+>
+> ```sh
+> RUSTFLAGS="-C target-feature=-crt-static"
+> ```
 
-This will install the `hx` binary to `$HOME/.cargo/bin` and build tree-sitter grammars in `./runtime/grammars`.
+>  Tree-sitter grammars can be fetched and compiled if not pre-packaged. Fetch
+> grammars with `hx --grammar fetch` (requires `git`) and compile them with
+> `hx --grammar build` (requires a C++ compiler). This will install them in
+> the `runtime` directory within the user's helix config directory (more
+> [details below](#multiple-runtime-directories)).
 
-Helix also needs its runtime files so make sure to copy/symlink the `runtime/` directory into the
-config directory (for example `~/.config/helix/runtime` on Linux/macOS). This location can be overridden
-via the `HELIX_RUNTIME` environment variable.
+### Configuring Helix's runtime files
 
-| OS                   | Command                                          |
-| -------------------- | ------------------------------------------------ |
-| Windows (Cmd)        | `xcopy /e /i runtime %AppData%\helix\runtime`    |
-| Windows (PowerShell) | `xcopy /e /i runtime $Env:AppData\helix\runtime` |
-| Linux / macOS        | `ln -s $PWD/runtime ~/.config/helix/runtime`     |
+#### Linux and macOS
 
-Starting with Windows Vista you can also create symbolic links on Windows. Note that this requires
-elevated privileges - i.e. PowerShell or Cmd must be run as administrator.
+Either set the `HELIX_RUNTIME` environment variable to point to the runtime files and add it to your `~/.bashrc` or equivalent:
 
-**PowerShell:**
+```sh
+HELIX_RUNTIME=/home/user-name/src/helix/runtime
+```
+
+Or, create a symlink in `~/.config/helix` that links to the source code directory:
 
-```powershell
-New-Item -ItemType SymbolicLink -Target "runtime" -Path "$Env:AppData\helix\runtime"
+```sh
+ln -s $PWD/runtime ~/.config/helix/runtime
 ```
 
-**Cmd:**
+#### Windows
+
+Either set the `HELIX_RUNTIME` environment variable to point to the runtime files using the Windows setting (search for
+`Edit environment variables for your account`) or use the `setx` command in
+Cmd:
 
-```cmd
-cd %appdata%\helix
-mklink /D runtime "<helix-repo>\runtime"
+```sh
+setx HELIX_RUNTIME "%userprofile%\source\repos\helix\runtime"
 ```
 
-The runtime location can be overridden via the `HELIX_RUNTIME` environment variable.
+>  `%userprofile%` resolves to your user directory like
+> `C:\Users\Your-Name\` for example.
 
-> NOTE: if `HELIX_RUNTIME` is set prior to calling `cargo install --path helix-term`,
-> tree-sitter grammars will be built in `$HELIX_RUNTIME/grammars`.
+Or, create a symlink in `%appdata%\helix\` that links to the source code directory:
 
-If you plan on keeping the repo locally, an alternative to copying/symlinking
-runtime files is to set `HELIX_RUNTIME=/path/to/helix/runtime`
-(`HELIX_RUNTIME=$PWD/runtime` if you're in the helix repo directory).
+| Method     | Command                                                                                |
+| ---------- | -------------------------------------------------------------------------------------- |
+| PowerShell | `New-Item -ItemType Junction -Target "runtime" -Path "$Env:AppData\helix\runtime"`     |
+| Cmd        | `cd %appdata%\helix` <br/> `mklink /D runtime "%userprofile%\src\helix\runtime"`       |
 
-To use Helix in desktop environments that supports [XDG desktop menu](https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html), including Gnome and KDE, copy the provided `.desktop` file to the correct folder:
+>  On Windows, creating a symbolic link may require running PowerShell or
+> Cmd as an administrator.
 
-```bash
-cp contrib/Helix.desktop ~/.local/share/applications
-```
+#### Multiple runtime directories
 
-To use another terminal than the default, you will need to modify the `.desktop` file. For example, to use `kitty`:
+When Helix finds multiple runtime directories it will search through them for files in the
+following order:
 
-```bash
-sed -i "s|Exec=hx %F|Exec=kitty hx %F|g" ~/.local/share/applications/Helix.desktop
-sed -i "s|Terminal=true|Terminal=false|g" ~/.local/share/applications/Helix.desktop
-```
+1. `runtime/` sibling directory to `$CARGO_MANIFEST_DIR` directory (this is intended for
+  developing and testing helix only).
+2. `runtime/` subdirectory of OS-dependent helix user config directory.
+3. `$HELIX_RUNTIME`.
+4. `runtime/` subdirectory of path to Helix executable.
 
-Please note: there is no icon for Helix yet, so the system default will be used.
+This order also sets the priority for selecting which file will be used if multiple runtime
+directories have files with the same name.
 
-## Finishing up the installation
+### Validating the installation
 
-To make sure everything is set up as expected you should finally run the helix healthcheck via
+To make sure everything is set up as expected you should run the Helix health
+check:
 
-```
+```sh
 hx --health
 ```
 
-For more information on the information displayed in the health check results refer to [Healthcheck](https://github.com/helix-editor/helix/wiki/Healthcheck).
+For more information on the health check results refer to
+[Health check](https://github.com/helix-editor/helix/wiki/Healthcheck).
 
-### Building tree-sitter grammars
+### Configure the desktop shortcut
 
-Tree-sitter grammars must be fetched and compiled if not pre-packaged.
-Fetch grammars with `hx --grammar fetch` (requires `git`) and compile them
-with `hx --grammar build` (requires a C++ compiler).
+If your desktop environment supports the
+[XDG desktop menu](https://specifications.freedesktop.org/menu-spec/menu-spec-latest.html)
+you can configure Helix to show up in the application menu by copying the
+provided `.desktop` and icon files to their correct folders:
 
-### Installing language servers
+```sh
+cp contrib/Helix.desktop ~/.local/share/applications
+cp contrib/helix.png ~/.icons # or ~/.local/share/icons
+```
+
+To use another terminal than the system default, you can modify the `.desktop`
+file. For example, to use `kitty`:
 
-Language servers can optionally be installed if you want their features (auto-complete, diagnostics etc.).
-Follow the [instructions on the wiki page](https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers) to add your language servers of choice.
+```sh
+sed -i "s|Exec=hx %F|Exec=kitty hx %F|g" ~/.local/share/applications/Helix.desktop
+sed -i "s|Terminal=true|Terminal=false|g" ~/.local/share/applications/Helix.desktop
+```
diff --git a/book/src/keymap.md b/book/src/keymap.md
index 139e8fddf..173728f27 100644
--- a/book/src/keymap.md
+++ b/book/src/keymap.md
@@ -14,14 +14,14 @@ # Keymap
     - [Space mode](#space-mode)
       - [Popup](#popup)
     - [Unimpaired](#unimpaired)
-- [Insert Mode](#insert-mode)
-- [Select / extend mode](#select--extend-mode)
+- [Insert mode](#insert-mode)
+- [Select / extend mode](#select-extend-mode)
 - [Picker](#picker)
 - [Prompt](#prompt)
 
 >  Mappings marked (**LSP**) require an active language server for the file.
 
->  Mappings marked (**TS**) require a tree-sitter grammar for the filetype.
+>  Mappings marked (**TS**) require a tree-sitter grammar for the file type.
 
 ## Normal mode
 
@@ -109,8 +109,9 @@ ### Selection manipulation
 | Key                   | Description                                                       | Command                              |
 | -----                 | -----------                                                       | -------                              |
 | `s`                   | Select all regex matches inside selections                        | `select_regex`                       |
-| `S`                   | Split selection into subselections on regex matches               | `split_selection`                    |
+| `S`                   | Split selection into sub selections on regex matches              | `split_selection`                    |
 | `Alt-s`               | Split selection on newlines                                       | `split_selection_on_newline`         |
+| `Alt-_ `              | Merge consecutive selections                                      | `merge_consecutive_selections`       |
 | `&`                   | Align selection in columns                                        | `align_selections`                   |
 | `_`                   | Trim whitespace from the selection                                | `trim_selections`                    |
 | `;`                   | Collapse selection onto a single cursor                           | `collapse_selection`                 |
@@ -129,7 +130,7 @@ ### Selection manipulation
 | `X`                   | Extend selection to line bounds (line-wise selection)             | `extend_to_line_bounds`              |
 | `Alt-x`               | Shrink selection to line bounds (line-wise selection)             | `shrink_to_line_bounds`              |
 | `J`                   | Join lines inside selection                                       | `join_selections`                    |
-| `Alt-J`               | Join lines inside selection and select space                      | `join_selections_space`              |
+| `Alt-J`               | Join lines inside selection and select the inserted space         | `join_selections_space`              |
 | `K`                   | Keep selections matching the regex                                | `keep_selections`                    |
 | `Alt-K`               | Remove selections matching the regex                              | `remove_selections`                  |
 | `Ctrl-c`              | Comment/uncomment the selections                                  | `toggle_comments`                    |
@@ -140,7 +141,7 @@ ### Selection manipulation
 
 ### Search
 
-Search commands all operate on the `/` register by default. Use `"<char>` to operate on a different one.
+Search commands all operate on the `/` register by default. To use a different register, use `"<char>`.
 
 | Key   | Description                                 | Command              |
 | ----- | -----------                                 | -------              |
@@ -165,15 +166,17 @@ ### Minor modes
 | `Ctrl-w` | Enter [window mode](#window-mode)                  | N/A            |
 | `Space`  | Enter [space mode](#space-mode)                    | N/A            |
 
+These modes (except command mode) can be configured by
+[remapping keys](https://docs.helix-editor.com/remapping.html#minor-modes).
+
 #### View mode
 
 Accessed by typing `z` in [normal mode](#normal-mode).
 
 View mode is intended for scrolling and manipulating the view without changing
 the selection. The "sticky" variant of this mode (accessed by typing `Z` in
-normal mode) is persistent; use the Escape key to return to normal mode after
-usage (useful when you're simply looking over text and not actively editing
-it).
+normal mode) is persistent and can be exited using the escape key. This is
+useful when you're simply looking over text and not actively editing it.
 
 
 | Key                  | Description                                               | Command             |
@@ -221,7 +224,7 @@ #### Match mode
 Accessed by typing `m` in [normal mode](#normal-mode).
 
 See the relevant section in [Usage](./usage.md) for an explanation about
-[surround](./usage.md#surround) and [textobject](./usage.md#textobjects) usage.
+[surround](./usage.md#surround) and [textobject](./usage.md#navigating-using-tree-sitter-textobjects) usage.
 
 | Key              | Description                                     | Command                    |
 | -----            | -----------                                     | -------                    |
@@ -238,7 +241,7 @@ #### Window mode
 
 Accessed by typing `Ctrl-w` in [normal mode](#normal-mode).
 
-This layer is similar to Vim keybindings as Kakoune does not support window.
+This layer is similar to Vim keybindings as Kakoune does not support windows.
 
 | Key                    | Description                                          | Command           |
 | -----                  | -------------                                        | -------           |
@@ -264,30 +267,32 @@ #### Space mode
 
 This layer is a kludge of mappings, mostly pickers.
 
-| Key     | Description                                                             | Command                             |
-| -----   | -----------                                                             | -------                             |
-| `f`     | Open file picker                                                        | `file_picker`                       |
-| `F`     | Open file picker at current working directory                           | `file_picker_in_current_directory`  |
-| `b`     | Open buffer picker                                                      | `buffer_picker`                     |
-| `j`     | Open jumplist picker                                                    | `jumplist_picker`                   |
-| `k`     | Show documentation for item under cursor in a [popup](#popup) (**LSP**) | `hover`                             |
-| `s`     | Open document symbol picker (**LSP**)                                   | `symbol_picker`                     |
-| `S`     | Open workspace symbol picker (**LSP**)                                  | `workspace_symbol_picker`           |
-| `d`     | Open document diagnostics picker (**LSP**)                              | `diagnostics_picker`                |
-| `D`     | Open workspace diagnostics picker (**LSP**)                             | `workspace_diagnostics_picker`      |
-| `r`     | Rename symbol (**LSP**)                                                 | `rename_symbol`                     |
-| `a`     | Apply code action  (**LSP**)                                            | `code_action`                       |
-| `'`     | Open last fuzzy picker                                                  | `last_picker`                       |
-| `w`     | Enter [window mode](#window-mode)                                       | N/A                                 |
-| `p`     | Paste system clipboard after selections                                 | `paste_clipboard_after`             |
-| `P`     | Paste system clipboard before selections                                | `paste_clipboard_before`            |
-| `y`     | Join and yank selections to clipboard                                   | `yank_joined_to_clipboard`          |
-| `Y`     | Yank main selection to clipboard                                        | `yank_main_selection_to_clipboard`  |
-| `R`     | Replace selections by clipboard contents                                | `replace_selections_with_clipboard` |
-| `/`     | Global search in workspace folder                                       | `global_search`                     |
-| `?`     | Open command palette                                                    | `command_palette`                   |
-
-> TIP: Global search displays results in a fuzzy picker, use `Space + '` to bring it back up after opening a file.
+| Key     | Description                                                             | Command                                    |
+| -----   | -----------                                                             | -------                                    |
+| `f`     | Open file picker                                                        | `file_picker`                              |
+| `F`     | Open file picker at current working directory                           | `file_picker_in_current_directory`         |
+| `b`     | Open buffer picker                                                      | `buffer_picker`                            |
+| `j`     | Open jumplist picker                                                    | `jumplist_picker`                          |
+| `g`     | Debug (experimental)                                                    | N/A                                        |
+| `k`     | Show documentation for item under cursor in a [popup](#popup) (**LSP**) | `hover`                                    |
+| `s`     | Open document symbol picker (**LSP**)                                   | `symbol_picker`                            |
+| `S`     | Open workspace symbol picker (**LSP**)                                  | `workspace_symbol_picker`                  |
+| `d`     | Open document diagnostics picker (**LSP**)                              | `diagnostics_picker`                       |
+| `D`     | Open workspace diagnostics picker (**LSP**)                             | `workspace_diagnostics_picker`             |
+| `r`     | Rename symbol (**LSP**)                                                 | `rename_symbol`                            |
+| `a`     | Apply code action (**LSP**)                                             | `code_action`                              |
+| `h`     | Select symbol references (**LSP**)                                      | `select_references_to_symbol_under_cursor` |
+| `'`     | Open last fuzzy picker                                                  | `last_picker`                              |
+| `w`     | Enter [window mode](#window-mode)                                       | N/A                                        |
+| `p`     | Paste system clipboard after selections                                 | `paste_clipboard_after`                    |
+| `P`     | Paste system clipboard before selections                                | `paste_clipboard_before`                   |
+| `y`     | Join and yank selections to clipboard                                   | `yank_joined_to_clipboard`                 |
+| `Y`     | Yank main selection to clipboard                                        | `yank_main_selection_to_clipboard`         |
+| `R`     | Replace selections by clipboard contents                                | `replace_selections_with_clipboard`        |
+| `/`     | Global search in workspace folder                                       | `global_search`                            |
+| `?`     | Open command palette                                                    | `command_palette`                          |
+
+>  Global search displays results in a fuzzy picker, use `Space + '` to bring it back up after opening a file.
 
 ##### Popup
 
@@ -300,14 +305,14 @@ ##### Popup
 
 #### Unimpaired
 
-Mappings in the style of [vim-unimpaired](https://github.com/tpope/vim-unimpaired).
+These mappings are in the style of [vim-unimpaired](https://github.com/tpope/vim-unimpaired).
 
 | Key      | Description                                  | Command               |
 | -----    | -----------                                  | -------               |
-| `[d`     | Go to previous diagnostic (**LSP**)          | `goto_prev_diag`      |
 | `]d`     | Go to next diagnostic (**LSP**)              | `goto_next_diag`      |
-| `[D`     | Go to first diagnostic in document (**LSP**) | `goto_first_diag`     |
+| `[d`     | Go to previous diagnostic (**LSP**)          | `goto_prev_diag`      |
 | `]D`     | Go to last diagnostic in document (**LSP**)  | `goto_last_diag`      |
+| `[D`     | Go to first diagnostic in document (**LSP**) | `goto_first_diag`     |
 | `]f`     | Go to next function (**TS**)                 | `goto_next_function`  |
 | `[f`     | Go to previous function (**TS**)             | `goto_prev_function`  |
 | `]t`     | Go to next type definition (**TS**)          | `goto_next_class`     |
@@ -317,24 +322,25 @@ #### Unimpaired
 | `]c`     | Go to next comment (**TS**)                  | `goto_next_comment`   |
 | `[c`     | Go to previous comment (**TS**)              | `goto_prev_comment`   |
 | `]T`     | Go to next test (**TS**)                     | `goto_next_test`      |
-| `]T`     | Go to previous test (**TS**)                 | `goto_prev_test`      |
+| `[T`     | Go to previous test (**TS**)                 | `goto_prev_test`      |
 | `]p`     | Go to next paragraph                         | `goto_next_paragraph` |
 | `[p`     | Go to previous paragraph                     | `goto_prev_paragraph` |
 | `]g`     | Go to next change                            | `goto_next_change`    |
 | `[g`     | Go to previous change                        | `goto_prev_change`    |
-| `]G`     | Go to first change                           | `goto_first_change`   |
-| `[G`     | Go to last change                            | `goto_last_change`    |
-| `[Space` | Add newline above                            | `add_newline_above`   |
+| `]G`     | Go to last change                            | `goto_last_change`    |
+| `[G`     | Go to first change                           | `goto_first_change`   |
 | `]Space` | Add newline below                            | `add_newline_below`   |
+| `[Space` | Add newline above                            | `add_newline_above`   |
 
 ## Insert mode
 
-Insert mode bindings are somewhat minimal by default. Helix is designed to
+Insert mode bindings are minimal by default. Helix is designed to
 be a modal editor, and this is reflected in the user experience and internal
-mechanics. For example, changes to the text are only saved for undos when
-escaping from insert mode to normal mode. For this reason, new users are
-strongly encouraged to learn the modal editing paradigm to get the smoothest
-experience.
+mechanics. Changes to the text are only saved for undos when
+escaping from insert mode to normal mode.
+
+>  New users are strongly encouraged to learn the modal editing paradigm
+> to get the smoothest experience.
 
 | Key                                         | Description                 | Command                  |
 | -----                                       | -----------                 | -------                  |
@@ -346,7 +352,7 @@ ## Insert mode
 | `Alt-d`, `Alt-Delete`                       | Delete next word            | `delete_word_forward`    |
 | `Ctrl-u`                                    | Delete to start of line     | `kill_to_line_start`     |
 | `Ctrl-k`                                    | Delete to end of line       | `kill_to_line_end`       |
-| `Ctrl-h`, `Backspace`                       | Delete previous char        | `delete_char_backward`   |
+| `Ctrl-h`, `Backspace`, `Shift-Backspace`    | Delete previous char        | `delete_char_backward`   |
 | `Ctrl-d`, `Delete`                          | Delete next char            | `delete_char_forward`    |
 | `Ctrl-j`, `Enter`                           | Insert new line             | `insert_newline`         |
 
@@ -364,8 +370,8 @@ ## Insert mode
 | `Home`                                      | Move to line start          | `goto_line_start`        |
 | `End`                                       | Move to line end            | `goto_line_end_newline`  |
 
-If you want to disable them in insert mode as you become more comfortable with modal editing, you can use
-the following in your `config.toml`:
+As you become more comfortable with modal editing, you may want to disable some
+insert mode bindings. You can do this by editing your `config.toml` file.
 
 ```toml
 [keys.insert]
@@ -381,7 +387,7 @@ ## Insert mode
 
 ## Select / extend mode
 
-This mode echoes Normal mode, but changes any movements to extend
+Select mode echoes Normal mode, but changes any movements to extend
 selections rather than replace them. Goto motions are also changed to
 extend, so that `vgl` for example extends the selection to the end of
 the line.
@@ -427,7 +433,7 @@ ## Prompt
 | `Alt-d`, `Alt-Delete`, `Ctrl-Delete`        | Delete next word                                                        |
 | `Ctrl-u`                                    | Delete to start of line                                                 |
 | `Ctrl-k`                                    | Delete to end of line                                                   |
-| `Backspace`, `Ctrl-h`                       | Delete previous char                                                    |
+| `Backspace`, `Ctrl-h`, `Shift-Backspace`    | Delete previous char                                                    |
 | `Delete`, `Ctrl-d`                          | Delete next char                                                        |
 | `Ctrl-s`                                    | Insert a word under doc cursor, may be changed to Ctrl-r Ctrl-w later   |
 | `Ctrl-p`, `Up`                              | Select previous history                                                 |
diff --git a/book/src/lang-support.md b/book/src/lang-support.md
index 6a08cd699..3f96673bc 100644
--- a/book/src/lang-support.md
+++ b/book/src/lang-support.md
@@ -1,10 +1,10 @@
 # Language Support
 
-The following languages and Language Servers are supported. In order to use
+The following languages and Language Servers are supported. To use
 Language Server features, you must first [install][lsp-install-wiki] the
 appropriate Language Server.
 
-Check the language support in your installed helix version with `hx --health`.
+You can check the language support in your installed helix version with `hx --health`.
 
 Also see the [Language Configuration][lang-config] docs and the [Adding
 Languages][adding-languages] guide for more language configuration information.
diff --git a/book/src/languages.md b/book/src/languages.md
index e45ef910a..f44509fc8 100644
--- a/book/src/languages.md
+++ b/book/src/languages.md
@@ -5,13 +5,15 @@ # Languages
 
 ## `languages.toml` files
 
-There are three possible `languages.toml` files. The first is compiled into
-Helix and lives in the [Helix repository](https://github.com/helix-editor/helix/blob/master/languages.toml).
-This provides the default configurations for languages and language servers.
+There are three possible locations for a `languages.toml` file:
 
-You may define a `languages.toml` in your [configuration directory](./configuration.md)
-which overrides values from the built-in language configuration. For example
-to disable auto-LSP-formatting in Rust:
+1. In the Helix source code, this lives in the
+   [Helix repository](https://github.com/helix-editor/helix/blob/master/languages.toml).
+   It provides the default configurations for languages and language servers.
+
+2. In your [configuration directory](./configuration.md). This overrides values
+   from the built-in language configuration. For example to disable
+   auto-LSP-formatting in Rust:
 
 ```toml
 # in <config_dir>/helix/languages.toml
@@ -21,10 +23,10 @@ # in <config_dir>/helix/languages.toml
 auto-format = false
 ```
 
-Language configuration may also be overridden local to a project by creating
-a `languages.toml` file under a `.helix` directory. Its settings will be merged
-with the language configuration in the configuration directory and the built-in
-configuration.
+3. In a `.helix` folder in your project. Language configuration may also be
+   overridden local to a project by creating a `languages.toml` file in a
+   `.helix` folder. Its settings will be merged with the language configuration
+   in the configuration directory and the built-in configuration.
 
 ## Language configuration
 
@@ -35,7 +37,7 @@ ## Language configuration
 [[language]]
 name = "mylang"
 scope = "source.mylang"
-injection-regex = "^mylang$"
+injection-regex = "mylang"
 file-types = ["mylang", "myl"]
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
@@ -56,16 +58,17 @@ ## Language configuration
 | `auto-format`         | Whether to autoformat this language when saving               |
 | `diagnostic-severity` | Minimal severity of diagnostic for it to be displayed. (Allowed values: `Error`, `Warning`, `Info`, `Hint`) |
 | `comment-token`       | The token to use as a comment-token                           |
-| `indent`              | The indent to use. Has sub keys `tab-width` and `unit`        |
+| `indent`              | The indent to use. Has sub keys `unit` (the text inserted into the document when indenting; usually set to N spaces or `"\t"` for tabs) and `tab-width` (the number of spaces rendered for a tab) |
 | `language-server`     | The Language Server to run. See the Language Server configuration section below. |
 | `config`              | Language Server configuration                                 |
 | `grammar`             | The tree-sitter grammar to use (defaults to the value of `name`) |
 | `formatter`           | The formatter for the language, it will take precedence over the lsp when defined. The formatter must be able to take the original file as input from stdin and write the formatted file to stdout |
-| `max-line-length`     | Maximum line length. Used for the `:reflow` command           |
+| `text-width`          |  Maximum line length. Used for the `:reflow` command and soft-wrapping if `soft-wrap.wrap_at_text_width` is set, defaults to `editor.text-width`   |
+| `workspace-lsp-roots`     | Directories relative to the workspace root that are treated as LSP roots. Should only be set in `.helix/config.toml`. Overwrites the setting of the same name in `config.toml` if set. |
 
 ### File-type detection and the `file-types` key
 
-Helix determines which language configuration to use with the `file-types` key
+Helix determines which language configuration to use based on the `file-types` key
 from the above section. `file-types` is a list of strings or tables, for
 example:
 
diff --git a/book/src/remapping.md b/book/src/remapping.md
index e89c66113..d762c6add 100644
--- a/book/src/remapping.md
+++ b/book/src/remapping.md
@@ -1,18 +1,18 @@
-# Key Remapping
+# Key remapping
 
-One-way key remapping is temporarily supported via a simple TOML configuration
+Helix currently supports one-way key remapping through a simple TOML configuration
 file. (More powerful solutions such as rebinding via commands will be
 available in the future).
 
-To remap keys, write a `config.toml` file in your `helix` configuration
-directory (default `~/.config/helix` in Linux systems) with a structure like
+To remap keys, create a `config.toml` file in your `helix` configuration
+directory (default `~/.config/helix` on Linux systems) with a structure like
 this:
 
 ```toml
 # At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'
 [keys.normal]
-C-s = ":w" # Maps the Ctrl-s to the typable command :w which is an alias for :write (save file)
-C-o = ":open ~/.config/helix/config.toml" # Maps the Ctrl-o to opening of the helix config file
+C-s = ":w" # Maps Ctrl-s to the typable command :w which is an alias for :write (save file)
+C-o = ":open ~/.config/helix/config.toml" # Maps Ctrl-o to opening of the helix config file
 a = "move_char_left" # Maps the 'a' key to the move_char_left command
 w = "move_line_up" # Maps the 'w' key move_line_up
 "C-S-esc" = "extend_line" # Maps Ctrl-Shift-Escape to extend_line
@@ -20,10 +20,35 @@ # At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'
 "ret" = ["open_below", "normal_mode"] # Maps the enter key to open_below then re-enter normal mode
 
 [keys.insert]
-"A-x" = "normal_mode" # Maps Alt-X to enter normal mode
+"A-x" = "normal_mode"     # Maps Alt-X to enter normal mode
 j = { k = "normal_mode" } # Maps `jk` to exit insert mode
 ```
-> NOTE: Typable commands can also be remapped, remember to keep the `:` prefix to indicate it's a typable command.
+
+## Minor modes
+
+Minor modes are accessed by pressing a key (usually from normal mode), giving access to dedicated bindings. Bindings
+can be modified or added by nesting definitions.
+
+```toml
+[keys.insert.j]
+k = "normal_mode" # Maps `jk` to exit insert mode
+
+[keys.normal.g]
+a = "code_action" # Maps `ga` to show possible code actions
+
+# invert `j` and `k` in view mode
+[keys.normal.z]
+j = "scroll_up"
+k = "scroll_down"
+
+# create a new minor mode bound to `+`
+[keys.normal."+"]
+m = ":run-shell-command make"
+c = ":run-shell-command cargo build"
+t = ":run-shell-command cargo test"
+```
+
+## Special keys and modifiers
 
 Ctrl, Shift and Alt modifiers are encoded respectively with the prefixes
 `C-`, `S-` and `A-`. Special keys are encoded as follows:
@@ -50,5 +75,5 @@ # At most one section each of 'keys.normal', 'keys.insert' and 'keys.select'
 
 Keys can be disabled by binding them to the `no_op` command.
 
-Commands can be found at [Keymap](https://docs.helix-editor.com/keymap.html) Commands.
-> Commands can also be found in the source code at [`helix-term/src/commands.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands.rs) at the invocation of `static_commands!` macro and the `TypableCommandList`.
+A list of commands is available in the [Keymap](https://docs.helix-editor.com/keymap.html) documentation
+ and in the source code at [`helix-term/src/commands.rs`](https://github.com/helix-editor/helix/blob/master/helix-term/src/commands.rs) at the invocation of `static_commands!` macro and the `TypableCommandList`.
diff --git a/book/src/themes.md b/book/src/themes.md
index 322caea54..56d0372ca 100644
--- a/book/src/themes.md
+++ b/book/src/themes.md
@@ -1,14 +1,15 @@
 # Themes
 
-To use a theme add `theme = "<name>"` to your [`config.toml`](./configuration.md) at the very top of the file before the first section or select it during runtime using `:theme <name>`.
+To use a theme add `theme = "<name>"` to the top of your [`config.toml`](./configuration.md) file, or select it during runtime using `:theme <name>`.
 
 ## Creating a theme
 
-Create a file with the name of your theme as file name (i.e `mytheme.toml`) and place it in your `themes` directory (i.e `~/.config/helix/themes`). The directory might have to be created beforehand.
+Create a file with the name of your theme as the file name (i.e `mytheme.toml`) and place it in your `themes` directory (i.e `~/.config/helix/themes` or `%AppData%\helix\themes` on Windows). The directory might have to be created beforehand.
 
-The names "default" and "base16_default" are reserved for the builtin themes and cannot be overridden by user defined themes.
+>  The names "default" and "base16_default" are reserved for built-in themes
+> and cannot be overridden by user-defined themes.
 
-The default theme.toml can be found [here](https://github.com/helix-editor/helix/blob/master/theme.toml), and user submitted themes [here](https://github.com/helix-editor/helix/blob/master/runtime/themes). 
+### Overview
 
 Each line in the theme file is specified as below:
 
@@ -16,7 +17,7 @@ ## Creating a theme
 key = { fg = "#ffffff", bg = "#000000", underline = { color = "#ff0000", style = "curl"}, modifiers = ["bold", "italic"] }
 ```
 
-where `key` represents what you want to style, `fg` specifies the foreground color, `bg` the background color, `underline` the underline `style`/`color`, and `modifiers` is a list of style modifiers. `bg`, `underline` and `modifiers` can be omitted to defer to the defaults.
+Where `key` represents what you want to style, `fg` specifies the foreground color, `bg` the background color, `underline` the underline `style`/`color`, and `modifiers` is a list of style modifiers. `bg`, `underline` and `modifiers` can be omitted to defer to the defaults.
 
 To specify only the foreground color:
 
@@ -24,15 +25,30 @@ ## Creating a theme
 key = "#ffffff"
 ```
 
-if the key contains a dot `'.'`, it must be quoted to prevent it being parsed as a [dotted key](https://toml.io/en/v1.0.0#keys).
+If the key contains a dot `'.'`, it must be quoted to prevent it being parsed as a [dotted key](https://toml.io/en/v1.0.0#keys).
 
 ```toml
 "key.key" = "#ffffff"
 ```
 
+For inspiration, you can find the default `theme.toml`
+[here](https://github.com/helix-editor/helix/blob/master/theme.toml) and
+user-submitted themes
+[here](https://github.com/helix-editor/helix/blob/master/runtime/themes).
+
+### Using the linter
+
+Use the supplied linting tool to check for errors and missing scopes:
+
+```sh
+cargo xtask themelint onedark # replace onedark with <name>
+```
+
+## The details of theme creation
+
 ### Color palettes
 
-It's recommended define a palette of named colors, and refer to them from the
+It's recommended to define a palette of named colors, and refer to them in the
 configuration values in your theme. To do this, add a table called
 `palette` to your theme file:
 
@@ -45,8 +61,8 @@ ### Color palettes
 black = "#000000"
 ```
 
-Remember that the `[palette]` table includes all keys after its header,
-so you should define the palette after normal theme options.
+Keep in mind that the `[palette]` table includes all keys after its header,
+so it should be defined after the normal theme options.
 
 The default palette uses the terminal's default 16 colors, and the colors names
 are listed below. The `[palette]` section in the config file takes precedence
@@ -73,9 +89,8 @@ ### Color palettes
 
 ### Modifiers
 
-The following values may be used as modifiers. 
-
-Less common modifiers might not be supported by your terminal emulator.
+The following values may be used as modifier, provided they are supported by
+your terminal emulator.
 
 | Modifier             |
 | ---                  |
@@ -89,14 +104,13 @@ ### Modifiers
 | `hidden`             |
 | `crossed_out`        |
 
-> Note: The `underlined` modifier is deprecated and only available for backwards compatibility.
+>  The `underlined` modifier is deprecated and only available for backwards compatibility.
 > Its behavior is equivalent to setting `underline.style="line"`.
 
-### Underline Style
-
-One of the following values may be used as a value for `underline.style`. 
+### Underline style
 
-Some styles might not be supported by your terminal emulator.
+One of the following values may be used as a value for `underline.style`, providing it is
+supported by your terminal emulator.
 
 | Modifier       |
 | ---            |
@@ -109,7 +123,7 @@ ### Underline Style
 
 ### Inheritance
 
-Extend upon other themes by setting the `inherits` property to an existing theme.
+Extend other themes by setting the `inherits` property to an existing theme.
 
 ```toml
 inherits = "boo_berry"
@@ -124,25 +138,27 @@ # Override colors in the palette:
 
 ### Scopes
 
-The following is a list of scopes available to use for styling.
+The following is a list of scopes available to use for styling:
 
 #### Syntax highlighting
 
 These keys match [tree-sitter scopes](https://tree-sitter.github.io/tree-sitter/syntax-highlighting#theme).
 
-For a given highlight produced, styling will be determined based on the longest matching theme key. For example, the highlight `function.builtin.static` would match the key `function.builtin` rather than `function`.
+When determining styling for a highlight, the longest matching theme key will be used. For example, if the highlight is `function.builtin.static`, the key `function.builtin` will be used instead of `function`.
 
 We use a similar set of scopes as
-[SublimeText](https://www.sublimetext.com/docs/scope_naming.html). See also
+[Sublime Text](https://www.sublimetext.com/docs/scope_naming.html). See also
 [TextMate](https://macromates.com/manual/en/language_grammars) scopes.
 
-- `attribute` - Class attributes, html tag attributes
+- `attribute` - Class attributes, HTML tag attributes
 
 - `type` - Types
   - `builtin` - Primitive types provided by the language (`int`, `usize`)
+  - `enum`
+    - `variant`
 - `constructor`
 
-- `constant` (TODO: constant.other.placeholder for %v)
+- `constant` (TODO: constant.other.placeholder for `%v`)
   - `builtin` Special constants provided by the language (`true`, `false`, `nil` etc)
     - `boolean`
   - `character`
@@ -160,11 +176,11 @@ #### Syntax highlighting
 
 - `comment` - Code comments
   - `line` - Single line comments (`//`)
-  - `block` - Block comments (e.g. (`/*     */`)
+  - `block` - Block comments (e.g. (`/* */`)
     - `documentation` - Documentation comments (e.g. `///` in Rust)
 
 - `variable` - Variables
-  - `builtin` - Reserved language variables (`self`, `this`, `super`, etc)
+  - `builtin` - Reserved language variables (`self`, `this`, `super`, etc.)
   - `parameter` - Function parameters
   - `other`
     - `member` - Fields of composite data types (e.g. structs, unions)
@@ -184,10 +200,10 @@ #### Syntax highlighting
     - `return`
     - `exception`
   - `operator` - `or`, `in`
-  - `directive` - Preprocessor directives (`#if` in C) 
+  - `directive` - Preprocessor directives (`#if` in C)
   - `function` - `fn`, `func`
   - `storage` - Keywords describing how things are stored
-    - `type` - The type of something, `class`, `function`, `var`, `let`, etc. 
+    - `type` - The type of something, `class`, `function`, `var`, `let`, etc.
     - `modifier` - Storage modifiers like `static`, `mut`, `const`, `ref`, etc.
 
 - `operator` - `||`, `+=`, `>`
@@ -199,9 +215,12 @@ #### Syntax highlighting
   - `special` (preprocessor in C)
 
 - `tag` - Tags (e.g. `<body>` in HTML)
+  - `builtin`
 
 - `namespace`
 
+- `special`
+
 - `markup`
   - `heading`
     - `marker`
@@ -209,12 +228,15 @@ #### Syntax highlighting
   - `list`
     - `unnumbered`
     - `numbered`
+    - `checked`
+    - `unchecked`
   - `bold`
   - `italic`
+  - `strikethrough`
   - `link`
-    - `url` - urls pointed to by links
-    - `label` - non-url link references
-    - `text` - url and image descriptions in links
+    - `url` - URLs pointed to by links
+    - `label` - non-URL link references
+    - `text` - URL and image descriptions in links
   - `quote`
   - `raw`
     - `inline`
@@ -228,73 +250,80 @@ #### Syntax highlighting
 
 #### Interface
 
-These scopes are used for theming the editor interface.
+These scopes are used for theming the editor interface:
 
 - `markup`
   - `normal`
-    - `completion` - for completion doc popup ui
-    - `hover` - for hover popup ui
+    - `completion` - for completion doc popup UI
+    - `hover` - for hover popup UI
   - `heading`
-    - `completion` - for completion doc popup ui
-    - `hover` - for hover popup ui
+    - `completion` - for completion doc popup UI
+    - `hover` - for hover popup UI
   - `raw`
     - `inline`
-      - `completion` - for completion doc popup ui
-      - `hover` - for hover popup ui
-
-
-| Key                         | Notes                                                                                          |
-| ---                         | ---                                                                                            |
-| `ui.background`             |                                                                                                |
-| `ui.background.separator`   | Picker separator below input line                                                              |
-| `ui.cursor`                 |                                                                                                |
-| `ui.cursor.insert`          |                                                                                                |
-| `ui.cursor.select`          |                                                                                                |
-| `ui.cursor.match`           | Matching bracket etc.                                                                          |
-| `ui.cursor.primary`         | Cursor with primary selection                                                                  |
-| `ui.gutter`                 | Gutter                                                                                         |
-| `ui.gutter.selected`        | Gutter for the line the cursor is on                                                           |
-| `ui.linenr`                 | Line numbers                                                                                   |
-| `ui.linenr.selected`        | Line number for the line the cursor is on                                                      |
-| `ui.statusline`             | Statusline                                                                                     |
-| `ui.statusline.inactive`    | Statusline (unfocused document)                                                                |
-| `ui.statusline.normal`      | Statusline mode during normal mode ([only if `editor.color-modes` is enabled][editor-section]) |
-| `ui.statusline.insert`      | Statusline mode during insert mode ([only if `editor.color-modes` is enabled][editor-section]) |
-| `ui.statusline.select`      | Statusline mode during select mode ([only if `editor.color-modes` is enabled][editor-section]) |
-| `ui.statusline.separator`   | Separator character in statusline                                                              |
-| `ui.popup`                  | Documentation popups (e.g Space + k)                                                             |
-| `ui.popup.info`             | Prompt for multiple key options                                                                |
-| `ui.window`                 | Border lines separating splits                                                                 |
-| `ui.help`                   | Description box for commands                                                                   |
-| `ui.text`                   | Command prompts, popup text, etc.                                                              |
-| `ui.text.focus`             |                                                                                                |
-| `ui.text.info`              | The key: command text in `ui.popup.info` boxes                                                 |
-| `ui.virtual.ruler`          | Ruler columns (see the [`editor.rulers` config][editor-section])                               |
-| `ui.virtual.whitespace`     | Visible whitespace characters                                                                 |
-| `ui.virtual.indent-guide`   | Vertical indent width guides                                                                   |
-| `ui.menu`                   | Code and command completion menus                                                              |
-| `ui.menu.selected`          | Selected autocomplete item                                                                     |
-| `ui.menu.scroll`            | `fg` sets thumb color, `bg` sets track color of scrollbar                                      |
-| `ui.selection`              | For selections in the editing area                                                             |
-| `ui.selection.primary`      |                                                                                                |
-| `ui.cursorline.primary`     | The line of the primary cursor ([if cursorline is enabled][editor-section])                    |
-| `ui.cursorline.secondary`   | The lines of any other cursors ([if cursorline is enabled][editor-section])                    |
-| `ui.cursorcolumn.primary`   | The column of the primary cursor ([if cursorcolumn is enabled][editor-section])                |
-| `ui.cursorcolumn.secondary` | The columns of any other cursors ([if cursorcolumn is enabled][editor-section])                |
-| `warning`                   | Diagnostics warning (gutter)                                                                   |
-| `error`                     | Diagnostics error (gutter)                                                                     |
-| `info`                      | Diagnostics info (gutter)                                                                      |
-| `hint`                      | Diagnostics hint (gutter)                                                                      |
-| `diagnostic`                | Diagnostics fallback style (editing area)                                                      |
-| `diagnostic.hint`           | Diagnostics hint (editing area)                                                                |
-| `diagnostic.info`           | Diagnostics info (editing area)                                                                |
-| `diagnostic.warning`        | Diagnostics warning (editing area)                                                             |
-| `diagnostic.error`          | Diagnostics error (editing area)                                                               |
-
-You can check compliance to spec with
-
-```shell
-cargo xtask themelint onedark  # replace onedark with <name>
-```
+      - `completion` - for completion doc popup UI
+      - `hover` - for hover popup UI
+
+
+| Key                               | Notes                                                                                          |
+| ---                               | ---                                                                                            |
+| `ui.background`                   |                                                                                                |
+| `ui.background.separator`         | Picker separator below input line                                                              |
+| `ui.cursor`                       |                                                                                                |
+| `ui.cursor.normal`                |                                                                                                |
+| `ui.cursor.insert`                |                                                                                                |
+| `ui.cursor.select`                |                                                                                                |
+| `ui.cursor.match`                 | Matching bracket etc.                                                                          |
+| `ui.cursor.primary`               | Cursor with primary selection                                                                  |
+| `ui.cursor.primary.normal`        |                                                                                                |
+| `ui.cursor.primary.insert`        |                                                                                                |
+| `ui.cursor.primary.select`        |                                                                                                |
+| `ui.debug.breakpoint`             | Breakpoint indicator, found in the gutter                                                      |
+| `ui.debug.active`                 | Indicator for the line at which debugging execution is paused at, found in the gutter          |
+| `ui.gutter`                       | Gutter                                                                                         |
+| `ui.gutter.selected`              | Gutter for the line the cursor is on                                                           |
+| `ui.highlight.frameline`          | Line at which debugging execution is paused at                                                 |
+| `ui.linenr`                       | Line numbers                                                                                   |
+| `ui.linenr.selected`              | Line number for the line the cursor is on                                                      |
+| `ui.statusline`                   | Statusline                                                                                     |
+| `ui.statusline.inactive`          | Statusline (unfocused document)                                                                |
+| `ui.statusline.normal`            | Statusline mode during normal mode ([only if `editor.color-modes` is enabled][editor-section]) |
+| `ui.statusline.insert`            | Statusline mode during insert mode ([only if `editor.color-modes` is enabled][editor-section]) |
+| `ui.statusline.select`            | Statusline mode during select mode ([only if `editor.color-modes` is enabled][editor-section]) |
+| `ui.statusline.separator`         | Separator character in statusline                                                              |
+| `ui.popup`                        | Documentation popups (e.g. Space + k)                                                          |
+| `ui.popup.info`                   | Prompt for multiple key options                                                                |
+| `ui.window`                       | Borderlines separating splits                                                                  |
+| `ui.help`                         | Description box for commands                                                                   |
+| `ui.text`                         | Command prompts, popup text, etc.                                                              |
+| `ui.text.focus`                   |                                                                                                |
+| `ui.text.inactive`                | Same as `ui.text` but when the text is inactive (e.g. suggestions)                             |
+| `ui.text.info`                    | The key: command text in `ui.popup.info` boxes                                                 |
+| `ui.virtual.ruler`                | Ruler columns (see the [`editor.rulers` config][editor-section])                               |
+| `ui.virtual.whitespace`           | Visible whitespace characters                                                                  |
+| `ui.virtual.indent-guide`         | Vertical indent width guides                                                                   |
+| `ui.virtual.inlay-hint`           | Default style for inlay hints of all kinds                                                     |
+| `ui.virtual.inlay-hint.parameter` | Style for inlay hints of kind `parameter` (LSPs are not required to set a kind)                |
+| `ui.virtual.inlay-hint.type`      | Style for inlay hints of kind `type` (LSPs are not required to set a kind)                     |
+| `ui.virtual.wrap`                 | Soft-wrap indicator (see the [`editor.soft-wrap` config][editor-section])                      |
+| `ui.menu`                         | Code and command completion menus                                                              |
+| `ui.menu.selected`                | Selected autocomplete item                                                                     |
+| `ui.menu.scroll`                  | `fg` sets thumb color, `bg` sets track color of scrollbar                                      |
+| `ui.selection`                    | For selections in the editing area                                                             |
+| `ui.selection.primary`            |                                                                                                |
+| `ui.highlight`                    | Highlighted lines in the picker preview                                                        |
+| `ui.cursorline.primary`           | The line of the primary cursor ([if cursorline is enabled][editor-section])                    |
+| `ui.cursorline.secondary`         | The lines of any other cursors ([if cursorline is enabled][editor-section])                    |
+| `ui.cursorcolumn.primary`         | The column of the primary cursor ([if cursorcolumn is enabled][editor-section])                |
+| `ui.cursorcolumn.secondary`       | The columns of any other cursors ([if cursorcolumn is enabled][editor-section])                |
+| `warning`                         | Diagnostics warning (gutter)                                                                   |
+| `error`                           | Diagnostics error (gutter)                                                                     |
+| `info`                            | Diagnostics info (gutter)                                                                      |
+| `hint`                            | Diagnostics hint (gutter)                                                                      |
+| `diagnostic`                      | Diagnostics fallback style (editing area)                                                      |
+| `diagnostic.hint`                 | Diagnostics hint (editing area)                                                                |
+| `diagnostic.info`                 | Diagnostics info (editing area)                                                                |
+| `diagnostic.warning`              | Diagnostics warning (editing area)                                                             |
+| `diagnostic.error`                | Diagnostics error (editing area)                                                               |
 
 [editor-section]: ./configuration.md#editor-section
diff --git a/book/src/usage.md b/book/src/usage.md
index a6eb9ec1d..81cf83725 100644
--- a/book/src/usage.md
+++ b/book/src/usage.md
@@ -1,22 +1,43 @@
-# Usage
+# Using Helix
 
-(Currently not fully documented, see the [keymappings](./keymap.md) list for more.)
+<!--toc:start-->
+- [Registers](#registers)
+  - [User-defined registers](#user-defined-registers)
+  - [Special registers](#special-registers)
+- [Surround](#surround)
+- [Selecting and manipulating text with textobjects](#selecting-and-manipulating-text-with-textobjects)
+- [Navigating using tree-sitter textobjects](#navigating-using-tree-sitter-textobjects)
+- [Moving the selection with syntax-aware motions](#moving-the-selection-with-syntax-aware-motions)
+<!--toc:end-->
 
-See [tutor](https://github.com/helix-editor/helix/blob/master/runtime/tutor) (accessible via `hx --tutor` or `:tutor`) for a vimtutor-like introduction.
+For a full interactive introduction to Helix, refer to the
+[tutor](https://github.com/helix-editor/helix/blob/master/runtime/tutor) which
+can be accessed via the command `hx --tutor` or `:tutor`.
+
+>  Currently, not all functionality is fully documented, please refer to the
+> [key mappings](./keymap.md) list.
 
 ## Registers
 
-Vim-like registers can be used to yank and store text to be pasted later. Usage is similar, with `"` being used to select a register:
+In Helix, registers are storage locations for text and other data, such as the
+result of a search. Registers can be used to cut, copy, and paste text, similar
+to the clipboard in other text editors. Usage is similar to Vim, with `"` being
+used to select a register.
+
+### User-defined registers
+
+Helix allows you to create your own named registers for storing text, for
+example:
 
 - `"ay` - Yank the current selection to register `a`.
 - `"op` - Paste the text in register `o` after the selection.
 
-If there is a selected register before invoking a change or delete command, the selection will be stored in the register and the action will be carried out:
+If a register is selected before invoking a change or delete command, the selection will be stored in the register and the action will be carried out:
 
 - `"hc` - Store the selection in register `h` and then change it (delete and enter insert mode).
 - `"md` - Store the selection in register `m` and delete it.
 
-### Special Registers
+### Special registers
 
 | Register character | Contains              |
 | ---                | ---                   |
@@ -25,41 +46,90 @@ ### Special Registers
 | `"`                | Last yanked text      |
 | `_`                | Black hole            |
 
-> There is no special register for copying to system clipboard, instead special commands and keybindings are provided. See the [keymap](keymap.md#space-mode) for the specifics.
-> The black hole register works as a no-op register, meaning no data will be written to / read from it.
+The system clipboard is not directly supported by a special register. Instead, special commands and keybindings are provided. Refer to the
+[key map](keymap.md#space-mode) for more details.
+
+The black hole register is a no-op register, meaning that no data will be read or written to it.
 
 ## Surround
 
-Functionality similar to [vim-surround](https://github.com/tpope/vim-surround) is built into
-helix. The keymappings have been inspired from [vim-sandwich](https://github.com/machakann/vim-sandwich):
+Helix includes built-in functionality similar to [vim-surround](https://github.com/tpope/vim-surround).
+The keymappings have been inspired from [vim-sandwich](https://github.com/machakann/vim-sandwich):
 
-![surround demo](https://user-images.githubusercontent.com/23398472/122865801-97073180-d344-11eb-8142-8f43809982c6.gif)
+![Surround demo](https://user-images.githubusercontent.com/23398472/122865801-97073180-d344-11eb-8142-8f43809982c6.gif)
 
-- `ms` - Add surround characters
-- `mr` - Replace surround characters
-- `md` - Delete surround characters
+| Key Sequence                      | Action                                  |
+| --------------------------------- | --------------------------------------- |
+| `ms<char>` (after selecting text) | Add surround characters to selection    |
+| `mr<char_to_replace><new_char>`   | Replace the closest surround characters |
+| `md<char_to_delete>`              | Delete the closest surround characters  |
 
-`ms` acts on a selection, so select the text first and use `ms<char>`. `mr` and `md` work
-on the closest pairs found and selections are not required; use counts to act in outer pairs.
+You can use counts to act on outer pairs.
 
-It can also act on multiple selections (yay!). For example, to change every occurrence of `(use)` to `[use]`:
+Surround can also act on multiple selections. For example, to change every occurrence of `(use)` to `[use]`:
 
-- `%` to select the whole file
-- `s` to split the selections on a search term
-- Input `use` and hit Enter
-- `mr([` to replace the parens with square brackets
+1. `%` to select the whole file
+2. `s` to split the selections on a search term
+3. Input `use` and hit Enter
+4. `mr([` to replace the parentheses with square brackets
 
-Multiple characters are currently not supported, but planned.
+Multiple characters are currently not supported, but planned for future release.
 
-## Syntax-tree Motions
+## Selecting and manipulating text with textobjects
 
-`Alt-p`, `Alt-o`, `Alt-i`, and `Alt-n` (or `Alt` and arrow keys) move the primary
-selection according to the selection's place in the syntax tree. Let's walk
-through an example to get familiar with them. Many languages have a syntax like
-so for function calls:
+In Helix, textobjects are a way to select, manipulate and operate on a piece of
+text in a structured way. They allow you to refer to blocks of text based on
+their structure or purpose, such as a word, sentence, paragraph, or even a
+function or block of code.
 
-```
-func(arg1, arg2, arg3)
+![Textobject demo](https://user-images.githubusercontent.com/23398472/124231131-81a4bb00-db2d-11eb-9d10-8e577ca7b177.gif)
+![Textobject tree-sitter demo](https://user-images.githubusercontent.com/23398472/132537398-2a2e0a54-582b-44ab-a77f-eb818942203d.gif)
+
+- `ma` - Select around the object (`va` in Vim, `<alt-a>` in Kakoune)
+- `mi` - Select inside the object (`vi` in Vim, `<alt-i>` in Kakoune)
+
+| Key after `mi` or `ma` | Textobject selected      |
+| ---                    | ---                      |
+| `w`                    | Word                     |
+| `W`                    | WORD                     |
+| `p`                    | Paragraph                |
+| `(`, `[`, `'`, etc.    | Specified surround pairs |
+| `m`                    | The closest surround pair    |
+| `f`                    | Function                 |
+| `c`                    | Class                    |
+| `a`                    | Argument/parameter       |
+| `o`                    | Comment                  |
+| `t`                    | Test                     |
+| `g`                    | Change                   |
+
+>  `f`, `c`, etc. need a tree-sitter grammar active for the current
+document and a special tree-sitter query file to work properly. [Only
+some grammars][lang-support] currently have the query file implemented.
+Contributions are welcome!
+
+## Navigating using tree-sitter textobjects
+
+Navigating between functions, classes, parameters, and other elements is
+possible using tree-sitter and textobject queries. For
+example to move to the next function use `]f`, to move to previous
+class use `[c`, and so on.
+
+![Tree-sitter-nav-demo][tree-sitter-nav-demo]
+
+For the full reference see the [unimpaired][unimpaired-keybinds] section of the key bind
+documentation.
+
+>  This feature relies on tree-sitter textobjects
+> and requires the corresponding query file to work properly.
+
+## Moving the selection with syntax-aware motions
+
+`Alt-p`, `Alt-o`, `Alt-i`, and `Alt-n` (or `Alt` and arrow keys) allow you to move the 
+selection according to its location in the syntax tree. For example, many languages have the
+following syntax for function calls:
+
+```js
+func(arg1, arg2, arg3);
 ```
 
 A function call might be parsed by tree-sitter into a tree like the following.
@@ -93,77 +163,29 @@ ## Syntax-tree Motions
        
 ```
 
-Say we have a selection that wraps `arg1`. The selection is on the `arg1` leaf
-in the tree above.
+If you have a selection that wraps `arg1` (see the tree above), and you use
+`Alt-n`, it will select the next sibling in the syntax tree: `arg2`.
 
-```
+```js
+// before
 func([arg1], arg2, arg3)
+// after
+func(arg1, [arg2], arg3);
 ```
 
-Using `Alt-n` would select the next sibling in the syntax tree: `arg2`.
+Similarly, `Alt-o` will expand the selection to the parent node, in this case, the
+arguments node.
 
-```
-func(arg1, [arg2], arg3)
-```
-
-While `Alt-o` would expand the selection to the parent node. In the tree above we
-can see that we would select the `arguments` node.
-
-```
-func[(arg1, arg2, arg3)]
+```js
+func[(arg1, arg2, arg3)];
 ```
 
 There is also some nuanced behavior that prevents you from getting stuck on a
-node with no sibling. If we have a selection on `arg1`, `Alt-p` would bring us
-to the previous child node. Since `arg1` doesn't have a sibling to its left,
-though, we climb the syntax tree and then take the previous selection. So
-`Alt-p` will move the selection over to the "func" `identifier`.
-
-```
-[func](arg1, arg2, arg3)
-```
-
-## Textobjects
-
-![textobject-demo](https://user-images.githubusercontent.com/23398472/124231131-81a4bb00-db2d-11eb-9d10-8e577ca7b177.gif)
-![textobject-treesitter-demo](https://user-images.githubusercontent.com/23398472/132537398-2a2e0a54-582b-44ab-a77f-eb818942203d.gif)
-
-- `ma` - Select around the object (`va` in Vim, `<alt-a>` in Kakoune)
-- `mi` - Select inside the object (`vi` in Vim, `<alt-i>` in Kakoune)
-
-| Key after `mi` or `ma` | Textobject selected      |
-| ---                    | ---                      |
-| `w`                    | Word                     |
-| `W`                    | WORD                     |
-| `p`                    | Paragraph                |
-| `(`, `[`, `'`, etc     | Specified surround pairs |
-| `m`                    | Closest surround pair    |
-| `f`                    | Function                 |
-| `c`                    | Class                    |
-| `a`                    | Argument/parameter       |
-| `o`                    | Comment                  |
-| `t`                    | Test                     |
-| `g`                    | Change                   |
-
-> NOTE: `f`, `c`, etc need a tree-sitter grammar active for the current
-document and a special tree-sitter query file to work properly. [Only
-some grammars][lang-support] currently have the query file implemented.
-Contributions are welcome!
-
-## Tree-sitter Textobject Based Navigation
-
-Navigating between functions, classes, parameters, etc is made
-possible by leveraging tree-sitter and textobjects queries. For
-example to move to the next function use `]f`, to move to previous
-class use `[c`, and so on.
-
-![tree-sitter-nav-demo][tree-sitter-nav-demo]
-
-See the [unimpaired][unimpaired-keybinds] section of the keybind
-documentation for the full reference.
-
-> NOTE: This feature is dependent on tree-sitter based textobjects
-and therefore requires the corresponding query file to work properly.
+node with no sibling. When using `Alt-p` with a selection on `arg1`, the previous
+child node will be selected. In the event that `arg1` does not have a previous
+sibling, the selection will move up the syntax tree and select the previous
+element. As a result, using `Alt-p` with a selection on `arg1` will move the
+selection to the "func" `identifier`.
 
 [lang-support]: ./lang-support.md
 [unimpaired-keybinds]: ./keymap.md#unimpaired
diff --git a/book/theme/css/variables.css b/book/theme/css/variables.css
index 1bf91b19a..5d0978cc3 100644
--- a/book/theme/css/variables.css
+++ b/book/theme/css/variables.css
@@ -48,6 +48,18 @@
     --searchresults-border-color: #888;
     --searchresults-li-bg: #252932;
     --search-mark-bg: #e3b171;
+    --hljs-background: #191f26;
+    --hljs-color: #e6e1cf;
+    --hljs-quote: #5c6773;
+    --hljs-variable: #ff7733;
+    --hljs-type: #ffee99;
+    --hljs-title: #b8cc52;
+    --hljs-symbol: #ffb454;
+    --hljs-selector-tag: #ff7733;
+    --hljs-selector-tag: #36a3d9;
+    --hljs-selector-tag: #00568d;
+    --hljs-selector-tag: #91b362;
+    --hljs-selector-tag: #d96c75;
 }
 
 .coal {
@@ -88,6 +100,18 @@
     --searchresults-border-color: #98a3ad;
     --searchresults-li-bg: #2b2b2f;
     --search-mark-bg: #355c7d;
+    --hljs-background: #969896;
+    --hljs-color: #cc6666;
+    --hljs-quote: #de935f;
+    --hljs-variable: #f0c674;
+    --hljs-type: #b5bd68;
+    --hljs-title: #8abeb7;
+    --hljs-symbol: #81a2be;
+    --hljs-selector-tag: #b294bb;
+    --hljs-selector-tag: #1d1f21;
+    --hljs-selector-tag: #c5c8c6;
+    --hljs-selector-tag: #718c00;
+    --hljs-selector-tag: #c82829;
 }
 
 .light {
@@ -128,6 +152,14 @@
     --searchresults-border-color: #888;
     --searchresults-li-bg: #e4f2fe;
     --search-mark-bg: #a2cff5;
+    --hljs-background: #f6f7f6;
+    --hljs-color: #000;
+    --hljs-quote: #575757;
+    --hljs-variable: #d70025;
+    --hljs-type: #b21e00;
+    --hljs-title: #0030f2;
+    --hljs-symbol: #008200;
+    --hljs-selector-tag: #9d00ec;
 }
 
 .navy {
@@ -168,6 +200,19 @@
     --searchresults-border-color: #5c5c68;
     --searchresults-li-bg: #242430;
     --search-mark-bg: #a2cff5;
+
+    --hljs-background: #969896;
+    --hljs-color: #cc6666;
+    --hljs-quote: #de935f;
+    --hljs-variable: #f0c674;
+    --hljs-type: #b5bd68;
+    --hljs-title: #8abeb7;
+    --hljs-symbol: #81a2be;
+    --hljs-selector-tag: #b294bb;
+    --hljs-selector-tag: #1d1f21;
+    --hljs-selector-tag: #c5c8c6;
+    --hljs-selector-tag: #718c00;
+    --hljs-selector-tag: #c82829;
 }
 
 .rust {
@@ -208,6 +253,14 @@
     --searchresults-border-color: #888;
     --searchresults-li-bg: #dec2a2;
     --search-mark-bg: #e69f67;
+    --hljs-background: #f6f7f6;
+    --hljs-color: #000;
+    --hljs-quote: #575757;
+    --hljs-variable: #d70025;
+    --hljs-type: #b21e00;
+    --hljs-title: #0030f2;
+    --hljs-symbol: #008200;
+    --hljs-selector-tag: #9d00ec;
 }
 
 @media (prefers-color-scheme: dark) {
@@ -292,7 +345,15 @@
     --searchresults-header-fg: #5f5f71;
     --searchresults-border-color: #5c5c68;
     --searchresults-li-bg: #242430;
-    --search-mark-bg: #a2cff5;
+    --search-mark-bg: #acff5;
+    --hljs-background: #2f1e2e;
+    --hljs-color: #a39e9b;
+    --hljs-quote: #8d8687;
+    --hljs-variable: #ef6155;
+    --hljs-type: #f99b15;
+    --hljs-title: #fec418;
+    --hljs-symbol: #48b685;
+    --hljs-selector-tag: #815ba4;
 }
 
 .colibri {
@@ -338,5 +399,13 @@
     --searchresults-border-color: #5c5c68;
     --searchresults-li-bg: #242430;
     --search-mark-bg: #a2cff5;
+    --hljs-background: #TODO;
+    --hljs-color: #TODO;
+    --hljs-quote: #TODO;
+    --hljs-variable: #TODO;
+    --hljs-type: #TODO;
+    --hljs-title: #TODO;
+    --hljs-symbol: #TODO;
+    --hljs-selector-tag: #TODO;
 */
 }
diff --git a/book/theme/highlight.css b/book/theme/highlight.css
index 8dce7d65f..a2db0500a 100644
--- a/book/theme/highlight.css
+++ b/book/theme/highlight.css
@@ -7,12 +7,12 @@ code.hljs {
  padding:3px 5px
 }
 .hljs {
- background:#2f1e2e;
- color:#a39e9b
+ background: var(--hljs-background);
+ color: var(--hljs-color);
 }
 .hljs-comment,
 .hljs-quote {
- color:#8d8687
+ color: var(--hljs-quote)
 }
 .hljs-link,
 .hljs-meta,
@@ -23,7 +23,7 @@ code.hljs {
 .hljs-tag,
 .hljs-template-variable,
 .hljs-variable {
- color:#ef6155
+ color: var(--hljs-variable)
 }
 .hljs-built_in,
 .hljs-deletion,
@@ -31,22 +31,22 @@ code.hljs {
 .hljs-number,
 .hljs-params,
 .hljs-type {
- color:#f99b15
+ color: var(--hljs-type)
 }
 .hljs-attribute,
 .hljs-section,
 .hljs-title {
- color:#fec418
+ color: var(--hljs-title)
 }
 .hljs-addition,
 .hljs-bullet,
 .hljs-string,
 .hljs-symbol {
- color:#48b685
+ color: var(--hljs-symbol)
 }
 .hljs-keyword,
 .hljs-selector-tag {
- color:#815ba4
+ color: var(--hljs-selector-tag)
 }
 .hljs-emphasis {
  font-style:italic
diff --git a/contrib/Helix.appdata.xml b/contrib/Helix.appdata.xml
new file mode 100644
index 000000000..b99738a18
--- /dev/null
+++ b/contrib/Helix.appdata.xml
@@ -0,0 +1,90 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component type="desktop-application">
+  <id>com.helix_editor.Helix</id>
+  <metadata_license>CC0-1.0</metadata_license>
+  <project_license>MPL-2.0</project_license>
+  <name>Helix</name>
+  <summary>A post-modern text editor</summary>
+
+  <description>
+    <p>
+      Helix is a terminal-based text editor inspired by Kakoune / Neovim and written in Rust.
+    </p>
+    <ul>
+      <li>Vim-like modal editing</li>
+      <li>Multiple selections</li>
+      <li>Built-in language server support</li>
+      <li>Smart, incremental syntax highlighting and code editing via tree-sitter</li>
+    </ul>
+  </description>
+
+  <launchable type="desktop-id">Helix.desktop</launchable>
+
+  <screenshots>
+    <screenshot type="default">
+      <caption>Helix with default theme</caption>
+      <image>https://github.com/helix-editor/helix/raw/d4565b4404cabc522bd60822abd374755581d751/screenshot.png</image>
+    </screenshot>
+  </screenshots>
+
+  <url type="homepage">https://helix-editor.com/</url>
+  <url type="donation">https://opencollective.com/helix-editor</url>
+  <url type="help">https://docs.helix-editor.com/</url>
+  <url type="vcs-browser">https://github.com/helix-editor/helix</url>
+  <url type="bugtracker">https://github.com/helix-editor/helix/issues</url>
+
+  <content_rating type="oars-1.1" />
+
+  <releases>
+    <release version="23.03" date="2023-03-31">
+      <url>https://helix-editor.com/news/release-23-03-highlights/</url>
+    </release>
+    <release version="22.12" date="2022-12-6">
+      <url>https://helix-editor.com/news/release-22-12-highlights/</url>
+    </release>
+    <release version="22.08" date="2022-8-31">
+      <url>https://helix-editor.com/news/release-22-08-highlights/</url>
+    </release>
+    <release version="22.05" date="2022-5-28">
+      <url>https://helix-editor.com/news/release-22-05-highlights/</url>
+    </release>
+    <release version="22.03" date="2022-3-28">
+      <url>https://helix-editor.com/news/release-22-03-highlights/</url>
+    </release>
+  </releases>
+
+  <requires>
+    <control>keyboard</control>
+  </requires>
+
+  <categories>
+    <category>Utility</category>
+    <category>TextEditor</category>
+  </categories>
+
+  <keywords>
+    <keyword>text</keyword>
+    <keyword>editor</keyword>
+    <keyword>development</keyword>
+    <keyword>programming</keyword>
+  </keywords>
+
+  <provides>
+    <binary>hx</binary>
+    <mediatype>text/english</mediatype>
+    <mediatype>text/plain</mediatype>
+    <mediatype>text/x-makefile</mediatype>
+    <mediatype>text/x-c++hdr</mediatype>
+    <mediatype>text/x-c++src</mediatype>
+    <mediatype>text/x-chdr</mediatype>
+    <mediatype>text/x-csrc</mediatype>
+    <mediatype>text/x-java</mediatype>
+    <mediatype>text/x-moc</mediatype>
+    <mediatype>text/x-pascal</mediatype>
+    <mediatype>text/x-tcl</mediatype>
+    <mediatype>text/x-tex</mediatype>
+    <mediatype>application/x-shellscript</mediatype>
+    <mediatype>text/x-c</mediatype>
+    <mediatype>text/x-c++</mediatype>
+  </provides>
+</component>
diff --git a/docs/CONTRIBUTING.md b/docs/CONTRIBUTING.md
index 491cd4249..982b2237e 100644
--- a/docs/CONTRIBUTING.md
+++ b/docs/CONTRIBUTING.md
@@ -8,7 +8,10 @@ # Contributing
 - Help with packaging on various distributions needed!
 - To use print debugging to the [Helix log file][log-file], you must:
   * Print using `log::info!`, `warn!`, or `error!`. (`log::info!("helix!")`)
-  * Pass the appropriate verbosity level option for the desired log level. (`hx -v <file>` for info, more `v`s for higher severity inclusive)
+  * Pass the appropriate verbosity level option for the desired log level. (`hx -v <file>` for info, more `v`s for higher verbosity)
+  * Want to display the logs in a separate file instead of using the `:log-open` command in your compiled Helix editor? Start your debug version with `cargo run -- --log foo.log` and in a new terminal use `tail -f foo.log`
+- Instead of running a release version of Helix, while developing you may want to run in debug mode with `cargo run` which is way faster to compile
+- Looking for even faster compile times? Give a try to [mold](https://github.com/rui314/mold)
 - If your preferred language is missing, integrating a tree-sitter grammar for
     it and defining syntax highlight queries for it is straight forward and
     doesn't require much knowledge of the internals.
@@ -30,7 +33,13 @@ # Auto generated documentation
 thus do not require any dependencies other than `cargo` (You don't have
 to `cargo install` anything either).
 
-# Integration tests
+# Testing
+
+## Unit tests/Documentation tests
+
+Run `cargo test --workspace` to run unit tests and documentation tests in all packages.
+
+## Integration tests
 
 Integration tests for helix-term can be run with `cargo integration-test`. Code
 contributors are strongly encouraged to write integration tests for their code.
diff --git a/docs/releases.md b/docs/releases.md
index ec0b72704..6e7c37c6e 100644
--- a/docs/releases.md
+++ b/docs/releases.md
@@ -5,6 +5,7 @@ ## Checklist
 we'll use `<tag>` as a placeholder for the tag being published.
 
 * Merge the changelog PR
+* Add new `<release>` entry in `contrib/Helix.appdata.xml` with release information according to the [AppStream spec](https://www.freedesktop.org/software/appstream/docs/sect-Metadata-Releases.html)
 * Tag and push
     * `git tag -s -m "<tag>" -a <tag> && git push`
     * Make sure to switch to master and pull first
diff --git a/flake.lock b/flake.lock
index f097519e3..d33c404ef 100644
--- a/flake.lock
+++ b/flake.lock
@@ -3,11 +3,11 @@
     "crane": {
       "flake": false,
       "locked": {
-        "lastModified": 1661875961,
-        "narHash": "sha256-f1h/2c6Teeu1ofAHWzrS8TwBPcnN+EEu+z1sRVmMQTk=",
+        "lastModified": 1670900067,
+        "narHash": "sha256-VXVa+KBfukhmWizaiGiHRVX/fuk66P8dgSFfkVN4/MY=",
         "owner": "ipetkov",
         "repo": "crane",
-        "rev": "d9f394e4e20e97c2a60c3ad82c2b6ef99be19e24",
+        "rev": "59b31b41a589c0a65e4a1f86b0e5eac68081468b",
         "type": "github"
       },
       "original": {
@@ -16,34 +16,20 @@
         "type": "github"
       }
     },
-    "devshell": {
-      "flake": false,
-      "locked": {
-        "lastModified": 1667210711,
-        "narHash": "sha256-IoErjXZAkzYWHEpQqwu/DeRNJGFdR7X2OGbkhMqMrpw=",
-        "owner": "numtide",
-        "repo": "devshell",
-        "rev": "96a9dd12b8a447840cc246e17a47b81a4268bba7",
-        "type": "github"
-      },
-      "original": {
-        "owner": "numtide",
-        "repo": "devshell",
-        "type": "github"
-      }
-    },
     "dream2nix": {
       "inputs": {
-        "alejandra": [
-          "nci"
-        ],
         "all-cabal-json": [
           "nci"
         ],
         "crane": "crane",
         "devshell": [
+          "nci"
+        ],
+        "drv-parts": "drv-parts",
+        "flake-compat": "flake-compat",
+        "flake-parts": [
           "nci",
-          "devshell"
+          "parts"
         ],
         "flake-utils-pre-commit": [
           "nci"
@@ -57,23 +43,30 @@
         "mach-nix": [
           "nci"
         ],
+        "nix-pypi-fetcher": [
+          "nci"
+        ],
         "nixpkgs": [
           "nci",
           "nixpkgs"
         ],
+        "nixpkgsV1": "nixpkgsV1",
         "poetry2nix": [
           "nci"
         ],
         "pre-commit-hooks": [
           "nci"
+        ],
+        "pruned-racket-catalog": [
+          "nci"
         ]
       },
       "locked": {
-        "lastModified": 1668851003,
-        "narHash": "sha256-X7RCQQynbxStZR2m7HW38r/msMQwVl3afD6UXOCtvx4=",
+        "lastModified": 1680258209,
+        "narHash": "sha256-lEo50RXI/17/a9aCIun8Hz62ZJ5JM5RGeTgclIP+Lgc=",
         "owner": "nix-community",
         "repo": "dream2nix",
-        "rev": "c77e8379d8fe01213ba072e40946cbfb7b58e628",
+        "rev": "6f512b5a220fdb26bd3c659f7b55e4f052ec8b35",
         "type": "github"
       },
       "original": {
@@ -82,6 +75,54 @@
         "type": "github"
       }
     },
+    "drv-parts": {
+      "inputs": {
+        "flake-compat": [
+          "nci",
+          "dream2nix",
+          "flake-compat"
+        ],
+        "flake-parts": [
+          "nci",
+          "dream2nix",
+          "flake-parts"
+        ],
+        "nixpkgs": [
+          "nci",
+          "dream2nix",
+          "nixpkgs"
+        ]
+      },
+      "locked": {
+        "lastModified": 1680172861,
+        "narHash": "sha256-QMyI338xRxaHFDlCXdLCtgelGQX2PdlagZALky4ZXJ8=",
+        "owner": "davhau",
+        "repo": "drv-parts",
+        "rev": "ced8a52f62b0a94244713df2225c05c85b416110",
+        "type": "github"
+      },
+      "original": {
+        "owner": "davhau",
+        "repo": "drv-parts",
+        "type": "github"
+      }
+    },
+    "flake-compat": {
+      "flake": false,
+      "locked": {
+        "lastModified": 1673956053,
+        "narHash": "sha256-4gtG9iQuiKITOjNQQeQIpoIB6b16fm+504Ch3sNKLd8=",
+        "owner": "edolstra",
+        "repo": "flake-compat",
+        "rev": "35bb57c0c8d8b62bbfd284272c928ceb64ddbde9",
+        "type": "github"
+      },
+      "original": {
+        "owner": "edolstra",
+        "repo": "flake-compat",
+        "type": "github"
+      }
+    },
     "flake-utils": {
       "locked": {
         "lastModified": 1659877975,
@@ -97,23 +138,40 @@
         "type": "github"
       }
     },
+    "mk-naked-shell": {
+      "flake": false,
+      "locked": {
+        "lastModified": 1676572903,
+        "narHash": "sha256-oQoDHHUTxNVSURfkFcYLuAK+btjs30T4rbEUtCUyKy8=",
+        "owner": "yusdacra",
+        "repo": "mk-naked-shell",
+        "rev": "aeca9f8aa592f5e8f71f407d081cb26fd30c5a57",
+        "type": "github"
+      },
+      "original": {
+        "owner": "yusdacra",
+        "repo": "mk-naked-shell",
+        "type": "github"
+      }
+    },
     "nci": {
       "inputs": {
-        "devshell": "devshell",
         "dream2nix": "dream2nix",
+        "mk-naked-shell": "mk-naked-shell",
         "nixpkgs": [
           "nixpkgs"
         ],
+        "parts": "parts",
         "rust-overlay": [
           "rust-overlay"
         ]
       },
       "locked": {
-        "lastModified": 1669011203,
-        "narHash": "sha256-Lymj4HktNEFmVXtwI0Os7srDXHZbZW0Nzw3/+5Hf8ko=",
+        "lastModified": 1680329418,
+        "narHash": "sha256-+KN0eQLSZvL1J0kDO8/fxv0UCHTyZCADLmpIfeeiSGo=",
         "owner": "yusdacra",
         "repo": "nix-cargo-integration",
-        "rev": "c5133b91fc1d549087c91228bd213f2518728a4b",
+        "rev": "98c1d2ff5155f0fee5d290f6b982cb990839d540",
         "type": "github"
       },
       "original": {
@@ -124,11 +182,11 @@
     },
     "nixpkgs": {
       "locked": {
-        "lastModified": 1668905981,
-        "narHash": "sha256-RBQa/+9Uk1eFTqIOXBSBezlEbA3v5OkgP+qptQs1OxY=",
+        "lastModified": 1680213900,
+        "narHash": "sha256-cIDr5WZIj3EkKyCgj/6j3HBH4Jj1W296z7HTcWj1aMA=",
         "owner": "nixos",
         "repo": "nixpkgs",
-        "rev": "690ffff026b4e635b46f69002c0f4e81c65dfc2e",
+        "rev": "e3652e0735fbec227f342712f180f4f21f0594f2",
         "type": "github"
       },
       "original": {
@@ -138,10 +196,83 @@
         "type": "github"
       }
     },
+    "nixpkgs-lib": {
+      "locked": {
+        "dir": "lib",
+        "lastModified": 1678375444,
+        "narHash": "sha256-XIgHfGvjFvZQ8hrkfocanCDxMefc/77rXeHvYdzBMc8=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "130fa0baaa2b93ec45523fdcde942f6844ee9f6e",
+        "type": "github"
+      },
+      "original": {
+        "dir": "lib",
+        "owner": "NixOS",
+        "ref": "nixos-unstable",
+        "repo": "nixpkgs",
+        "type": "github"
+      }
+    },
+    "nixpkgsV1": {
+      "locked": {
+        "lastModified": 1678500271,
+        "narHash": "sha256-tRBLElf6f02HJGG0ZR7znMNFv/Uf7b2fFInpTHiHaSE=",
+        "owner": "NixOS",
+        "repo": "nixpkgs",
+        "rev": "5eb98948b66de29f899c7fe27ae112a47964baf8",
+        "type": "github"
+      },
+      "original": {
+        "id": "nixpkgs",
+        "ref": "nixos-22.11",
+        "type": "indirect"
+      }
+    },
+    "parts": {
+      "inputs": {
+        "nixpkgs-lib": [
+          "nci",
+          "nixpkgs"
+        ]
+      },
+      "locked": {
+        "lastModified": 1679737941,
+        "narHash": "sha256-srSD9CwsVPnUMsIZ7Kt/UegkKUEBcTyU1Rev7mO45S0=",
+        "owner": "hercules-ci",
+        "repo": "flake-parts",
+        "rev": "3502ee99d6dade045bdeaf7b0cd8ec703484c25c",
+        "type": "github"
+      },
+      "original": {
+        "owner": "hercules-ci",
+        "repo": "flake-parts",
+        "type": "github"
+      }
+    },
+    "parts_2": {
+      "inputs": {
+        "nixpkgs-lib": "nixpkgs-lib"
+      },
+      "locked": {
+        "lastModified": 1679737941,
+        "narHash": "sha256-srSD9CwsVPnUMsIZ7Kt/UegkKUEBcTyU1Rev7mO45S0=",
+        "owner": "hercules-ci",
+        "repo": "flake-parts",
+        "rev": "3502ee99d6dade045bdeaf7b0cd8ec703484c25c",
+        "type": "github"
+      },
+      "original": {
+        "owner": "hercules-ci",
+        "repo": "flake-parts",
+        "type": "github"
+      }
+    },
     "root": {
       "inputs": {
         "nci": "nci",
         "nixpkgs": "nixpkgs",
+        "parts": "parts_2",
         "rust-overlay": "rust-overlay"
       }
     },
@@ -153,11 +284,11 @@
         ]
       },
       "locked": {
-        "lastModified": 1668998422,
-        "narHash": "sha256-G/BklIplCHZEeDIabaaxqgITdIXtMolRGlwxn9jG2/Q=",
+        "lastModified": 1680315536,
+        "narHash": "sha256-0AsBuKssJMbcRcw4HJQwJsUHhZxR5+gaf6xPQayhR44=",
         "owner": "oxalica",
         "repo": "rust-overlay",
-        "rev": "68ab029c93f8f8eed4cf3ce9a89a9fd4504b2d6e",
+        "rev": "5c8c151bdd639074a0051325c16df1a64ee23497",
         "type": "github"
       },
       "original": {
diff --git a/flake.nix b/flake.nix
index fe1c6b44b..6dcaf6cc4 100644
--- a/flake.nix
+++ b/flake.nix
@@ -12,16 +12,10 @@
       inputs.nixpkgs.follows = "nixpkgs";
       inputs.rust-overlay.follows = "rust-overlay";
     };
+    parts.url = "github:hercules-ci/flake-parts";
   };
 
-  outputs = {
-    self,
-    nixpkgs,
-    nci,
-    ...
-  }: let
-    lib = nixpkgs.lib;
-    ncl = nci.lib.nci-lib;
+  outputs = inp: let
     mkRootPath = rel:
       builtins.path {
         path = "${toString ./.}/${rel}";
@@ -32,6 +26,12 @@
         ".envrc"
         ".ignore"
         ".github"
+        ".gitignore"
+        "logo.svg"
+        "logo_dark.svg"
+        "logo_light.svg"
+        "rust-toolchain.toml"
+        "rustfmt.toml"
         "runtime"
         "screenshot.png"
         "book"
@@ -46,6 +46,7 @@
         "flake.lock"
       ];
       ignorePaths = path: type: let
+        inherit (inp.nixpkgs) lib;
         # split the nix store path into its components
         components = lib.splitString "/" path;
         # drop off the `/nix/hash-source` section from the path
@@ -61,117 +62,105 @@
         # filter out unnecessary paths
         filter = ignorePaths;
       };
-    outputs = nci.lib.makeOutputs {
-      root = ./.;
-      config = common: {
-        outputs = {
-          # rename helix-term to helix since it's our main package
-          rename = {"helix-term" = "helix";};
-          # Set default app to hx (binary is from helix-term release build)
-          # Set default package to helix-term release build
-          defaults = {
-            app = "hx";
-            package = "helix";
-          };
-        };
-        cCompiler.package = with common.pkgs;
-          if stdenv.isLinux
-          then gcc
-          else clang;
-        shell = {
-          packages = with common.pkgs;
-            [lld_13 cargo-flamegraph rust-analyzer]
-            ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) cargo-tarpaulin)
-            ++ (lib.optional stdenv.isLinux lldb);
-          env = [
-            {
-              name = "HELIX_RUNTIME";
-              eval = "$PWD/runtime";
-            }
-            {
-              name = "RUST_BACKTRACE";
-              value = "1";
-            }
+  in
+    inp.parts.lib.mkFlake {inputs = inp;} {
+      imports = [inp.nci.flakeModule];
+      systems = [
+        "x86_64-linux"
+        "x86_64-darwin"
+        "aarch64-linux"
+        "aarch64-darwin"
+        "i686-linux"
+      ];
+      perSystem = {
+        config,
+        pkgs,
+        lib,
+        ...
+      }: let
+        makeOverridableHelix = old: config: let
+          grammars = pkgs.callPackage ./grammars.nix config;
+          runtimeDir = pkgs.runCommand "helix-runtime" {} ''
+            mkdir -p $out
+            ln -s ${mkRootPath "runtime"}/* $out
+            rm -r $out/grammars
+            ln -s ${grammars} $out/grammars
+          '';
+          helix-wrapped =
+            pkgs.runCommand
+            old.name
             {
-              name = "RUSTFLAGS";
-              value =
-                if common.pkgs.stdenv.isLinux
-                then "-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment"
-                else "";
+              inherit (old) pname version;
+              meta = old.meta or {};
+              passthru =
+                (old.passthru or {})
+                // {
+                  unwrapped = old;
+                };
+              nativeBuildInputs = [pkgs.makeWrapper];
+              makeWrapperArgs = config.makeWrapperArgs or [];
             }
-          ];
-        };
-      };
-      pkgConfig = common: {
-        helix-term = {
-          # Wrap helix with runtime
-          wrapper = _: old: let
-            inherit (common) pkgs;
-            makeOverridableHelix = old: config: let
-              grammars = pkgs.callPackage ./grammars.nix config;
-              runtimeDir = pkgs.runCommand "helix-runtime" {} ''
-                mkdir -p $out
-                ln -s ${mkRootPath "runtime"}/* $out
-                rm -r $out/grammars
-                ln -s ${grammars} $out/grammars
-              '';
-              helix-wrapped =
-                common.internal.pkgsSet.utils.wrapDerivation old
-                {
-                  nativeBuildInputs = [pkgs.makeWrapper];
-                  makeWrapperArgs = config.makeWrapperArgs or [];
-                }
-                ''
-                  rm -rf $out/bin
-                  mkdir -p $out/bin
-                  ln -sf ${old}/bin/* $out/bin/
-                  wrapProgram "$out/bin/hx" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME "${runtimeDir}"
-                '';
-            in
-              helix-wrapped
-              // {override = makeOverridableHelix old;};
-          in
-            makeOverridableHelix old {};
-          overrides.fix-build.overrideAttrs = prev: {
-            src = filteredSource;
-
-            # disable fetching and building of tree-sitter grammars in the helix-term build.rs
-            HELIX_DISABLE_AUTO_GRAMMAR_BUILD = "1";
-
-            buildInputs = ncl.addBuildInputs prev [common.config.cCompiler.package.cc.lib];
-
-            # link languages and theme toml files since helix-term expects them (for tests)
-            preConfigure = ''
-              ${prev.preConfigure or ""}
-              ${
-                lib.concatMapStringsSep
-                "\n"
-                (path: "ln -sf ${mkRootPath path} ..")
-                ["languages.toml" "theme.toml" "base16_theme.toml"]
-              }
+            ''
+              cp -rs --no-preserve=mode,ownership ${old} $out
+              wrapProgram "$out/bin/hx" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME "${runtimeDir}"
             '';
-            checkPhase = ":";
-
-            meta.mainProgram = "hx";
+        in
+          helix-wrapped
+          // {
+            override = makeOverridableHelix old;
+            passthru =
+              helix-wrapped.passthru
+              // {
+                wrapper = old: makeOverridableHelix old config;
+              };
+          };
+        stdenv =
+          if pkgs.stdenv.isLinux
+          then pkgs.stdenv
+          else pkgs.clangStdenv;
+        rustFlagsEnv =
+          if stdenv.isLinux
+          then ''$RUSTFLAGS -C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment''
+          else "$RUSTFLAGS";
+      in {
+        nci.projects."helix-project".relPath = "";
+        nci.crates."helix-term" = {
+          overrides = {
+            add-meta.override = _: {meta.mainProgram = "hx";};
+            add-inputs.overrideAttrs = prev: {
+              buildInputs = (prev.buildInputs or []) ++ [stdenv.cc.cc.lib];
+            };
+            disable-grammar-builds = {
+              # disable fetching and building of tree-sitter grammars in the helix-term build.rs
+              HELIX_DISABLE_AUTO_GRAMMAR_BUILD = "1";
+            };
+            disable-tests = {checkPhase = ":";};
+            set-stdenv.override = _: {inherit stdenv;};
+            set-filtered-src.override = _: {src = filteredSource;};
           };
         };
+
+        packages.helix-unwrapped = config.nci.outputs."helix-term".packages.release;
+        packages.helix-unwrapped-dev = config.nci.outputs."helix-term".packages.dev;
+        packages.helix = makeOverridableHelix config.packages.helix-unwrapped {};
+        packages.helix-dev = makeOverridableHelix config.packages.helix-unwrapped-dev {};
+        packages.default = config.packages.helix;
+
+        devShells.default = config.nci.outputs."helix-project".devShell.overrideAttrs (old: {
+          nativeBuildInputs =
+            (old.nativeBuildInputs or [])
+            ++ (with pkgs; [lld_13 cargo-flamegraph rust-analyzer])
+            ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) pkgs.cargo-tarpaulin)
+            ++ (lib.optional stdenv.isLinux pkgs.lldb)
+            ++ (lib.optional stdenv.isDarwin pkgs.darwin.apple_sdk.frameworks.CoreFoundation);
+          shellHook = ''
+            export HELIX_RUNTIME="$PWD/runtime"
+            export RUST_BACKTRACE="1"
+            export RUSTFLAGS="${rustFlagsEnv}"
+          '';
+        });
       };
     };
-  in
-    outputs
-    // {
-      packages =
-        lib.mapAttrs
-        (
-          system: packages:
-            packages
-            // {
-              helix-unwrapped = packages.helix.passthru.unwrapped;
-              helix-unwrapped-dev = packages.helix-dev.passthru.unwrapped;
-            }
-        )
-        outputs.packages;
-    };
 
   nixConfig = {
     extra-substituters = ["https://helix.cachix.org"];
diff --git a/helix-core/Cargo.toml b/helix-core/Cargo.toml
index 31b6546f0..e5c5f8f1a 100644
--- a/helix-core/Cargo.toml
+++ b/helix-core/Cargo.toml
@@ -17,7 +17,7 @@ integration = []
 [dependencies]
 helix-loader = { version = "0.6", path = "../helix-loader" }
 
-ropey = { version = "1.5.1-alpha", default-features = false, features = ["simd"] }
+ropey = { version = "1.6.0", default-features = false, features = ["simd"] }
 smallvec = "1.10"
 smartstring = "1.0.1"
 unicode-segmentation = "1.10"
@@ -26,17 +26,18 @@ unicode-general-category = "0.6"
 # slab = "0.4.2"
 slotmap = "1.0"
 tree-sitter = "0.20"
-once_cell = "1.16"
+once_cell = "1.17"
 arc-swap = "1"
 regex = "1"
-bitflags = "1.3"
-ahash = "0.8.2"
-hashbrown = { version = "0.13.1", features = ["raw"] }
+bitflags = "2.0"
+ahash = "0.8.3"
+hashbrown = { version = "0.13.2", features = ["raw"] }
+dunce = "1.0"
 
 log = "0.4"
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
-toml = "0.5"
+toml = "0.7"
 
 imara-diff = "0.1.0"
 
@@ -49,3 +50,4 @@ textwrap = "0.16.0"
 
 [dev-dependencies]
 quickcheck = { version = "1", default-features = false }
+indoc = "2.0.1"
diff --git a/helix-core/src/auto_pairs.rs b/helix-core/src/auto_pairs.rs
index 072c93d01..31f9d3649 100644
--- a/helix-core/src/auto_pairs.rs
+++ b/helix-core/src/auto_pairs.rs
@@ -17,7 +17,7 @@
 ];
 
 /// The type that represents the collection of auto pairs,
-/// keyed by the opener.
+/// keyed by both opener and closer.
 #[derive(Debug, Clone)]
 pub struct AutoPairs(HashMap<char, Pair>);
 
diff --git a/helix-core/src/comment.rs b/helix-core/src/comment.rs
index ec5d7a45a..9c7e50f33 100644
--- a/helix-core/src/comment.rs
+++ b/helix-core/src/comment.rs
@@ -45,7 +45,7 @@ fn find_line_comment(
 
             // determine margin of 0 or 1 for uncommenting; if any comment token is not followed by a space,
             // a margin of 0 is used for all lines.
-            if matches!(line_slice.get_char(pos + token_len), Some(c) if c != ' ') {
+            if !matches!(line_slice.get_char(pos + token_len), Some(c) if c == ' ') {
                 margin = 0;
             }
 
@@ -68,7 +68,7 @@ pub fn toggle_line_comments(doc: &Rope, selection: &Selection, token: Option<&st
     let mut min_next_line = 0;
     for selection in selection {
         let (start, end) = selection.line_range(text);
-        let start = start.max(min_next_line).min(text.len_lines());
+        let start = start.clamp(min_next_line, text.len_lines());
         let end = (end + 1).min(text.len_lines());
 
         lines.extend(start..end);
@@ -108,8 +108,8 @@ fn test_find_line_comment() {
         let text = doc.slice(..);
 
         let res = find_line_comment("//", text, 0..3);
-        // (commented = true, to_change = [line 0, line 2], min = col 2, margin = 1)
-        assert_eq!(res, (false, vec![0, 2], 2, 1));
+        // (commented = true, to_change = [line 0, line 2], min = col 2, margin = 0)
+        assert_eq!(res, (false, vec![0, 2], 2, 0));
 
         // comment
         let transaction = toggle_line_comments(&doc, &selection, None);
@@ -136,6 +136,17 @@ fn test_find_line_comment() {
         assert_eq!(doc, "  1\n\n  2\n  3");
         assert!(selection.len() == 1); // to ignore the selection unused warning
 
+        // 0 margin comments, with no space
+        doc = Rope::from("//");
+        // reset the selection.
+        selection = Selection::single(0, doc.len_chars() - 1);
+
+        let transaction = toggle_line_comments(&doc, &selection, None);
+        transaction.apply(&mut doc);
+        selection = selection.map(transaction.changes());
+        assert_eq!(doc, "");
+        assert!(selection.len() == 1); // to ignore the selection unused warning
+
         // TODO: account for uncommenting with uneven comment indentation
     }
 }
diff --git a/helix-core/src/diagnostic.rs b/helix-core/src/diagnostic.rs
index 6b5da17ef..58ddb0383 100644
--- a/helix-core/src/diagnostic.rs
+++ b/helix-core/src/diagnostic.rs
@@ -35,7 +35,7 @@ pub enum DiagnosticTag {
     Deprecated,
 }
 
-/// Corresponds to [`lsp_types::Diagnostic`](https://docs.rs/lsp-types/0.91.0/lsp_types/struct.Diagnostic.html)
+/// Corresponds to [`lsp_types::Diagnostic`](https://docs.rs/lsp-types/0.94.0/lsp_types/struct.Diagnostic.html)
 #[derive(Debug, Clone)]
 pub struct Diagnostic {
     pub range: Range,
diff --git a/helix-core/src/doc_formatter.rs b/helix-core/src/doc_formatter.rs
new file mode 100644
index 000000000..c7dc9081f
--- /dev/null
+++ b/helix-core/src/doc_formatter.rs
@@ -0,0 +1,384 @@
+//! The `DocumentFormatter` forms the bridge between the raw document text
+//! and onscreen positioning. It yields the text graphemes as an iterator
+//! and traverses (part) of the document text. During that traversal it
+//! handles grapheme detection, softwrapping and annotations.
+//! It yields `FormattedGrapheme`s and their corresponding visual coordinates.
+//!
+//! As both virtual text and softwrapping can insert additional lines into the document
+//! it is generally not possible to find the start of the previous visual line.
+//! Instead the `DocumentFormatter` starts at the last "checkpoint" (usually a linebreak)
+//! called a "block" and the caller must advance it as needed.
+
+use std::borrow::Cow;
+use std::fmt::Debug;
+use std::mem::{replace, take};
+
+#[cfg(test)]
+mod test;
+
+use unicode_segmentation::{Graphemes, UnicodeSegmentation};
+
+use crate::graphemes::{Grapheme, GraphemeStr};
+use crate::syntax::Highlight;
+use crate::text_annotations::TextAnnotations;
+use crate::{Position, RopeGraphemes, RopeSlice};
+
+/// TODO make Highlight a u32 to reduce the size of this enum to a single word.
+#[derive(Debug, Clone, Copy)]
+pub enum GraphemeSource {
+    Document {
+        codepoints: u32,
+    },
+    /// Inline virtual text can not be highlighted with a `Highlight` iterator
+    /// because it's not part of the document. Instead the `Highlight`
+    /// is emitted right by the document formatter
+    VirtualText {
+        highlight: Option<Highlight>,
+    },
+}
+
+#[derive(Debug, Clone)]
+pub struct FormattedGrapheme<'a> {
+    pub grapheme: Grapheme<'a>,
+    pub source: GraphemeSource,
+}
+
+impl<'a> FormattedGrapheme<'a> {
+    pub fn new(
+        g: GraphemeStr<'a>,
+        visual_x: usize,
+        tab_width: u16,
+        source: GraphemeSource,
+    ) -> FormattedGrapheme<'a> {
+        FormattedGrapheme {
+            grapheme: Grapheme::new(g, visual_x, tab_width),
+            source,
+        }
+    }
+    /// Returns whether this grapheme is virtual inline text
+    pub fn is_virtual(&self) -> bool {
+        matches!(self.source, GraphemeSource::VirtualText { .. })
+    }
+
+    pub fn placeholder() -> Self {
+        FormattedGrapheme {
+            grapheme: Grapheme::Other { g: " ".into() },
+            source: GraphemeSource::Document { codepoints: 0 },
+        }
+    }
+
+    pub fn doc_chars(&self) -> usize {
+        match self.source {
+            GraphemeSource::Document { codepoints } => codepoints as usize,
+            GraphemeSource::VirtualText { .. } => 0,
+        }
+    }
+
+    pub fn is_whitespace(&self) -> bool {
+        self.grapheme.is_whitespace()
+    }
+
+    pub fn width(&self) -> usize {
+        self.grapheme.width()
+    }
+
+    pub fn is_word_boundary(&self) -> bool {
+        self.grapheme.is_word_boundary()
+    }
+}
+
+#[derive(Debug, Clone)]
+pub struct TextFormat {
+    pub soft_wrap: bool,
+    pub tab_width: u16,
+    pub max_wrap: u16,
+    pub max_indent_retain: u16,
+    pub wrap_indicator: Box<str>,
+    pub wrap_indicator_highlight: Option<Highlight>,
+    pub viewport_width: u16,
+}
+
+// test implementation is basically only used for testing or when softwrap is always disabled
+impl Default for TextFormat {
+    fn default() -> Self {
+        TextFormat {
+            soft_wrap: false,
+            tab_width: 4,
+            max_wrap: 3,
+            max_indent_retain: 4,
+            wrap_indicator: Box::from(" "),
+            viewport_width: 17,
+            wrap_indicator_highlight: None,
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct DocumentFormatter<'t> {
+    text_fmt: &'t TextFormat,
+    annotations: &'t TextAnnotations,
+
+    /// The visual position at the end of the last yielded word boundary
+    visual_pos: Position,
+    graphemes: RopeGraphemes<'t>,
+    /// The character pos of the `graphemes` iter used for inserting annotations
+    char_pos: usize,
+    /// The line pos of the `graphemes` iter used for inserting annotations
+    line_pos: usize,
+    exhausted: bool,
+
+    /// Line breaks to be reserved for virtual text
+    /// at the next line break
+    virtual_lines: usize,
+    inline_anntoation_graphemes: Option<(Graphemes<'t>, Option<Highlight>)>,
+
+    // softwrap specific
+    /// The indentation of the current line
+    /// Is set to `None` if the indentation level is not yet known
+    /// because no non-whitespace graphemes have been encountered yet
+    indent_level: Option<usize>,
+    /// In case a long word needs to be split a single grapheme might need to be wrapped
+    /// while the rest of the word stays on the same line
+    peeked_grapheme: Option<(FormattedGrapheme<'t>, usize)>,
+    /// A first-in first-out (fifo) buffer for the Graphemes of any given word
+    word_buf: Vec<FormattedGrapheme<'t>>,
+    /// The index of the next grapheme that will be yielded from the `word_buf`
+    word_i: usize,
+}
+
+impl<'t> DocumentFormatter<'t> {
+    /// Creates a new formatter at the last block before `char_idx`.
+    /// A block is a chunk which always ends with a linebreak.
+    /// This is usually just a normal line break.
+    /// However very long lines are always wrapped at constant intervals that can be cheaply calculated
+    /// to avoid pathological behaviour.
+    pub fn new_at_prev_checkpoint(
+        text: RopeSlice<'t>,
+        text_fmt: &'t TextFormat,
+        annotations: &'t TextAnnotations,
+        char_idx: usize,
+    ) -> (Self, usize) {
+        // TODO divide long lines into blocks to avoid bad performance for long lines
+        let block_line_idx = text.char_to_line(char_idx.min(text.len_chars()));
+        let block_char_idx = text.line_to_char(block_line_idx);
+        annotations.reset_pos(block_char_idx);
+        (
+            DocumentFormatter {
+                text_fmt,
+                annotations,
+                visual_pos: Position { row: 0, col: 0 },
+                graphemes: RopeGraphemes::new(text.slice(block_char_idx..)),
+                char_pos: block_char_idx,
+                exhausted: false,
+                virtual_lines: 0,
+                indent_level: None,
+                peeked_grapheme: None,
+                word_buf: Vec::with_capacity(64),
+                word_i: 0,
+                line_pos: block_line_idx,
+                inline_anntoation_graphemes: None,
+            },
+            block_char_idx,
+        )
+    }
+
+    fn next_inline_annotation_grapheme(&mut self) -> Option<(&'t str, Option<Highlight>)> {
+        loop {
+            if let Some(&mut (ref mut annotation, highlight)) =
+                self.inline_anntoation_graphemes.as_mut()
+            {
+                if let Some(grapheme) = annotation.next() {
+                    return Some((grapheme, highlight));
+                }
+            }
+
+            if let Some((annotation, highlight)) =
+                self.annotations.next_inline_annotation_at(self.char_pos)
+            {
+                self.inline_anntoation_graphemes = Some((
+                    UnicodeSegmentation::graphemes(&*annotation.text, true),
+                    highlight,
+                ))
+            } else {
+                return None;
+            }
+        }
+    }
+
+    fn advance_grapheme(&mut self, col: usize) -> Option<FormattedGrapheme<'t>> {
+        let (grapheme, source) =
+            if let Some((grapheme, highlight)) = self.next_inline_annotation_grapheme() {
+                (grapheme.into(), GraphemeSource::VirtualText { highlight })
+            } else if let Some(grapheme) = self.graphemes.next() {
+                self.virtual_lines += self.annotations.annotation_lines_at(self.char_pos);
+                let codepoints = grapheme.len_chars() as u32;
+
+                let overlay = self.annotations.overlay_at(self.char_pos);
+                let grapheme = match overlay {
+                    Some((overlay, _)) => overlay.grapheme.as_str().into(),
+                    None => Cow::from(grapheme).into(),
+                };
+
+                self.char_pos += codepoints as usize;
+                (grapheme, GraphemeSource::Document { codepoints })
+            } else {
+                if self.exhausted {
+                    return None;
+                }
+                self.exhausted = true;
+                // EOF grapheme is required for rendering
+                // and correct position computations
+                return Some(FormattedGrapheme {
+                    grapheme: Grapheme::Other { g: " ".into() },
+                    source: GraphemeSource::Document { codepoints: 0 },
+                });
+            };
+
+        let grapheme = FormattedGrapheme::new(grapheme, col, self.text_fmt.tab_width, source);
+
+        Some(grapheme)
+    }
+
+    /// Move a word to the next visual line
+    fn wrap_word(&mut self, virtual_lines_before_word: usize) -> usize {
+        // softwrap this word to the next line
+        let indent_carry_over = if let Some(indent) = self.indent_level {
+            if indent as u16 <= self.text_fmt.max_indent_retain {
+                indent as u16
+            } else {
+                0
+            }
+        } else {
+            // ensure the indent stays 0
+            self.indent_level = Some(0);
+            0
+        };
+
+        self.visual_pos.col = indent_carry_over as usize;
+        self.virtual_lines -= virtual_lines_before_word;
+        self.visual_pos.row += 1 + virtual_lines_before_word;
+        let mut i = 0;
+        let mut word_width = 0;
+        let wrap_indicator = UnicodeSegmentation::graphemes(&*self.text_fmt.wrap_indicator, true)
+            .map(|g| {
+                i += 1;
+                let grapheme = FormattedGrapheme::new(
+                    g.into(),
+                    self.visual_pos.col + word_width,
+                    self.text_fmt.tab_width,
+                    GraphemeSource::VirtualText {
+                        highlight: self.text_fmt.wrap_indicator_highlight,
+                    },
+                );
+                word_width += grapheme.width();
+                grapheme
+            });
+        self.word_buf.splice(0..0, wrap_indicator);
+
+        for grapheme in &mut self.word_buf[i..] {
+            let visual_x = self.visual_pos.col + word_width;
+            grapheme
+                .grapheme
+                .change_position(visual_x, self.text_fmt.tab_width);
+            word_width += grapheme.width();
+        }
+        word_width
+    }
+
+    fn advance_to_next_word(&mut self) {
+        self.word_buf.clear();
+        let mut word_width = 0;
+        let virtual_lines_before_word = self.virtual_lines;
+        let mut virtual_lines_before_grapheme = self.virtual_lines;
+
+        loop {
+            // softwrap word if necessary
+            if word_width + self.visual_pos.col >= self.text_fmt.viewport_width as usize {
+                // wrapping this word would move too much text to the next line
+                // split the word at the line end instead
+                if word_width > self.text_fmt.max_wrap as usize {
+                    // Usually we stop accomulating graphemes as soon as softwrapping becomes necessary.
+                    // However if the last grapheme is multiple columns wide it might extend beyond the EOL.
+                    // The condition below ensures that this grapheme is not cutoff and instead wrapped to the next line
+                    if word_width + self.visual_pos.col > self.text_fmt.viewport_width as usize {
+                        self.peeked_grapheme = self.word_buf.pop().map(|grapheme| {
+                            (grapheme, self.virtual_lines - virtual_lines_before_grapheme)
+                        });
+                        self.virtual_lines = virtual_lines_before_grapheme;
+                    }
+                    return;
+                }
+
+                word_width = self.wrap_word(virtual_lines_before_word);
+            }
+
+            virtual_lines_before_grapheme = self.virtual_lines;
+
+            let grapheme = if let Some((grapheme, virtual_lines)) = self.peeked_grapheme.take() {
+                self.virtual_lines += virtual_lines;
+                grapheme
+            } else if let Some(grapheme) = self.advance_grapheme(self.visual_pos.col + word_width) {
+                grapheme
+            } else {
+                return;
+            };
+
+            // Track indentation
+            if !grapheme.is_whitespace() && self.indent_level.is_none() {
+                self.indent_level = Some(self.visual_pos.col);
+            } else if grapheme.grapheme == Grapheme::Newline {
+                self.indent_level = None;
+            }
+
+            let is_word_boundary = grapheme.is_word_boundary();
+            word_width += grapheme.width();
+            self.word_buf.push(grapheme);
+
+            if is_word_boundary {
+                return;
+            }
+        }
+    }
+
+    /// returns the document line pos of the **next** grapheme that will be yielded
+    pub fn line_pos(&self) -> usize {
+        self.line_pos
+    }
+
+    /// returns the visual pos of the **next** grapheme that will be yielded
+    pub fn visual_pos(&self) -> Position {
+        self.visual_pos
+    }
+}
+
+impl<'t> Iterator for DocumentFormatter<'t> {
+    type Item = (FormattedGrapheme<'t>, Position);
+
+    fn next(&mut self) -> Option<Self::Item> {
+        let grapheme = if self.text_fmt.soft_wrap {
+            if self.word_i >= self.word_buf.len() {
+                self.advance_to_next_word();
+                self.word_i = 0;
+            }
+            let grapheme = replace(
+                self.word_buf.get_mut(self.word_i)?,
+                FormattedGrapheme::placeholder(),
+            );
+            self.word_i += 1;
+            grapheme
+        } else {
+            self.advance_grapheme(self.visual_pos.col)?
+        };
+
+        let pos = self.visual_pos;
+        if grapheme.grapheme == Grapheme::Newline {
+            self.visual_pos.row += 1;
+            self.visual_pos.row += take(&mut self.virtual_lines);
+            self.visual_pos.col = 0;
+            self.line_pos += 1;
+        } else {
+            self.visual_pos.col += grapheme.width();
+        }
+        Some((grapheme, pos))
+    }
+}
diff --git a/helix-core/src/doc_formatter/test.rs b/helix-core/src/doc_formatter/test.rs
new file mode 100644
index 000000000..ac8918bb7
--- /dev/null
+++ b/helix-core/src/doc_formatter/test.rs
@@ -0,0 +1,182 @@
+use std::rc::Rc;
+
+use crate::doc_formatter::{DocumentFormatter, TextFormat};
+use crate::text_annotations::{InlineAnnotation, Overlay, TextAnnotations};
+
+impl TextFormat {
+    fn new_test(softwrap: bool) -> Self {
+        TextFormat {
+            soft_wrap: softwrap,
+            tab_width: 2,
+            max_wrap: 3,
+            max_indent_retain: 4,
+            wrap_indicator: ".".into(),
+            wrap_indicator_highlight: None,
+            // use a prime number to allow lining up too often with repeat
+            viewport_width: 17,
+        }
+    }
+}
+
+impl<'t> DocumentFormatter<'t> {
+    fn collect_to_str(&mut self) -> String {
+        use std::fmt::Write;
+        let mut res = String::new();
+        let viewport_width = self.text_fmt.viewport_width;
+        let mut line = 0;
+
+        for (grapheme, pos) in self {
+            if pos.row != line {
+                line += 1;
+                assert_eq!(pos.row, line);
+                write!(res, "\n{}", ".".repeat(pos.col)).unwrap();
+                assert!(
+                    pos.col <= viewport_width as usize,
+                    "softwrapped failed {}<={viewport_width}",
+                    pos.col
+                );
+            }
+            write!(res, "{}", grapheme.grapheme).unwrap();
+        }
+
+        res
+    }
+}
+
+fn softwrap_text(text: &str) -> String {
+    DocumentFormatter::new_at_prev_checkpoint(
+        text.into(),
+        &TextFormat::new_test(true),
+        &TextAnnotations::default(),
+        0,
+    )
+    .0
+    .collect_to_str()
+}
+
+#[test]
+fn basic_softwrap() {
+    assert_eq!(
+        softwrap_text(&"foo ".repeat(10)),
+        "foo foo foo foo \n.foo foo foo foo \n.foo foo  "
+    );
+    assert_eq!(
+        softwrap_text(&"fooo ".repeat(10)),
+        "fooo fooo fooo \n.fooo fooo fooo \n.fooo fooo fooo \n.fooo  "
+    );
+
+    // check that we don't wrap unnecessarily
+    assert_eq!(softwrap_text("\t\txxxx1xxxx2xx\n"), "    xxxx1xxxx2xx \n ");
+}
+
+#[test]
+fn softwrap_indentation() {
+    assert_eq!(
+        softwrap_text("\t\tfoo1 foo2 foo3 foo4 foo5 foo6\n"),
+        "    foo1 foo2 \n.....foo3 foo4 \n.....foo5 foo6 \n "
+    );
+    assert_eq!(
+        softwrap_text("\t\t\tfoo1 foo2 foo3 foo4 foo5 foo6\n"),
+        "      foo1 foo2 \n.foo3 foo4 foo5 \n.foo6 \n "
+    );
+}
+
+#[test]
+fn long_word_softwrap() {
+    assert_eq!(
+        softwrap_text("\t\txxxx1xxxx2xxxx3xxxx4xxxx5xxxx6xxxx7xxxx8xxxx9xxx\n"),
+        "    xxxx1xxxx2xxx\n.....x3xxxx4xxxx5\n.....xxxx6xxxx7xx\n.....xx8xxxx9xxx \n "
+    );
+    assert_eq!(
+        softwrap_text("xxxxxxxx1xxxx2xxx\n"),
+        "xxxxxxxx1xxxx2xxx\n. \n "
+    );
+    assert_eq!(
+        softwrap_text("\t\txxxx1xxxx 2xxxx3xxxx4xxxx5xxxx6xxxx7xxxx8xxxx9xxx\n"),
+        "    xxxx1xxxx \n.....2xxxx3xxxx4x\n.....xxx5xxxx6xxx\n.....x7xxxx8xxxx9\n.....xxx \n "
+    );
+    assert_eq!(
+        softwrap_text("\t\txxxx1xxx 2xxxx3xxxx4xxxx5xxxx6xxxx7xxxx8xxxx9xxx\n"),
+        "    xxxx1xxx 2xxx\n.....x3xxxx4xxxx5\n.....xxxx6xxxx7xx\n.....xx8xxxx9xxx \n "
+    );
+}
+
+fn overlay_text(text: &str, char_pos: usize, softwrap: bool, overlays: &[Overlay]) -> String {
+    DocumentFormatter::new_at_prev_checkpoint(
+        text.into(),
+        &TextFormat::new_test(softwrap),
+        TextAnnotations::default().add_overlay(overlays.into(), None),
+        char_pos,
+    )
+    .0
+    .collect_to_str()
+}
+
+#[test]
+fn overlay() {
+    assert_eq!(
+        overlay_text(
+            "foobar",
+            0,
+            false,
+            &[Overlay::new(0, "X"), Overlay::new(2, "\t")],
+        ),
+        "Xo  bar "
+    );
+    assert_eq!(
+        overlay_text(
+            &"foo ".repeat(10),
+            0,
+            true,
+            &[
+                Overlay::new(2, "\t"),
+                Overlay::new(5, "\t"),
+                Overlay::new(16, "X"),
+            ]
+        ),
+        "fo   f  o foo \n.foo Xoo foo foo \n.foo foo foo  "
+    );
+}
+
+fn annotate_text(text: &str, softwrap: bool, annotations: &[InlineAnnotation]) -> String {
+    DocumentFormatter::new_at_prev_checkpoint(
+        text.into(),
+        &TextFormat::new_test(softwrap),
+        TextAnnotations::default().add_inline_annotations(annotations.into(), None),
+        0,
+    )
+    .0
+    .collect_to_str()
+}
+
+#[test]
+fn annotation() {
+    assert_eq!(
+        annotate_text("bar", false, &[InlineAnnotation::new(0, "foo")]),
+        "foobar "
+    );
+    assert_eq!(
+        annotate_text(
+            &"foo ".repeat(10),
+            true,
+            &[InlineAnnotation::new(0, "foo ")]
+        ),
+        "foo foo foo foo \n.foo foo foo foo \n.foo foo foo  "
+    );
+}
+#[test]
+fn annotation_and_overlay() {
+    assert_eq!(
+        DocumentFormatter::new_at_prev_checkpoint(
+            "bbar".into(),
+            &TextFormat::new_test(false),
+            TextAnnotations::default()
+                .add_inline_annotations(Rc::new([InlineAnnotation::new(0, "fooo")]), None)
+                .add_overlay(Rc::new([Overlay::new(0, "\t")]), None),
+            0,
+        )
+        .0
+        .collect_to_str(),
+        "fooo  bar "
+    );
+}
diff --git a/helix-core/src/graphemes.rs b/helix-core/src/graphemes.rs
index 675f57505..15ef3eb04 100644
--- a/helix-core/src/graphemes.rs
+++ b/helix-core/src/graphemes.rs
@@ -5,7 +5,88 @@
 use unicode_segmentation::{GraphemeCursor, GraphemeIncomplete};
 use unicode_width::UnicodeWidthStr;
 
-use std::fmt;
+use std::borrow::Cow;
+use std::fmt::{self, Debug, Display};
+use std::marker::PhantomData;
+use std::ops::Deref;
+use std::ptr::NonNull;
+use std::{slice, str};
+
+use crate::chars::{char_is_whitespace, char_is_word};
+use crate::LineEnding;
+
+#[inline]
+pub fn tab_width_at(visual_x: usize, tab_width: u16) -> usize {
+    tab_width as usize - (visual_x % tab_width as usize)
+}
+
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub enum Grapheme<'a> {
+    Newline,
+    Tab { width: usize },
+    Other { g: GraphemeStr<'a> },
+}
+
+impl<'a> Grapheme<'a> {
+    pub fn new(g: GraphemeStr<'a>, visual_x: usize, tab_width: u16) -> Grapheme<'a> {
+        match g {
+            g if g == "\t" => Grapheme::Tab {
+                width: tab_width_at(visual_x, tab_width),
+            },
+            _ if LineEnding::from_str(&g).is_some() => Grapheme::Newline,
+            _ => Grapheme::Other { g },
+        }
+    }
+
+    pub fn change_position(&mut self, visual_x: usize, tab_width: u16) {
+        if let Grapheme::Tab { width } = self {
+            *width = tab_width_at(visual_x, tab_width)
+        }
+    }
+
+    /// Returns the a visual width of this grapheme,
+    #[inline]
+    pub fn width(&self) -> usize {
+        match *self {
+            // width is not cached because we are dealing with
+            // ASCII almost all the time which already has a fastpath
+            // it's okay to convert to u16 here because no codepoint has a width larger
+            // than 2 and graphemes are usually atmost two visible codepoints wide
+            Grapheme::Other { ref g } => grapheme_width(g),
+            Grapheme::Tab { width } => width,
+            Grapheme::Newline => 1,
+        }
+    }
+
+    pub fn is_whitespace(&self) -> bool {
+        !matches!(&self, Grapheme::Other { g } if !g.chars().all(char_is_whitespace))
+    }
+
+    // TODO currently word boundaries are used for softwrapping.
+    // This works best for programming languages and well for prose.
+    // This could however be improved in the future by considering unicode
+    // character classes but
+    pub fn is_word_boundary(&self) -> bool {
+        !matches!(&self, Grapheme::Other { g,.. } if g.chars().all(char_is_word))
+    }
+}
+
+impl Display for Grapheme<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match *self {
+            Grapheme::Newline => write!(f, " "),
+            Grapheme::Tab { width } => {
+                for _ in 0..width {
+                    write!(f, " ")?;
+                }
+                Ok(())
+            }
+            Grapheme::Other { ref g } => {
+                write!(f, "{g}")
+            }
+        }
+    }
+}
 
 #[must_use]
 pub fn grapheme_width(g: &str) -> usize {
@@ -27,6 +108,8 @@ pub fn grapheme_width(g: &str) -> usize {
         // We use max(1) here because all grapeheme clusters--even illformed
         // ones--should have at least some width so they can be edited
         // properly.
+        // TODO properly handle unicode width for all codepoints
+        // example of where unicode width is currently wrong:  (taken from https://hsivonen.fi/string-length/)
         UnicodeWidthStr::width(g).max(1)
     }
 }
@@ -341,3 +424,101 @@ fn next(&mut self) -> Option<RopeSlice<'a>> {
         }
     }
 }
+
+/// A highly compressed Cow<'a, str> that holds
+/// atmost u31::MAX bytes and is readonly
+pub struct GraphemeStr<'a> {
+    ptr: NonNull<u8>,
+    len: u32,
+    phantom: PhantomData<&'a str>,
+}
+
+impl GraphemeStr<'_> {
+    const MASK_OWNED: u32 = 1 << 31;
+
+    fn compute_len(&self) -> usize {
+        (self.len & !Self::MASK_OWNED) as usize
+    }
+}
+
+impl Deref for GraphemeStr<'_> {
+    type Target = str;
+    fn deref(&self) -> &Self::Target {
+        unsafe {
+            let bytes = slice::from_raw_parts(self.ptr.as_ptr(), self.compute_len());
+            str::from_utf8_unchecked(bytes)
+        }
+    }
+}
+
+impl Drop for GraphemeStr<'_> {
+    fn drop(&mut self) {
+        if self.len & Self::MASK_OWNED != 0 {
+            // free allocation
+            unsafe {
+                drop(Box::from_raw(slice::from_raw_parts_mut(
+                    self.ptr.as_ptr(),
+                    self.compute_len(),
+                )));
+            }
+        }
+    }
+}
+
+impl<'a> From<&'a str> for GraphemeStr<'a> {
+    fn from(g: &'a str) -> Self {
+        GraphemeStr {
+            ptr: unsafe { NonNull::new_unchecked(g.as_bytes().as_ptr() as *mut u8) },
+            len: i32::try_from(g.len()).unwrap() as u32,
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<'a> From<String> for GraphemeStr<'a> {
+    fn from(g: String) -> Self {
+        let len = g.len();
+        let ptr = Box::into_raw(g.into_bytes().into_boxed_slice()) as *mut u8;
+        GraphemeStr {
+            ptr: unsafe { NonNull::new_unchecked(ptr) },
+            len: i32::try_from(len).unwrap() as u32,
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<'a> From<Cow<'a, str>> for GraphemeStr<'a> {
+    fn from(g: Cow<'a, str>) -> Self {
+        match g {
+            Cow::Borrowed(g) => g.into(),
+            Cow::Owned(g) => g.into(),
+        }
+    }
+}
+
+impl<T: Deref<Target = str>> PartialEq<T> for GraphemeStr<'_> {
+    fn eq(&self, other: &T) -> bool {
+        self.deref() == other.deref()
+    }
+}
+impl PartialEq<str> for GraphemeStr<'_> {
+    fn eq(&self, other: &str) -> bool {
+        self.deref() == other
+    }
+}
+impl Eq for GraphemeStr<'_> {}
+impl Debug for GraphemeStr<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        Debug::fmt(self.deref(), f)
+    }
+}
+impl Display for GraphemeStr<'_> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        Display::fmt(self.deref(), f)
+    }
+}
+impl Clone for GraphemeStr<'_> {
+    fn clone(&self) -> Self {
+        self.deref().to_owned().into()
+    }
+}
diff --git a/helix-core/src/increment/date_time.rs b/helix-core/src/increment/date_time.rs
index 265242ce4..2980bb58b 100644
--- a/helix-core/src/increment/date_time.rs
+++ b/helix-core/src/increment/date_time.rs
@@ -1,114 +1,53 @@
-use chrono::{Datelike, Duration, NaiveDate, NaiveDateTime, NaiveTime, Timelike};
+use chrono::{Duration, NaiveDate, NaiveDateTime, NaiveTime};
 use once_cell::sync::Lazy;
 use regex::Regex;
-use ropey::RopeSlice;
-
-use std::borrow::Cow;
-use std::cmp;
 use std::fmt::Write;
 
-use super::Increment;
-use crate::{Range, Tendril};
+/// Increment a Date or DateTime
+///
+/// If just a Date is selected the day will be incremented.
+/// If a DateTime is selected the second will be incremented.
+pub fn increment(selected_text: &str, amount: i64) -> Option<String> {
+    if selected_text.is_empty() {
+        return None;
+    }
 
-#[derive(Debug, PartialEq, Eq)]
-pub struct DateTimeIncrementor {
-    date_time: NaiveDateTime,
-    range: Range,
-    fmt: &'static str,
-    field: DateField,
-}
+    FORMATS.iter().find_map(|format| {
+        let captures = format.regex.captures(selected_text)?;
+        if captures.len() - 1 != format.fields.len() {
+            return None;
+        }
 
-impl DateTimeIncrementor {
-    pub fn from_range(text: RopeSlice, range: Range) -> Option<DateTimeIncrementor> {
-        let range = if range.is_empty() {
-            if range.anchor < text.len_chars() {
-                // Treat empty range as a cursor range.
-                range.put_cursor(text, range.anchor + 1, true)
-            } else {
-                // The range is empty and at the end of the text.
-                return None;
+        let date_time = captures.get(0)?;
+        let has_date = format.fields.iter().any(|f| f.unit.is_date());
+        let has_time = format.fields.iter().any(|f| f.unit.is_time());
+        let date_time = &selected_text[date_time.start()..date_time.end()];
+        match (has_date, has_time) {
+            (true, true) => {
+                let date_time = NaiveDateTime::parse_from_str(date_time, format.fmt).ok()?;
+                Some(
+                    date_time
+                        .checked_add_signed(Duration::minutes(amount))?
+                        .format(format.fmt)
+                        .to_string(),
+                )
             }
-        } else {
-            range
-        };
-
-        FORMATS.iter().find_map(|format| {
-            let from = range.from().saturating_sub(format.max_len);
-            let to = (range.from() + format.max_len).min(text.len_chars());
-
-            let (from_in_text, to_in_text) = (range.from() - from, range.to() - from);
-            let text: Cow<str> = text.slice(from..to).into();
-
-            let captures = format.regex.captures(&text)?;
-            if captures.len() - 1 != format.fields.len() {
-                return None;
+            (true, false) => {
+                let date = NaiveDate::parse_from_str(date_time, format.fmt).ok()?;
+                Some(
+                    date.checked_add_signed(Duration::days(amount))?
+                        .format(format.fmt)
+                        .to_string(),
+                )
             }
-
-            let date_time = captures.get(0)?;
-            let offset = range.from() - from_in_text;
-            let range = Range::new(date_time.start() + offset, date_time.end() + offset);
-
-            let field = captures
-                .iter()
-                .skip(1)
-                .enumerate()
-                .find_map(|(i, capture)| {
-                    let capture = capture?;
-                    let capture_range = capture.range();
-
-                    if capture_range.contains(&from_in_text)
-                        && capture_range.contains(&(to_in_text - 1))
-                    {
-                        Some(format.fields[i])
-                    } else {
-                        None
-                    }
-                })?;
-
-            let has_date = format.fields.iter().any(|f| f.unit.is_date());
-            let has_time = format.fields.iter().any(|f| f.unit.is_time());
-
-            let date_time = &text[date_time.start()..date_time.end()];
-            let date_time = match (has_date, has_time) {
-                (true, true) => NaiveDateTime::parse_from_str(date_time, format.fmt).ok()?,
-                (true, false) => {
-                    let date = NaiveDate::parse_from_str(date_time, format.fmt).ok()?;
-
-                    date.and_hms_opt(0, 0, 0).unwrap()
-                }
-                (false, true) => {
-                    let time = NaiveTime::parse_from_str(date_time, format.fmt).ok()?;
-
-                    NaiveDate::from_ymd_opt(0, 1, 1).unwrap().and_time(time)
-                }
-                (false, false) => return None,
-            };
-
-            Some(DateTimeIncrementor {
-                date_time,
-                range,
-                fmt: format.fmt,
-                field,
-            })
-        })
-    }
-}
-
-impl Increment for DateTimeIncrementor {
-    fn increment(&self, amount: i64) -> (Range, Tendril) {
-        let date_time = match self.field.unit {
-            DateUnit::Years => add_years(self.date_time, amount),
-            DateUnit::Months => add_months(self.date_time, amount),
-            DateUnit::Days => add_duration(self.date_time, Duration::days(amount)),
-            DateUnit::Hours => add_duration(self.date_time, Duration::hours(amount)),
-            DateUnit::Minutes => add_duration(self.date_time, Duration::minutes(amount)),
-            DateUnit::Seconds => add_duration(self.date_time, Duration::seconds(amount)),
-            DateUnit::AmPm => toggle_am_pm(self.date_time),
+            (false, true) => {
+                let time = NaiveTime::parse_from_str(date_time, format.fmt).ok()?;
+                let (adjusted_time, _) = time.overflowing_add_signed(Duration::minutes(amount));
+                Some(adjusted_time.format(format.fmt).to_string())
+            }
+            (false, false) => None,
         }
-        .unwrap_or(self.date_time);
-
-        (self.range, date_time.format(self.fmt).to_string().into())
-    }
+    })
 }
 
 static FORMATS: Lazy<Vec<Format>> = Lazy::new(|| {
@@ -144,7 +83,7 @@ impl Format {
     fn new(fmt: &'static str) -> Self {
         let mut remaining = fmt;
         let mut fields = Vec::new();
-        let mut regex = String::new();
+        let mut regex = "^".to_string();
         let mut max_len = 0;
 
         while let Some(i) = remaining.find('%') {
@@ -166,6 +105,7 @@ fn new(fmt: &'static str) -> Self {
             write!(regex, "({})", field.regex).unwrap();
             remaining = &after[spec_len..];
         }
+        regex += "$";
 
         let regex = Regex::new(&regex).unwrap();
 
@@ -305,155 +245,47 @@ fn is_time(self) -> bool {
     }
 }
 
-fn ndays_in_month(year: i32, month: u32) -> u32 {
-    // The first day of the next month...
-    let (y, m) = if month == 12 {
-        (year + 1, 1)
-    } else {
-        (year, month + 1)
-    };
-    let d = NaiveDate::from_ymd_opt(y, m, 1).unwrap();
-
-    // ...is preceded by the last day of the original month.
-    d.pred_opt().unwrap().day()
-}
-
-fn add_months(date_time: NaiveDateTime, amount: i64) -> Option<NaiveDateTime> {
-    let month = (date_time.month0() as i64).checked_add(amount)?;
-    let year = date_time.year() + i32::try_from(month / 12).ok()?;
-    let year = if month.is_negative() { year - 1 } else { year };
-
-    // Normalize month
-    let month = month % 12;
-    let month = if month.is_negative() {
-        month + 12
-    } else {
-        month
-    } as u32
-        + 1;
-
-    let day = cmp::min(date_time.day(), ndays_in_month(year, month));
-
-    NaiveDate::from_ymd_opt(year, month, day).map(|date| date.and_time(date_time.time()))
-}
-
-fn add_years(date_time: NaiveDateTime, amount: i64) -> Option<NaiveDateTime> {
-    let year = i32::try_from((date_time.year() as i64).checked_add(amount)?).ok()?;
-    let ndays = ndays_in_month(year, date_time.month());
-
-    if date_time.day() > ndays {
-        NaiveDate::from_ymd_opt(year, date_time.month(), ndays)
-            .and_then(|date| date.succ_opt().map(|date| date.and_time(date_time.time())))
-    } else {
-        date_time.with_year(year)
-    }
-}
-
-fn add_duration(date_time: NaiveDateTime, duration: Duration) -> Option<NaiveDateTime> {
-    date_time.checked_add_signed(duration)
-}
-
-fn toggle_am_pm(date_time: NaiveDateTime) -> Option<NaiveDateTime> {
-    if date_time.hour() < 12 {
-        add_duration(date_time, Duration::hours(12))
-    } else {
-        add_duration(date_time, Duration::hours(-12))
-    }
-}
-
 #[cfg(test)]
 mod test {
     use super::*;
-    use crate::Rope;
 
     #[test]
     fn test_increment_date_times() {
         let tests = [
             // (original, cursor, amount, expected)
-            ("2020-02-28", 0, 1, "2021-02-28"),
-            ("2020-02-29", 0, 1, "2021-03-01"),
-            ("2020-01-31", 5, 1, "2020-02-29"),
-            ("2020-01-20", 5, 1, "2020-02-20"),
-            ("2021-01-01", 5, -1, "2020-12-01"),
-            ("2021-01-31", 5, -2, "2020-11-30"),
-            ("2020-02-28", 8, 1, "2020-02-29"),
-            ("2021-02-28", 8, 1, "2021-03-01"),
-            ("2021-02-28", 0, -1, "2020-02-28"),
-            ("2021-03-01", 0, -1, "2020-03-01"),
-            ("2020-02-29", 5, -1, "2020-01-29"),
-            ("2020-02-20", 5, -1, "2020-01-20"),
-            ("2020-02-29", 8, -1, "2020-02-28"),
-            ("2021-03-01", 8, -1, "2021-02-28"),
-            ("1980/12/21", 8, 100, "1981/03/31"),
-            ("1980/12/21", 8, -100, "1980/09/12"),
-            ("1980/12/21", 8, 1000, "1983/09/17"),
-            ("1980/12/21", 8, -1000, "1978/03/27"),
-            ("2021-11-24 07:12:23", 0, 1, "2022-11-24 07:12:23"),
-            ("2021-11-24 07:12:23", 5, 1, "2021-12-24 07:12:23"),
-            ("2021-11-24 07:12:23", 8, 1, "2021-11-25 07:12:23"),
-            ("2021-11-24 07:12:23", 11, 1, "2021-11-24 08:12:23"),
-            ("2021-11-24 07:12:23", 14, 1, "2021-11-24 07:13:23"),
-            ("2021-11-24 07:12:23", 17, 1, "2021-11-24 07:12:24"),
-            ("2021/11/24 07:12:23", 0, 1, "2022/11/24 07:12:23"),
-            ("2021/11/24 07:12:23", 5, 1, "2021/12/24 07:12:23"),
-            ("2021/11/24 07:12:23", 8, 1, "2021/11/25 07:12:23"),
-            ("2021/11/24 07:12:23", 11, 1, "2021/11/24 08:12:23"),
-            ("2021/11/24 07:12:23", 14, 1, "2021/11/24 07:13:23"),
-            ("2021/11/24 07:12:23", 17, 1, "2021/11/24 07:12:24"),
-            ("2021-11-24 07:12", 0, 1, "2022-11-24 07:12"),
-            ("2021-11-24 07:12", 5, 1, "2021-12-24 07:12"),
-            ("2021-11-24 07:12", 8, 1, "2021-11-25 07:12"),
-            ("2021-11-24 07:12", 11, 1, "2021-11-24 08:12"),
-            ("2021-11-24 07:12", 14, 1, "2021-11-24 07:13"),
-            ("2021/11/24 07:12", 0, 1, "2022/11/24 07:12"),
-            ("2021/11/24 07:12", 5, 1, "2021/12/24 07:12"),
-            ("2021/11/24 07:12", 8, 1, "2021/11/25 07:12"),
-            ("2021/11/24 07:12", 11, 1, "2021/11/24 08:12"),
-            ("2021/11/24 07:12", 14, 1, "2021/11/24 07:13"),
-            ("Wed Nov 24 2021", 0, 1, "Thu Nov 25 2021"),
-            ("Wed Nov 24 2021", 4, 1, "Fri Dec 24 2021"),
-            ("Wed Nov 24 2021", 8, 1, "Thu Nov 25 2021"),
-            ("Wed Nov 24 2021", 11, 1, "Thu Nov 24 2022"),
-            ("24-Nov-2021", 0, 1, "25-Nov-2021"),
-            ("24-Nov-2021", 3, 1, "24-Dec-2021"),
-            ("24-Nov-2021", 7, 1, "24-Nov-2022"),
-            ("2021 Nov 24", 0, 1, "2022 Nov 24"),
-            ("2021 Nov 24", 5, 1, "2021 Dec 24"),
-            ("2021 Nov 24", 9, 1, "2021 Nov 25"),
-            ("Nov 24, 2021", 0, 1, "Dec 24, 2021"),
-            ("Nov 24, 2021", 4, 1, "Nov 25, 2021"),
-            ("Nov 24, 2021", 8, 1, "Nov 24, 2022"),
-            ("7:21:53 am", 0, 1, "8:21:53 am"),
-            ("7:21:53 am", 3, 1, "7:22:53 am"),
-            ("7:21:53 am", 5, 1, "7:21:54 am"),
-            ("7:21:53 am", 8, 1, "7:21:53 pm"),
-            ("7:21:53 AM", 0, 1, "8:21:53 AM"),
-            ("7:21:53 AM", 3, 1, "7:22:53 AM"),
-            ("7:21:53 AM", 5, 1, "7:21:54 AM"),
-            ("7:21:53 AM", 8, 1, "7:21:53 PM"),
-            ("7:21 am", 0, 1, "8:21 am"),
-            ("7:21 am", 3, 1, "7:22 am"),
-            ("7:21 am", 5, 1, "7:21 pm"),
-            ("7:21 AM", 0, 1, "8:21 AM"),
-            ("7:21 AM", 3, 1, "7:22 AM"),
-            ("7:21 AM", 5, 1, "7:21 PM"),
-            ("23:24:23", 1, 1, "00:24:23"),
-            ("23:24:23", 3, 1, "23:25:23"),
-            ("23:24:23", 6, 1, "23:24:24"),
-            ("23:24", 1, 1, "00:24"),
-            ("23:24", 3, 1, "23:25"),
+            ("2020-02-28", 1, "2020-02-29"),
+            ("2020-02-29", 1, "2020-03-01"),
+            ("2020-01-31", 1, "2020-02-01"),
+            ("2020-01-20", 1, "2020-01-21"),
+            ("2021-01-01", -1, "2020-12-31"),
+            ("2021-01-31", -2, "2021-01-29"),
+            ("2020-02-28", 1, "2020-02-29"),
+            ("2021-02-28", 1, "2021-03-01"),
+            ("2021-03-01", -1, "2021-02-28"),
+            ("2020-02-29", -1, "2020-02-28"),
+            ("2020-02-20", -1, "2020-02-19"),
+            ("2021-03-01", -1, "2021-02-28"),
+            ("1980/12/21", 100, "1981/03/31"),
+            ("1980/12/21", -100, "1980/09/12"),
+            ("1980/12/21", 1000, "1983/09/17"),
+            ("1980/12/21", -1000, "1978/03/27"),
+            ("2021-11-24 07:12:23", 1, "2021-11-24 07:13:23"),
+            ("2021-11-24 07:12", 1, "2021-11-24 07:13"),
+            ("Wed Nov 24 2021", 1, "Thu Nov 25 2021"),
+            ("24-Nov-2021", 1, "25-Nov-2021"),
+            ("2021 Nov 24", 1, "2021 Nov 25"),
+            ("Nov 24, 2021", 1, "Nov 25, 2021"),
+            ("7:21:53 am", 1, "7:22:53 am"),
+            ("7:21:53 AM", 1, "7:22:53 AM"),
+            ("7:21 am", 1, "7:22 am"),
+            ("23:24:23", 1, "23:25:23"),
+            ("23:24", 1, "23:25"),
+            ("23:59", 1, "00:00"),
+            ("23:59:59", 1, "00:00:59"),
         ];
 
-        for (original, cursor, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::new(cursor, cursor + 1);
-            assert_eq!(
-                DateTimeIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
         }
     }
 
@@ -482,10 +314,7 @@ fn test_invalid_date_times() {
         ];
 
         for invalid in tests {
-            let rope = Rope::from_str(invalid);
-            let range = Range::new(0, 1);
-
-            assert_eq!(DateTimeIncrementor::from_range(rope.slice(..), range), None)
+            assert_eq!(increment(invalid, 1), None)
         }
     }
 }
diff --git a/helix-core/src/increment/integer.rs b/helix-core/src/increment/integer.rs
new file mode 100644
index 000000000..0dfabc0d3
--- /dev/null
+++ b/helix-core/src/increment/integer.rs
@@ -0,0 +1,235 @@
+const SEPARATOR: char = '_';
+
+/// Increment an integer.
+///
+/// Supported bases:
+///     2 with prefix 0b
+///     8 with prefix 0o
+///     10 with no prefix
+///     16 with prefix 0x
+///
+/// An integer can contain `_` as a separator but may not start or end with a separator.
+/// Base 10 integers can go negative, but bases 2, 8, and 16 cannot.
+/// All addition and subtraction is saturating.
+pub fn increment(selected_text: &str, amount: i64) -> Option<String> {
+    if selected_text.is_empty()
+        || selected_text.ends_with(SEPARATOR)
+        || selected_text.starts_with(SEPARATOR)
+    {
+        return None;
+    }
+
+    let radix = if selected_text.starts_with("0x") {
+        16
+    } else if selected_text.starts_with("0o") {
+        8
+    } else if selected_text.starts_with("0b") {
+        2
+    } else {
+        10
+    };
+
+    // Get separator indexes from right to left.
+    let separator_rtl_indexes: Vec<usize> = selected_text
+        .chars()
+        .rev()
+        .enumerate()
+        .filter_map(|(i, c)| if c == SEPARATOR { Some(i) } else { None })
+        .collect();
+
+    let word: String = selected_text.chars().filter(|&c| c != SEPARATOR).collect();
+
+    let mut new_text = if radix == 10 {
+        let number = &word;
+        let value = i128::from_str_radix(number, radix).ok()?;
+        let new_value = value.saturating_add(amount as i128);
+
+        let format_length = match (value.is_negative(), new_value.is_negative()) {
+            (true, false) => number.len() - 1,
+            (false, true) => number.len() + 1,
+            _ => number.len(),
+        } - separator_rtl_indexes.len();
+
+        if number.starts_with('0') || number.starts_with("-0") {
+            format!("{:01$}", new_value, format_length)
+        } else {
+            format!("{}", new_value)
+        }
+    } else {
+        let number = &word[2..];
+        let value = u128::from_str_radix(number, radix).ok()?;
+        let new_value = (value as i128).saturating_add(amount as i128);
+        let new_value = if new_value < 0 { 0 } else { new_value };
+        let format_length = selected_text.len() - 2 - separator_rtl_indexes.len();
+
+        match radix {
+            2 => format!("0b{:01$b}", new_value, format_length),
+            8 => format!("0o{:01$o}", new_value, format_length),
+            16 => {
+                let (lower_count, upper_count): (usize, usize) =
+                    number.chars().fold((0, 0), |(lower, upper), c| {
+                        (
+                            lower + c.is_ascii_lowercase() as usize,
+                            upper + c.is_ascii_uppercase() as usize,
+                        )
+                    });
+                if upper_count > lower_count {
+                    format!("0x{:01$X}", new_value, format_length)
+                } else {
+                    format!("0x{:01$x}", new_value, format_length)
+                }
+            }
+            _ => unimplemented!("radix not supported: {}", radix),
+        }
+    };
+
+    // Add separators from original number.
+    for &rtl_index in &separator_rtl_indexes {
+        if rtl_index < new_text.len() {
+            let new_index = new_text.len().saturating_sub(rtl_index);
+            if new_index > 0 {
+                new_text.insert(new_index, SEPARATOR);
+            }
+        }
+    }
+
+    // Add in additional separators if necessary.
+    if new_text.len() > selected_text.len() && !separator_rtl_indexes.is_empty() {
+        let spacing = match separator_rtl_indexes.as_slice() {
+            [.., b, a] => a - b - 1,
+            _ => separator_rtl_indexes[0],
+        };
+
+        let prefix_length = if radix == 10 { 0 } else { 2 };
+        if let Some(mut index) = new_text.find(SEPARATOR) {
+            while index - prefix_length > spacing {
+                index -= spacing;
+                new_text.insert(index, SEPARATOR);
+            }
+        }
+    }
+
+    Some(new_text)
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    #[test]
+    fn test_increment_basic_decimal_numbers() {
+        let tests = [
+            ("100", 1, "101"),
+            ("100", -1, "99"),
+            ("99", 1, "100"),
+            ("100", 1000, "1100"),
+            ("100", -1000, "-900"),
+            ("-1", 1, "0"),
+            ("-1", 2, "1"),
+            ("1", -1, "0"),
+            ("1", -2, "-1"),
+        ];
+
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
+        }
+    }
+
+    #[test]
+    fn test_increment_basic_hexadecimal_numbers() {
+        let tests = [
+            ("0x0100", 1, "0x0101"),
+            ("0x0100", -1, "0x00ff"),
+            ("0x0001", -1, "0x0000"),
+            ("0x0000", -1, "0x0000"),
+            ("0xffffffffffffffff", 1, "0x10000000000000000"),
+            ("0xffffffffffffffff", 2, "0x10000000000000001"),
+            ("0xffffffffffffffff", -1, "0xfffffffffffffffe"),
+            ("0xABCDEF1234567890", 1, "0xABCDEF1234567891"),
+            ("0xabcdef1234567890", 1, "0xabcdef1234567891"),
+        ];
+
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
+        }
+    }
+
+    #[test]
+    fn test_increment_basic_octal_numbers() {
+        let tests = [
+            ("0o0107", 1, "0o0110"),
+            ("0o0110", -1, "0o0107"),
+            ("0o0001", -1, "0o0000"),
+            ("0o7777", 1, "0o10000"),
+            ("0o1000", -1, "0o0777"),
+            ("0o0107", 10, "0o0121"),
+            ("0o0000", -1, "0o0000"),
+            ("0o1777777777777777777777", 1, "0o2000000000000000000000"),
+            ("0o1777777777777777777777", 2, "0o2000000000000000000001"),
+            ("0o1777777777777777777777", -1, "0o1777777777777777777776"),
+        ];
+
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
+        }
+    }
+
+    #[test]
+    fn test_increment_basic_binary_numbers() {
+        let tests = [
+            ("0b00000100", 1, "0b00000101"),
+            ("0b00000100", -1, "0b00000011"),
+            ("0b00000100", 2, "0b00000110"),
+            ("0b00000100", -2, "0b00000010"),
+            ("0b00000001", -1, "0b00000000"),
+            ("0b00111111", 10, "0b01001001"),
+            ("0b11111111", 1, "0b100000000"),
+            ("0b10000000", -1, "0b01111111"),
+            ("0b0000", -1, "0b0000"),
+            (
+                "0b1111111111111111111111111111111111111111111111111111111111111111",
+                1,
+                "0b10000000000000000000000000000000000000000000000000000000000000000",
+            ),
+            (
+                "0b1111111111111111111111111111111111111111111111111111111111111111",
+                2,
+                "0b10000000000000000000000000000000000000000000000000000000000000001",
+            ),
+            (
+                "0b1111111111111111111111111111111111111111111111111111111111111111",
+                -1,
+                "0b1111111111111111111111111111111111111111111111111111111111111110",
+            ),
+        ];
+
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
+        }
+    }
+
+    #[test]
+    fn test_increment_with_separators() {
+        let tests = [
+            ("999_999", 1, "1_000_000"),
+            ("1_000_000", -1, "999_999"),
+            ("-999_999", -1, "-1_000_000"),
+            ("0x0000_0000_0001", 0x1_ffff_0000, "0x0001_ffff_0001"),
+            ("0x0000_0000", -1, "0x0000_0000"),
+            ("0x0000_0000_0000", -1, "0x0000_0000_0000"),
+            ("0b01111111_11111111", 1, "0b10000000_00000000"),
+            ("0b11111111_11111111", 1, "0b1_00000000_00000000"),
+        ];
+
+        for (original, amount, expected) in tests {
+            assert_eq!(increment(original, amount).unwrap(), expected);
+        }
+    }
+
+    #[test]
+    fn test_leading_and_trailing_separators_arent_a_match() {
+        assert_eq!(increment("9_", 1), None);
+        assert_eq!(increment("_9", 1), None);
+        assert_eq!(increment("_9_", 1), None);
+    }
+}
diff --git a/helix-core/src/increment/mod.rs b/helix-core/src/increment/mod.rs
index f59457748..f1978bde4 100644
--- a/helix-core/src/increment/mod.rs
+++ b/helix-core/src/increment/mod.rs
@@ -1,8 +1,10 @@
-pub mod date_time;
-pub mod number;
+mod date_time;
+mod integer;
 
-use crate::{Range, Tendril};
+pub fn integer(selected_text: &str, amount: i64) -> Option<String> {
+    integer::increment(selected_text, amount)
+}
 
-pub trait Increment {
-    fn increment(&self, amount: i64) -> (Range, Tendril);
+pub fn date_time(selected_text: &str, amount: i64) -> Option<String> {
+    date_time::increment(selected_text, amount)
 }
diff --git a/helix-core/src/increment/number.rs b/helix-core/src/increment/number.rs
deleted file mode 100644
index 912687293..000000000
--- a/helix-core/src/increment/number.rs
+++ /dev/null
@@ -1,507 +0,0 @@
-use std::borrow::Cow;
-
-use ropey::RopeSlice;
-
-use super::Increment;
-
-use crate::{
-    textobject::{textobject_word, TextObject},
-    Range, Tendril,
-};
-
-#[derive(Debug, PartialEq, Eq)]
-pub struct NumberIncrementor<'a> {
-    value: i64,
-    radix: u32,
-    range: Range,
-
-    text: RopeSlice<'a>,
-}
-
-impl<'a> NumberIncrementor<'a> {
-    /// Return information about number under rang if there is one.
-    pub fn from_range(text: RopeSlice, range: Range) -> Option<NumberIncrementor> {
-        // If the cursor is on the minus sign of a number we want to get the word textobject to the
-        // right of it.
-        let range = if range.to() < text.len_chars()
-            && range.to() - range.from() <= 1
-            && text.char(range.from()) == '-'
-        {
-            Range::new(range.from() + 1, range.to() + 1)
-        } else {
-            range
-        };
-
-        let range = textobject_word(text, range, TextObject::Inside, 1, false);
-
-        // If there is a minus sign to the left of the word object, we want to include it in the range.
-        let range = if range.from() > 0 && text.char(range.from() - 1) == '-' {
-            range.extend(range.from() - 1, range.from())
-        } else {
-            range
-        };
-
-        let word: String = text
-            .slice(range.from()..range.to())
-            .chars()
-            .filter(|&c| c != '_')
-            .collect();
-        let (radix, prefixed) = if word.starts_with("0x") {
-            (16, true)
-        } else if word.starts_with("0o") {
-            (8, true)
-        } else if word.starts_with("0b") {
-            (2, true)
-        } else {
-            (10, false)
-        };
-
-        let number = if prefixed { &word[2..] } else { &word };
-
-        let value = i128::from_str_radix(number, radix).ok()?;
-        if (value.is_positive() && value.leading_zeros() < 64)
-            || (value.is_negative() && value.leading_ones() < 64)
-        {
-            return None;
-        }
-
-        let value = value as i64;
-        Some(NumberIncrementor {
-            range,
-            value,
-            radix,
-            text,
-        })
-    }
-}
-
-impl<'a> Increment for NumberIncrementor<'a> {
-    fn increment(&self, amount: i64) -> (Range, Tendril) {
-        let old_text: Cow<str> = self.text.slice(self.range.from()..self.range.to()).into();
-        let old_length = old_text.len();
-        let new_value = self.value.wrapping_add(amount);
-
-        // Get separator indexes from right to left.
-        let separator_rtl_indexes: Vec<usize> = old_text
-            .chars()
-            .rev()
-            .enumerate()
-            .filter_map(|(i, c)| if c == '_' { Some(i) } else { None })
-            .collect();
-
-        let format_length = if self.radix == 10 {
-            match (self.value.is_negative(), new_value.is_negative()) {
-                (true, false) => old_length - 1,
-                (false, true) => old_length + 1,
-                _ => old_text.len(),
-            }
-        } else {
-            old_text.len() - 2
-        } - separator_rtl_indexes.len();
-
-        let mut new_text = match self.radix {
-            2 => format!("0b{:01$b}", new_value, format_length),
-            8 => format!("0o{:01$o}", new_value, format_length),
-            10 if old_text.starts_with('0') || old_text.starts_with("-0") => {
-                format!("{:01$}", new_value, format_length)
-            }
-            10 => format!("{}", new_value),
-            16 => {
-                let (lower_count, upper_count): (usize, usize) =
-                    old_text.chars().skip(2).fold((0, 0), |(lower, upper), c| {
-                        (
-                            lower + usize::from(c.is_ascii_lowercase()),
-                            upper + usize::from(c.is_ascii_uppercase()),
-                        )
-                    });
-                if upper_count > lower_count {
-                    format!("0x{:01$X}", new_value, format_length)
-                } else {
-                    format!("0x{:01$x}", new_value, format_length)
-                }
-            }
-            _ => unimplemented!("radix not supported: {}", self.radix),
-        };
-
-        // Add separators from original number.
-        for &rtl_index in &separator_rtl_indexes {
-            if rtl_index < new_text.len() {
-                let new_index = new_text.len() - rtl_index;
-                new_text.insert(new_index, '_');
-            }
-        }
-
-        // Add in additional separators if necessary.
-        if new_text.len() > old_length && !separator_rtl_indexes.is_empty() {
-            let spacing = match separator_rtl_indexes.as_slice() {
-                [.., b, a] => a - b - 1,
-                _ => separator_rtl_indexes[0],
-            };
-
-            let prefix_length = if self.radix == 10 { 0 } else { 2 };
-            if let Some(mut index) = new_text.find('_') {
-                while index - prefix_length > spacing {
-                    index -= spacing;
-                    new_text.insert(index, '_');
-                }
-            }
-        }
-
-        (self.range, new_text.into())
-    }
-}
-
-#[cfg(test)]
-mod test {
-    use super::*;
-    use crate::Rope;
-
-    #[test]
-    fn test_decimal_at_point() {
-        let rope = Rope::from_str("Test text 12345 more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 15),
-                value: 12345,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_uppercase_hexadecimal_at_point() {
-        let rope = Rope::from_str("Test text 0x123ABCDEF more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 21),
-                value: 0x123ABCDEF,
-                radix: 16,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_lowercase_hexadecimal_at_point() {
-        let rope = Rope::from_str("Test text 0xfa3b4e more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 18),
-                value: 0xfa3b4e,
-                radix: 16,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_octal_at_point() {
-        let rope = Rope::from_str("Test text 0o1074312 more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 19),
-                value: 0o1074312,
-                radix: 8,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_binary_at_point() {
-        let rope = Rope::from_str("Test text 0b10111010010101 more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 26),
-                value: 0b10111010010101,
-                radix: 2,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_negative_decimal_at_point() {
-        let rope = Rope::from_str("Test text -54321 more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 16),
-                value: -54321,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_decimal_with_leading_zeroes_at_point() {
-        let rope = Rope::from_str("Test text 000045326 more text.");
-        let range = Range::point(12);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 19),
-                value: 45326,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_negative_decimal_cursor_on_minus_sign() {
-        let rope = Rope::from_str("Test text -54321 more text.");
-        let range = Range::point(10);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(10, 16),
-                value: -54321,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_number_under_range_start_of_rope() {
-        let rope = Rope::from_str("100");
-        let range = Range::point(0);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(0, 3),
-                value: 100,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_number_under_range_end_of_rope() {
-        let rope = Rope::from_str("100");
-        let range = Range::point(2);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(0, 3),
-                value: 100,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_number_surrounded_by_punctuation() {
-        let rope = Rope::from_str(",100;");
-        let range = Range::point(1);
-        assert_eq!(
-            NumberIncrementor::from_range(rope.slice(..), range),
-            Some(NumberIncrementor {
-                range: Range::new(1, 4),
-                value: 100,
-                radix: 10,
-                text: rope.slice(..),
-            })
-        );
-    }
-
-    #[test]
-    fn test_not_a_number_point() {
-        let rope = Rope::from_str("Test text 45326 more text.");
-        let range = Range::point(6);
-        assert_eq!(NumberIncrementor::from_range(rope.slice(..), range), None);
-    }
-
-    #[test]
-    fn test_number_too_large_at_point() {
-        let rope = Rope::from_str("Test text 0xFFFFFFFFFFFFFFFFF more text.");
-        let range = Range::point(12);
-        assert_eq!(NumberIncrementor::from_range(rope.slice(..), range), None);
-    }
-
-    #[test]
-    fn test_number_cursor_one_right_of_number() {
-        let rope = Rope::from_str("100 ");
-        let range = Range::point(3);
-        assert_eq!(NumberIncrementor::from_range(rope.slice(..), range), None);
-    }
-
-    #[test]
-    fn test_number_cursor_one_left_of_number() {
-        let rope = Rope::from_str(" 100");
-        let range = Range::point(0);
-        assert_eq!(NumberIncrementor::from_range(rope.slice(..), range), None);
-    }
-
-    #[test]
-    fn test_increment_basic_decimal_numbers() {
-        let tests = [
-            ("100", 1, "101"),
-            ("100", -1, "99"),
-            ("99", 1, "100"),
-            ("100", 1000, "1100"),
-            ("100", -1000, "-900"),
-            ("-1", 1, "0"),
-            ("-1", 2, "1"),
-            ("1", -1, "0"),
-            ("1", -2, "-1"),
-        ];
-
-        for (original, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::point(0);
-            assert_eq!(
-                NumberIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
-        }
-    }
-
-    #[test]
-    fn test_increment_basic_hexadecimal_numbers() {
-        let tests = [
-            ("0x0100", 1, "0x0101"),
-            ("0x0100", -1, "0x00ff"),
-            ("0x0001", -1, "0x0000"),
-            ("0x0000", -1, "0xffffffffffffffff"),
-            ("0xffffffffffffffff", 1, "0x0000000000000000"),
-            ("0xffffffffffffffff", 2, "0x0000000000000001"),
-            ("0xffffffffffffffff", -1, "0xfffffffffffffffe"),
-            ("0xABCDEF1234567890", 1, "0xABCDEF1234567891"),
-            ("0xabcdef1234567890", 1, "0xabcdef1234567891"),
-        ];
-
-        for (original, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::point(0);
-            assert_eq!(
-                NumberIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
-        }
-    }
-
-    #[test]
-    fn test_increment_basic_octal_numbers() {
-        let tests = [
-            ("0o0107", 1, "0o0110"),
-            ("0o0110", -1, "0o0107"),
-            ("0o0001", -1, "0o0000"),
-            ("0o7777", 1, "0o10000"),
-            ("0o1000", -1, "0o0777"),
-            ("0o0107", 10, "0o0121"),
-            ("0o0000", -1, "0o1777777777777777777777"),
-            ("0o1777777777777777777777", 1, "0o0000000000000000000000"),
-            ("0o1777777777777777777777", 2, "0o0000000000000000000001"),
-            ("0o1777777777777777777777", -1, "0o1777777777777777777776"),
-        ];
-
-        for (original, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::point(0);
-            assert_eq!(
-                NumberIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
-        }
-    }
-
-    #[test]
-    fn test_increment_basic_binary_numbers() {
-        let tests = [
-            ("0b00000100", 1, "0b00000101"),
-            ("0b00000100", -1, "0b00000011"),
-            ("0b00000100", 2, "0b00000110"),
-            ("0b00000100", -2, "0b00000010"),
-            ("0b00000001", -1, "0b00000000"),
-            ("0b00111111", 10, "0b01001001"),
-            ("0b11111111", 1, "0b100000000"),
-            ("0b10000000", -1, "0b01111111"),
-            (
-                "0b0000",
-                -1,
-                "0b1111111111111111111111111111111111111111111111111111111111111111",
-            ),
-            (
-                "0b1111111111111111111111111111111111111111111111111111111111111111",
-                1,
-                "0b0000000000000000000000000000000000000000000000000000000000000000",
-            ),
-            (
-                "0b1111111111111111111111111111111111111111111111111111111111111111",
-                2,
-                "0b0000000000000000000000000000000000000000000000000000000000000001",
-            ),
-            (
-                "0b1111111111111111111111111111111111111111111111111111111111111111",
-                -1,
-                "0b1111111111111111111111111111111111111111111111111111111111111110",
-            ),
-        ];
-
-        for (original, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::point(0);
-            assert_eq!(
-                NumberIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
-        }
-    }
-
-    #[test]
-    fn test_increment_with_separators() {
-        let tests = [
-            ("999_999", 1, "1_000_000"),
-            ("1_000_000", -1, "999_999"),
-            ("-999_999", -1, "-1_000_000"),
-            ("0x0000_0000_0001", 0x1_ffff_0000, "0x0001_ffff_0001"),
-            ("0x0000_0000_0001", 0x1_ffff_0000, "0x0001_ffff_0001"),
-            ("0x0000_0000_0001", 0x1_ffff_0000, "0x0001_ffff_0001"),
-            ("0x0000_0000", -1, "0xffff_ffff_ffff_ffff"),
-            ("0x0000_0000_0000", -1, "0xffff_ffff_ffff_ffff"),
-            ("0b01111111_11111111", 1, "0b10000000_00000000"),
-            ("0b11111111_11111111", 1, "0b1_00000000_00000000"),
-        ];
-
-        for (original, amount, expected) in tests {
-            let rope = Rope::from_str(original);
-            let range = Range::point(0);
-            assert_eq!(
-                NumberIncrementor::from_range(rope.slice(..), range)
-                    .unwrap()
-                    .increment(amount)
-                    .1,
-                Tendril::from(expected)
-            );
-        }
-    }
-}
diff --git a/helix-core/src/indent.rs b/helix-core/src/indent.rs
index d6aa5edb8..db780ed97 100644
--- a/helix-core/src/indent.rs
+++ b/helix-core/src/indent.rs
@@ -4,6 +4,7 @@
 
 use crate::{
     chars::{char_is_line_ending, char_is_whitespace},
+    graphemes::tab_width_at,
     syntax::{LanguageConfiguration, RopeProvider, Syntax},
     tree_sitter::Node,
     Rope, RopeSlice,
@@ -56,6 +57,14 @@ pub fn as_str(&self) -> &'static str {
             }
         }
     }
+
+    #[inline]
+    pub fn indent_width(&self, tab_width: usize) -> usize {
+        match *self {
+            IndentStyle::Tabs => tab_width,
+            IndentStyle::Spaces(width) => width as usize,
+        }
+    }
 }
 
 /// Attempts to detect the indentation style used in a document.
@@ -177,17 +186,17 @@ pub fn auto_detect_indent_style(document_text: &Rope) -> Option<IndentStyle> {
 
 /// To determine indentation of a newly inserted line, figure out the indentation at the last col
 /// of the previous line.
-pub fn indent_level_for_line(line: RopeSlice, tab_width: usize) -> usize {
+pub fn indent_level_for_line(line: RopeSlice, tab_width: usize, indent_width: usize) -> usize {
     let mut len = 0;
     for ch in line.chars() {
         match ch {
-            '\t' => len += tab_width,
+            '\t' => len += tab_width_at(len, tab_width as u16),
             ' ' => len += 1,
             _ => break,
         }
     }
 
-    len / tab_width
+    len / indent_width
 }
 
 /// Computes for node and all ancestors whether they are the first node on their line.
@@ -466,6 +475,7 @@ fn extend_nodes<'a>(
     text: RopeSlice,
     line: usize,
     tab_width: usize,
+    indent_width: usize,
 ) {
     let mut stop_extend = false;
 
@@ -490,10 +500,12 @@ fn extend_nodes<'a>(
                         if deepest_preceding.end_position().row == line {
                             extend_node = true;
                         } else {
-                            let cursor_indent = indent_level_for_line(text.line(line), tab_width);
+                            let cursor_indent =
+                                indent_level_for_line(text.line(line), tab_width, indent_width);
                             let node_indent = indent_level_for_line(
                                 text.line(deepest_preceding.start_position().row),
                                 tab_width,
+                                indent_width,
                             );
                             if cursor_indent > node_indent {
                                 extend_node = true;
@@ -562,6 +574,7 @@ pub fn treesitter_indent_for_pos(
     syntax: &Syntax,
     indent_style: &IndentStyle,
     tab_width: usize,
+    indent_width: usize,
     text: RopeSlice,
     line: usize,
     pos: usize,
@@ -604,7 +617,7 @@ pub fn treesitter_indent_for_pos(
                 &mut cursor,
                 text,
                 query_range,
-                new_line.then(|| (line, byte_pos)),
+                new_line.then_some((line, byte_pos)),
             );
             ts_parser.cursors.push(cursor);
             (query_result, deepest_preceding)
@@ -622,9 +635,10 @@ pub fn treesitter_indent_for_pos(
             text,
             line,
             tab_width,
+            indent_width,
         );
     }
-    let mut first_in_line = get_first_in_line(node, new_line.then(|| byte_pos));
+    let mut first_in_line = get_first_in_line(node, new_line.then_some(byte_pos));
 
     let mut result = Indentation::default();
     // We always keep track of all the indent changes on one line, in order to only indent once
@@ -709,6 +723,7 @@ pub fn indent_for_newline(
     line_before_end_pos: usize,
     current_line: usize,
 ) -> String {
+    let indent_width = indent_style.indent_width(tab_width);
     if let (Some(query), Some(syntax)) = (
         language_config.and_then(|config| config.indent_query()),
         syntax,
@@ -718,6 +733,7 @@ pub fn indent_for_newline(
             syntax,
             indent_style,
             tab_width,
+            indent_width,
             text,
             line_before,
             line_before_end_pos,
@@ -726,7 +742,7 @@ pub fn indent_for_newline(
             return indent;
         };
     }
-    let indent_level = indent_level_for_line(text.line(current_line), tab_width);
+    let indent_level = indent_level_for_line(text.line(current_line), tab_width, indent_width);
     indent_style.as_str().repeat(indent_level)
 }
 
@@ -763,12 +779,22 @@ mod test {
     #[test]
     fn test_indent_level() {
         let tab_width = 4;
+        let indent_width = 4;
         let line = Rope::from("        fn new"); // 8 spaces
-        assert_eq!(indent_level_for_line(line.slice(..), tab_width), 2);
+        assert_eq!(
+            indent_level_for_line(line.slice(..), tab_width, indent_width),
+            2
+        );
         let line = Rope::from("\t\t\tfn new"); // 3 tabs
-        assert_eq!(indent_level_for_line(line.slice(..), tab_width), 3);
+        assert_eq!(
+            indent_level_for_line(line.slice(..), tab_width, indent_width),
+            3
+        );
         // mixed indentation
         let line = Rope::from("\t    \tfn new"); // 1 tab, 4 spaces, tab
-        assert_eq!(indent_level_for_line(line.slice(..), tab_width), 3);
+        assert_eq!(
+            indent_level_for_line(line.slice(..), tab_width, indent_width),
+            3
+        );
     }
 }
diff --git a/helix-core/src/lib.rs b/helix-core/src/lib.rs
index ee174e69d..b67e2c8a3 100644
--- a/helix-core/src/lib.rs
+++ b/helix-core/src/lib.rs
@@ -6,6 +6,7 @@
 pub mod config;
 pub mod diagnostic;
 pub mod diff;
+pub mod doc_formatter;
 pub mod graphemes;
 pub mod history;
 pub mod increment;
@@ -24,6 +25,7 @@
 pub mod surround;
 pub mod syntax;
 pub mod test;
+pub mod text_annotations;
 pub mod textobject;
 mod transaction;
 pub mod wrap;
@@ -34,55 +36,12 @@ pub mod unicode {
     pub use unicode_width as width;
 }
 
+pub use helix_loader::find_workspace;
+
 pub fn find_first_non_whitespace_char(line: RopeSlice) -> Option<usize> {
     line.chars().position(|ch| !ch.is_whitespace())
 }
 
-/// Find project root.
-///
-/// Order of detection:
-/// * Top-most folder containing a root marker in current git repository
-/// * Git repository root if no marker detected
-/// * Top-most folder containing a root marker if not git repository detected
-/// * Current working directory as fallback
-pub fn find_root(root: Option<&str>, root_markers: &[String]) -> std::path::PathBuf {
-    let current_dir = std::env::current_dir().expect("unable to determine current directory");
-
-    let root = match root {
-        Some(root) => {
-            let root = std::path::Path::new(root);
-            if root.is_absolute() {
-                root.to_path_buf()
-            } else {
-                current_dir.join(root)
-            }
-        }
-        None => current_dir.clone(),
-    };
-
-    let mut top_marker = None;
-    for ancestor in root.ancestors() {
-        if root_markers
-            .iter()
-            .any(|marker| ancestor.join(marker).exists())
-        {
-            top_marker = Some(ancestor);
-        }
-
-        if ancestor.join(".git").exists() {
-            // Top marker is repo root if not root marker was detected yet
-            if top_marker.is_none() {
-                top_marker = Some(ancestor);
-            }
-            // Don't go higher than repo if we're in one
-            break;
-        }
-    }
-
-    // Return the found top marker or the current_dir as fallback
-    top_marker.map_or(current_dir, |a| a.to_path_buf())
-}
-
 pub use ropey::{self, str_utils, Rope, RopeBuilder, RopeSlice};
 
 // pub use tendril::StrTendril as Tendril;
@@ -95,8 +54,12 @@ pub fn find_root(root: Option<&str>, root_markers: &[String]) -> std::path::Path
 
 pub use graphemes::RopeGraphemes;
 pub use position::{
-    coords_at_pos, pos_at_coords, pos_at_visual_coords, visual_coords_at_pos, Position,
+    char_idx_at_visual_offset, coords_at_pos, pos_at_coords, visual_offset_from_anchor,
+    visual_offset_from_block, Position, VisualOffsetError,
 };
+#[allow(deprecated)]
+pub use position::{pos_at_visual_coords, visual_coords_at_pos};
+
 pub use selection::{Range, Selection};
 pub use smallvec::{smallvec, SmallVec};
 pub use syntax::Syntax;
diff --git a/helix-core/src/line_ending.rs b/helix-core/src/line_ending.rs
index 09e925230..953d567d5 100644
--- a/helix-core/src/line_ending.rs
+++ b/helix-core/src/line_ending.rs
@@ -203,6 +203,13 @@ pub fn line_end_char_index(slice: &RopeSlice, line: usize) -> usize {
             .unwrap_or(0)
 }
 
+pub fn line_end_byte_index(slice: &RopeSlice, line: usize) -> usize {
+    slice.line_to_byte(line + 1)
+        - get_line_ending(&slice.line(line))
+            .map(|le| le.as_str().len())
+            .unwrap_or(0)
+}
+
 /// Fetches line `line_idx` from the passed rope slice, sans any line ending.
 pub fn line_without_line_ending<'a>(slice: &'a RopeSlice, line_idx: usize) -> RopeSlice<'a> {
     let start = slice.line_to_char(line_idx);
diff --git a/helix-core/src/movement.rs b/helix-core/src/movement.rs
index 278375e8f..60af47e5b 100644
--- a/helix-core/src/movement.rs
+++ b/helix-core/src/movement.rs
@@ -4,16 +4,19 @@
 use tree_sitter::{Node, QueryCursor};
 
 use crate::{
+    char_idx_at_visual_offset,
     chars::{categorize_char, char_is_line_ending, CharCategory},
+    doc_formatter::TextFormat,
     graphemes::{
         next_grapheme_boundary, nth_next_grapheme_boundary, nth_prev_grapheme_boundary,
         prev_grapheme_boundary,
     },
     line_ending::rope_is_line_ending,
-    pos_at_visual_coords,
+    position::char_idx_at_visual_block_offset,
     syntax::LanguageConfiguration,
+    text_annotations::TextAnnotations,
     textobject::TextObject,
-    visual_coords_at_pos, Position, Range, RopeSlice,
+    visual_offset_from_block, Range, RopeSlice,
 };
 
 #[derive(Debug, Copy, Clone, PartialEq, Eq)]
@@ -34,7 +37,8 @@ pub fn move_horizontally(
     dir: Direction,
     count: usize,
     behaviour: Movement,
-    _: usize,
+    _: &TextFormat,
+    _: &mut TextAnnotations,
 ) -> Range {
     let pos = range.cursor(slice);
 
@@ -48,35 +52,116 @@ pub fn move_horizontally(
     range.put_cursor(slice, new_pos, behaviour == Movement::Extend)
 }
 
+pub fn move_vertically_visual(
+    slice: RopeSlice,
+    range: Range,
+    dir: Direction,
+    count: usize,
+    behaviour: Movement,
+    text_fmt: &TextFormat,
+    annotations: &mut TextAnnotations,
+) -> Range {
+    if !text_fmt.soft_wrap {
+        move_vertically(slice, range, dir, count, behaviour, text_fmt, annotations);
+    }
+    annotations.clear_line_annotations();
+    let pos = range.cursor(slice);
+
+    // Compute the current position's 2d coordinates.
+    let (visual_pos, block_off) = visual_offset_from_block(slice, pos, pos, text_fmt, annotations);
+    let new_col = range
+        .old_visual_position
+        .map_or(visual_pos.col as u32, |(_, col)| col);
+
+    // Compute the new position.
+    let mut row_off = match dir {
+        Direction::Forward => count as isize,
+        Direction::Backward => -(count as isize),
+    };
+
+    // TODO how to handle inline annotations that span an entire visual line (very unlikely).
+
+    // Compute visual offset relative to block start to avoid trasversing the block twice
+    row_off += visual_pos.row as isize;
+    let new_pos = char_idx_at_visual_offset(
+        slice,
+        block_off,
+        row_off,
+        new_col as usize,
+        text_fmt,
+        annotations,
+    )
+    .0;
+
+    // Special-case to avoid moving to the end of the last non-empty line.
+    if behaviour == Movement::Extend && slice.line(slice.char_to_line(new_pos)).len_chars() == 0 {
+        return range;
+    }
+
+    let mut new_range = range.put_cursor(slice, new_pos, behaviour == Movement::Extend);
+    new_range.old_visual_position = Some((0, new_col));
+    new_range
+}
+
 pub fn move_vertically(
     slice: RopeSlice,
     range: Range,
     dir: Direction,
     count: usize,
     behaviour: Movement,
-    tab_width: usize,
+    text_fmt: &TextFormat,
+    annotations: &mut TextAnnotations,
 ) -> Range {
+    annotations.clear_line_annotations();
     let pos = range.cursor(slice);
+    let line_idx = slice.char_to_line(pos);
+    let line_start = slice.line_to_char(line_idx);
 
     // Compute the current position's 2d coordinates.
-    let Position { row, col } = visual_coords_at_pos(slice, pos, tab_width);
-    let horiz = range.horiz.unwrap_or(col as u32);
+    let visual_pos = visual_offset_from_block(slice, line_start, pos, text_fmt, annotations).0;
+    let (mut new_row, new_col) = range
+        .old_visual_position
+        .map_or((visual_pos.row as u32, visual_pos.col as u32), |pos| pos);
+    new_row = new_row.max(visual_pos.row as u32);
+    let line_idx = slice.char_to_line(pos);
 
     // Compute the new position.
-    let new_row = match dir {
-        Direction::Forward => (row + count).min(slice.len_lines().saturating_sub(1)),
-        Direction::Backward => row.saturating_sub(count),
+    let mut new_line_idx = match dir {
+        Direction::Forward => line_idx.saturating_add(count),
+        Direction::Backward => line_idx.saturating_sub(count),
+    };
+
+    let line = if new_line_idx >= slice.len_lines() - 1 {
+        // there is no line terminator for the last line
+        // so the logic below is not necessary here
+        new_line_idx = slice.len_lines() - 1;
+        slice
+    } else {
+        // char_idx_at_visual_block_offset returns a one-past-the-end index
+        // in case it reaches the end of the slice
+        // to avoid moving to the nextline in that case the line terminator is removed from the line
+        let new_line_end = prev_grapheme_boundary(slice, slice.line_to_char(new_line_idx + 1));
+        slice.slice(..new_line_end)
     };
-    let new_col = col.max(horiz as usize);
-    let new_pos = pos_at_visual_coords(slice, Position::new(new_row, new_col), tab_width);
+
+    let new_line_start = line.line_to_char(new_line_idx);
+
+    let (new_pos, _) = char_idx_at_visual_block_offset(
+        line,
+        new_line_start,
+        new_row as usize,
+        new_col as usize,
+        text_fmt,
+        annotations,
+    );
 
     // Special-case to avoid moving to the end of the last non-empty line.
-    if behaviour == Movement::Extend && slice.line(new_row).len_chars() == 0 {
+    if behaviour == Movement::Extend && slice.line(new_line_idx).len_chars() == 0 {
         return range;
     }
 
     let mut new_range = range.put_cursor(slice, new_pos, behaviour == Movement::Extend);
-    new_range.horiz = Some(horiz);
+    new_range.old_visual_position = Some((new_row, new_col));
     new_range
 }
 
@@ -142,9 +227,15 @@ fn word_move(slice: RopeSlice, range: Range, count: usize, target: WordMotionTar
     };
 
     // Do the main work.
-    (0..count).fold(start_range, |r, _| {
-        slice.chars_at(r.head).range_to_target(target, r)
-    })
+    let mut range = start_range;
+    for _ in 0..count {
+        let next_range = slice.chars_at(range.head).range_to_target(target, range);
+        if range == next_range {
+            break;
+        }
+        range = next_range;
+    }
+    range
 }
 
 pub fn move_prev_paragraph(
@@ -166,6 +257,7 @@ pub fn move_prev_paragraph(
     let mut lines = slice.lines_at(line);
     lines.reverse();
     let mut lines = lines.map(rope_is_line_ending).peekable();
+    let mut last_line = line;
     for _ in 0..count {
         while lines.next_if(|&e| e).is_some() {
             line -= 1;
@@ -173,6 +265,10 @@ pub fn move_prev_paragraph(
         while lines.next_if(|&e| !e).is_some() {
             line -= 1;
         }
+        if line == last_line {
+            break;
+        }
+        last_line = line;
     }
 
     let head = slice.line_to_char(line);
@@ -208,6 +304,7 @@ pub fn move_next_paragraph(
         line += 1;
     }
     let mut lines = slice.lines_at(line).map(rope_is_line_ending).peekable();
+    let mut last_line = line;
     for _ in 0..count {
         while lines.next_if(|&e| !e).is_some() {
             line += 1;
@@ -215,6 +312,10 @@ pub fn move_next_paragraph(
         while lines.next_if(|&e| e).is_some() {
             line += 1;
         }
+        if line == last_line {
+            break;
+        }
+        last_line = line;
     }
     let head = slice.line_to_char(line);
     let anchor = if behavior == Movement::Move {
@@ -438,7 +539,14 @@ pub fn goto_treesitter_object(
         // head of range should be at beginning
         Some(Range::new(start_char, end_char))
     };
-    (0..count).fold(range, |range, _| get_range(range).unwrap_or(range))
+    let mut last_range = range;
+    for _ in 0..count {
+        match get_range(last_range) {
+            Some(r) if r != last_range => last_range = r,
+            _ => break,
+        }
+    }
+    last_range
 }
 
 #[cfg(test)]
@@ -473,7 +581,16 @@ fn test_vertical_move() {
         assert_eq!(
             coords_at_pos(
                 slice,
-                move_vertically(slice, range, Direction::Forward, 1, Movement::Move, 4).head
+                move_vertically_visual(
+                    slice,
+                    range,
+                    Direction::Forward,
+                    1,
+                    Movement::Move,
+                    &TextFormat::default(),
+                    &mut TextAnnotations::default(),
+                )
+                .head
             ),
             (1, 3).into()
         );
@@ -497,7 +614,15 @@ fn horizontal_moves_through_single_line_text() {
         ];
 
         for ((direction, amount), coordinates) in moves_and_expected_coordinates {
-            range = move_horizontally(slice, range, direction, amount, Movement::Move, 0);
+            range = move_horizontally(
+                slice,
+                range,
+                direction,
+                amount,
+                Movement::Move,
+                &TextFormat::default(),
+                &mut TextAnnotations::default(),
+            );
             assert_eq!(coords_at_pos(slice, range.head), coordinates.into())
         }
     }
@@ -523,7 +648,15 @@ fn horizontal_moves_through_multiline_text() {
         ];
 
         for ((direction, amount), coordinates) in moves_and_expected_coordinates {
-            range = move_horizontally(slice, range, direction, amount, Movement::Move, 0);
+            range = move_horizontally(
+                slice,
+                range,
+                direction,
+                amount,
+                Movement::Move,
+                &TextFormat::default(),
+                &mut TextAnnotations::default(),
+            );
             assert_eq!(coords_at_pos(slice, range.head), coordinates.into());
             assert_eq!(range.head, range.anchor);
         }
@@ -545,7 +678,15 @@ fn selection_extending_moves_in_single_line_text() {
         ];
 
         for (direction, amount) in moves {
-            range = move_horizontally(slice, range, direction, amount, Movement::Extend, 0);
+            range = move_horizontally(
+                slice,
+                range,
+                direction,
+                amount,
+                Movement::Extend,
+                &TextFormat::default(),
+                &mut TextAnnotations::default(),
+            );
             assert_eq!(range.anchor, original_anchor);
         }
     }
@@ -569,7 +710,15 @@ fn vertical_moves_in_single_column() {
         ];
 
         for ((direction, amount), coordinates) in moves_and_expected_coordinates {
-            range = move_vertically(slice, range, direction, amount, Movement::Move, 4);
+            range = move_vertically_visual(
+                slice,
+                range,
+                direction,
+                amount,
+                Movement::Move,
+                &TextFormat::default(),
+                &mut TextAnnotations::default(),
+            );
             assert_eq!(coords_at_pos(slice, range.head), coordinates.into());
             assert_eq!(range.head, range.anchor);
         }
@@ -603,8 +752,24 @@ enum Axis {
 
         for ((axis, direction, amount), coordinates) in moves_and_expected_coordinates {
             range = match axis {
-                Axis::H => move_horizontally(slice, range, direction, amount, Movement::Move, 0),
-                Axis::V => move_vertically(slice, range, direction, amount, Movement::Move, 4),
+                Axis::H => move_horizontally(
+                    slice,
+                    range,
+                    direction,
+                    amount,
+                    Movement::Move,
+                    &TextFormat::default(),
+                    &mut TextAnnotations::default(),
+                ),
+                Axis::V => move_vertically_visual(
+                    slice,
+                    range,
+                    direction,
+                    amount,
+                    Movement::Move,
+                    &TextFormat::default(),
+                    &mut TextAnnotations::default(),
+                ),
             };
             assert_eq!(coords_at_pos(slice, range.head), coordinates.into());
             assert_eq!(range.head, range.anchor);
@@ -638,8 +803,24 @@ enum Axis {
 
         for ((axis, direction, amount), coordinates) in moves_and_expected_coordinates {
             range = match axis {
-                Axis::H => move_horizontally(slice, range, direction, amount, Movement::Move, 0),
-                Axis::V => move_vertically(slice, range, direction, amount, Movement::Move, 4),
+                Axis::H => move_horizontally(
+                    slice,
+                    range,
+                    direction,
+                    amount,
+                    Movement::Move,
+                    &TextFormat::default(),
+                    &mut TextAnnotations::default(),
+                ),
+                Axis::V => move_vertically_visual(
+                    slice,
+                    range,
+                    direction,
+                    amount,
+                    Movement::Move,
+                    &TextFormat::default(),
+                    &mut TextAnnotations::default(),
+                ),
             };
             assert_eq!(coords_at_pos(slice, range.head), coordinates.into());
             assert_eq!(range.head, range.anchor);
@@ -1293,7 +1474,7 @@ fn test_behaviour_when_moving_to_prev_paragraph_single() {
             let text = Rope::from(s.as_str());
             let selection =
                 selection.transform(|r| move_prev_paragraph(text.slice(..), r, 1, Movement::Move));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -1316,7 +1497,7 @@ fn test_behaviour_when_moving_to_prev_paragraph_double() {
             let text = Rope::from(s.as_str());
             let selection =
                 selection.transform(|r| move_prev_paragraph(text.slice(..), r, 2, Movement::Move));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -1339,7 +1520,7 @@ fn test_behaviour_when_moving_to_prev_paragraph_extend() {
             let text = Rope::from(s.as_str());
             let selection = selection
                 .transform(|r| move_prev_paragraph(text.slice(..), r, 1, Movement::Extend));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -1359,7 +1540,7 @@ fn test_behaviour_when_moving_to_next_paragraph_single() {
                 "a\nb\n\n#[goto\nthird\n\n|]#paragraph",
             ),
             (
-                "a\nb#[\n|]#\ngoto\nsecond\n\nparagraph",
+                "a\nb#[\n|]#\n\ngoto\nsecond\n\nparagraph",
                 "a\nb#[\n\n|]#goto\nsecond\n\nparagraph",
             ),
             (
@@ -1381,7 +1562,7 @@ fn test_behaviour_when_moving_to_next_paragraph_single() {
             let text = Rope::from(s.as_str());
             let selection =
                 selection.transform(|r| move_next_paragraph(text.slice(..), r, 1, Movement::Move));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -1404,7 +1585,7 @@ fn test_behaviour_when_moving_to_next_paragraph_double() {
             let text = Rope::from(s.as_str());
             let selection =
                 selection.transform(|r| move_next_paragraph(text.slice(..), r, 2, Movement::Move));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -1427,7 +1608,7 @@ fn test_behaviour_when_moving_to_next_paragraph_extend() {
             let text = Rope::from(s.as_str());
             let selection = selection
                 .transform(|r| move_next_paragraph(text.slice(..), r, 1, Movement::Extend));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
diff --git a/helix-core/src/path.rs b/helix-core/src/path.rs
index d59a6baad..efa46c46e 100644
--- a/helix-core/src/path.rs
+++ b/helix-core/src/path.rs
@@ -40,6 +40,21 @@ pub fn expand_tilde(path: &Path) -> PathBuf {
 /// needs to improve on.
 /// Copied from cargo: <https://github.com/rust-lang/cargo/blob/070e459c2d8b79c5b2ac5218064e7603329c92ae/crates/cargo-util/src/paths.rs#L81>
 pub fn get_normalized_path(path: &Path) -> PathBuf {
+    // normalization strategy is to canonicalize first ancestor path that exists (i.e., canonicalize as much as possible),
+    // then run handrolled normalization on the non-existent remainder
+    let (base, path) = path
+        .ancestors()
+        .find_map(|base| {
+            let canonicalized_base = dunce::canonicalize(base).ok()?;
+            let remainder = path.strip_prefix(base).ok()?.into();
+            Some((canonicalized_base, remainder))
+        })
+        .unwrap_or_else(|| (PathBuf::new(), PathBuf::from(path)));
+
+    if path.as_os_str().is_empty() {
+        return base;
+    }
+
     let mut components = path.components().peekable();
     let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {
         components.next();
@@ -63,7 +78,7 @@ pub fn get_normalized_path(path: &Path) -> PathBuf {
             }
         }
     }
-    ret
+    base.join(ret)
 }
 
 /// Returns the canonical, absolute form of a path with all intermediate components normalized.
@@ -82,13 +97,19 @@ pub fn get_canonicalized_path(path: &Path) -> std::io::Result<PathBuf> {
 }
 
 pub fn get_relative_path(path: &Path) -> PathBuf {
+    let path = PathBuf::from(path);
     let path = if path.is_absolute() {
-        let cwdir = std::env::current_dir().expect("couldn't determine current directory");
-        path.strip_prefix(cwdir).unwrap_or(path)
+        let cwdir = std::env::current_dir()
+            .map(|path| get_normalized_path(&path))
+            .expect("couldn't determine current directory");
+        get_normalized_path(&path)
+            .strip_prefix(cwdir)
+            .map(PathBuf::from)
+            .unwrap_or(path)
     } else {
         path
     };
-    fold_home_dir(path)
+    fold_home_dir(&path)
 }
 
 /// Returns a truncated filepath where the basepart of the path is reduced to the first
diff --git a/helix-core/src/position.rs b/helix-core/src/position.rs
index f456eb988..ee764bc64 100644
--- a/helix-core/src/position.rs
+++ b/helix-core/src/position.rs
@@ -1,9 +1,11 @@
-use std::borrow::Cow;
+use std::{borrow::Cow, cmp::Ordering};
 
 use crate::{
     chars::char_is_line_ending,
+    doc_formatter::{DocumentFormatter, TextFormat},
     graphemes::{ensure_grapheme_boundary_prev, grapheme_width, RopeGraphemes},
     line_ending::line_end_char_index,
+    text_annotations::TextAnnotations,
     RopeSlice,
 };
 
@@ -73,6 +75,13 @@ pub fn coords_at_pos(text: RopeSlice, pos: usize) -> Position {
 /// Takes \t, double-width characters (CJK) into account as well as text
 /// not in the document in the future.
 /// See [`coords_at_pos`] for an "objective" one.
+///
+/// This function should be used very rarely. Usually `visual_offset_from_anchor`
+/// or `visual_offset_from_block` is preferable. However when you want to compute the
+/// actual visual row/column in the text (not what is actually shown on screen)
+/// then you should use this function. For example aligning text should ignore virtual
+/// text and softwrap.
+#[deprecated = "Doesn't account for softwrap or decorations, use visual_offset_from_anchor instead"]
 pub fn visual_coords_at_pos(text: RopeSlice, pos: usize, tab_width: usize) -> Position {
     let line = text.char_to_line(pos);
 
@@ -93,6 +102,106 @@ pub fn visual_coords_at_pos(text: RopeSlice, pos: usize, tab_width: usize) -> Po
     Position::new(line, col)
 }
 
+/// Returns the visual offset from the start of the first visual line
+/// in the block that contains anchor.
+/// Text is always wrapped at blocks, they usually correspond to
+/// actual line breaks but for very long lines
+/// softwrapping positions are estimated with an O(1) algorithm
+/// to ensure consistent performance for large lines (currently unimplemented)
+///
+/// Usually you want to use `visual_offset_from_anchor` instead but this function
+/// can be useful (and faster) if
+/// * You already know the visual position of the block
+/// * You only care about the horizontal offset (column) and not the vertical offset (row)
+pub fn visual_offset_from_block(
+    text: RopeSlice,
+    anchor: usize,
+    pos: usize,
+    text_fmt: &TextFormat,
+    annotations: &TextAnnotations,
+) -> (Position, usize) {
+    let mut last_pos = Position::default();
+    let (formatter, block_start) =
+        DocumentFormatter::new_at_prev_checkpoint(text, text_fmt, annotations, anchor);
+    let mut char_pos = block_start;
+
+    for (grapheme, vpos) in formatter {
+        last_pos = vpos;
+        char_pos += grapheme.doc_chars();
+
+        if char_pos > pos {
+            return (last_pos, block_start);
+        }
+    }
+
+    (last_pos, block_start)
+}
+
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
+pub enum VisualOffsetError {
+    PosBeforeAnchorRow,
+    PosAfterMaxRow,
+}
+
+/// Returns the visual offset from the start of the visual line
+/// that contains anchor.
+pub fn visual_offset_from_anchor(
+    text: RopeSlice,
+    anchor: usize,
+    pos: usize,
+    text_fmt: &TextFormat,
+    annotations: &TextAnnotations,
+    max_rows: usize,
+) -> Result<(Position, usize), VisualOffsetError> {
+    let (formatter, block_start) =
+        DocumentFormatter::new_at_prev_checkpoint(text, text_fmt, annotations, anchor);
+    let mut char_pos = block_start;
+    let mut anchor_line = None;
+    let mut found_pos = None;
+    let mut last_pos = Position::default();
+
+    if pos < block_start {
+        return Err(VisualOffsetError::PosBeforeAnchorRow);
+    }
+
+    for (grapheme, vpos) in formatter {
+        last_pos = vpos;
+        char_pos += grapheme.doc_chars();
+
+        if char_pos > pos {
+            if let Some(anchor_line) = anchor_line {
+                last_pos.row -= anchor_line;
+                return Ok((last_pos, block_start));
+            } else {
+                found_pos = Some(last_pos);
+            }
+        }
+        if char_pos > anchor && anchor_line.is_none() {
+            if let Some(mut found_pos) = found_pos {
+                return if found_pos.row == last_pos.row {
+                    found_pos.row = 0;
+                    Ok((found_pos, block_start))
+                } else {
+                    Err(VisualOffsetError::PosBeforeAnchorRow)
+                };
+            } else {
+                anchor_line = Some(last_pos.row);
+            }
+        }
+
+        if let Some(anchor_line) = anchor_line {
+            if vpos.row >= anchor_line + max_rows {
+                return Err(VisualOffsetError::PosAfterMaxRow);
+            }
+        }
+    }
+
+    let anchor_line = anchor_line.unwrap_or(last_pos.row);
+    last_pos.row -= anchor_line;
+
+    Ok((last_pos, block_start))
+}
+
 /// Convert (line, column) coordinates to a character index.
 ///
 /// If the `line` coordinate is beyond the end of the file, the EOF
@@ -140,6 +249,11 @@ pub fn pos_at_coords(text: RopeSlice, coords: Position, limit_before_line_ending
 /// If the `column` coordinate is past the end of the given line, the
 /// line-end position (in this case, just before the line ending
 /// character) will be returned.
+/// This function should be used very rarely. Usually `char_idx_at_visual_offset` is preferable.
+/// However when you want to compute a char position from the visual row/column in the text
+/// (not what is actually shown on screen) then you should use this function.
+/// For example aligning text should ignore virtual text and softwrap.
+#[deprecated = "Doesn't account for softwrap or decorations, use char_idx_at_visual_offset instead"]
 pub fn pos_at_visual_coords(text: RopeSlice, coords: Position, tab_width: usize) -> usize {
     let Position { mut row, col } = coords;
     row = row.min(text.len_lines() - 1);
@@ -169,6 +283,121 @@ pub fn pos_at_visual_coords(text: RopeSlice, coords: Position, tab_width: usize)
     line_start + col_char_offset
 }
 
+/// Returns the char index on the visual line `row_offset` below the visual line of
+/// the provided char index `anchor` that is closest to the supplied visual `column`.
+///
+/// If the targeted visual line is entirely covered by virtual text the last
+/// char position before the virtual text and a virtual offset is returned instead.
+///
+/// If no (text) grapheme starts at exactly at the specified column the
+/// start of the grapheme to the left is returned. If there is no grapheme
+/// to the left (for example if the line starts with virtual text) then the positioning
+/// of the next grapheme to the right is returned.
+///
+/// If the `line` coordinate is beyond the end of the file, the EOF
+/// position will be returned.
+///
+/// If the `column` coordinate is past the end of the given line, the
+/// line-end position (in this case, just before the line ending
+/// character) will be returned.
+///
+/// # Returns
+///
+/// `(real_char_idx, virtual_lines)`
+///
+/// The nearest character idx "closest" (see above) to the specified visual offset
+/// on the visual line is returned if the visual line contains any text:
+/// If the visual line at the specified offset is a virtual line generated by a `LineAnnotation`
+/// the previous char_index is returned, together with the remaining vertical offset (`virtual_lines`)
+pub fn char_idx_at_visual_offset(
+    text: RopeSlice,
+    mut anchor: usize,
+    mut row_offset: isize,
+    column: usize,
+    text_fmt: &TextFormat,
+    annotations: &TextAnnotations,
+) -> (usize, usize) {
+    let mut pos = anchor;
+    // convert row relative to visual line containing anchor to row relative to a block containing anchor (anchor may change)
+    loop {
+        let (visual_pos_in_block, block_char_offset) =
+            visual_offset_from_block(text, anchor, pos, text_fmt, annotations);
+        row_offset += visual_pos_in_block.row as isize;
+        anchor = block_char_offset;
+        if row_offset >= 0 {
+            break;
+        }
+
+        if block_char_offset == 0 {
+            row_offset = 0;
+            break;
+        }
+        // the row_offset is negative so we need to look at the previous block
+        // set the anchor to the last char before the current block so that we can compute
+        // the distance of this block from the start of the previous block
+        pos = anchor;
+        anchor -= 1;
+    }
+
+    char_idx_at_visual_block_offset(
+        text,
+        anchor,
+        row_offset as usize,
+        column,
+        text_fmt,
+        annotations,
+    )
+}
+
+/// This function behaves the same as `char_idx_at_visual_offset`, except that
+/// the vertical offset `row` is always computed relative to the block that contains `anchor`
+/// instead of the visual line that contains `anchor`.
+/// Usually `char_idx_at_visual_offset` is more useful but this function can be
+/// used in some situations as an optimization when `visual_offset_from_block` was used
+///
+/// # Returns
+///
+/// `(real_char_idx, virtual_lines)`
+///
+/// See `char_idx_at_visual_offset` for details
+pub fn char_idx_at_visual_block_offset(
+    text: RopeSlice,
+    anchor: usize,
+    row: usize,
+    column: usize,
+    text_fmt: &TextFormat,
+    annotations: &TextAnnotations,
+) -> (usize, usize) {
+    let (formatter, mut char_idx) =
+        DocumentFormatter::new_at_prev_checkpoint(text, text_fmt, annotations, anchor);
+    let mut last_char_idx = char_idx;
+    let mut last_char_idx_on_line = None;
+    let mut last_row = 0;
+    for (grapheme, grapheme_pos) in formatter {
+        match grapheme_pos.row.cmp(&row) {
+            Ordering::Equal => {
+                if grapheme_pos.col + grapheme.width() > column {
+                    if !grapheme.is_virtual() {
+                        return (char_idx, 0);
+                    } else if let Some(char_idx) = last_char_idx_on_line {
+                        return (char_idx, 0);
+                    }
+                } else if !grapheme.is_virtual() {
+                    last_char_idx_on_line = Some(char_idx)
+                }
+            }
+            Ordering::Greater => return (last_char_idx, row - last_row),
+            _ => (),
+        }
+
+        last_char_idx = char_idx;
+        last_row = grapheme_pos.row;
+        char_idx += grapheme.doc_chars();
+    }
+
+    (char_idx, 0)
+}
+
 #[cfg(test)]
 mod test {
     use super::*;
@@ -228,6 +457,7 @@ fn test_coords_at_pos() {
     }
 
     #[test]
+    #[allow(deprecated)]
     fn test_visual_coords_at_pos() {
         let text = Rope::from("\n");
         let slice = text.slice(..);
@@ -275,6 +505,130 @@ fn test_visual_coords_at_pos() {
         assert_eq!(visual_coords_at_pos(slice, 2, 8), (0, 9).into());
     }
 
+    #[test]
+    fn test_visual_off_from_block() {
+        let text = Rope::from("\n");
+        let slice = text.slice(..);
+        let annot = TextAnnotations::default();
+        let text_fmt = TextFormat::default();
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 0, &text_fmt, &annot).0,
+            (0, 0).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 5, &text_fmt, &annot).0,
+            (0, 5).into()
+        ); // position on \n
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 6, &text_fmt, &annot).0,
+            (1, 0).into()
+        ); // position on w
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 7, &text_fmt, &annot).0,
+            (1, 1).into()
+        ); // position on o
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 10, &text_fmt, &annot).0,
+            (1, 4).into()
+        ); // position on d
+
+        // Test with wide characters.
+        let text = Rope::from("\n");
+        let slice = text.slice(..);
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 0, &text_fmt, &annot).0,
+            (0, 0).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 1, &text_fmt, &annot).0,
+            (0, 2).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 2, &text_fmt, &annot).0,
+            (0, 4).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 3, &text_fmt, &annot).0,
+            (0, 6).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 4, &text_fmt, &annot).0,
+            (0, 8).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 5, &text_fmt, &annot).0,
+            (0, 10).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 6, &text_fmt, &annot).0,
+            (1, 0).into()
+        );
+
+        // Test with grapheme clusters.
+        let text = Rope::from("aeo\r\n");
+        let slice = text.slice(..);
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 0, &text_fmt, &annot).0,
+            (0, 0).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 2, &text_fmt, &annot).0,
+            (0, 1).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 4, &text_fmt, &annot).0,
+            (0, 2).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 7, &text_fmt, &annot).0,
+            (0, 3).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 9, &text_fmt, &annot).0,
+            (1, 0).into()
+        );
+
+        // Test with wide-character grapheme clusters.
+        // TODO: account for cluster.
+        let text = Rope::from("\n");
+        let slice = text.slice(..);
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 0, &text_fmt, &annot).0,
+            (0, 0).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 2, &text_fmt, &annot).0,
+            (0, 2).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 3, &text_fmt, &annot).0,
+            (0, 3).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 5, &text_fmt, &annot).0,
+            (0, 5).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 6, &text_fmt, &annot).0,
+            (1, 0).into()
+        );
+
+        // Test with tabs.
+        let text = Rope::from("\tHello\n");
+        let slice = text.slice(..);
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 0, &text_fmt, &annot).0,
+            (0, 0).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 1, &text_fmt, &annot).0,
+            (0, 4).into()
+        );
+        assert_eq!(
+            visual_offset_from_block(slice, 0, 2, &text_fmt, &annot).0,
+            (0, 5).into()
+        );
+    }
     #[test]
     fn test_pos_at_coords() {
         let text = Rope::from("\n");
@@ -341,6 +695,7 @@ fn test_pos_at_coords() {
     }
 
     #[test]
+    #[allow(deprecated)]
     fn test_pos_at_visual_coords() {
         let text = Rope::from("\n");
         let slice = text.slice(..);
@@ -405,4 +760,100 @@ fn test_pos_at_visual_coords() {
         assert_eq!(pos_at_visual_coords(slice, (0, 10).into(), 4), 0);
         assert_eq!(pos_at_visual_coords(slice, (10, 10).into(), 4), 0);
     }
+
+    #[test]
+    fn test_char_idx_at_visual_row_offset() {
+        let text = Rope::from("\n\nfoo");
+        let slice = text.slice(..);
+        let mut text_fmt = TextFormat::default();
+        for i in 0isize..3isize {
+            for j in -2isize..=2isize {
+                if !(0..3).contains(&(i + j)) {
+                    continue;
+                }
+                println!("{i} {j}");
+                assert_eq!(
+                    char_idx_at_visual_offset(
+                        slice,
+                        slice.line_to_char(i as usize),
+                        j,
+                        3,
+                        &text_fmt,
+                        &TextAnnotations::default(),
+                    )
+                    .0,
+                    slice.line_to_char((i + j) as usize) + 3
+                );
+            }
+        }
+
+        text_fmt.soft_wrap = true;
+        let mut softwrapped_text = "foo ".repeat(10);
+        softwrapped_text.push('\n');
+        let last_char = softwrapped_text.len() - 1;
+
+        let text = Rope::from(softwrapped_text.repeat(3));
+        let slice = text.slice(..);
+        assert_eq!(
+            char_idx_at_visual_offset(
+                slice,
+                last_char,
+                0,
+                0,
+                &text_fmt,
+                &TextAnnotations::default(),
+            )
+            .0,
+            32
+        );
+        assert_eq!(
+            char_idx_at_visual_offset(
+                slice,
+                last_char,
+                -1,
+                0,
+                &text_fmt,
+                &TextAnnotations::default(),
+            )
+            .0,
+            16
+        );
+        assert_eq!(
+            char_idx_at_visual_offset(
+                slice,
+                last_char,
+                -2,
+                0,
+                &text_fmt,
+                &TextAnnotations::default(),
+            )
+            .0,
+            0
+        );
+        assert_eq!(
+            char_idx_at_visual_offset(
+                slice,
+                softwrapped_text.len() + last_char,
+                -2,
+                0,
+                &text_fmt,
+                &TextAnnotations::default(),
+            )
+            .0,
+            softwrapped_text.len()
+        );
+
+        assert_eq!(
+            char_idx_at_visual_offset(
+                slice,
+                softwrapped_text.len() + last_char,
+                -5,
+                0,
+                &text_fmt,
+                &TextAnnotations::default(),
+            )
+            .0,
+            0
+        );
+    }
 }
diff --git a/helix-core/src/selection.rs b/helix-core/src/selection.rs
index 1f28ecefb..259b131a4 100644
--- a/helix-core/src/selection.rs
+++ b/helix-core/src/selection.rs
@@ -21,14 +21,14 @@
 /// can be in any order, or even share the same position.
 ///
 /// The anchor and head positions use gap indexing, meaning
-/// that their indices represent the the gaps *between* `char`s
+/// that their indices represent the gaps *between* `char`s
 /// rather than the `char`s themselves. For example, 1
 /// represents the position between the first and second `char`.
 ///
-/// Below are some example `Range` configurations to better
-/// illustrate.  The anchor and head indices are show as
-/// "(anchor, head)", followed by example text with "[" and "]"
-/// inserted to represent the anchor and head positions:
+/// Below are some examples of `Range` configurations.
+/// The anchor and head indices are shown as "(anchor, head)"
+/// tuples, followed by example text with "[" and "]" symbols
+/// representing the anchor and head positions:
 ///
 /// - (0, 3): `[Som]e text`.
 /// - (3, 0): `]Som[e text`.
@@ -38,7 +38,7 @@
 /// Ranges are considered to be inclusive on the left and
 /// exclusive on the right, regardless of anchor-head ordering.
 /// This means, for example, that non-zero-width ranges that
-/// are directly adjecent, sharing an edge, do not overlap.
+/// are directly adjacent, sharing an edge, do not overlap.
 /// However, a zero-width range will overlap with the shared
 /// left-edge of another range.
 ///
@@ -53,7 +53,9 @@ pub struct Range {
     pub anchor: usize,
     /// The head of the range, moved when extending.
     pub head: usize,
-    pub horiz: Option<u32>,
+    /// The previous visual offset (softwrapped lines and columns) from
+    /// the start of the line
+    pub old_visual_position: Option<(u32, u32)>,
 }
 
 impl Range {
@@ -61,7 +63,7 @@ pub fn new(anchor: usize, head: usize) -> Self {
         Self {
             anchor,
             head,
-            horiz: None,
+            old_visual_position: None,
         }
     }
 
@@ -127,7 +129,7 @@ pub fn flip(&self) -> Self {
         Self {
             anchor: self.head,
             head: self.anchor,
-            horiz: self.horiz,
+            old_visual_position: self.old_visual_position,
         }
     }
 
@@ -185,7 +187,7 @@ pub fn map(self, changes: &ChangeSet) -> Self {
         Self {
             anchor,
             head,
-            horiz: None,
+            old_visual_position: None,
         }
     }
 
@@ -198,13 +200,13 @@ pub fn extend(&self, from: usize, to: usize) -> Self {
             Self {
                 anchor: self.anchor.min(from),
                 head: self.head.max(to),
-                horiz: None,
+                old_visual_position: None,
             }
         } else {
             Self {
                 anchor: self.anchor.max(to),
                 head: self.head.min(from),
-                horiz: None,
+                old_visual_position: None,
             }
         }
     }
@@ -219,13 +221,13 @@ pub fn merge(&self, other: Self) -> Self {
             Range {
                 anchor: self.anchor.max(other.anchor),
                 head: self.head.min(other.head),
-                horiz: None,
+                old_visual_position: None,
             }
         } else {
             Range {
                 anchor: self.from().min(other.from()),
                 head: self.to().max(other.to()),
-                horiz: None,
+                old_visual_position: None,
             }
         }
     }
@@ -279,8 +281,8 @@ pub fn grapheme_aligned(&self, slice: RopeSlice) -> Self {
         Range {
             anchor: new_anchor,
             head: new_head,
-            horiz: if new_anchor == self.anchor {
-                self.horiz
+            old_visual_position: if new_anchor == self.anchor {
+                self.old_visual_position
             } else {
                 None
             },
@@ -306,7 +308,7 @@ pub fn min_width_1(&self, slice: RopeSlice) -> Self {
             Range {
                 anchor: self.anchor,
                 head: next_grapheme_boundary(slice, self.head),
-                horiz: self.horiz,
+                old_visual_position: self.old_visual_position,
             }
         } else {
             *self
@@ -378,7 +380,7 @@ fn from((anchor, head): (usize, usize)) -> Self {
         Self {
             anchor,
             head,
-            horiz: None,
+            old_visual_position: None,
         }
     }
 }
@@ -482,7 +484,7 @@ pub fn single(anchor: usize, head: usize) -> Self {
             ranges: smallvec![Range {
                 anchor,
                 head,
-                horiz: None
+                old_visual_position: None
             }],
             primary_index: 0,
         }
@@ -495,28 +497,53 @@ pub fn point(pos: usize) -> Self {
 
     /// Normalizes a `Selection`.
     fn normalize(mut self) -> Self {
-        let primary = self.ranges[self.primary_index];
+        let mut primary = self.ranges[self.primary_index];
         self.ranges.sort_unstable_by_key(Range::from);
+
+        self.ranges.dedup_by(|curr_range, prev_range| {
+            if prev_range.overlaps(curr_range) {
+                let new_range = curr_range.merge(*prev_range);
+                if prev_range == &primary || curr_range == &primary {
+                    primary = new_range;
+                }
+                *prev_range = new_range;
+                true
+            } else {
+                false
+            }
+        });
+
         self.primary_index = self
             .ranges
             .iter()
             .position(|&range| range == primary)
             .unwrap();
 
-        let mut prev_i = 0;
-        for i in 1..self.ranges.len() {
-            if self.ranges[prev_i].overlaps(&self.ranges[i]) {
-                self.ranges[prev_i] = self.ranges[prev_i].merge(self.ranges[i]);
+        self
+    }
+
+    // Merges all ranges that are consecutive
+    pub fn merge_consecutive_ranges(mut self) -> Self {
+        let mut primary = self.ranges[self.primary_index];
+
+        self.ranges.dedup_by(|curr_range, prev_range| {
+            if prev_range.to() == curr_range.from() {
+                let new_range = curr_range.merge(*prev_range);
+                if prev_range == &primary || curr_range == &primary {
+                    primary = new_range;
+                }
+                *prev_range = new_range;
+                true
             } else {
-                prev_i += 1;
-                self.ranges[prev_i] = self.ranges[i];
-            }
-            if i == self.primary_index {
-                self.primary_index = prev_i;
+                false
             }
-        }
+        });
 
-        self.ranges.truncate(prev_i + 1);
+        self.primary_index = self
+            .ranges
+            .iter()
+            .position(|&range| range == primary)
+            .unwrap();
 
         self
     }
@@ -541,9 +568,9 @@ fn normalize(mut self) -> Self {
     }
 
     /// Takes a closure and maps each `Range` over the closure.
-    pub fn transform<F>(mut self, f: F) -> Self
+    pub fn transform<F>(mut self, mut f: F) -> Self
     where
-        F: Fn(Range) -> Range,
+        F: FnMut(Range) -> Range,
     {
         for range in self.ranges.iter_mut() {
             *range = f(*range)
@@ -551,6 +578,16 @@ pub fn transform<F>(mut self, f: F) -> Self
         self.normalize()
     }
 
+    /// Takes a closure and maps each `Range` over the closure to multiple `Range`s.
+    pub fn transform_iter<F, I>(mut self, f: F) -> Self
+    where
+        F: FnMut(Range) -> I,
+        I: Iterator<Item = Range>,
+    {
+        self.ranges = self.ranges.into_iter().flat_map(f).collect();
+        self.normalize()
+    }
+
     // Ensures the selection adheres to the following invariants:
     // 1. All ranges are grapheme aligned.
     // 2. All ranges are at least 1 character wide, unless at the
@@ -588,11 +625,6 @@ pub fn len(&self) -> usize {
 
     // returns true if self  other
     pub fn contains(&self, other: &Selection) -> bool {
-        // can't contain other if it is larger
-        if other.len() > self.len() {
-            return false;
-        }
-
         let (mut iter_self, mut iter_other) = (self.iter(), other.iter());
         let (mut ele_self, mut ele_other) = (iter_self.next(), iter_other.next());
 
@@ -629,6 +661,15 @@ fn into_iter(self) -> std::slice::Iter<'a, Range> {
     }
 }
 
+impl IntoIterator for Selection {
+    type Item = Range;
+    type IntoIter = smallvec::IntoIter<[Range; 1]>;
+
+    fn into_iter(self) -> smallvec::IntoIter<[Range; 1]> {
+        self.ranges.into_iter()
+    }
+}
+
 // TODO: checkSelection -> check if valid for doc length && sorted
 
 pub fn keep_or_remove_matches(
@@ -1132,6 +1173,52 @@ fn test_split_on_matches() {
             &["", "abcd", "efg", "rs", "xyz"]
         );
     }
+
+    #[test]
+    fn test_merge_consecutive_ranges() {
+        let selection = Selection::new(
+            smallvec![
+                Range::new(0, 1),
+                Range::new(1, 10),
+                Range::new(15, 20),
+                Range::new(25, 26),
+                Range::new(26, 30)
+            ],
+            4,
+        );
+
+        let result = selection.merge_consecutive_ranges();
+
+        assert_eq!(
+            result.ranges(),
+            &[Range::new(0, 10), Range::new(15, 20), Range::new(25, 30)]
+        );
+        assert_eq!(result.primary_index, 2);
+
+        let selection = Selection::new(smallvec![Range::new(0, 1)], 0);
+        let result = selection.merge_consecutive_ranges();
+
+        assert_eq!(result.ranges(), &[Range::new(0, 1)]);
+        assert_eq!(result.primary_index, 0);
+
+        let selection = Selection::new(
+            smallvec![
+                Range::new(0, 1),
+                Range::new(1, 5),
+                Range::new(5, 8),
+                Range::new(8, 10),
+                Range::new(10, 15),
+                Range::new(18, 25)
+            ],
+            3,
+        );
+
+        let result = selection.merge_consecutive_ranges();
+
+        assert_eq!(result.ranges(), &[Range::new(0, 15), Range::new(18, 25)]);
+        assert_eq!(result.primary_index, 0);
+    }
+
     #[test]
     fn test_selection_contains() {
         fn contains(a: Vec<(usize, usize)>, b: Vec<(usize, usize)>) -> bool {
@@ -1157,5 +1244,11 @@ fn contains(a: Vec<(usize, usize)>, b: Vec<(usize, usize)>) -> bool {
             vec!((3, 4), (7, 9))
         ));
         assert!(!contains(vec!((1, 1), (5, 6)), vec!((1, 6))));
+
+        // multiple ranges of other are all contained in some ranges of self,
+        assert!(contains(
+            vec!((1, 4), (7, 10)),
+            vec!((1, 2), (3, 4), (7, 9))
+        ));
     }
 }
diff --git a/helix-core/src/shellwords.rs b/helix-core/src/shellwords.rs
index 9475f5e50..9d873c366 100644
--- a/helix-core/src/shellwords.rs
+++ b/helix-core/src/shellwords.rs
@@ -129,8 +129,9 @@ fn from(input: &'a str) -> Self {
                 DquoteEscaped => Dquoted,
             };
 
-            if i >= input.len() - 1 && end == 0 {
-                end = i + 1;
+            let c_len = c.len_utf8();
+            if i == input.len() - c_len && end == 0 {
+                end = i + c_len;
             }
 
             if end > 0 {
@@ -293,14 +294,14 @@ fn test_mixed() {
     #[test]
     fn test_lists() {
         let input =
-            r#":set statusline.center ["file-type","file-encoding"] '["list", "in", "qoutes"]'"#;
+            r#":set statusline.center ["file-type","file-encoding"] '["list", "in", "quotes"]'"#;
         let shellwords = Shellwords::from(input);
         let result = shellwords.words().to_vec();
         let expected = vec![
             Cow::from(":set"),
             Cow::from("statusline.center"),
             Cow::from(r#"["file-type","file-encoding"]"#),
-            Cow::from(r#"["list", "in", "qoutes"]"#),
+            Cow::from(r#"["list", "in", "quotes"]"#),
         ];
         assert_eq!(expected, result);
     }
@@ -333,4 +334,17 @@ fn test_parts() {
         assert_eq!(Shellwords::from(":o a").parts(), &[":o", "a"]);
         assert_eq!(Shellwords::from(":o a\\ ").parts(), &[":o", "a\\"]);
     }
+
+    #[test]
+    fn test_multibyte_at_end() {
+        assert_eq!(Shellwords::from("").parts(), &[""]);
+        assert_eq!(
+            Shellwords::from(":sh echo ").parts(),
+            &[":sh", "echo", ""]
+        );
+        assert_eq!(
+            Shellwords::from(":sh echo  hello world").parts(),
+            &[":sh", "echo", "", "hello", "world"]
+        );
+    }
 }
diff --git a/helix-core/src/surround.rs b/helix-core/src/surround.rs
index a3de3cd17..f430aee8a 100644
--- a/helix-core/src/surround.rs
+++ b/helix-core/src/surround.rs
@@ -1,6 +1,6 @@
 use std::fmt::Display;
 
-use crate::{search, Range, Selection};
+use crate::{movement::Direction, search, Range, Selection};
 use ropey::RopeSlice;
 
 pub const PAIRS: &[(char, char)] = &[
@@ -55,15 +55,18 @@ pub fn get_pair(ch: char) -> (char, char) {
 pub fn find_nth_closest_pairs_pos(
     text: RopeSlice,
     range: Range,
-    n: usize,
+    mut skip: usize,
 ) -> Result<(usize, usize)> {
     let is_open_pair = |ch| PAIRS.iter().any(|(open, _)| *open == ch);
     let is_close_pair = |ch| PAIRS.iter().any(|(_, close)| *close == ch);
 
     let mut stack = Vec::with_capacity(2);
-    let pos = range.cursor(text);
+    let pos = range.from();
+    let mut close_pos = pos.saturating_sub(1);
 
     for ch in text.chars_at(pos) {
+        close_pos += 1;
+
         if is_open_pair(ch) {
             // Track open pairs encountered so that we can step over
             // the corresponding close pairs that will come up further
@@ -71,20 +74,46 @@ pub fn find_nth_closest_pairs_pos(
             // open pair is before the cursor position.
             stack.push(ch);
             continue;
-        } else if is_close_pair(ch) {
-            let (open, _) = get_pair(ch);
-            if stack.last() == Some(&open) {
-                stack.pop();
-                continue;
-            } else {
-                // In the ideal case the stack would be empty here and the
-                // current character would be the close pair that we are
-                // looking for. It could also be the case that the pairs
-                // are unbalanced and we encounter a close pair that doesn't
-                // close the last seen open pair. In either case use this
-                // char as the auto-detected closest pair.
-                return find_nth_pairs_pos(text, ch, range, n);
+        }
+
+        if !is_close_pair(ch) {
+            // We don't care if this character isn't a brace pair item,
+            // so short circuit here.
+            continue;
+        }
+
+        let (open, close) = get_pair(ch);
+
+        if stack.last() == Some(&open) {
+            // If we are encountering the closing pair for an opener
+            // we just found while traversing, then its inside the
+            // selection and should be skipped over.
+            stack.pop();
+            continue;
+        }
+
+        match find_nth_open_pair(text, open, close, close_pos, 1) {
+            // Before we accept this pair, we want to ensure that the
+            // pair encloses the range rather than just the cursor.
+            Some(open_pos)
+                if open_pos <= pos.saturating_add(1)
+                    && close_pos >= range.to().saturating_sub(1) =>
+            {
+                // Since we have special conditions for when to
+                // accept, we can't just pass the skip parameter on
+                // through to the find_nth_*_pair methods, so we
+                // track skips manually here.
+                if skip > 1 {
+                    skip -= 1;
+                    continue;
+                }
+
+                return match range.direction() {
+                    Direction::Forward => Ok((open_pos, close_pos)),
+                    Direction::Backward => Ok((close_pos, open_pos)),
+                };
             }
+            _ => continue,
         }
     }
 
@@ -244,141 +273,140 @@ mod test {
     use ropey::Rope;
     use smallvec::SmallVec;
 
-    #[allow(clippy::type_complexity)]
-    fn check_find_nth_pair_pos(
-        text: &str,
-        cases: Vec<(usize, char, usize, Result<(usize, usize)>)>,
-    ) {
-        let doc = Rope::from(text);
-        let slice = doc.slice(..);
-
-        for (cursor_pos, ch, n, expected_range) in cases {
-            let range = find_nth_pairs_pos(slice, ch, (cursor_pos, cursor_pos + 1).into(), n);
-            assert_eq!(
-                range, expected_range,
-                "Expected {:?}, got {:?}",
-                expected_range, range
+    #[test]
+    fn test_get_surround_pos() {
+        #[rustfmt::skip]
+        let (doc, selection, expectations) =
+            rope_with_selections_and_expectations(
+                "(some) (chars)\n(newline)",
+                "_ ^  _ _ ^   _\n_    ^  _"
             );
-        }
+
+        assert_eq!(
+            get_surround_pos(doc.slice(..), &selection, Some('('), 1).unwrap(),
+            expectations
+        );
     }
 
     #[test]
-    fn test_find_nth_pairs_pos() {
-        check_find_nth_pair_pos(
-            "some (text) here",
-            vec![
-                // cursor on [t]ext
-                (6, '(', 1, Ok((5, 10))),
-                (6, ')', 1, Ok((5, 10))),
-                // cursor on so[m]e
-                (2, '(', 1, Err(Error::PairNotFound)),
-                // cursor on bracket itself
-                (5, '(', 1, Ok((5, 10))),
-                (10, '(', 1, Ok((5, 10))),
-            ],
+    fn test_get_surround_pos_bail_different_surround_chars() {
+        #[rustfmt::skip]
+        let (doc, selection, _) =
+            rope_with_selections_and_expectations(
+                "[some]\n(chars)xx\n(newline)",
+                "  ^   \n  ^      \n         "
+            );
+
+        assert_eq!(
+            get_surround_pos(doc.slice(..), &selection, Some('('), 1),
+            Err(Error::PairNotFound)
         );
     }
 
     #[test]
-    fn test_find_nth_pairs_pos_skip() {
-        check_find_nth_pair_pos(
-            "(so (many (good) text) here)",
-            vec![
-                // cursor on go[o]d
-                (13, '(', 1, Ok((10, 15))),
-                (13, '(', 2, Ok((4, 21))),
-                (13, '(', 3, Ok((0, 27))),
-            ],
+    fn test_get_surround_pos_bail_overlapping_surround_chars() {
+        #[rustfmt::skip]
+        let (doc, selection, _) =
+            rope_with_selections_and_expectations(
+                "[some]\n(chars)xx\n(newline)",
+                "      \n       ^ \n      ^  "
+            );
+
+        assert_eq!(
+            get_surround_pos(doc.slice(..), &selection, Some('('), 1),
+            Err(Error::PairNotFound) // overlapping surround chars
         );
     }
 
     #[test]
-    fn test_find_nth_pairs_pos_same() {
-        check_find_nth_pair_pos(
-            "'so 'many 'good' text' here'",
-            vec![
-                // cursor on go[o]d
-                (13, '\'', 1, Ok((10, 15))),
-                (13, '\'', 2, Ok((4, 21))),
-                (13, '\'', 3, Ok((0, 27))),
-                // cursor on the quotes
-                (10, '\'', 1, Err(Error::CursorOnAmbiguousPair)),
-            ],
-        )
+    fn test_get_surround_pos_bail_cursor_overlap() {
+        #[rustfmt::skip]
+        let (doc, selection, _) =
+            rope_with_selections_and_expectations(
+                "[some]\n(chars)xx\n(newline)",
+                "  ^^  \n         \n         "
+            );
+
+        assert_eq!(
+            get_surround_pos(doc.slice(..), &selection, Some('['), 1),
+            Err(Error::CursorOverlap)
+        );
     }
 
     #[test]
-    fn test_find_nth_pairs_pos_step() {
-        check_find_nth_pair_pos(
-            "((so)((many) good (text))(here))",
-            vec![
-                // cursor on go[o]d
-                (15, '(', 1, Ok((5, 24))),
-                (15, '(', 2, Ok((0, 31))),
-            ],
+    fn test_find_nth_pairs_pos_quote_success() {
+        #[rustfmt::skip]
+        let (doc, selection, expectations) =
+            rope_with_selections_and_expectations(
+                "some 'quoted text' on this 'line'\n'and this one'",
+                "     _        ^  _               \n              "
+            );
+
+        assert_eq!(2, expectations.len());
+        assert_eq!(
+            find_nth_pairs_pos(doc.slice(..), '\'', selection.primary(), 1)
+                .expect("find should succeed"),
+            (expectations[0], expectations[1])
         )
     }
 
     #[test]
-    fn test_find_nth_pairs_pos_mixed() {
-        check_find_nth_pair_pos(
-            "(so [many {good} text] here)",
-            vec![
-                // cursor on go[o]d
-                (13, '{', 1, Ok((10, 15))),
-                (13, '[', 1, Ok((4, 21))),
-                (13, '(', 1, Ok((0, 27))),
-            ],
+    fn test_find_nth_pairs_pos_nested_quote_success() {
+        #[rustfmt::skip]
+        let (doc, selection, expectations) =
+            rope_with_selections_and_expectations(
+                "some 'nested 'quoted' text' on this 'line'\n'and this one'",
+                "     _           ^        _               \n              "
+            );
+
+        assert_eq!(2, expectations.len());
+        assert_eq!(
+            find_nth_pairs_pos(doc.slice(..), '\'', selection.primary(), 2)
+                .expect("find should succeed"),
+            (expectations[0], expectations[1])
         )
     }
 
     #[test]
-    fn test_get_surround_pos() {
-        let doc = Rope::from("(some) (chars)\n(newline)");
-        let slice = doc.slice(..);
-        let selection = Selection::new(
-            SmallVec::from_slice(&[Range::point(2), Range::point(9), Range::point(20)]),
-            0,
-        );
+    fn test_find_nth_pairs_pos_inside_quote_ambiguous() {
+        #[rustfmt::skip]
+        let (doc, selection, _) =
+            rope_with_selections_and_expectations(
+                "some 'nested 'quoted' text' on this 'line'\n'and this one'",
+                "                    ^                     \n              "
+            );
 
-        // cursor on s[o]me, c[h]ars, newl[i]ne
         assert_eq!(
-            get_surround_pos(slice, &selection, Some('('), 1)
-                .unwrap()
-                .as_slice(),
-            &[0, 5, 7, 13, 15, 23]
-        );
+            find_nth_pairs_pos(doc.slice(..), '\'', selection.primary(), 1),
+            Err(Error::CursorOnAmbiguousPair)
+        )
     }
 
-    #[test]
-    fn test_get_surround_pos_bail() {
-        let doc = Rope::from("[some]\n(chars)xx\n(newline)");
-        let slice = doc.slice(..);
+    // Create a Rope and a matching Selection using a specification language.
+    // ^ is a single-point selection.
+    // _ is an expected index. These are returned as a Vec<usize> for use in assertions.
+    fn rope_with_selections_and_expectations(
+        text: &str,
+        spec: &str,
+    ) -> (Rope, Selection, Vec<usize>) {
+        if text.len() != spec.len() {
+            panic!("specification must match text length -- are newlines aligned?");
+        }
 
-        let selection =
-            Selection::new(SmallVec::from_slice(&[Range::point(2), Range::point(9)]), 0);
-        // cursor on s[o]me, c[h]ars
-        assert_eq!(
-            get_surround_pos(slice, &selection, Some('('), 1),
-            Err(Error::PairNotFound) // different surround chars
-        );
+        let rope = Rope::from(text);
 
-        let selection = Selection::new(
-            SmallVec::from_slice(&[Range::point(14), Range::point(24)]),
-            0,
-        );
-        // cursor on [x]x, newli[n]e
-        assert_eq!(
-            get_surround_pos(slice, &selection, Some('('), 1),
-            Err(Error::PairNotFound) // overlapping surround chars
-        );
+        let selections: SmallVec<[Range; 1]> = spec
+            .match_indices('^')
+            .into_iter()
+            .map(|(i, _)| Range::point(i))
+            .collect();
 
-        let selection =
-            Selection::new(SmallVec::from_slice(&[Range::point(2), Range::point(3)]), 0);
-        // cursor on s[o][m]e
-        assert_eq!(
-            get_surround_pos(slice, &selection, Some('['), 1),
-            Err(Error::CursorOverlap)
-        );
+        let expectations: Vec<usize> = spec
+            .match_indices('_')
+            .into_iter()
+            .map(|(i, _)| i)
+            .collect();
+
+        (rope, Selection::new(selections, 0), expectations)
     }
 }
diff --git a/helix-core/src/syntax.rs b/helix-core/src/syntax.rs
index 41ab23e13..c34ea81a3 100644
--- a/helix-core/src/syntax.rs
+++ b/helix-core/src/syntax.rs
@@ -20,7 +20,7 @@
     fmt,
     hash::{Hash, Hasher},
     mem::{replace, transmute},
-    path::Path,
+    path::{Path, PathBuf},
     str::FromStr,
     sync::Arc,
 };
@@ -82,7 +82,8 @@ pub struct LanguageConfiguration {
     pub shebangs: Vec<String>, // interpreter(s) associated with language
     pub roots: Vec<String>,        // these indicate project roots <.git, Cargo.toml>
     pub comment_token: Option<String>,
-    pub max_line_length: Option<usize>,
+    pub text_width: Option<usize>,
+    pub soft_wrap: Option<SoftWrap>,
 
     #[serde(default, skip_serializing, deserialize_with = "deserialize_lsp_config")]
     pub config: Option<serde_json::Value>,
@@ -126,6 +127,10 @@ pub struct LanguageConfiguration {
     pub auto_pairs: Option<AutoPairs>,
 
     pub rulers: Option<Vec<u16>>, // if set, override editor's rulers
+
+    /// Hardcoded LSP root directories relative to the workspace root, like `examples` or `tools/fuzz`.
+    /// Falling back to the current working directory if none are configured.
+    pub workspace_lsp_roots: Option<Vec<PathBuf>>,
 }
 
 #[derive(Debug, PartialEq, Eq, Hash)]
@@ -427,7 +432,7 @@ pub fn capture_nodes_any<'a>(
                 let nodes: Vec<_> = mat
                     .captures
                     .iter()
-                    .filter_map(|cap| (cap.index == capture_idx).then(|| cap.node))
+                    .filter_map(|cap| (cap.index == capture_idx).then_some(cap.node))
                     .collect();
 
                 if nodes.len() > 1 {
@@ -546,6 +551,35 @@ fn load_query(&self, kind: &str) -> Option<Query> {
             .ok()
     }
 }
+#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
+#[serde(default, rename_all = "kebab-case", deny_unknown_fields)]
+pub struct SoftWrap {
+    /// Soft wrap lines that exceed viewport width. Default to off
+    // NOTE: Option on purpose because the struct is shared between language config and global config.
+    // By default the option is None so that the language config falls back to the global config unless explicitly set.
+    pub enable: Option<bool>,
+    /// Maximum space left free at the end of the line.
+    /// This space is used to wrap text at word boundaries. If that is not possible within this limit
+    /// the word is simply split at the end of the line.
+    ///
+    /// This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+    ///
+    /// Default to 20
+    pub max_wrap: Option<u16>,
+    /// Maximum number of indentation that can be carried over from the previous line when softwrapping.
+    /// If a line is indented further then this limit it is rendered at the start of the viewport instead.
+    ///
+    /// This is automatically hard-limited to a quarter of the viewport to ensure correct display on small views.
+    ///
+    /// Default to 40
+    pub max_indent_retain: Option<u16>,
+    /// Indicator placed at the beginning of softwrapped lines
+    ///
+    /// Defaults to 
+    pub wrap_indicator: Option<String>,
+    /// Softwrap at `text_width` instead of viewport width if it is shorter
+    pub wrap_at_text_width: Option<bool>,
+}
 
 // Expose loader as Lazy<> global since it's always static?
 
@@ -1092,21 +1126,14 @@ pub fn highlight_iter<'a>(
                     }],
                     cursor,
                     _tree: None,
-                    captures,
+                    captures: RefCell::new(captures),
                     config: layer.config.as_ref(), // TODO: just reuse `layer`
                     depth: layer.depth,            // TODO: just reuse `layer`
-                    ranges: &layer.ranges,         // TODO: temp
                 })
             })
             .collect::<Vec<_>>();
 
-        // HAXX: arrange layers by byte range, with deeper layers positioned first
-        layers.sort_by_key(|layer| {
-            (
-                layer.ranges.first().cloned(),
-                std::cmp::Reverse(layer.depth),
-            )
-        });
+        layers.sort_unstable_by_key(|layer| layer.sort_key());
 
         let mut result = HighlightIter {
             source,
@@ -1136,6 +1163,7 @@ pub fn highlight_iter<'a>(
 bitflags! {
     /// Flags that track the status of a layer
     /// in the `Sytaxn::update` function
+    #[derive(Debug)]
     struct LayerUpdateFlags : u32{
         const MODIFIED = 0b001;
         const MOVED = 0b010;
@@ -1424,12 +1452,11 @@ fn text(&mut self, node: Node) -> Self::I {
 struct HighlightIterLayer<'a> {
     _tree: Option<Tree>,
     cursor: QueryCursor,
-    captures: iter::Peekable<QueryCaptures<'a, 'a, RopeProvider<'a>>>,
+    captures: RefCell<iter::Peekable<QueryCaptures<'a, 'a, RopeProvider<'a>>>>,
     config: &'a HighlightConfiguration,
     highlight_end_stack: Vec<usize>,
     scope_stack: Vec<LocalScope<'a>>,
     depth: u32,
-    ranges: &'a [Range],
 }
 
 impl<'a> fmt::Debug for HighlightIterLayer<'a> {
@@ -1610,10 +1637,11 @@ impl<'a> HighlightIterLayer<'a> {
     // First, sort scope boundaries by their byte offset in the document. At a
     // given position, emit scope endings before scope beginnings. Finally, emit
     // scope boundaries from deeper layers first.
-    fn sort_key(&mut self) -> Option<(usize, bool, isize)> {
+    fn sort_key(&self) -> Option<(usize, bool, isize)> {
         let depth = -(self.depth as isize);
         let next_start = self
             .captures
+            .borrow_mut()
             .peek()
             .map(|(m, i)| m.captures[*i].node.start_byte());
         let next_end = self.highlight_end_stack.last().cloned();
@@ -1838,7 +1866,8 @@ fn next(&mut self) -> Option<Self::Item> {
             // Get the next capture from whichever layer has the earliest highlight boundary.
             let range;
             let layer = &mut self.layers[0];
-            if let Some((next_match, capture_index)) = layer.captures.peek() {
+            let captures = layer.captures.get_mut();
+            if let Some((next_match, capture_index)) = captures.peek() {
                 let next_capture = next_match.captures[*capture_index];
                 range = next_capture.node.byte_range();
 
@@ -1861,7 +1890,7 @@ fn next(&mut self) -> Option<Self::Item> {
                 return self.emit_event(self.source.len_bytes(), None);
             };
 
-            let (mut match_, capture_index) = layer.captures.next().unwrap();
+            let (mut match_, capture_index) = captures.next().unwrap();
             let mut capture = match_.captures[capture_index];
 
             // Remove from the local scope stack any local scopes that have already ended.
@@ -1937,11 +1966,11 @@ fn next(&mut self) -> Option<Self::Item> {
                 }
 
                 // Continue processing any additional matches for the same node.
-                if let Some((next_match, next_capture_index)) = layer.captures.peek() {
+                if let Some((next_match, next_capture_index)) = captures.peek() {
                     let next_capture = next_match.captures[*next_capture_index];
                     if next_capture.node == capture.node {
                         capture = next_capture;
-                        match_ = layer.captures.next().unwrap().0;
+                        match_ = captures.next().unwrap().0;
                         continue;
                     }
                 }
@@ -1964,11 +1993,11 @@ fn next(&mut self) -> Option<Self::Item> {
             // highlighting patterns that are disabled for local variables.
             if definition_highlight.is_some() || reference_highlight.is_some() {
                 while layer.config.non_local_variable_patterns[match_.pattern_index] {
-                    if let Some((next_match, next_capture_index)) = layer.captures.peek() {
+                    if let Some((next_match, next_capture_index)) = captures.peek() {
                         let next_capture = next_match.captures[*next_capture_index];
                         if next_capture.node == capture.node {
                             capture = next_capture;
-                            match_ = layer.captures.next().unwrap().0;
+                            match_ = captures.next().unwrap().0;
                             continue;
                         }
                     }
@@ -1983,10 +2012,10 @@ fn next(&mut self) -> Option<Self::Item> {
             // for a given node are ordered by pattern index, so these subsequent
             // captures are guaranteed to be for highlighting, not injections or
             // local variables.
-            while let Some((next_match, next_capture_index)) = layer.captures.peek() {
+            while let Some((next_match, next_capture_index)) = captures.peek() {
                 let next_capture = next_match.captures[*next_capture_index];
                 if next_capture.node == capture.node {
-                    layer.captures.next();
+                    captures.next();
                 } else {
                     break;
                 }
diff --git a/helix-core/src/test.rs b/helix-core/src/test.rs
index 17523ed76..7183302c6 100644
--- a/helix-core/src/test.rs
+++ b/helix-core/src/test.rs
@@ -1,7 +1,9 @@
 //! Test helpers.
 use crate::{Range, Selection};
+use ropey::Rope;
 use smallvec::SmallVec;
 use std::cmp::Reverse;
+use unicode_segmentation::UnicodeSegmentation;
 
 /// Convert annotated test string to test string and selection.
 ///
@@ -10,6 +12,10 @@
 /// `#[` for primary selection with head after anchor followed by `|]#`.
 /// `#(` for secondary selection with head after anchor followed by `|)#`.
 ///
+/// If the selection contains any LF or CRLF sequences, which are immediately
+/// followed by the same grapheme, then the subsequent one is removed. This is
+/// to allow representing having the cursor over the end of the line.
+///
 /// # Examples
 ///
 /// ```
@@ -30,23 +36,23 @@
 pub fn print(s: &str) -> (String, Selection) {
     let mut primary_idx = None;
     let mut ranges = SmallVec::new();
-    let mut iter = s.chars().peekable();
+    let mut iter = UnicodeSegmentation::graphemes(s, true).peekable();
     let mut left = String::with_capacity(s.len());
 
     'outer: while let Some(c) = iter.next() {
         let start = left.chars().count();
 
-        if c != '#' {
-            left.push(c);
+        if c != "#" {
+            left.push_str(c);
             continue;
         }
 
         let (is_primary, close_pair) = match iter.next() {
-            Some('[') => (true, ']'),
-            Some('(') => (false, ')'),
+            Some("[") => (true, "]"),
+            Some("(") => (false, ")"),
             Some(ch) => {
                 left.push('#');
-                left.push(ch);
+                left.push_str(ch);
                 continue;
             }
             None => break,
@@ -56,24 +62,45 @@ pub fn print(s: &str) -> (String, Selection) {
             panic!("primary `#[` already appeared {:?} {:?}", left, s);
         }
 
-        let head_at_beg = iter.next_if_eq(&'|').is_some();
+        let head_at_beg = iter.next_if_eq(&"|").is_some();
+        let last_grapheme = |s: &str| {
+            UnicodeSegmentation::graphemes(s, true)
+                .last()
+                .map(String::from)
+        };
 
         while let Some(c) = iter.next() {
-            if !(c == close_pair && iter.peek() == Some(&'#')) {
-                left.push(c);
+            let next = iter.peek();
+            let mut prev = last_grapheme(left.as_str());
+
+            if !(c == close_pair && next == Some(&"#")) {
+                left.push_str(c);
                 continue;
             }
 
             if !head_at_beg {
-                let prev = left.pop().unwrap();
-                if prev != '|' {
-                    left.push(prev);
-                    left.push(c);
-                    continue;
+                match &prev {
+                    Some(p) if p != "|" => {
+                        left.push_str(c);
+                        continue;
+                    }
+                    Some(p) if p == "|" => {
+                        left.pop().unwrap(); // pop the |
+                        prev = last_grapheme(left.as_str());
+                    }
+                    _ => (),
                 }
             }
 
             iter.next(); // skip "#"
+            let next = iter.peek();
+
+            // skip explicit line end inside selection
+            if (prev == Some(String::from("\r\n")) || prev == Some(String::from("\n")))
+                && next.map(|n| String::from(*n)) == prev
+            {
+                iter.next();
+            }
 
             if is_primary {
                 primary_idx = Some(ranges.len());
@@ -118,14 +145,16 @@ pub fn print(s: &str) -> (String, Selection) {
 /// use smallvec::smallvec;
 ///
 /// assert_eq!(
-///     plain("abc", Selection::new(smallvec![Range::new(0, 1), Range::new(3, 2)], 0)),
+///     plain("abc", &Selection::new(smallvec![Range::new(0, 1), Range::new(3, 2)], 0)),
 ///     "#[a|]#b#(|c)#".to_owned()
 /// );
 /// ```
-pub fn plain(s: &str, selection: Selection) -> String {
+pub fn plain<R: Into<Rope>>(s: R, selection: &Selection) -> String {
+    let s = s.into();
     let primary = selection.primary_index();
-    let mut out = String::with_capacity(s.len() + 5 * selection.len());
-    out.push_str(s);
+    let mut out = String::with_capacity(s.len_bytes() + 5 * selection.len());
+    out.push_str(&s.to_string());
+
     let mut insertion: Vec<_> = selection
         .iter()
         .enumerate()
@@ -138,7 +167,9 @@ pub fn plain(s: &str, selection: Selection) -> String {
                 (false, false) => [(range.anchor, ")#"), (range.head, "#(|")],
             }
         })
+        .map(|(char_idx, marker)| (s.char_to_byte(char_idx), marker))
         .collect();
+
     // insert in reverse order
     insertion.sort_unstable_by_key(|k| Reverse(k.0));
     for (i, s) in insertion {
@@ -262,4 +293,94 @@ fn print_multi_code_point_grapheme() {
             print("hello #[|]# goodbye")
         );
     }
+
+    #[test]
+    fn plain_single() {
+        assert_eq!("#[|h]#ello", plain("hello", &Selection::single(1, 0)));
+        assert_eq!("#[h|]#ello", plain("hello", &Selection::single(0, 1)));
+        assert_eq!("#[|hell]#o", plain("hello", &Selection::single(4, 0)));
+        assert_eq!("#[hell|]#o", plain("hello", &Selection::single(0, 4)));
+        assert_eq!("#[|hello]#", plain("hello", &Selection::single(5, 0)));
+        assert_eq!("#[hello|]#", plain("hello", &Selection::single(0, 5)));
+    }
+
+    #[test]
+    fn plain_multi() {
+        assert_eq!(
+            plain(
+                "hello",
+                &Selection::new(
+                    SmallVec::from_slice(&[Range::new(1, 0), Range::new(5, 4)]),
+                    0
+                )
+            ),
+            String::from("#[|h]#ell#(|o)#")
+        );
+        assert_eq!(
+            plain(
+                "hello",
+                &Selection::new(
+                    SmallVec::from_slice(&[Range::new(0, 1), Range::new(4, 5)]),
+                    0
+                )
+            ),
+            String::from("#[h|]#ell#(o|)#")
+        );
+        assert_eq!(
+            plain(
+                "hello",
+                &Selection::new(
+                    SmallVec::from_slice(&[Range::new(2, 0), Range::new(5, 3)]),
+                    0
+                )
+            ),
+            String::from("#[|he]#l#(|lo)#")
+        );
+        assert_eq!(
+            plain(
+                "hello\r\nhello\r\nhello\r\n",
+                &Selection::new(
+                    SmallVec::from_slice(&[
+                        Range::new(7, 5),
+                        Range::new(21, 19),
+                        Range::new(14, 12)
+                    ]),
+                    0
+                )
+            ),
+            String::from("hello#[|\r\n]#hello#(|\r\n)#hello#(|\r\n)#")
+        );
+    }
+
+    #[test]
+    fn plain_multi_byte_code_point() {
+        assert_eq!(
+            plain("", &Selection::single(1, 0)),
+            String::from("#[|]#")
+        );
+        assert_eq!(
+            plain("", &Selection::single(2, 1)),
+            String::from("#[|]#")
+        );
+        assert_eq!(
+            plain("", &Selection::single(0, 1)),
+            String::from("#[|]#")
+        );
+        assert_eq!(
+            plain("", &Selection::single(1, 2)),
+            String::from("#[|]#")
+        );
+        assert_eq!(
+            plain("they said hello", &Selection::single(11, 10)),
+            String::from("they said #[|]#hello")
+        );
+    }
+
+    #[test]
+    fn plain_multi_code_point_grapheme() {
+        assert_eq!(
+            plain("hello  goodbye", &Selection::single(13, 6)),
+            String::from("hello #[|]# goodbye")
+        );
+    }
 }
diff --git a/helix-core/src/text_annotations.rs b/helix-core/src/text_annotations.rs
new file mode 100644
index 000000000..11d19d485
--- /dev/null
+++ b/helix-core/src/text_annotations.rs
@@ -0,0 +1,271 @@
+use std::cell::Cell;
+use std::ops::Range;
+use std::rc::Rc;
+
+use crate::syntax::Highlight;
+use crate::Tendril;
+
+/// An inline annotation is continuous text shown
+/// on the screen before the grapheme that starts at
+/// `char_idx`
+#[derive(Debug, Clone)]
+pub struct InlineAnnotation {
+    pub text: Tendril,
+    pub char_idx: usize,
+}
+
+impl InlineAnnotation {
+    pub fn new(char_idx: usize, text: impl Into<Tendril>) -> Self {
+        Self {
+            char_idx,
+            text: text.into(),
+        }
+    }
+}
+
+/// Represents a **single Grapheme** that is part of the document
+/// that start at `char_idx` that will be replaced with
+/// a different `grapheme`.
+/// If `grapheme` contains multiple graphemes the text
+/// will render incorrectly.
+/// If you want to overlay multiple graphemes simply
+/// use multiple `Overlays`.
+///
+/// # Examples
+///
+/// The following examples are valid overlays for the following text:
+///
+/// `aXbc`
+///
+/// ```
+/// use helix_core::text_annotations::Overlay;
+///
+/// // replaces a
+/// Overlay::new(0, "X");
+///
+/// // replaces X
+/// Overlay::new(1, "\t");
+///
+/// // replaces b
+/// Overlay::new(6, "X");
+/// ```
+///
+/// The following examples are invalid uses
+///
+/// ```
+/// use helix_core::text_annotations::Overlay;
+///
+/// // overlay is not aligned at grapheme boundary
+/// Overlay::new(3, "x");
+///
+/// // overlay contains multiple graphemes
+/// Overlay::new(0, "xy");
+/// ```
+#[derive(Debug, Clone)]
+pub struct Overlay {
+    pub char_idx: usize,
+    pub grapheme: Tendril,
+}
+
+impl Overlay {
+    pub fn new(char_idx: usize, grapheme: impl Into<Tendril>) -> Self {
+        Self {
+            char_idx,
+            grapheme: grapheme.into(),
+        }
+    }
+}
+
+/// Line annotations allow for virtual text between normal
+/// text lines. They cause `height` empty lines to be inserted
+/// below the document line that contains `anchor_char_idx`.
+///
+/// These lines can be filled with text in the rendering code
+/// as their contents have no effect beyond visual appearance.
+///
+/// To insert a line after a document line simply set
+/// `anchor_char_idx` to `doc.line_to_char(line_idx)`
+#[derive(Debug, Clone)]
+pub struct LineAnnotation {
+    pub anchor_char_idx: usize,
+    pub height: usize,
+}
+
+#[derive(Debug)]
+struct Layer<A, M> {
+    annotations: Rc<[A]>,
+    current_index: Cell<usize>,
+    metadata: M,
+}
+
+impl<A, M: Clone> Clone for Layer<A, M> {
+    fn clone(&self) -> Self {
+        Layer {
+            annotations: self.annotations.clone(),
+            current_index: self.current_index.clone(),
+            metadata: self.metadata.clone(),
+        }
+    }
+}
+
+impl<A, M> Layer<A, M> {
+    pub fn reset_pos(&self, char_idx: usize, get_char_idx: impl Fn(&A) -> usize) {
+        let new_index = self
+            .annotations
+            .partition_point(|annot| get_char_idx(annot) < char_idx);
+        self.current_index.set(new_index);
+    }
+
+    pub fn consume(&self, char_idx: usize, get_char_idx: impl Fn(&A) -> usize) -> Option<&A> {
+        let annot = self.annotations.get(self.current_index.get())?;
+        debug_assert!(get_char_idx(annot) >= char_idx);
+        if get_char_idx(annot) == char_idx {
+            self.current_index.set(self.current_index.get() + 1);
+            Some(annot)
+        } else {
+            None
+        }
+    }
+}
+
+impl<A, M> From<(Rc<[A]>, M)> for Layer<A, M> {
+    fn from((annotations, metadata): (Rc<[A]>, M)) -> Layer<A, M> {
+        Layer {
+            annotations,
+            current_index: Cell::new(0),
+            metadata,
+        }
+    }
+}
+
+fn reset_pos<A, M>(layers: &[Layer<A, M>], pos: usize, get_pos: impl Fn(&A) -> usize) {
+    for layer in layers {
+        layer.reset_pos(pos, &get_pos)
+    }
+}
+
+/// Annotations that change that is displayed when the document is render.
+/// Also commonly called virtual text.
+#[derive(Default, Debug, Clone)]
+pub struct TextAnnotations {
+    inline_annotations: Vec<Layer<InlineAnnotation, Option<Highlight>>>,
+    overlays: Vec<Layer<Overlay, Option<Highlight>>>,
+    line_annotations: Vec<Layer<LineAnnotation, ()>>,
+}
+
+impl TextAnnotations {
+    /// Prepare the TextAnnotations for iteration starting at char_idx
+    pub fn reset_pos(&self, char_idx: usize) {
+        reset_pos(&self.inline_annotations, char_idx, |annot| annot.char_idx);
+        reset_pos(&self.overlays, char_idx, |annot| annot.char_idx);
+        reset_pos(&self.line_annotations, char_idx, |annot| {
+            annot.anchor_char_idx
+        });
+    }
+
+    pub fn collect_overlay_highlights(
+        &self,
+        char_range: Range<usize>,
+    ) -> Vec<(usize, Range<usize>)> {
+        let mut highlights = Vec::new();
+        self.reset_pos(char_range.start);
+        for char_idx in char_range {
+            if let Some((_, Some(highlight))) = self.overlay_at(char_idx) {
+                // we don't know the number of chars the original grapheme takes
+                // however it doesn't matter as highlight boundaries are automatically
+                // aligned to grapheme boundaries in the rendering code
+                highlights.push((highlight.0, char_idx..char_idx + 1))
+            }
+        }
+
+        highlights
+    }
+
+    /// Add new inline annotations.
+    ///
+    /// The annotations grapheme will be rendered with `highlight`
+    /// patched on top of `ui.text`.
+    ///
+    /// The annotations **must be sorted** by their `char_idx`.
+    /// Multiple annotations with the same `char_idx` are allowed,
+    /// they will be display in the order that they are present in the layer.
+    ///
+    /// If multiple layers contain annotations at the same position
+    /// the annotations that belong to the layers added first will be shown first.
+    pub fn add_inline_annotations(
+        &mut self,
+        layer: Rc<[InlineAnnotation]>,
+        highlight: Option<Highlight>,
+    ) -> &mut Self {
+        self.inline_annotations.push((layer, highlight).into());
+        self
+    }
+
+    /// Add new grapheme overlays.
+    ///
+    /// The overlaid grapheme will be rendered with `highlight`
+    /// patched on top of `ui.text`.
+    ///
+    /// The overlays **must be sorted** by their `char_idx`.
+    /// Multiple overlays with the same `char_idx` **are allowed**.
+    ///
+    /// If multiple layers contain overlay at the same position
+    /// the overlay from the layer added last will be show.
+    pub fn add_overlay(&mut self, layer: Rc<[Overlay]>, highlight: Option<Highlight>) -> &mut Self {
+        self.overlays.push((layer, highlight).into());
+        self
+    }
+
+    /// Add new annotation lines.
+    ///
+    /// The line annotations **must be sorted** by their `char_idx`.
+    /// Multiple line annotations with the same `char_idx` **are not allowed**.
+    pub fn add_line_annotation(&mut self, layer: Rc<[LineAnnotation]>) -> &mut Self {
+        self.line_annotations.push((layer, ()).into());
+        self
+    }
+
+    /// Removes all line annotations, useful for vertical motions
+    /// so that virtual text lines are automatically skipped.
+    pub fn clear_line_annotations(&mut self) {
+        self.line_annotations.clear();
+    }
+
+    pub(crate) fn next_inline_annotation_at(
+        &self,
+        char_idx: usize,
+    ) -> Option<(&InlineAnnotation, Option<Highlight>)> {
+        self.inline_annotations.iter().find_map(|layer| {
+            let annotation = layer.consume(char_idx, |annot| annot.char_idx)?;
+            Some((annotation, layer.metadata))
+        })
+    }
+
+    pub(crate) fn overlay_at(&self, char_idx: usize) -> Option<(&Overlay, Option<Highlight>)> {
+        let mut overlay = None;
+        for layer in &self.overlays {
+            while let Some(new_overlay) = layer.consume(char_idx, |annot| annot.char_idx) {
+                overlay = Some((new_overlay, layer.metadata));
+            }
+        }
+        overlay
+    }
+
+    pub(crate) fn annotation_lines_at(&self, char_idx: usize) -> usize {
+        self.line_annotations
+            .iter()
+            .map(|layer| {
+                let mut lines = 0;
+                while let Some(annot) = layer.annotations.get(layer.current_index.get()) {
+                    if annot.anchor_char_idx == char_idx {
+                        layer.current_index.set(layer.current_index.get() + 1);
+                        lines += annot.height
+                    } else {
+                        break;
+                    }
+                }
+                lines
+            })
+            .sum()
+    }
+}
diff --git a/helix-core/src/textobject.rs b/helix-core/src/textobject.rs
index 76c6d103e..bf00a4580 100644
--- a/helix-core/src/textobject.rs
+++ b/helix-core/src/textobject.rs
@@ -231,8 +231,20 @@ fn textobject_pair_surround_impl(
     };
     pair_pos
         .map(|(anchor, head)| match textobject {
-            TextObject::Inside => Range::new(next_grapheme_boundary(slice, anchor), head),
-            TextObject::Around => Range::new(anchor, next_grapheme_boundary(slice, head)),
+            TextObject::Inside => {
+                if anchor < head {
+                    Range::new(next_grapheme_boundary(slice, anchor), head)
+                } else {
+                    Range::new(anchor, next_grapheme_boundary(slice, head))
+                }
+            }
+            TextObject::Around => {
+                if anchor < head {
+                    Range::new(anchor, next_grapheme_boundary(slice, head))
+                } else {
+                    Range::new(next_grapheme_boundary(slice, anchor), head)
+                }
+            }
             TextObject::Movement => unreachable!(),
         })
         .unwrap_or(range)
@@ -425,7 +437,7 @@ fn test_textobject_paragraph_inside_single() {
             let text = Rope::from(s.as_str());
             let selection = selection
                 .transform(|r| textobject_paragraph(text.slice(..), r, TextObject::Inside, 1));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -448,7 +460,7 @@ fn test_textobject_paragraph_inside_double() {
             let text = Rope::from(s.as_str());
             let selection = selection
                 .transform(|r| textobject_paragraph(text.slice(..), r, TextObject::Inside, 2));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
@@ -479,7 +491,7 @@ fn test_textobject_paragraph_around_single() {
             let text = Rope::from(s.as_str());
             let selection = selection
                 .transform(|r| textobject_paragraph(text.slice(..), r, TextObject::Around, 1));
-            let actual = crate::test::plain(&s, selection);
+            let actual = crate::test::plain(s.as_ref(), &selection);
             assert_eq!(actual, expected, "\nbefore: `{:?}`", before);
         }
     }
diff --git a/helix-core/src/transaction.rs b/helix-core/src/transaction.rs
index 482fd6d97..d8e581aae 100644
--- a/helix-core/src/transaction.rs
+++ b/helix-core/src/transaction.rs
@@ -1,3 +1,5 @@
+use smallvec::SmallVec;
+
 use crate::{Range, Rope, Selection, Tendril};
 use std::borrow::Cow;
 
@@ -466,6 +468,33 @@ pub fn with_selection(mut self, selection: Selection) -> Self {
         self
     }
 
+    /// Generate a transaction from a set of potentially overlapping changes. The `change_ranges`
+    /// iterator yield the range (of removed text) in the old document for each edit. If any change
+    /// overlaps with a range overlaps with a previous range then that range is ignored.
+    ///
+    /// The `process_change` callback is called for each edit that is not ignored (in the order
+    /// yielded by `changes`) and should return the new text that the associated range will be
+    /// replaced with.
+    ///
+    /// To make this function more flexible the iterator can yield additional data for each change
+    /// that is passed to `process_change`
+    pub fn change_ignore_overlapping<T>(
+        doc: &Rope,
+        change_ranges: impl Iterator<Item = (usize, usize, T)>,
+        mut process_change: impl FnMut(usize, usize, T) -> Option<Tendril>,
+    ) -> Self {
+        let mut last = 0;
+        let changes = change_ranges.filter_map(|(from, to, data)| {
+            if from < last {
+                return None;
+            }
+            let tendril = process_change(from, to, data);
+            last = to;
+            Some((from, to, tendril))
+        });
+        Self::change(doc, changes)
+    }
+
     /// Generate a transaction from a set of changes.
     pub fn change<I>(doc: &Rope, changes: I) -> Self
     where
@@ -481,6 +510,11 @@ pub fn change<I>(doc: &Rope, changes: I) -> Self
         for (from, to, tendril) in changes {
             // Verify ranges are ordered and not overlapping
             debug_assert!(last <= from);
+            // Verify ranges are correct
+            debug_assert!(
+                from <= to,
+                "Edit end must end before it starts (should {from} <= {to})"
+            );
 
             // Retain from last "to" to current "from"
             changeset.retain(from - last);
@@ -508,6 +542,44 @@ pub fn change_by_selection<F>(doc: &Rope, selection: &Selection, f: F) -> Self
         Self::change(doc, selection.iter().map(f))
     }
 
+    pub fn change_by_selection_ignore_overlapping(
+        doc: &Rope,
+        selection: &Selection,
+        mut change_range: impl FnMut(&Range) -> (usize, usize),
+        mut create_tendril: impl FnMut(usize, usize) -> Option<Tendril>,
+    ) -> (Transaction, Selection) {
+        let mut last_selection_idx = None;
+        let mut new_primary_idx = None;
+        let mut ranges: SmallVec<[Range; 1]> = SmallVec::new();
+        let process_change = |change_start, change_end, (idx, range): (usize, &Range)| {
+            // update the primary idx
+            if idx == selection.primary_index() {
+                new_primary_idx = Some(idx);
+            } else if new_primary_idx.is_none() {
+                if idx > selection.primary_index() {
+                    new_primary_idx = last_selection_idx;
+                } else {
+                    last_selection_idx = Some(idx);
+                }
+            }
+            ranges.push(*range);
+            create_tendril(change_start, change_end)
+        };
+        let transaction = Self::change_ignore_overlapping(
+            doc,
+            selection.iter().enumerate().map(|range| {
+                let (change_start, change_end) = change_range(range.1);
+                (change_start, change_end, range)
+            }),
+            process_change,
+        );
+
+        (
+            transaction,
+            Selection::new(ranges, new_primary_idx.unwrap_or(0)),
+        )
+    }
+
     /// Insert text at each selection head.
     pub fn insert(doc: &Rope, selection: &Selection, text: Tendril) -> Self {
         Self::change_by_selection(doc, selection, |range| {
diff --git a/helix-core/src/wrap.rs b/helix-core/src/wrap.rs
index eabc47d47..2ba8d173e 100644
--- a/helix-core/src/wrap.rs
+++ b/helix-core/src/wrap.rs
@@ -2,6 +2,6 @@
 
 /// Given a slice of text, return the text re-wrapped to fit it
 /// within the given width.
-pub fn reflow_hard_wrap(text: &str, max_line_len: usize) -> SmartString<LazyCompact> {
-    textwrap::refill(text, max_line_len).into()
+pub fn reflow_hard_wrap(text: &str, text_width: usize) -> SmartString<LazyCompact> {
+    textwrap::refill(text, text_width).into()
 }
diff --git a/helix-core/tests/indent.rs b/helix-core/tests/indent.rs
index e1114f4a9..f558f86f3 100644
--- a/helix-core/tests/indent.rs
+++ b/helix-core/tests/indent.rs
@@ -1,5 +1,5 @@
 use helix_core::{
-    indent::{treesitter_indent_for_pos, IndentStyle},
+    indent::{indent_level_for_line, treesitter_indent_for_pos, IndentStyle},
     syntax::Loader,
     Syntax,
 };
@@ -17,6 +17,39 @@ fn test_treesitter_indent_rust_2() {
     // test_treesitter_indent("commands.rs", "source.rust");
 }
 
+#[test]
+fn test_indent_level_for_line_with_spaces() {
+    let tab_width: usize = 4;
+    let indent_width: usize = 4;
+
+    let line = ropey::Rope::from_str("        Indented with 8 spaces");
+
+    let indent_level = indent_level_for_line(line.slice(0..), tab_width, indent_width);
+    assert_eq!(indent_level, 2)
+}
+
+#[test]
+fn test_indent_level_for_line_with_tabs() {
+    let tab_width: usize = 4;
+    let indent_width: usize = 4;
+
+    let line = ropey::Rope::from_str("\t\tIndented with 2 tabs");
+
+    let indent_level = indent_level_for_line(line.slice(0..), tab_width, indent_width);
+    assert_eq!(indent_level, 2)
+}
+
+#[test]
+fn test_indent_level_for_line_with_spaces_and_tabs() {
+    let tab_width: usize = 4;
+    let indent_width: usize = 4;
+
+    let line = ropey::Rope::from_str("   \t \tIndented with mix of spaces and tabs");
+
+    let indent_level = indent_level_for_line(line.slice(0..), tab_width, indent_width);
+    assert_eq!(indent_level, 2)
+}
+
 fn test_treesitter_indent(file_name: &str, lang_scope: &str) {
     let mut test_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
     test_dir.push("tests/data/indent");
@@ -28,8 +61,8 @@ fn test_treesitter_indent(file_name: &str, lang_scope: &str) {
 
     let mut config_file = test_dir;
     config_file.push("languages.toml");
-    let config = std::fs::read(config_file).unwrap();
-    let config = toml::from_slice(&config).unwrap();
+    let config = std::fs::read_to_string(config_file).unwrap();
+    let config = toml::from_str(&config).unwrap();
     let loader = Loader::new(config);
 
     // set runtime path so we can find the queries
@@ -46,11 +79,13 @@ fn test_treesitter_indent(file_name: &str, lang_scope: &str) {
     for i in 0..doc.len_lines() {
         let line = text.line(i);
         if let Some(pos) = helix_core::find_first_non_whitespace_char(line) {
+            let tab_and_indent_width: usize = 4;
             let suggested_indent = treesitter_indent_for_pos(
                 indent_query,
                 &syntax,
-                &IndentStyle::Spaces(4),
-                4,
+                &IndentStyle::Spaces(tab_and_indent_width as u8),
+                tab_and_indent_width,
+                tab_and_indent_width,
                 text,
                 i,
                 text.line_to_char(i) + pos,
diff --git a/helix-dap/Cargo.toml b/helix-dap/Cargo.toml
index 95a059052..d42ce23ff 100644
--- a/helix-dap/Cargo.toml
+++ b/helix-dap/Cargo.toml
@@ -19,7 +19,7 @@ serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
 thiserror = "1.0"
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot", "net", "sync"] }
-which = "4.2"
+which = "4.4"
 
 [dev-dependencies]
 fern = "0.6"
diff --git a/helix-dap/src/client.rs b/helix-dap/src/client.rs
index 371cf3032..7efb72d80 100644
--- a/helix-dap/src/client.rs
+++ b/helix-dap/src/client.rs
@@ -1,4 +1,5 @@
 use crate::{
+    requests::DisconnectArguments,
     transport::{Payload, Request, Response, Transport},
     types::*,
     Error, Result, ThreadId,
@@ -31,6 +32,8 @@ pub struct Client {
     _process: Option<Child>,
     server_tx: UnboundedSender<Payload>,
     request_counter: AtomicU64,
+    connection_type: Option<ConnectionType>,
+    starting_request_args: Option<Value>,
     pub caps: Option<DebuggerCapabilities>,
     // thread_id -> frames
     pub stack_frames: HashMap<ThreadId, Vec<StackFrame>>,
@@ -41,6 +44,12 @@ pub struct Client {
     pub quirks: DebuggerQuirks,
 }
 
+#[derive(Clone, Copy, Debug)]
+pub enum ConnectionType {
+    Launch,
+    Attach,
+}
+
 impl Client {
     // Spawn a process and communicate with it by either TCP or stdio
     pub async fn process(
@@ -70,7 +79,7 @@ pub fn streams(
         process: Option<Child>,
     ) -> Result<(Self, UnboundedReceiver<Payload>)> {
         let (server_rx, server_tx) = Transport::start(rx, tx, err, id);
-        let (client_rx, client_tx) = unbounded_channel();
+        let (client_tx, client_rx) = unbounded_channel();
 
         let client = Self {
             id,
@@ -78,7 +87,8 @@ pub fn streams(
             server_tx,
             request_counter: AtomicU64::new(0),
             caps: None,
-            //
+            connection_type: None,
+            starting_request_args: None,
             stack_frames: HashMap::new(),
             thread_states: HashMap::new(),
             thread_id: None,
@@ -86,9 +96,9 @@ pub fn streams(
             quirks: DebuggerQuirks::default(),
         };
 
-        tokio::spawn(Self::recv(server_rx, client_rx));
+        tokio::spawn(Self::recv(server_rx, client_tx));
 
-        Ok((client, client_tx))
+        Ok((client, client_rx))
     }
 
     pub async fn tcp(
@@ -150,6 +160,10 @@ async fn get_port() -> Option<u16> {
         )
     }
 
+    pub fn starting_request_args(&self) -> &Option<Value> {
+        &self.starting_request_args
+    }
+
     pub async fn tcp_process(
         cmd: &str,
         args: Vec<&str>,
@@ -207,6 +221,10 @@ pub fn id(&self) -> usize {
         self.id
     }
 
+    pub fn connection_type(&self) -> Option<ConnectionType> {
+        self.connection_type
+    }
+
     fn next_request_id(&self) -> u64 {
         self.request_counter.fetch_add(1, Ordering::Relaxed)
     }
@@ -254,7 +272,7 @@ pub fn call<R: crate::types::Request>(
             // TODO: specifiable timeout, delay other calls until initialize success
             timeout(Duration::from_secs(20), callback_rx.recv())
                 .await
-                .map_err(|_| Error::Timeout)? // return Timeout
+                .map_err(|_| Error::Timeout(id))? // return Timeout
                 .ok_or(Error::StreamClosed)?
                 .map(|response| response.body.unwrap_or_default())
             // TODO: check response.success
@@ -334,18 +352,35 @@ pub async fn initialize(&mut self, adapter_id: String) -> Result<()> {
         Ok(())
     }
 
-    pub fn disconnect(&self) -> impl Future<Output = Result<Value>> {
-        self.call::<requests::Disconnect>(())
+    pub fn disconnect(
+        &mut self,
+        args: Option<DisconnectArguments>,
+    ) -> impl Future<Output = Result<Value>> {
+        self.connection_type = None;
+        self.call::<requests::Disconnect>(args)
     }
 
-    pub fn launch(&self, args: serde_json::Value) -> impl Future<Output = Result<Value>> {
+    pub fn launch(&mut self, args: serde_json::Value) -> impl Future<Output = Result<Value>> {
+        self.connection_type = Some(ConnectionType::Launch);
+        self.starting_request_args = Some(args.clone());
         self.call::<requests::Launch>(args)
     }
 
-    pub fn attach(&self, args: serde_json::Value) -> impl Future<Output = Result<Value>> {
+    pub fn attach(&mut self, args: serde_json::Value) -> impl Future<Output = Result<Value>> {
+        self.connection_type = Some(ConnectionType::Attach);
+        self.starting_request_args = Some(args.clone());
         self.call::<requests::Attach>(args)
     }
 
+    pub fn restart(&self) -> impl Future<Output = Result<Value>> {
+        let args = if let Some(args) = &self.starting_request_args {
+            args.clone()
+        } else {
+            Value::Null
+        };
+        self.call::<requests::Restart>(args)
+    }
+
     pub async fn set_breakpoints(
         &self,
         file: PathBuf,
@@ -477,4 +512,10 @@ pub fn set_exception_breakpoints(
 
         self.call::<requests::SetExceptionBreakpoints>(args)
     }
+
+    pub fn current_stack_frame(&self) -> Option<&StackFrame> {
+        self.stack_frames
+            .get(&self.thread_id?)?
+            .get(self.active_frame?)
+    }
 }
diff --git a/helix-dap/src/lib.rs b/helix-dap/src/lib.rs
index f60b102c0..21162cb86 100644
--- a/helix-dap/src/lib.rs
+++ b/helix-dap/src/lib.rs
@@ -2,7 +2,7 @@
 mod transport;
 mod types;
 
-pub use client::Client;
+pub use client::{Client, ConnectionType};
 pub use events::Event;
 pub use transport::{Payload, Response, Transport};
 pub use types::*;
@@ -14,8 +14,8 @@ pub enum Error {
     Parse(#[from] serde_json::Error),
     #[error("IO Error: {0}")]
     IO(#[from] std::io::Error),
-    #[error("request timed out")]
-    Timeout,
+    #[error("request {0} timed out")]
+    Timeout(u64),
     #[error("server closed the stream")]
     StreamClosed,
     #[error(transparent)]
diff --git a/helix-dap/src/types.rs b/helix-dap/src/types.rs
index 0a9ebe5e9..bbaf53a60 100644
--- a/helix-dap/src/types.rs
+++ b/helix-dap/src/types.rs
@@ -378,7 +378,7 @@ pub enum Launch {}
 
     impl Request for Launch {
         type Arguments = Value;
-        type Result = Value;
+        type Result = ();
         const COMMAND: &'static str = "launch";
     }
 
@@ -387,15 +387,35 @@ pub enum Attach {}
 
     impl Request for Attach {
         type Arguments = Value;
-        type Result = Value;
+        type Result = ();
         const COMMAND: &'static str = "attach";
     }
 
+    #[derive(Debug, Default, PartialEq, Eq, Clone, Deserialize, Serialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct DisconnectArguments {
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub restart: Option<bool>,
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub terminate_debuggee: Option<bool>,
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub suspend_debuggee: Option<bool>,
+    }
+
+    #[derive(Debug)]
+    pub enum Restart {}
+
+    impl Request for Restart {
+        type Arguments = Value;
+        type Result = ();
+        const COMMAND: &'static str = "restart";
+    }
+
     #[derive(Debug)]
     pub enum Disconnect {}
 
     impl Request for Disconnect {
-        type Arguments = ();
+        type Arguments = Option<DisconnectArguments>;
         type Result = ();
         const COMMAND: &'static str = "disconnect";
     }
diff --git a/helix-loader/Cargo.toml b/helix-loader/Cargo.toml
index 760205e1f..9225ad1a2 100644
--- a/helix-loader/Cargo.toml
+++ b/helix-loader/Cargo.toml
@@ -16,10 +16,10 @@ path = "src/main.rs"
 [dependencies]
 anyhow = "1"
 serde = { version = "1.0", features = ["derive"] }
-toml = "0.5"
+toml = "0.7"
 etcetera = "0.4"
 tree-sitter = "0.20"
-once_cell = "1.16"
+once_cell = "1.17"
 log = "0.4"
 
 # TODO: these two should be on !wasm32 only
diff --git a/helix-loader/src/config.rs b/helix-loader/src/config.rs
index 259b1318e..d092d20f7 100644
--- a/helix-loader/src/config.rs
+++ b/helix-loader/src/config.rs
@@ -1,42 +1,46 @@
+use std::str::from_utf8;
+
 /// Default built-in languages.toml.
 pub fn default_lang_config() -> toml::Value {
-    toml::from_slice(include_bytes!("../../languages.toml"))
+    let default_config = include_bytes!("../../languages.toml");
+    toml::from_str(from_utf8(default_config).unwrap())
         .expect("Could not parse built-in languages.toml to valid toml")
 }
 
 /// User configured languages.toml file, merged with the default config.
 pub fn user_lang_config() -> Result<toml::Value, toml::de::Error> {
-    let config = crate::local_config_dirs()
-        .into_iter()
-        .chain([crate::config_dir()].into_iter())
-        .map(|path| path.join("languages.toml"))
-        .filter_map(|file| {
-            std::fs::read(&file)
-                .map(|config| toml::from_slice(&config))
-                .ok()
-        })
-        .collect::<Result<Vec<_>, _>>()?
-        .into_iter()
-        .chain([default_lang_config()].into_iter())
-        .fold(toml::Value::Table(toml::value::Table::default()), |a, b| {
-            // combines for example
-            // b:
-            //   [[language]]
-            //   name = "toml"
-            //   language-server = { command = "taplo", args = ["lsp", "stdio"] }
-            //
-            // a:
-            //   [[language]]
-            //   language-server = { command = "/usr/bin/taplo" }
-            //
-            // into:
-            //   [[language]]
-            //   name = "toml"
-            //   language-server = { command = "/usr/bin/taplo" }
-            //
-            // thus it overrides the third depth-level of b with values of a if they exist, but otherwise merges their values
-            crate::merge_toml_values(b, a, 3)
-        });
+    let config = [
+        crate::config_dir(),
+        crate::find_workspace().0.join(".helix"),
+    ]
+    .into_iter()
+    .map(|path| path.join("languages.toml"))
+    .filter_map(|file| {
+        std::fs::read_to_string(file)
+            .map(|config| toml::from_str(&config))
+            .ok()
+    })
+    .collect::<Result<Vec<_>, _>>()?
+    .into_iter()
+    .fold(default_lang_config(), |a, b| {
+        // combines for example
+        // b:
+        //   [[language]]
+        //   name = "toml"
+        //   language-server = { command = "taplo", args = ["lsp", "stdio"] }
+        //
+        // a:
+        //   [[language]]
+        //   language-server = { command = "/usr/bin/taplo" }
+        //
+        // into:
+        //   [[language]]
+        //   name = "toml"
+        //   language-server = { command = "/usr/bin/taplo" }
+        //
+        // thus it overrides the third depth-level of b with values of a if they exist, but otherwise merges their values
+        crate::merge_toml_values(a, b, 3)
+    });
 
     Ok(config)
 }
diff --git a/helix-loader/src/grammar.rs b/helix-loader/src/grammar.rs
index 2aa924755..a85cb274c 100644
--- a/helix-loader/src/grammar.rs
+++ b/helix-loader/src/grammar.rs
@@ -67,8 +67,9 @@ pub fn get_language(name: &str) -> Result<Language> {
 #[cfg(not(target_arch = "wasm32"))]
 pub fn get_language(name: &str) -> Result<Language> {
     use libloading::{Library, Symbol};
-    let mut library_path = crate::runtime_dir().join("grammars").join(name);
-    library_path.set_extension(DYLIB_EXTENSION);
+    let mut rel_library_path = PathBuf::new().join("grammars").join(name);
+    rel_library_path.set_extension(DYLIB_EXTENSION);
+    let library_path = crate::runtime_file(&rel_library_path);
 
     let library = unsafe { Library::new(&library_path) }
         .with_context(|| format!("Error opening dynamic library {:?}", library_path))?;
@@ -252,7 +253,9 @@ fn fetch_grammar(grammar: GrammarConfiguration) -> Result<FetchStatus> {
         remote, revision, ..
     } = grammar.source
     {
-        let grammar_dir = crate::runtime_dir()
+        let grammar_dir = crate::runtime_dirs()
+            .first()
+            .expect("No runtime directories provided") // guaranteed by post-condition
             .join("grammars")
             .join("sources")
             .join(&grammar.grammar_id);
@@ -350,7 +353,9 @@ fn build_grammar(grammar: GrammarConfiguration, target: Option<&str>) -> Result<
     let grammar_dir = if let GrammarSource::Local { path } = &grammar.source {
         PathBuf::from(&path)
     } else {
-        crate::runtime_dir()
+        crate::runtime_dirs()
+            .first()
+            .expect("No runtime directories provided") // guaranteed by post-condition
             .join("grammars")
             .join("sources")
             .join(&grammar.grammar_id)
@@ -401,7 +406,10 @@ fn build_tree_sitter_library(
             None
         }
     };
-    let parser_lib_path = crate::runtime_dir().join("grammars");
+    let parser_lib_path = crate::runtime_dirs()
+        .first()
+        .expect("No runtime directories provided") // guaranteed by post-condition
+        .join("grammars");
     let mut library_path = parser_lib_path.join(&grammar.grammar_id);
     library_path.set_extension(DYLIB_EXTENSION);
 
@@ -511,9 +519,6 @@ fn mtime(path: &Path) -> Result<SystemTime> {
 /// Gives the contents of a file from a language's `runtime/queries/<lang>`
 /// directory
 pub fn load_runtime_file(language: &str, filename: &str) -> Result<String, std::io::Error> {
-    let path = crate::RUNTIME_DIR
-        .join("queries")
-        .join(language)
-        .join(filename);
-    std::fs::read_to_string(&path)
+    let path = crate::runtime_file(&PathBuf::new().join("queries").join(language).join(filename));
+    std::fs::read_to_string(path)
 }
diff --git a/helix-loader/src/lib.rs b/helix-loader/src/lib.rs
index 80d44a826..6c7169758 100644
--- a/helix-loader/src/lib.rs
+++ b/helix-loader/src/lib.rs
@@ -2,11 +2,12 @@
 pub mod grammar;
 
 use etcetera::base_strategy::{choose_base_strategy, BaseStrategy};
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 
 pub const VERSION_AND_GIT_HASH: &str = env!("VERSION_AND_GIT_HASH");
 
-pub static RUNTIME_DIR: once_cell::sync::Lazy<PathBuf> = once_cell::sync::Lazy::new(runtime_dir);
+static RUNTIME_DIRS: once_cell::sync::Lazy<Vec<PathBuf>> =
+    once_cell::sync::Lazy::new(prioritize_runtime_dirs);
 
 static CONFIG_FILE: once_cell::sync::OnceCell<PathBuf> = once_cell::sync::OnceCell::new();
 
@@ -25,31 +26,83 @@ pub fn initialize_config_file(specified_file: Option<PathBuf>) {
     CONFIG_FILE.set(config_file).ok();
 }
 
-pub fn runtime_dir() -> PathBuf {
-    if let Ok(dir) = std::env::var("HELIX_RUNTIME") {
-        return dir.into();
-    }
-
+/// A list of runtime directories from highest to lowest priority
+///
+/// The priority is:
+///
+/// 1. sibling directory to `CARGO_MANIFEST_DIR` (if environment variable is set)
+/// 2. subdirectory of user config directory (always included)
+/// 3. `HELIX_RUNTIME` (if environment variable is set)
+/// 4. subdirectory of path to helix executable (always included)
+///
+/// Postcondition: returns at least two paths (they might not exist).
+fn prioritize_runtime_dirs() -> Vec<PathBuf> {
+    const RT_DIR: &str = "runtime";
+    // Adding higher priority first
+    let mut rt_dirs = Vec::new();
     if let Ok(dir) = std::env::var("CARGO_MANIFEST_DIR") {
         // this is the directory of the crate being run by cargo, we need the workspace path so we take the parent
-        let path = std::path::PathBuf::from(dir).parent().unwrap().join(RT_DIR);
+        let path = PathBuf::from(dir).parent().unwrap().join(RT_DIR);
         log::debug!("runtime dir: {}", path.to_string_lossy());
-        return path;
+        rt_dirs.push(path);
     }
 
-    const RT_DIR: &str = "runtime";
-    let conf_dir = config_dir().join(RT_DIR);
-    if conf_dir.exists() {
-        return conf_dir;
+    let conf_rt_dir = config_dir().join(RT_DIR);
+    rt_dirs.push(conf_rt_dir);
+
+    if let Ok(dir) = std::env::var("HELIX_RUNTIME") {
+        rt_dirs.push(dir.into());
     }
 
     // fallback to location of the executable being run
     // canonicalize the path in case the executable is symlinked
-    std::env::current_exe()
+    let exe_rt_dir = std::env::current_exe()
         .ok()
         .and_then(|path| std::fs::canonicalize(path).ok())
         .and_then(|path| path.parent().map(|path| path.to_path_buf().join(RT_DIR)))
-        .unwrap()
+        .unwrap();
+    rt_dirs.push(exe_rt_dir);
+    rt_dirs
+}
+
+/// Runtime directories ordered from highest to lowest priority
+///
+/// All directories should be checked when looking for files.
+///
+/// Postcondition: returns at least one path (it might not exist).
+pub fn runtime_dirs() -> &'static [PathBuf] {
+    &RUNTIME_DIRS
+}
+
+/// Find file with path relative to runtime directory
+///
+/// `rel_path` should be the relative path from within the `runtime/` directory.
+/// The valid runtime directories are searched in priority order and the first
+/// file found to exist is returned, otherwise None.
+fn find_runtime_file(rel_path: &Path) -> Option<PathBuf> {
+    RUNTIME_DIRS.iter().find_map(|rt_dir| {
+        let path = rt_dir.join(rel_path);
+        if path.exists() {
+            Some(path)
+        } else {
+            None
+        }
+    })
+}
+
+/// Find file with path relative to runtime directory
+///
+/// `rel_path` should be the relative path from within the `runtime/` directory.
+/// The valid runtime directories are searched in priority order and the first
+/// file found to exist is returned, otherwise the path to the final attempt
+/// that failed.
+pub fn runtime_file(rel_path: &Path) -> PathBuf {
+    find_runtime_file(rel_path).unwrap_or_else(|| {
+        RUNTIME_DIRS
+            .last()
+            .map(|dir| dir.join(rel_path))
+            .unwrap_or_default()
+    })
 }
 
 pub fn config_dir() -> PathBuf {
@@ -60,15 +113,6 @@ pub fn config_dir() -> PathBuf {
     path
 }
 
-pub fn local_config_dirs() -> Vec<PathBuf> {
-    let directories = find_local_config_dirs()
-        .into_iter()
-        .map(|path| path.join(".helix"))
-        .collect();
-    log::debug!("Located configuration folders: {:?}", directories);
-    directories
-}
-
 pub fn cache_dir() -> PathBuf {
     // TODO: allow env var override
     let strategy = choose_base_strategy().expect("Unable to find the config directory!");
@@ -84,6 +128,10 @@ pub fn config_file() -> PathBuf {
         .unwrap_or_else(|| config_dir().join("config.toml"))
 }
 
+pub fn workspace_config_file() -> PathBuf {
+    find_workspace().0.join(".helix").join("config.toml")
+}
+
 pub fn lang_config_file() -> PathBuf {
     config_dir().join("languages.toml")
 }
@@ -92,22 +140,6 @@ pub fn log_file() -> PathBuf {
     cache_dir().join("helix.log")
 }
 
-pub fn find_local_config_dirs() -> Vec<PathBuf> {
-    let current_dir = std::env::current_dir().expect("unable to determine current directory");
-    let mut directories = Vec::new();
-
-    for ancestor in current_dir.ancestors() {
-        if ancestor.join(".git").exists() {
-            directories.push(ancestor.to_path_buf());
-            // Don't go higher than repo if we're in one
-            break;
-        } else if ancestor.join(".helix").is_dir() {
-            directories.push(ancestor.to_path_buf());
-        }
-    }
-    directories
-}
-
 /// Merge two TOML documents, merging values from `right` onto `left`
 ///
 /// When an array exists in both `left` and `right`, `right`'s array is
@@ -179,6 +211,8 @@ fn get_name(v: &Value) -> Option<&str> {
 
 #[cfg(test)]
 mod merge_toml_tests {
+    use std::str;
+
     use super::merge_toml_values;
     use toml::Value;
 
@@ -191,8 +225,9 @@ fn language_toml_map_merges() {
         indent = { tab-width = 4, unit = "    ", test = "aaa" }
         "#;
 
-        let base: Value = toml::from_slice(include_bytes!("../../languages.toml"))
-            .expect("Couldn't parse built-in languages config");
+        let base = include_bytes!("../../languages.toml");
+        let base = str::from_utf8(base).expect("Couldn't parse built-in languages config");
+        let base: Value = toml::from_str(base).expect("Couldn't parse built-in languages config");
         let user: Value = toml::from_str(USER).unwrap();
 
         let merged = merge_toml_values(base, user, 3);
@@ -224,8 +259,9 @@ fn language_toml_nested_array_merges() {
         language-server = { command = "deno", args = ["lsp"] }
         "#;
 
-        let base: Value = toml::from_slice(include_bytes!("../../languages.toml"))
-            .expect("Couldn't parse built-in languages config");
+        let base = include_bytes!("../../languages.toml");
+        let base = str::from_utf8(base).expect("Couldn't parse built-in languages config");
+        let base: Value = toml::from_str(base).expect("Couldn't parse built-in languages config");
         let user: Value = toml::from_str(USER).unwrap();
 
         let merged = merge_toml_values(base, user, 3);
@@ -245,3 +281,21 @@ fn language_toml_nested_array_merges() {
         )
     }
 }
+
+/// Finds the current workspace folder.
+/// Used as a ceiling dir for LSP root resolution, the filepicker and potentially as a future filewatching root
+///
+/// This function starts searching the FS upward from the CWD
+/// and returns the first directory that contains either `.git` or `.helix`.
+/// If no workspace was found returns (CWD, true).
+/// Otherwise (workspace, false) is returned
+pub fn find_workspace() -> (PathBuf, bool) {
+    let current_dir = std::env::current_dir().expect("unable to determine current directory");
+    for ancestor in current_dir.ancestors() {
+        if ancestor.join(".git").exists() || ancestor.join(".helix").exists() {
+            return (ancestor.to_owned(), false);
+        }
+    }
+
+    (current_dir, true)
+}
diff --git a/helix-lsp/Cargo.toml b/helix-lsp/Cargo.toml
index 05c5467ea..f85265152 100644
--- a/helix-lsp/Cargo.toml
+++ b/helix-lsp/Cargo.toml
@@ -14,15 +14,17 @@ homepage = "https://helix-editor.com"
 [dependencies]
 helix-core = { version = "0.6", path = "../helix-core" }
 helix-loader = { version = "0.6", path = "../helix-loader" }
+helix-parsec = { version = "0.6", path = "../helix-parsec" }
 
 anyhow = "1.0"
 futures-executor = "0.3"
 futures-util = { version = "0.3", features = ["std", "async-await"], default-features = false }
 log = "0.4"
-lsp-types = { version = "0.93", features = ["proposed"] }
+lsp-types = { version = "0.94" }
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
 thiserror = "1.0"
-tokio = { version = "1.22", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot", "sync"] }
-tokio-stream = "0.1.11"
-which = "4.2"
+tokio = { version = "1.27", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot", "sync"] }
+tokio-stream = "0.1.12"
+which = "4.4"
+parking_lot = "0.12.1"
diff --git a/helix-lsp/src/client.rs b/helix-lsp/src/client.rs
index dd2581c6d..93e822c44 100644
--- a/helix-lsp/src/client.rs
+++ b/helix-lsp/src/client.rs
@@ -1,21 +1,26 @@
 use crate::{
-    jsonrpc,
+    find_lsp_workspace, jsonrpc,
     transport::{Payload, Transport},
     Call, Error, OffsetEncoding, Result,
 };
 
-use helix_core::{find_root, ChangeSet, Rope};
+use helix_core::{find_workspace, path, ChangeSet, Rope};
 use helix_loader::{self, VERSION_AND_GIT_HASH};
+use lsp::{
+    notification::DidChangeWorkspaceFolders, DidChangeWorkspaceFoldersParams, OneOf,
+    PositionEncodingKind, WorkspaceFolder, WorkspaceFoldersChangeEvent,
+};
 use lsp_types as lsp;
+use parking_lot::Mutex;
 use serde::Deserialize;
 use serde_json::Value;
-use std::collections::HashMap;
 use std::future::Future;
 use std::process::Stdio;
 use std::sync::{
     atomic::{AtomicU64, Ordering},
     Arc,
 };
+use std::{collections::HashMap, path::PathBuf};
 use tokio::{
     io::{BufReader, BufWriter},
     process::{Child, Command},
@@ -25,6 +30,17 @@
     },
 };
 
+fn workspace_for_uri(uri: lsp::Url) -> WorkspaceFolder {
+    lsp::WorkspaceFolder {
+        name: uri
+            .path_segments()
+            .and_then(|segments| segments.last())
+            .map(|basename| basename.to_string())
+            .unwrap_or_default(),
+        uri,
+    }
+}
+
 #[derive(Debug)]
 pub struct Client {
     id: usize,
@@ -32,15 +48,124 @@ pub struct Client {
     server_tx: UnboundedSender<Payload>,
     request_counter: AtomicU64,
     pub(crate) capabilities: OnceCell<lsp::ServerCapabilities>,
-    offset_encoding: OffsetEncoding,
     config: Option<Value>,
     root_path: std::path::PathBuf,
     root_uri: Option<lsp::Url>,
-    workspace_folders: Vec<lsp::WorkspaceFolder>,
+    workspace_folders: Mutex<Vec<lsp::WorkspaceFolder>>,
+    initialize_notify: Arc<Notify>,
+    /// workspace folders added while the server is still initializing
     req_timeout: u64,
 }
 
 impl Client {
+    pub fn try_add_doc(
+        self: &Arc<Self>,
+        root_markers: &[String],
+        manual_roots: &[PathBuf],
+        doc_path: Option<&std::path::PathBuf>,
+        may_support_workspace: bool,
+    ) -> bool {
+        let (workspace, workspace_is_cwd) = find_workspace();
+        let workspace = path::get_normalized_path(&workspace);
+        let root = find_lsp_workspace(
+            doc_path
+                .and_then(|x| x.parent().and_then(|x| x.to_str()))
+                .unwrap_or("."),
+            root_markers,
+            manual_roots,
+            &workspace,
+            workspace_is_cwd,
+        );
+        let root_uri = root
+            .as_ref()
+            .and_then(|root| lsp::Url::from_file_path(root).ok());
+
+        if self.root_path == root.unwrap_or(workspace)
+            || root_uri.as_ref().map_or(false, |root_uri| {
+                self.workspace_folders
+                    .lock()
+                    .iter()
+                    .any(|workspace| &workspace.uri == root_uri)
+            })
+        {
+            // workspace URI is already registered so we can use this client
+            return true;
+        }
+
+        // this server definitely doesn't support multiple workspace, no need to check capabilities
+        if !may_support_workspace {
+            return false;
+        }
+
+        let Some(capabilities) = self.capabilities.get() else {
+            let client = Arc::clone(self);
+            // initialization hasn't finished yet, deal with this new root later
+            // TODO: In the edgecase that a **new root** is added
+            // for an LSP that **doesn't support workspace_folders** before initaliation is finished
+            // the new roots are ignored.
+            // That particular edgecase would require retroactively spawning new LSP
+            // clients and therefore also require us to retroactively update the corresponding
+            // documents LSP client handle. It's doable but a pretty weird edgecase so let's
+            // wait and see if anyone ever runs into it.
+            tokio::spawn(async move {
+                client.initialize_notify.notified().await;
+                if let Some(workspace_folders_caps) = client
+                    .capabilities()
+                    .workspace
+                    .as_ref()
+                    .and_then(|cap| cap.workspace_folders.as_ref())
+                    .filter(|cap| cap.supported.unwrap_or(false))
+                {
+                    client.add_workspace_folder(
+                        root_uri,
+                        &workspace_folders_caps.change_notifications,
+                    );
+                }
+            });
+            return true;
+        };
+
+        if let Some(workspace_folders_caps) = capabilities
+            .workspace
+            .as_ref()
+            .and_then(|cap| cap.workspace_folders.as_ref())
+            .filter(|cap| cap.supported.unwrap_or(false))
+        {
+            self.add_workspace_folder(root_uri, &workspace_folders_caps.change_notifications);
+            true
+        } else {
+            // the server doesn't support multi workspaces, we need a new client
+            false
+        }
+    }
+
+    fn add_workspace_folder(
+        &self,
+        root_uri: Option<lsp::Url>,
+        change_notifications: &Option<OneOf<bool, String>>,
+    ) {
+        // root_uri is None just means that there isn't really any LSP workspace
+        // associated with this file. For servers that support multiple workspaces
+        // there is just one server so we can always just use that shared instance.
+        // No need to add a new workspace root here as there is no logical root for this file
+        // let the server deal with this
+        let Some(root_uri) = root_uri else {
+            return;
+        };
+
+        // server supports workspace folders, let's add the new root to the list
+        self.workspace_folders
+            .lock()
+            .push(workspace_for_uri(root_uri.clone()));
+        if &Some(OneOf::Left(false)) == change_notifications {
+            // server specifically opted out of DidWorkspaceChange notifications
+            // let's assume the server will request the workspace folders itself
+            // and that we can therefore reuse the client (but are done now)
+            return;
+        }
+        tokio::spawn(self.did_change_workspace(vec![workspace_for_uri(root_uri)], Vec::new()));
+    }
+
     #[allow(clippy::type_complexity)]
     #[allow(clippy::too_many_arguments)]
     pub fn start(
@@ -49,6 +174,7 @@ pub fn start(
         config: Option<Value>,
         server_environment: HashMap<String, String>,
         root_markers: &[String],
+        manual_roots: &[PathBuf],
         id: usize,
         req_timeout: u64,
         doc_path: Option<&std::path::PathBuf>,
@@ -75,27 +201,26 @@ pub fn start(
 
         let (server_rx, server_tx, initialize_notify) =
             Transport::start(reader, writer, stderr, id);
-
-        let root_path = find_root(
-            doc_path.and_then(|x| x.parent().and_then(|x| x.to_str())),
+        let (workspace, workspace_is_cwd) = find_workspace();
+        let workspace = path::get_normalized_path(&workspace);
+        let root = find_lsp_workspace(
+            doc_path
+                .and_then(|x| x.parent().and_then(|x| x.to_str()))
+                .unwrap_or("."),
             root_markers,
+            manual_roots,
+            &workspace,
+            workspace_is_cwd,
         );
 
-        let root_uri = lsp::Url::from_file_path(root_path.clone()).ok();
+        // `root_uri` and `workspace_folder` can be empty in case there is no workspace
+        // `root_url` can not, use `workspace` as a fallback
+        let root_path = root.clone().unwrap_or_else(|| workspace.clone());
+        let root_uri = root.and_then(|root| lsp::Url::from_file_path(root).ok());
 
-        // TODO: support multiple workspace folders
         let workspace_folders = root_uri
             .clone()
-            .map(|root| {
-                vec![lsp::WorkspaceFolder {
-                    name: root
-                        .path_segments()
-                        .and_then(|segments| segments.last())
-                        .map(|basename| basename.to_string())
-                        .unwrap_or_default(),
-                    uri: root,
-                }]
-            })
+            .map(|root| vec![workspace_for_uri(root)])
             .unwrap_or_default();
 
         let client = Self {
@@ -104,13 +229,12 @@ pub fn start(
             server_tx,
             request_counter: AtomicU64::new(0),
             capabilities: OnceCell::new(),
-            offset_encoding: OffsetEncoding::Utf8,
             config,
             req_timeout,
-
             root_path,
             root_uri,
-            workspace_folders,
+            workspace_folders: Mutex::new(workspace_folders),
+            initialize_notify: initialize_notify.clone(),
         };
 
         Ok((client, server_rx, initialize_notify))
@@ -147,15 +271,29 @@ pub fn capabilities(&self) -> &lsp::ServerCapabilities {
     }
 
     pub fn offset_encoding(&self) -> OffsetEncoding {
-        self.offset_encoding
+        self.capabilities()
+            .position_encoding
+            .as_ref()
+            .and_then(|encoding| match encoding.as_str() {
+                "utf-8" => Some(OffsetEncoding::Utf8),
+                "utf-16" => Some(OffsetEncoding::Utf16),
+                "utf-32" => Some(OffsetEncoding::Utf32),
+                encoding => {
+                    log::error!("Server provided invalid position encoding {encoding}, defaulting to utf-16");
+                    None
+                },
+            })
+            .unwrap_or_default()
     }
 
     pub fn config(&self) -> Option<&Value> {
         self.config.as_ref()
     }
 
-    pub fn workspace_folders(&self) -> &[lsp::WorkspaceFolder] {
-        &self.workspace_folders
+    pub async fn workspace_folders(
+        &self,
+    ) -> parking_lot::MutexGuard<'_, Vec<lsp::WorkspaceFolder>> {
+        self.workspace_folders.lock()
     }
 
     /// Execute a RPC request on the language server.
@@ -190,7 +328,7 @@ fn call<R: lsp::request::Request>(
 
             let request = jsonrpc::MethodCall {
                 jsonrpc: Some(jsonrpc::Version::V2),
-                id,
+                id: id.clone(),
                 method: R::METHOD.to_string(),
                 params: Self::value_into_params(params),
             };
@@ -207,7 +345,7 @@ fn call<R: lsp::request::Request>(
             // TODO: delay other calls until initialize success
             timeout(Duration::from_secs(timeout_secs), rx.recv())
                 .await
-                .map_err(|_| Error::Timeout)? // return Timeout
+                .map_err(|_| Error::Timeout(id))? // return Timeout
                 .ok_or(Error::StreamClosed)?
         }
     }
@@ -275,7 +413,7 @@ pub fn reply(
     // General messages
     // -------------------------------------------------------------------------------------------
 
-    pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
+    pub(crate) async fn initialize(&self, enable_snippets: bool) -> Result<lsp::InitializeResult> {
         if let Some(config) = &self.config {
             log::info!("Using custom LSP config: {}", config);
         }
@@ -283,7 +421,7 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
         #[allow(deprecated)]
         let params = lsp::InitializeParams {
             process_id: Some(std::process::id()),
-            workspace_folders: Some(self.workspace_folders.clone()),
+            workspace_folders: Some(self.workspace_folders.lock().clone()),
             // root_path is obsolete, but some clients like pyright still use it so we specify both.
             // clients will prefer _uri if possible
             root_path: self.root_path.to_str().map(|path| path.to_owned()),
@@ -304,12 +442,26 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
                     execute_command: Some(lsp::DynamicRegistrationClientCapabilities {
                         dynamic_registration: Some(false),
                     }),
+                    inlay_hint: Some(lsp::InlayHintWorkspaceClientCapabilities {
+                        refresh_support: Some(false),
+                    }),
+                    workspace_edit: Some(lsp::WorkspaceEditClientCapabilities {
+                        document_changes: Some(true),
+                        resource_operations: Some(vec![
+                            lsp::ResourceOperationKind::Create,
+                            lsp::ResourceOperationKind::Rename,
+                            lsp::ResourceOperationKind::Delete,
+                        ]),
+                        failure_handling: Some(lsp::FailureHandlingKind::Abort),
+                        normalizes_line_endings: Some(false),
+                        change_annotation_support: None,
+                    }),
                     ..Default::default()
                 }),
                 text_document: Some(lsp::TextDocumentClientCapabilities {
                     completion: Some(lsp::CompletionClientCapabilities {
                         completion_item: Some(lsp::CompletionItemCapability {
-                            snippet_support: Some(false),
+                            snippet_support: Some(enable_snippets),
                             resolve_support: Some(lsp::CompletionItemCapabilityResolveSupport {
                                 properties: vec![
                                     String::from("documentation"),
@@ -318,6 +470,10 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
                                 ],
                             }),
                             insert_replace_support: Some(true),
+                            deprecated_support: Some(true),
+                            tag_support: Some(lsp::TagSupport {
+                                value_set: vec![lsp::CompletionItemTag::DEPRECATED],
+                            }),
                             ..Default::default()
                         }),
                         completion_item_kind: Some(lsp::CompletionItemKindCapability {
@@ -344,7 +500,7 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
                     }),
                     rename: Some(lsp::RenameClientCapabilities {
                         dynamic_registration: Some(false),
-                        prepare_support: Some(false),
+                        prepare_support: Some(true),
                         prepare_support_default_behavior: None,
                         honors_change_annotations: Some(false),
                     }),
@@ -369,14 +525,27 @@ pub(crate) async fn initialize(&self) -> Result<lsp::InitializeResult> {
                         ..Default::default()
                     }),
                     publish_diagnostics: Some(lsp::PublishDiagnosticsClientCapabilities {
+                        version_support: Some(true),
                         ..Default::default()
                     }),
+                    inlay_hint: Some(lsp::InlayHintClientCapabilities {
+                        dynamic_registration: Some(false),
+                        resolve_support: None,
+                    }),
                     ..Default::default()
                 }),
                 window: Some(lsp::WindowClientCapabilities {
                     work_done_progress: Some(true),
                     ..Default::default()
                 }),
+                general: Some(lsp::GeneralClientCapabilities {
+                    position_encodings: Some(vec![
+                        PositionEncodingKind::UTF8,
+                        PositionEncodingKind::UTF32,
+                        PositionEncodingKind::UTF16,
+                    ]),
+                    ..Default::default()
+                }),
                 ..Default::default()
             },
             trace: None,
@@ -423,6 +592,16 @@ pub fn did_change_configuration(&self, settings: Value) -> impl Future<Output =
         )
     }
 
+    pub fn did_change_workspace(
+        &self,
+        added: Vec<WorkspaceFolder>,
+        removed: Vec<WorkspaceFolder>,
+    ) -> impl Future<Output = Result<()>> {
+        self.notify::<DidChangeWorkspaceFolders>(DidChangeWorkspaceFoldersParams {
+            event: WorkspaceFoldersChangeEvent { added, removed },
+        })
+    }
+
     // -------------------------------------------------------------------------------------------
     // Text document
     // -------------------------------------------------------------------------------------------
@@ -577,7 +756,7 @@ pub fn text_document_did_change(
                 }]
             }
             lsp::TextDocumentSyncKind::INCREMENTAL => {
-                Self::changeset_to_changes(old_text, new_text, changes, self.offset_encoding)
+                Self::changeset_to_changes(old_text, new_text, changes, self.offset_encoding())
             }
             lsp::TextDocumentSyncKind::NONE => return None,
             kind => unimplemented!("{:?}", kind),
@@ -628,7 +807,7 @@ pub fn text_document_did_save(
         Some(self.notify::<lsp::notification::DidSaveTextDocument>(
             lsp::DidSaveTextDocumentParams {
                 text_document,
-                text: include_text.then(|| text.into()),
+                text: include_text.then_some(text.into()),
             },
         ))
     }
@@ -703,6 +882,31 @@ pub fn text_document_signature_help(
         Some(self.call::<lsp::request::SignatureHelpRequest>(params))
     }
 
+    pub fn text_document_range_inlay_hints(
+        &self,
+        text_document: lsp::TextDocumentIdentifier,
+        range: lsp::Range,
+        work_done_token: Option<lsp::ProgressToken>,
+    ) -> Option<impl Future<Output = Result<Value>>> {
+        let capabilities = self.capabilities.get().unwrap();
+
+        match capabilities.inlay_hint_provider {
+            Some(
+                lsp::OneOf::Left(true)
+                | lsp::OneOf::Right(lsp::InlayHintServerCapabilities::Options(_)),
+            ) => (),
+            _ => return None,
+        }
+
+        let params = lsp::InlayHintParams {
+            text_document,
+            range,
+            work_done_progress_params: lsp::WorkDoneProgressParams { work_done_token },
+        };
+
+        Some(self.call::<lsp::request::InlayHintRequest>(params))
+    }
+
     pub fn text_document_hover(
         &self,
         text_document: lsp::TextDocumentIdentifier,
@@ -886,6 +1090,31 @@ pub fn goto_definition(
         ))
     }
 
+    pub fn goto_declaration(
+        &self,
+        text_document: lsp::TextDocumentIdentifier,
+        position: lsp::Position,
+        work_done_token: Option<lsp::ProgressToken>,
+    ) -> Option<impl Future<Output = Result<Value>>> {
+        let capabilities = self.capabilities.get().unwrap();
+
+        // Return early if the server does not support goto-declaration.
+        match capabilities.declaration_provider {
+            Some(
+                lsp::DeclarationCapability::Simple(true)
+                | lsp::DeclarationCapability::RegistrationOptions(_)
+                | lsp::DeclarationCapability::Options(_),
+            ) => (),
+            _ => return None,
+        }
+
+        Some(self.goto_request::<lsp::request::GotoDeclaration>(
+            text_document,
+            position,
+            work_done_token,
+        ))
+    }
+
     pub fn goto_type_definition(
         &self,
         text_document: lsp::TextDocumentIdentifier,
@@ -986,6 +1215,29 @@ pub fn document_symbols(
         Some(self.call::<lsp::request::DocumentSymbolRequest>(params))
     }
 
+    pub fn prepare_rename(
+        &self,
+        text_document: lsp::TextDocumentIdentifier,
+        position: lsp::Position,
+    ) -> Option<impl Future<Output = Result<Value>>> {
+        let capabilities = self.capabilities.get().unwrap();
+
+        match capabilities.rename_provider {
+            Some(lsp::OneOf::Right(lsp::RenameOptions {
+                prepare_provider: Some(true),
+                ..
+            })) => (),
+            _ => return None,
+        }
+
+        let params = lsp::TextDocumentPositionParams {
+            text_document,
+            position,
+        };
+
+        Some(self.call::<lsp::request::PrepareRenameRequest>(params))
+    }
+
     // empty string to get all symbols
     pub fn workspace_symbols(&self, query: String) -> Option<impl Future<Output = Result<Value>>> {
         let capabilities = self.capabilities.get().unwrap();
@@ -1002,7 +1254,7 @@ pub fn workspace_symbols(&self, query: String) -> Option<impl Future<Output = Re
             partial_result_params: lsp::PartialResultParams::default(),
         };
 
-        Some(self.call::<lsp::request::WorkspaceSymbol>(params))
+        Some(self.call::<lsp::request::WorkspaceSymbolRequest>(params))
     }
 
     pub fn code_actions(
@@ -1033,20 +1285,23 @@ pub fn code_actions(
         Some(self.call::<lsp::request::CodeActionRequest>(params))
     }
 
+    pub fn supports_rename(&self) -> bool {
+        let capabilities = self.capabilities.get().unwrap();
+        matches!(
+            capabilities.rename_provider,
+            Some(lsp::OneOf::Left(true) | lsp::OneOf::Right(_))
+        )
+    }
+
     pub fn rename_symbol(
         &self,
         text_document: lsp::TextDocumentIdentifier,
         position: lsp::Position,
         new_name: String,
     ) -> Option<impl Future<Output = Result<lsp::WorkspaceEdit>>> {
-        let capabilities = self.capabilities.get().unwrap();
-
-        // Return early if the language server does not support renaming.
-        match capabilities.rename_provider {
-            Some(lsp::OneOf::Left(true)) | Some(lsp::OneOf::Right(_)) => (),
-            // None | Some(false)
-            _ => return None,
-        };
+        if !self.supports_rename() {
+            return None;
+        }
 
         let params = lsp::RenameParams {
             text_document_position: lsp::TextDocumentPositionParams {
diff --git a/helix-lsp/src/jsonrpc.rs b/helix-lsp/src/jsonrpc.rs
index 75ac9309b..f415dde0b 100644
--- a/helix-lsp/src/jsonrpc.rs
+++ b/helix-lsp/src/jsonrpc.rs
@@ -108,6 +108,16 @@ pub enum Id {
     Str(String),
 }
 
+impl std::fmt::Display for Id {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        match self {
+            Id::Null => f.write_str("null"),
+            Id::Num(num) => write!(f, "{}", num),
+            Id::Str(string) => f.write_str(string),
+        }
+    }
+}
+
 /// Protocol Version
 #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
 pub enum Version {
@@ -170,6 +180,10 @@ pub fn parse<D>(self) -> Result<D, Error>
         serde_json::from_value(value)
             .map_err(|err| Error::invalid_params(format!("Invalid params: {}.", err)))
     }
+
+    pub fn is_none(&self) -> bool {
+        self == &Params::None
+    }
 }
 
 impl From<Params> for Value {
@@ -187,7 +201,7 @@ fn from(params: Params) -> Value {
 pub struct MethodCall {
     pub jsonrpc: Option<Version>,
     pub method: String,
-    #[serde(default = "default_params")]
+    #[serde(default = "default_params", skip_serializing_if = "Params::is_none")]
     pub params: Params,
     pub id: Id,
 }
@@ -197,7 +211,7 @@ pub struct MethodCall {
 pub struct Notification {
     pub jsonrpc: Option<Version>,
     pub method: String,
-    #[serde(default = "default_params")]
+    #[serde(default = "default_params", skip_serializing_if = "Params::is_none")]
     pub params: Params,
 }
 
@@ -334,6 +348,33 @@ fn notification_serialize() {
     );
 }
 
+#[test]
+fn serialize_skip_none_params() {
+    use serde_json;
+
+    let m = MethodCall {
+        jsonrpc: Some(Version::V2),
+        method: "shutdown".to_owned(),
+        params: Params::None,
+        id: Id::Num(1),
+    };
+
+    let serialized = serde_json::to_string(&m).unwrap();
+    assert_eq!(
+        serialized,
+        r#"{"jsonrpc":"2.0","method":"shutdown","id":1}"#
+    );
+
+    let n = Notification {
+        jsonrpc: Some(Version::V2),
+        method: "exit".to_owned(),
+        params: Params::None,
+    };
+
+    let serialized = serde_json::to_string(&n).unwrap();
+    assert_eq!(serialized, r#"{"jsonrpc":"2.0","method":"exit"}"#);
+}
+
 #[test]
 fn success_output_deserialize() {
     use serde_json;
diff --git a/helix-lsp/src/lib.rs b/helix-lsp/src/lib.rs
index 8418896cb..31ee1d75c 100644
--- a/helix-lsp/src/lib.rs
+++ b/helix-lsp/src/lib.rs
@@ -1,5 +1,6 @@
 mod client;
 pub mod jsonrpc;
+pub mod snippet;
 mod transport;
 
 pub use client::Client;
@@ -9,18 +10,21 @@
 pub use lsp_types as lsp;
 
 use futures_util::stream::select_all::SelectAll;
-use helix_core::syntax::{LanguageConfiguration, LanguageServerConfiguration};
+use helix_core::{
+    path,
+    syntax::{LanguageConfiguration, LanguageServerConfiguration},
+};
 use tokio::sync::mpsc::UnboundedReceiver;
 
 use std::{
     collections::{hash_map::Entry, HashMap},
+    path::{Path, PathBuf},
     sync::{
         atomic::{AtomicUsize, Ordering},
         Arc,
     },
 };
 
-use serde::{Deserialize, Serialize};
 use thiserror::Error;
 use tokio_stream::wrappers::UnboundedReceiverStream;
 
@@ -35,8 +39,8 @@ pub enum Error {
     Parse(#[from] serde_json::Error),
     #[error("IO Error: {0}")]
     IO(#[from] std::io::Error),
-    #[error("request timed out")]
-    Timeout,
+    #[error("request {0} timed out")]
+    Timeout(jsonrpc::Id),
     #[error("server closed the stream")]
     StreamClosed,
     #[error("Unhandled")]
@@ -45,18 +49,21 @@ pub enum Error {
     Other(#[from] anyhow::Error),
 }
 
-#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
+#[derive(Clone, Copy, Debug, Default)]
 pub enum OffsetEncoding {
     /// UTF-8 code units aka bytes
-    #[serde(rename = "utf-8")]
     Utf8,
+    /// UTF-32 code units aka chars
+    Utf32,
     /// UTF-16 code units
-    #[serde(rename = "utf-16")]
+    #[default]
     Utf16,
 }
 
 pub mod util {
     use super::*;
+    use helix_core::line_ending::{line_end_byte_index, line_end_char_index};
+    use helix_core::{chars, RopeSlice, SmallVec};
     use helix_core::{diagnostic::NumberOrString, Range, Rope, Selection, Tendril, Transaction};
 
     /// Converts a diagnostic in the document to [`lsp::Diagnostic`].
@@ -117,7 +124,7 @@ pub fn diagnostic_to_lsp_diagnostic(
 
     /// Converts [`lsp::Position`] to a position in the document.
     ///
-    /// Returns `None` if position exceeds document length or an operation overflows.
+    /// Returns `None` if position.line is out of bounds or an overflow occurs
     pub fn lsp_pos_to_pos(
         doc: &Rope,
         pos: lsp::Position,
@@ -125,25 +132,70 @@ pub fn lsp_pos_to_pos(
     ) -> Option<usize> {
         let pos_line = pos.line as usize;
         if pos_line > doc.len_lines() - 1 {
-            return None;
+            // If it extends past the end, truncate it to the end. This is because the
+            // way the LSP describes the range including the last newline is by
+            // specifying a line number after what we would call the last line.
+            log::warn!("LSP position {pos:?} out of range assuming EOF");
+            return Some(doc.len_chars());
         }
 
-        match offset_encoding {
+        // We need to be careful here to fully comply ith the LSP spec.
+        // Two relevant quotes from the spec:
+        //
+        // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#position
+        // > If the character value is greater than the line length it defaults back
+        // >  to the line length.
+        //
+        // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocuments
+        // > To ensure that both client and server split the string into the same
+        // > line representation the protocol specifies the following end-of-line sequences:
+        // > \n, \r\n and \r. Positions are line end character agnostic.
+        // > So you can not specify a position that denotes \r|\n or \n| where | represents the character offset.
+        //
+        // This means that while the line must be in bounds the `character`
+        // must be capped to the end of the line.
+        // Note that the end of the line here is **before** the line terminator
+        // so we must use `line_end_char_index` instead of `doc.line_to_char(pos_line + 1)`
+        //
+        // FIXME: Helix does not fully comply with the LSP spec for line terminators.
+        // The LSP standard requires that line terminators are ['\n', '\r\n', '\r'].
+        // Without the unicode-linebreak feature disabled, the `\r` terminator is not handled by helix.
+        // With the unicode-linebreak feature, helix recognizes multiple extra line break chars
+        // which means that positions will be decoded/encoded incorrectly in their presence
+
+        let line = match offset_encoding {
             OffsetEncoding::Utf8 => {
-                let line = doc.line_to_char(pos_line);
-                let pos = line.checked_add(pos.character as usize)?;
-                if pos <= doc.len_chars() {
-                    Some(pos)
-                } else {
-                    None
-                }
+                let line_start = doc.line_to_byte(pos_line);
+                let line_end = line_end_byte_index(&doc.slice(..), pos_line);
+                line_start..line_end
             }
             OffsetEncoding::Utf16 => {
-                let line = doc.line_to_char(pos_line);
-                let line_start = doc.char_to_utf16_cu(line);
-                let pos = line_start.checked_add(pos.character as usize)?;
-                doc.try_utf16_cu_to_char(pos).ok()
+                // TODO directly translate line index to char-idx
+                // ropey can do this just as easily as utf-8 byte translation
+                // but the functions are just missing.
+                // Translate to char first and then utf-16 as a workaround
+                let line_start = doc.line_to_char(pos_line);
+                let line_end = line_end_char_index(&doc.slice(..), pos_line);
+                doc.char_to_utf16_cu(line_start)..doc.char_to_utf16_cu(line_end)
+            }
+            OffsetEncoding::Utf32 => {
+                let line_start = doc.line_to_char(pos_line);
+                let line_end = line_end_char_index(&doc.slice(..), pos_line);
+                line_start..line_end
             }
+        };
+
+        // The LSP spec demands that the offset is capped to the end of the line
+        let pos = line
+            .start
+            .checked_add(pos.character as usize)
+            .unwrap_or(line.end)
+            .min(line.end);
+
+        match offset_encoding {
+            OffsetEncoding::Utf8 => doc.try_byte_to_char(pos).ok(),
+            OffsetEncoding::Utf16 => doc.try_utf16_cu_to_char(pos).ok(),
+            OffsetEncoding::Utf32 => Some(pos),
         }
     }
 
@@ -158,8 +210,8 @@ pub fn pos_to_lsp_pos(
         match offset_encoding {
             OffsetEncoding::Utf8 => {
                 let line = doc.char_to_line(pos);
-                let line_start = doc.line_to_char(line);
-                let col = pos - line_start;
+                let line_start = doc.line_to_byte(line);
+                let col = doc.char_to_byte(pos) - line_start;
 
                 lsp::Position::new(line as u32, col as u32)
             }
@@ -168,6 +220,13 @@ pub fn pos_to_lsp_pos(
                 let line_start = doc.char_to_utf16_cu(doc.line_to_char(line));
                 let col = doc.char_to_utf16_cu(pos) - line_start;
 
+                lsp::Position::new(line as u32, col as u32)
+            }
+            OffsetEncoding::Utf32 => {
+                let line = doc.char_to_line(pos);
+                let line_start = doc.line_to_char(line);
+                let col = pos - line_start;
+
                 lsp::Position::new(line as u32, col as u32)
             }
         }
@@ -187,49 +246,247 @@ pub fn range_to_lsp_range(
 
     pub fn lsp_range_to_range(
         doc: &Rope,
-        range: lsp::Range,
+        mut range: lsp::Range,
         offset_encoding: OffsetEncoding,
     ) -> Option<Range> {
+        // This is sort of an edgecase. It's not clear from the spec how to deal with
+        // ranges where end < start. They don't make much sense but vscode simply caps start to end
+        // and because it's not specified quite a few LS rely on this as a result (for example the TS server)
+        if range.start > range.end {
+            log::error!(
+                "Invalid LSP range start {:?} > end {:?}, using an empty range at the end instead",
+                range.start,
+                range.end
+            );
+            range.start = range.end;
+        }
         let start = lsp_pos_to_pos(doc, range.start, offset_encoding)?;
         let end = lsp_pos_to_pos(doc, range.end, offset_encoding)?;
 
         Some(Range::new(start, end))
     }
 
+    /// If the LS did not provide a range for the completion or the range of the
+    /// primary cursor can not be used for the secondary cursor, this function
+    /// can be used to find the completion range for a cursor
+    fn find_completion_range(text: RopeSlice, replace_mode: bool, cursor: usize) -> (usize, usize) {
+        let start = cursor
+            - text
+                .chars_at(cursor)
+                .reversed()
+                .take_while(|ch| chars::char_is_word(*ch))
+                .count();
+        let mut end = cursor;
+        if replace_mode {
+            end += text
+                .chars_at(cursor)
+                .skip(1)
+                .take_while(|ch| chars::char_is_word(*ch))
+                .count();
+        }
+        (start, end)
+    }
+    fn completion_range(
+        text: RopeSlice,
+        edit_offset: Option<(i128, i128)>,
+        replace_mode: bool,
+        cursor: usize,
+    ) -> Option<(usize, usize)> {
+        let res = match edit_offset {
+            Some((start_offset, end_offset)) => {
+                let start_offset = cursor as i128 + start_offset;
+                if start_offset < 0 {
+                    return None;
+                }
+                let end_offset = cursor as i128 + end_offset;
+                if end_offset > text.len_chars() as i128 {
+                    return None;
+                }
+                (start_offset as usize, end_offset as usize)
+            }
+            None => find_completion_range(text, replace_mode, cursor),
+        };
+        Some(res)
+    }
+
     /// Creates a [Transaction] from the [lsp::TextEdit] in a completion response.
     /// The transaction applies the edit to all cursors.
     pub fn generate_transaction_from_completion_edit(
         doc: &Rope,
         selection: &Selection,
-        edit: lsp::TextEdit,
-        offset_encoding: OffsetEncoding,
+        edit_offset: Option<(i128, i128)>,
+        replace_mode: bool,
+        new_text: String,
     ) -> Transaction {
-        let replacement: Option<Tendril> = if edit.new_text.is_empty() {
+        let replacement: Option<Tendril> = if new_text.is_empty() {
             None
         } else {
-            Some(edit.new_text.into())
+            Some(new_text.into())
         };
 
         let text = doc.slice(..);
-        let primary_cursor = selection.primary().cursor(text);
+        let (removed_start, removed_end) = completion_range(
+            text,
+            edit_offset,
+            replace_mode,
+            selection.primary().cursor(text),
+        )
+        .expect("transaction must be valid for primary selection");
+        let removed_text = text.slice(removed_start..removed_end);
 
-        let start_offset = match lsp_pos_to_pos(doc, edit.range.start, offset_encoding) {
-            Some(start) => start as i128 - primary_cursor as i128,
-            None => return Transaction::new(doc),
-        };
-        let end_offset = match lsp_pos_to_pos(doc, edit.range.end, offset_encoding) {
-            Some(end) => end as i128 - primary_cursor as i128,
-            None => return Transaction::new(doc),
-        };
+        let (transaction, mut selection) = Transaction::change_by_selection_ignore_overlapping(
+            doc,
+            selection,
+            |range| {
+                let cursor = range.cursor(text);
+                completion_range(text, edit_offset, replace_mode, cursor)
+                    .filter(|(start, end)| text.slice(start..end) == removed_text)
+                    .unwrap_or_else(|| find_completion_range(text, replace_mode, cursor))
+            },
+            |_, _| replacement.clone(),
+        );
+        if transaction.changes().is_empty() {
+            return transaction;
+        }
+        selection = selection.map(transaction.changes());
+        transaction.with_selection(selection)
+    }
 
-        Transaction::change_by_selection(doc, selection, |range| {
-            let cursor = range.cursor(text);
-            (
-                (cursor as i128 + start_offset) as usize,
-                (cursor as i128 + end_offset) as usize,
-                replacement.clone(),
-            )
-        })
+    /// Creates a [Transaction] from the [snippet::Snippet] in a completion response.
+    /// The transaction applies the edit to all cursors.
+    #[allow(clippy::too_many_arguments)]
+    pub fn generate_transaction_from_snippet(
+        doc: &Rope,
+        selection: &Selection,
+        edit_offset: Option<(i128, i128)>,
+        replace_mode: bool,
+        snippet: snippet::Snippet,
+        line_ending: &str,
+        include_placeholder: bool,
+        tab_width: usize,
+        indent_width: usize,
+    ) -> Transaction {
+        let text = doc.slice(..);
+
+        let mut off = 0i128;
+        let mut mapped_doc = doc.clone();
+        let mut selection_tabstops: SmallVec<[_; 1]> = SmallVec::new();
+        let (removed_start, removed_end) = completion_range(
+            text,
+            edit_offset,
+            replace_mode,
+            selection.primary().cursor(text),
+        )
+        .expect("transaction must be valid for primary selection");
+        let removed_text = text.slice(removed_start..removed_end);
+
+        let (transaction, selection) = Transaction::change_by_selection_ignore_overlapping(
+            doc,
+            selection,
+            |range| {
+                let cursor = range.cursor(text);
+                completion_range(text, edit_offset, replace_mode, cursor)
+                    .filter(|(start, end)| text.slice(start..end) == removed_text)
+                    .unwrap_or_else(|| find_completion_range(text, replace_mode, cursor))
+            },
+            |replacement_start, replacement_end| {
+                let mapped_replacement_start = (replacement_start as i128 + off) as usize;
+                let mapped_replacement_end = (replacement_end as i128 + off) as usize;
+
+                let line_idx = mapped_doc.char_to_line(mapped_replacement_start);
+                let indent_level = helix_core::indent::indent_level_for_line(
+                    mapped_doc.line(line_idx),
+                    tab_width,
+                    indent_width,
+                ) * indent_width;
+
+                let newline_with_offset = format!(
+                    "{line_ending}{blank:indent_level$}",
+                    line_ending = line_ending,
+                    blank = ""
+                );
+
+                let (replacement, tabstops) =
+                    snippet::render(&snippet, &newline_with_offset, include_placeholder);
+                selection_tabstops.push((mapped_replacement_start, tabstops));
+                mapped_doc.remove(mapped_replacement_start..mapped_replacement_end);
+                mapped_doc.insert(mapped_replacement_start, &replacement);
+                off +=
+                    replacement_start as i128 - replacement_end as i128 + replacement.len() as i128;
+
+                Some(replacement)
+            },
+        );
+
+        let changes = transaction.changes();
+        if changes.is_empty() {
+            return transaction;
+        }
+
+        let mut mapped_selection = SmallVec::with_capacity(selection.len());
+        let mut mapped_primary_idx = 0;
+        let primary_range = selection.primary();
+        for (range, (tabstop_anchor, tabstops)) in selection.into_iter().zip(selection_tabstops) {
+            if range == primary_range {
+                mapped_primary_idx = mapped_selection.len()
+            }
+
+            let range = range.map(changes);
+            let tabstops = tabstops.first().filter(|tabstops| !tabstops.is_empty());
+            let Some(tabstops) = tabstops else{
+                // no tabstop normal mapping
+                mapped_selection.push(range);
+                continue;
+            };
+
+            // expand the selection to cover the tabstop to retain the helix selection semantic
+            // the tabstop closest to the range simply replaces `head` while anchor remains in place
+            // the remaining tabstops receive their own single-width cursor
+            if range.head < range.anchor {
+                let first_tabstop = tabstop_anchor + tabstops[0].1;
+
+                // if selection is forward but was moved to the right it is
+                // contained entirely in the replacement text, just do a point
+                // selection (fallback below)
+                if range.anchor >= first_tabstop {
+                    let range = Range::new(range.anchor, first_tabstop);
+                    mapped_selection.push(range);
+                    let rem_tabstops = tabstops[1..]
+                        .iter()
+                        .map(|tabstop| Range::point(tabstop_anchor + tabstop.1));
+                    mapped_selection.extend(rem_tabstops);
+                    continue;
+                }
+            } else {
+                let last_idx = tabstops.len() - 1;
+                let last_tabstop = tabstop_anchor + tabstops[last_idx].1;
+
+                // if selection is forward but was moved to the right it is
+                // contained entirely in the replacement text, just do a point
+                // selection (fallback below)
+                if range.anchor <= last_tabstop {
+                    // we can't properly compute the the next grapheme
+                    // here because the transaction hasn't been applied yet
+                    // that is not a problem because the range gets grapheme aligned anyway
+                    // tough so just adding one will always cause head to be grapheme
+                    // aligned correctly when applied to the document
+                    let range = Range::new(range.anchor, last_tabstop + 1);
+                    mapped_selection.push(range);
+                    let rem_tabstops = tabstops[..last_idx]
+                        .iter()
+                        .map(|tabstop| Range::point(tabstop_anchor + tabstop.0));
+                    mapped_selection.extend(rem_tabstops);
+                    continue;
+                }
+            };
+
+            let tabstops = tabstops
+                .iter()
+                .map(|tabstop| Range::point(tabstop_anchor + tabstop.0));
+            mapped_selection.extend(tabstops);
+        }
+
+        transaction.with_selection(Selection::new(mapped_selection, mapped_primary_idx))
     }
 
     pub fn generate_transaction_from_edits(
@@ -288,6 +545,7 @@ pub enum MethodCall {
     ApplyWorkspaceEdit(lsp::ApplyWorkspaceEditParams),
     WorkspaceFolders,
     WorkspaceConfiguration(lsp::ConfigurationParams),
+    RegisterCapability(lsp::RegistrationParams),
 }
 
 impl MethodCall {
@@ -307,6 +565,10 @@ pub fn parse(method: &str, params: jsonrpc::Params) -> Result<MethodCall> {
                 let params: lsp::ConfigurationParams = params.parse()?;
                 Self::WorkspaceConfiguration(params)
             }
+            lsp::request::RegisterCapability::METHOD => {
+                let params: lsp::RegistrationParams = params.parse()?;
+                Self::RegisterCapability(params)
+            }
             _ => {
                 return Err(Error::Unhandled);
             }
@@ -362,7 +624,7 @@ pub fn parse(method: &str, params: jsonrpc::Params) -> Result<Notification> {
 
 #[derive(Debug)]
 pub struct Registry {
-    inner: HashMap<LanguageId, (usize, Arc<Client>)>,
+    inner: HashMap<LanguageId, Vec<(usize, Arc<Client>)>>,
 
     counter: AtomicUsize,
     pub incoming: SelectAll<UnboundedReceiverStream<(usize, Call)>>,
@@ -386,18 +648,24 @@ pub fn new() -> Self {
     pub fn get_by_id(&self, id: usize) -> Option<&Client> {
         self.inner
             .values()
+            .flatten()
             .find(|(client_id, _)| client_id == &id)
             .map(|(_, client)| client.as_ref())
     }
 
     pub fn remove_by_id(&mut self, id: usize) {
-        self.inner.retain(|_, (client_id, _)| client_id != &id)
+        self.inner.retain(|_, clients| {
+            clients.retain(|&(client_id, _)| client_id != id);
+            !clients.is_empty()
+        })
     }
 
     pub fn restart(
         &mut self,
         language_config: &LanguageConfiguration,
         doc_path: Option<&std::path::PathBuf>,
+        root_dirs: &[PathBuf],
+        enable_snippets: bool,
     ) -> Result<Option<Arc<Client>>> {
         let config = match &language_config.language_server {
             Some(config) => config,
@@ -412,49 +680,78 @@ pub fn restart(
                 // initialize a new client
                 let id = self.counter.fetch_add(1, Ordering::Relaxed);
 
-                let NewClientResult(client, incoming) =
-                    start_client(id, language_config, config, doc_path)?;
+                let NewClientResult(client, incoming) = start_client(
+                    id,
+                    language_config,
+                    config,
+                    doc_path,
+                    root_dirs,
+                    enable_snippets,
+                )?;
                 self.incoming.push(UnboundedReceiverStream::new(incoming));
 
-                let (_, old_client) = entry.insert((id, client.clone()));
+                let old_clients = entry.insert(vec![(id, client.clone())]);
 
-                tokio::spawn(async move {
-                    let _ = old_client.force_shutdown().await;
-                });
+                for (_, old_client) in old_clients {
+                    tokio::spawn(async move {
+                        let _ = old_client.force_shutdown().await;
+                    });
+                }
 
                 Ok(Some(client))
             }
         }
     }
 
+    pub fn stop(&mut self, language_config: &LanguageConfiguration) {
+        let scope = language_config.scope.clone();
+
+        if let Some(clients) = self.inner.remove(&scope) {
+            for (_, client) in clients {
+                tokio::spawn(async move {
+                    let _ = client.force_shutdown().await;
+                });
+            }
+        }
+    }
+
     pub fn get(
         &mut self,
         language_config: &LanguageConfiguration,
         doc_path: Option<&std::path::PathBuf>,
+        root_dirs: &[PathBuf],
+        enable_snippets: bool,
     ) -> Result<Option<Arc<Client>>> {
         let config = match &language_config.language_server {
             Some(config) => config,
             None => return Ok(None),
         };
 
-        match self.inner.entry(language_config.scope.clone()) {
-            Entry::Occupied(entry) => Ok(Some(entry.get().1.clone())),
-            Entry::Vacant(entry) => {
-                // initialize a new client
-                let id = self.counter.fetch_add(1, Ordering::Relaxed);
-
-                let NewClientResult(client, incoming) =
-                    start_client(id, language_config, config, doc_path)?;
-                self.incoming.push(UnboundedReceiverStream::new(incoming));
-
-                entry.insert((id, client.clone()));
-                Ok(Some(client))
-            }
+        let clients = self.inner.entry(language_config.scope.clone()).or_default();
+        // check if we already have a client for this documents root that we can reuse
+        if let Some((_, client)) = clients.iter_mut().enumerate().find(|(i, (_, client))| {
+            client.try_add_doc(&language_config.roots, root_dirs, doc_path, *i == 0)
+        }) {
+            return Ok(Some(client.1.clone()));
         }
+        // initialize a new client
+        let id = self.counter.fetch_add(1, Ordering::Relaxed);
+
+        let NewClientResult(client, incoming) = start_client(
+            id,
+            language_config,
+            config,
+            doc_path,
+            root_dirs,
+            enable_snippets,
+        )?;
+        clients.push((id, client.clone()));
+        self.incoming.push(UnboundedReceiverStream::new(incoming));
+        Ok(Some(client))
     }
 
     pub fn iter_clients(&self) -> impl Iterator<Item = &Arc<Client>> {
-        self.inner.values().map(|(_, client)| client)
+        self.inner.values().flatten().map(|(_, client)| client)
     }
 }
 
@@ -545,6 +842,8 @@ fn start_client(
     config: &LanguageConfiguration,
     ls_config: &LanguageServerConfiguration,
     doc_path: Option<&std::path::PathBuf>,
+    root_dirs: &[PathBuf],
+    enable_snippets: bool,
 ) -> Result<NewClientResult> {
     let (client, incoming, initialize_notify) = Client::start(
         &ls_config.command,
@@ -552,6 +851,7 @@ fn start_client(
         config.config.clone(),
         ls_config.environment.clone(),
         &config.roots,
+        config.workspace_lsp_roots.as_deref().unwrap_or(root_dirs),
         id,
         ls_config.timeout,
         doc_path,
@@ -567,7 +867,7 @@ fn start_client(
             .capabilities
             .get_or_try_init(|| {
                 _client
-                    .initialize()
+                    .initialize(enable_snippets)
                     .map_ok(|response| response.capabilities)
             })
             .await;
@@ -589,6 +889,65 @@ fn start_client(
     Ok(NewClientResult(client, incoming))
 }
 
+/// Find an LSP workspace of a file using the following mechanism:
+/// * if the file is outside `workspace` return `None`
+/// * start at `file` and search the file tree upward
+/// * stop the search at the first `root_dirs` entry that contains `file`
+/// * if no `root_dirs` matches `file` stop at workspace
+/// * Returns the top most directory that contains a `root_marker`
+/// * If no root marker and we stopped at a `root_dirs` entry, return the directory we stopped at
+/// * If we stopped at `workspace` instead and `workspace_is_cwd == false` return `None`
+/// * If we stopped at `workspace` instead and `workspace_is_cwd == true` return `workspace`
+pub fn find_lsp_workspace(
+    file: &str,
+    root_markers: &[String],
+    root_dirs: &[PathBuf],
+    workspace: &Path,
+    workspace_is_cwd: bool,
+) -> Option<PathBuf> {
+    let file = std::path::Path::new(file);
+    let mut file = if file.is_absolute() {
+        file.to_path_buf()
+    } else {
+        let current_dir = std::env::current_dir().expect("unable to determine current directory");
+        current_dir.join(file)
+    };
+    file = path::get_normalized_path(&file);
+
+    if !file.starts_with(workspace) {
+        return None;
+    }
+
+    let mut top_marker = None;
+    for ancestor in file.ancestors() {
+        if root_markers
+            .iter()
+            .any(|marker| ancestor.join(marker).exists())
+        {
+            top_marker = Some(ancestor);
+        }
+
+        if root_dirs
+            .iter()
+            .any(|root_dir| path::get_normalized_path(&workspace.join(root_dir)) == ancestor)
+        {
+            // if the worskapce is the cwd do not search any higher for workspaces
+            // but specify
+            return Some(top_marker.unwrap_or(workspace).to_owned());
+        }
+        if ancestor == workspace {
+            // if the workspace is the CWD, let the LSP decide what the workspace
+            // is
+            return top_marker
+                .or_else(|| (!workspace_is_cwd).then_some(workspace))
+                .map(Path::to_owned);
+        }
+    }
+
+    debug_assert!(false, "workspace must be an ancestor of <file>");
+    None
+}
+
 #[cfg(test)]
 mod tests {
     use super::{lsp, util::*, OffsetEncoding};
@@ -606,16 +965,55 @@ macro_rules! test_case {
         }
 
         test_case!("", (0, 0) => Some(0));
-        test_case!("", (0, 1) => None);
-        test_case!("", (1, 0) => None);
+        test_case!("", (0, 1) => Some(0));
+        test_case!("", (1, 0) => Some(0));
         test_case!("\n\n", (0, 0) => Some(0));
         test_case!("\n\n", (1, 0) => Some(1));
-        test_case!("\n\n", (1, 1) => Some(2));
+        test_case!("\n\n", (1, 1) => Some(1));
         test_case!("\n\n", (2, 0) => Some(2));
-        test_case!("\n\n", (3, 0) => None);
+        test_case!("\n\n", (3, 0) => Some(2));
         test_case!("test\n\n\n\ncase", (4, 3) => Some(11));
         test_case!("test\n\n\n\ncase", (4, 4) => Some(12));
-        test_case!("test\n\n\n\ncase", (4, 5) => None);
-        test_case!("", (u32::MAX, u32::MAX) => None);
+        test_case!("test\n\n\n\ncase", (4, 5) => Some(12));
+        test_case!("", (u32::MAX, u32::MAX) => Some(0));
+    }
+
+    #[test]
+    fn emoji_format_gh_4791() {
+        use lsp_types::{Position, Range, TextEdit};
+
+        let edits = vec![
+            TextEdit {
+                range: Range {
+                    start: Position {
+                        line: 0,
+                        character: 1,
+                    },
+                    end: Position {
+                        line: 1,
+                        character: 0,
+                    },
+                },
+                new_text: "\n  ".to_string(),
+            },
+            TextEdit {
+                range: Range {
+                    start: Position {
+                        line: 1,
+                        character: 7,
+                    },
+                    end: Position {
+                        line: 2,
+                        character: 0,
+                    },
+                },
+                new_text: "\n  ".to_string(),
+            },
+        ];
+
+        let mut source = Rope::from_str("[\n\"\",\n\"\",\n]");
+
+        let transaction = generate_transaction_from_edits(&source, edits, OffsetEncoding::Utf8);
+        assert!(transaction.apply(&mut source));
     }
 }
diff --git a/helix-lsp/src/snippet.rs b/helix-lsp/src/snippet.rs
new file mode 100644
index 000000000..ebf3da240
--- /dev/null
+++ b/helix-lsp/src/snippet.rs
@@ -0,0 +1,1010 @@
+use std::borrow::Cow;
+
+use anyhow::{anyhow, Result};
+use helix_core::{smallvec, SmallVec, Tendril};
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum CaseChange {
+    Upcase,
+    Downcase,
+    Capitalize,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum FormatItem {
+    Text(Tendril),
+    Capture(usize),
+    CaseChange(usize, CaseChange),
+    Conditional(usize, Option<Tendril>, Option<Tendril>),
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub struct Regex {
+    value: Tendril,
+    replacement: Vec<FormatItem>,
+    options: Tendril,
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum SnippetElement<'a> {
+    Tabstop {
+        tabstop: usize,
+    },
+    Placeholder {
+        tabstop: usize,
+        value: Vec<SnippetElement<'a>>,
+    },
+    Choice {
+        tabstop: usize,
+        choices: Vec<Tendril>,
+    },
+    Variable {
+        name: &'a str,
+        default: Option<Vec<SnippetElement<'a>>>,
+        regex: Option<Regex>,
+    },
+    Text(Tendril),
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub struct Snippet<'a> {
+    elements: Vec<SnippetElement<'a>>,
+}
+
+pub fn parse(s: &str) -> Result<Snippet<'_>> {
+    parser::parse(s).map_err(|rest| anyhow!("Failed to parse snippet. Remaining input: {}", rest))
+}
+
+fn render_elements(
+    snippet_elements: &[SnippetElement<'_>],
+    insert: &mut Tendril,
+    offset: &mut usize,
+    tabstops: &mut Vec<(usize, (usize, usize))>,
+    newline_with_offset: &str,
+    include_placeholder: bool,
+) {
+    use SnippetElement::*;
+
+    for element in snippet_elements {
+        match element {
+            Text(text) => {
+                // small optimization to avoid calling replace when it's unnecessary
+                let text = if text.contains('\n') {
+                    Cow::Owned(text.replace('\n', newline_with_offset))
+                } else {
+                    Cow::Borrowed(text.as_str())
+                };
+                *offset += text.chars().count();
+                insert.push_str(&text);
+            }
+            Variable {
+                name: _,
+                regex: _,
+                r#default,
+            } => {
+                // TODO: variables. For now, fall back to the default, which defaults to "".
+                render_elements(
+                    r#default.as_deref().unwrap_or_default(),
+                    insert,
+                    offset,
+                    tabstops,
+                    newline_with_offset,
+                    include_placeholder,
+                );
+            }
+            &Tabstop { tabstop } => {
+                tabstops.push((tabstop, (*offset, *offset)));
+            }
+            Placeholder {
+                tabstop,
+                value: inner_snippet_elements,
+            } => {
+                let start_offset = *offset;
+                if include_placeholder {
+                    render_elements(
+                        inner_snippet_elements,
+                        insert,
+                        offset,
+                        tabstops,
+                        newline_with_offset,
+                        include_placeholder,
+                    );
+                }
+                tabstops.push((*tabstop, (start_offset, *offset)));
+            }
+            &Choice {
+                tabstop,
+                choices: _,
+            } => {
+                // TODO: choices
+                tabstops.push((tabstop, (*offset, *offset)));
+            }
+        }
+    }
+}
+
+#[allow(clippy::type_complexity)] // only used one time
+pub fn render(
+    snippet: &Snippet<'_>,
+    newline_with_offset: &str,
+    include_placeholder: bool,
+) -> (Tendril, Vec<SmallVec<[(usize, usize); 1]>>) {
+    let mut insert = Tendril::new();
+    let mut tabstops = Vec::new();
+    let mut offset = 0;
+
+    render_elements(
+        &snippet.elements,
+        &mut insert,
+        &mut offset,
+        &mut tabstops,
+        newline_with_offset,
+        include_placeholder,
+    );
+
+    // sort in ascending order (except for 0, which should always be the last one (per lsp doc))
+    tabstops.sort_unstable_by_key(|(n, _)| if *n == 0 { usize::MAX } else { *n });
+
+    // merge tabstops with the same index (we take advantage of the fact that we just sorted them
+    // above to simply look backwards)
+    let mut ntabstops = Vec::<SmallVec<[(usize, usize); 1]>>::new();
+    {
+        let mut prev = None;
+        for (tabstop, r) in tabstops {
+            if prev == Some(tabstop) {
+                let len_1 = ntabstops.len() - 1;
+                ntabstops[len_1].push(r);
+            } else {
+                prev = Some(tabstop);
+                ntabstops.push(smallvec![r]);
+            }
+        }
+    }
+
+    (insert, ntabstops)
+}
+
+mod parser {
+    use helix_core::Tendril;
+    use helix_parsec::*;
+
+    use super::{CaseChange, FormatItem, Regex, Snippet, SnippetElement};
+
+    /*
+    https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax
+
+        any         ::= tabstop | placeholder | choice | variable | text
+        tabstop     ::= '$' int | '${' int '}'
+        placeholder ::= '${' int ':' any '}'
+        choice      ::= '${' int '|' text (',' text)* '|}'
+        variable    ::= '$' var | '${' var }'
+                        | '${' var ':' any '}'
+                        | '${' var '/' regex '/' (format | text)+ '/' options '}'
+        format      ::= '$' int | '${' int '}'
+                        | '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
+                        | '${' int ':+' if '}'
+                        | '${' int ':?' if ':' else '}'
+                        | '${' int ':-' else '}' | '${' int ':' else '}'
+        regex       ::= Regular Expression value (ctor-string)
+        options     ::= Regular Expression option (ctor-options)
+        var         ::= [_a-zA-Z] [_a-zA-Z0-9]*
+        int         ::= [0-9]+
+        text        ::= .*
+        if          ::= text
+        else        ::= text
+    */
+
+    fn var<'a>() -> impl Parser<'a, Output = &'a str> {
+        // var = [_a-zA-Z][_a-zA-Z0-9]*
+        move |input: &'a str| {
+            input
+                .char_indices()
+                .take_while(|(p, c)| {
+                    *c == '_'
+                        || if *p == 0 {
+                            c.is_ascii_alphabetic()
+                        } else {
+                            c.is_ascii_alphanumeric()
+                        }
+                })
+                .last()
+                .map(|(index, c)| {
+                    let index = index + c.len_utf8();
+                    (&input[index..], &input[0..index])
+                })
+                .ok_or(input)
+        }
+    }
+
+    const TEXT_ESCAPE_CHARS: &[char] = &['\\', '}', '$'];
+    const CHOICE_TEXT_ESCAPE_CHARS: &[char] = &['\\', '|', ','];
+
+    fn text<'a>(
+        escape_chars: &'static [char],
+        term_chars: &'static [char],
+    ) -> impl Parser<'a, Output = Tendril> {
+        move |input: &'a str| {
+            let mut chars = input.char_indices().peekable();
+            let mut res = Tendril::new();
+            while let Some((i, c)) = chars.next() {
+                match c {
+                    '\\' => {
+                        if let Some(&(_, c)) = chars.peek() {
+                            if escape_chars.contains(&c) {
+                                chars.next();
+                                res.push(c);
+                                continue;
+                            }
+                        }
+                        res.push('\\');
+                    }
+                    c if term_chars.contains(&c) => return Ok((&input[i..], res)),
+                    c => res.push(c),
+                }
+            }
+
+            Ok(("", res))
+        }
+    }
+
+    fn digit<'a>() -> impl Parser<'a, Output = usize> {
+        filter_map(take_while(|c| c.is_ascii_digit()), |s| s.parse().ok())
+    }
+
+    fn case_change<'a>() -> impl Parser<'a, Output = CaseChange> {
+        use CaseChange::*;
+
+        choice!(
+            map("upcase", |_| Upcase),
+            map("downcase", |_| Downcase),
+            map("capitalize", |_| Capitalize),
+        )
+    }
+
+    fn format<'a>() -> impl Parser<'a, Output = FormatItem> {
+        use FormatItem::*;
+
+        choice!(
+            // '$' int
+            map(right("$", digit()), Capture),
+            // '${' int '}'
+            map(seq!("${", digit(), "}"), |seq| Capture(seq.1)),
+            // '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'
+            map(seq!("${", digit(), ":/", case_change(), "}"), |seq| {
+                CaseChange(seq.1, seq.3)
+            }),
+            // '${' int ':+' if '}'
+            map(
+                seq!("${", digit(), ":+", text(TEXT_ESCAPE_CHARS, &['}']), "}"),
+                |seq| { Conditional(seq.1, Some(seq.3), None) }
+            ),
+            // '${' int ':?' if ':' else '}'
+            map(
+                seq!(
+                    "${",
+                    digit(),
+                    ":?",
+                    text(TEXT_ESCAPE_CHARS, &[':']),
+                    ":",
+                    text(TEXT_ESCAPE_CHARS, &['}']),
+                    "}"
+                ),
+                |seq| { Conditional(seq.1, Some(seq.3), Some(seq.5)) }
+            ),
+            // '${' int ':-' else '}' | '${' int ':' else '}'
+            map(
+                seq!(
+                    "${",
+                    digit(),
+                    ":",
+                    optional("-"),
+                    text(TEXT_ESCAPE_CHARS, &['}']),
+                    "}"
+                ),
+                |seq| { Conditional(seq.1, None, Some(seq.4)) }
+            ),
+        )
+    }
+
+    fn regex<'a>() -> impl Parser<'a, Output = Regex> {
+        map(
+            seq!(
+                "/",
+                // TODO parse as ECMAScript and convert to rust regex
+                text(&['/'], &['/']),
+                "/",
+                zero_or_more(choice!(
+                    format(),
+                    // text doesn't parse $, if format fails we just accept the $ as text
+                    map("$", |_| FormatItem::Text("$".into())),
+                    map(text(&['\\', '/'], &['/', '$']), FormatItem::Text),
+                )),
+                "/",
+                // vscode really doesn't allow escaping } here
+                // so it's impossible to write a regex escape containing a }
+                // we can consider deviating here and allowing the escape
+                text(&[], &['}']),
+            ),
+            |(_, value, _, replacement, _, options)| Regex {
+                value,
+                replacement,
+                options,
+            },
+        )
+    }
+
+    fn tabstop<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
+        map(
+            or(
+                right("$", digit()),
+                map(seq!("${", digit(), "}"), |values| values.1),
+            ),
+            |digit| SnippetElement::Tabstop { tabstop: digit },
+        )
+    }
+
+    fn placeholder<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
+        map(
+            seq!(
+                "${",
+                digit(),
+                ":",
+                // according to the grammar there is just a single anything here.
+                // However in the prose it is explained that placeholders can be nested.
+                // The example there contains both a placeholder text and a nested placeholder
+                // which indicates a list. Looking at the VSCode sourcecode, the placeholder
+                // is indeed parsed as zero_or_more so the grammar is simply incorrect here
+                zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
+                "}"
+            ),
+            |seq| SnippetElement::Placeholder {
+                tabstop: seq.1,
+                value: seq.3,
+            },
+        )
+    }
+
+    fn choice<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
+        map(
+            seq!(
+                "${",
+                digit(),
+                "|",
+                sep(text(CHOICE_TEXT_ESCAPE_CHARS, &['|', ',']), ","),
+                "|}",
+            ),
+            |seq| SnippetElement::Choice {
+                tabstop: seq.1,
+                choices: seq.3,
+            },
+        )
+    }
+
+    fn variable<'a>() -> impl Parser<'a, Output = SnippetElement<'a>> {
+        choice!(
+            // $var
+            map(right("$", var()), |name| SnippetElement::Variable {
+                name,
+                default: None,
+                regex: None,
+            }),
+            // ${var}
+            map(seq!("${", var(), "}",), |values| SnippetElement::Variable {
+                name: values.1,
+                default: None,
+                regex: None,
+            }),
+            // ${var:default}
+            map(
+                seq!(
+                    "${",
+                    var(),
+                    ":",
+                    zero_or_more(anything(TEXT_ESCAPE_CHARS, true)),
+                    "}",
+                ),
+                |values| SnippetElement::Variable {
+                    name: values.1,
+                    default: Some(values.3),
+                    regex: None,
+                }
+            ),
+            // ${var/value/format/options}
+            map(seq!("${", var(), regex(), "}"), |values| {
+                SnippetElement::Variable {
+                    name: values.1,
+                    default: None,
+                    regex: Some(values.2),
+                }
+            }),
+        )
+    }
+
+    fn anything<'a>(
+        escape_chars: &'static [char],
+        end_at_brace: bool,
+    ) -> impl Parser<'a, Output = SnippetElement<'a>> {
+        let term_chars: &[_] = if end_at_brace { &['$', '}'] } else { &['$'] };
+        move |input: &'a str| {
+            let parser = choice!(
+                tabstop(),
+                placeholder(),
+                choice(),
+                variable(),
+                map("$", |_| SnippetElement::Text("$".into())),
+                map(text(escape_chars, term_chars), SnippetElement::Text),
+            );
+            parser.parse(input)
+        }
+    }
+
+    fn snippet<'a>() -> impl Parser<'a, Output = Snippet<'a>> {
+        map(one_or_more(anything(TEXT_ESCAPE_CHARS, false)), |parts| {
+            Snippet { elements: parts }
+        })
+    }
+
+    pub fn parse(s: &str) -> Result<Snippet, &str> {
+        snippet().parse(s).and_then(|(remainder, snippet)| {
+            if remainder.is_empty() {
+                Ok(snippet)
+            } else {
+                Err(remainder)
+            }
+        })
+    }
+
+    #[cfg(test)]
+    mod test {
+        use super::SnippetElement::*;
+        use super::*;
+
+        #[test]
+        fn empty_string_is_error() {
+            assert_eq!(Err(""), parse(""));
+        }
+
+        #[test]
+        fn parse_placeholders_in_function_call() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![
+                        Text("match(".into()),
+                        Placeholder {
+                            tabstop: 1,
+                            value: vec!(Text("Arg1".into())),
+                        },
+                        Text(")".into())
+                    ]
+                }),
+                parse("match(${1:Arg1})")
+            )
+        }
+
+        #[test]
+        fn unterminated_placeholder() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![Text("match(".into()), Text("$".into()), Text("{1:)".into())]
+                }),
+                parse("match(${1:)")
+            )
+        }
+
+        #[test]
+        fn parse_empty_placeholder() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![
+                        Text("match(".into()),
+                        Placeholder {
+                            tabstop: 1,
+                            value: vec![],
+                        },
+                        Text(")".into())
+                    ]
+                }),
+                parse("match(${1:})")
+            )
+        }
+
+        #[test]
+        fn parse_placeholders_in_statement() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![
+                        Text("local ".into()),
+                        Placeholder {
+                            tabstop: 1,
+                            value: vec!(Text("var".into())),
+                        },
+                        Text(" = ".into()),
+                        Placeholder {
+                            tabstop: 1,
+                            value: vec!(Text("value".into())),
+                        },
+                    ]
+                }),
+                parse("local ${1:var} = ${1:value}")
+            )
+        }
+
+        #[test]
+        fn parse_tabstop_nested_in_placeholder() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![Placeholder {
+                        tabstop: 1,
+                        value: vec!(Text("var, ".into()), Tabstop { tabstop: 2 },),
+                    },]
+                }),
+                parse("${1:var, $2}")
+            )
+        }
+
+        #[test]
+        fn parse_placeholder_nested_in_placeholder() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![Placeholder {
+                        tabstop: 1,
+                        value: vec!(
+                            Text("foo ".into()),
+                            Placeholder {
+                                tabstop: 2,
+                                value: vec!(Text("bar".into())),
+                            },
+                        ),
+                    },]
+                }),
+                parse("${1:foo ${2:bar}}")
+            )
+        }
+
+        #[test]
+        fn parse_all() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![
+                        Text("hello ".into()),
+                        Tabstop { tabstop: 1 },
+                        Tabstop { tabstop: 2 },
+                        Text(" ".into()),
+                        Choice {
+                            tabstop: 1,
+                            choices: vec!["one".into(), "two".into(), "three".into()]
+                        },
+                        Text(" ".into()),
+                        Variable {
+                            name: "name",
+                            default: Some(vec![Text("foo".into())]),
+                            regex: None
+                        },
+                        Text(" ".into()),
+                        Variable {
+                            name: "var",
+                            default: None,
+                            regex: None
+                        },
+                        Text(" ".into()),
+                        Variable {
+                            name: "TM",
+                            default: None,
+                            regex: None
+                        },
+                    ]
+                }),
+                parse("hello $1${2} ${1|one,two,three|} ${name:foo} $var $TM")
+            );
+        }
+
+        #[test]
+        fn regex_capture_replace() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![Variable {
+                        name: "TM_FILENAME",
+                        default: None,
+                        regex: Some(Regex {
+                            value: "(.*).+$".into(),
+                            replacement: vec![FormatItem::Capture(1), FormatItem::Text("$".into())],
+                            options: Tendril::new(),
+                        }),
+                    }]
+                }),
+                parse("${TM_FILENAME/(.*).+$/$1$/}")
+            );
+        }
+
+        #[test]
+        fn rust_macro() {
+            assert_eq!(
+                Ok(Snippet {
+                    elements: vec![
+                        Text("macro_rules! ".into()),
+                        Tabstop { tabstop: 1 },
+                        Text(" {\n    (".into()),
+                        Tabstop { tabstop: 2 },
+                        Text(") => {\n        ".into()),
+                        Tabstop { tabstop: 0 },
+                        Text("\n    };\n}".into())
+                    ]
+                }),
+                parse("macro_rules! $1 {\n    ($2) => {\n        $0\n    };\n}")
+            );
+        }
+
+        fn assert_text(snippet: &str, parsed_text: &str) {
+            let res = parse(snippet).unwrap();
+            let text = crate::snippet::render(&res, "\n", true).0;
+            assert_eq!(text, parsed_text)
+        }
+
+        #[test]
+        fn robust_parsing() {
+            assert_text("$", "$");
+            assert_text("\\\\$", "\\$");
+            assert_text("{", "{");
+            assert_text("\\}", "}");
+            assert_text("\\abc", "\\abc");
+            assert_text("foo${f:\\}}bar", "foo}bar");
+            assert_text("\\{", "\\{");
+            assert_text("I need \\\\\\$", "I need \\$");
+            assert_text("\\", "\\");
+            assert_text("\\{{", "\\{{");
+            assert_text("{{", "{{");
+            assert_text("{{dd", "{{dd");
+            assert_text("}}", "}}");
+            assert_text("ff}}", "ff}}");
+            assert_text("farboo", "farboo");
+            assert_text("far{{}}boo", "far{{}}boo");
+            assert_text("far{{123}}boo", "far{{123}}boo");
+            assert_text("far\\{{123}}boo", "far\\{{123}}boo");
+            assert_text("far{{id:bern}}boo", "far{{id:bern}}boo");
+            assert_text("far{{id:bern {{basel}}}}boo", "far{{id:bern {{basel}}}}boo");
+            assert_text(
+                "far{{id:bern {{id:basel}}}}boo",
+                "far{{id:bern {{id:basel}}}}boo",
+            );
+            assert_text(
+                "far{{id:bern {{id2:basel}}}}boo",
+                "far{{id:bern {{id2:basel}}}}boo",
+            );
+            assert_text("${}$\\a\\$\\}\\\\", "${}$\\a$}\\");
+            assert_text("farboo", "farboo");
+            assert_text("far{{}}boo", "far{{}}boo");
+            assert_text("far{{123}}boo", "far{{123}}boo");
+            assert_text("far\\{{123}}boo", "far\\{{123}}boo");
+            assert_text("far`123`boo", "far`123`boo");
+            assert_text("far\\`123\\`boo", "far\\`123\\`boo");
+            assert_text("\\$far-boo", "$far-boo");
+        }
+
+        fn assert_snippet(snippet: &str, expect: &[SnippetElement]) {
+            let parsed_snippet = parse(snippet).unwrap();
+            assert_eq!(parsed_snippet.elements, expect.to_owned())
+        }
+
+        #[test]
+        fn parse_variable() {
+            use SnippetElement::*;
+            assert_snippet(
+                "$far-boo",
+                &[
+                    Variable {
+                        name: "far",
+                        default: None,
+                        regex: None,
+                    },
+                    Text("-boo".into()),
+                ],
+            );
+            assert_snippet(
+                "far$farboo",
+                &[
+                    Text("far".into()),
+                    Variable {
+                        name: "farboo",
+                        regex: None,
+                        default: None,
+                    },
+                ],
+            );
+            assert_snippet(
+                "far${farboo}",
+                &[
+                    Text("far".into()),
+                    Variable {
+                        name: "farboo",
+                        regex: None,
+                        default: None,
+                    },
+                ],
+            );
+            assert_snippet("$123", &[Tabstop { tabstop: 123 }]);
+            assert_snippet(
+                "$farboo",
+                &[Variable {
+                    name: "farboo",
+                    regex: None,
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "$far12boo",
+                &[Variable {
+                    name: "far12boo",
+                    regex: None,
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "000_${far}_000",
+                &[
+                    Text("000_".into()),
+                    Variable {
+                        name: "far",
+                        regex: None,
+                        default: None,
+                    },
+                    Text("_000".into()),
+                ],
+            );
+        }
+
+        #[test]
+        fn parse_variable_transform() {
+            assert_snippet(
+                "${foo///}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: Tendril::new(),
+                        replacement: Vec::new(),
+                        options: Tendril::new(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/regex/format/gmi}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: "regex".into(),
+                        replacement: vec![FormatItem::Text("format".into())],
+                        options: "gmi".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/([A-Z][a-z])/format/}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: "([A-Z][a-z])".into(),
+                        replacement: vec![FormatItem::Text("format".into())],
+                        options: Tendril::new(),
+                    }),
+                    default: None,
+                }],
+            );
+
+            // invalid regex TODO: reneable tests once we actually parse this regex flavour
+            // assert_text(
+            //     "${foo/([A-Z][a-z])/format/GMI}",
+            //     "${foo/([A-Z][a-z])/format/GMI}",
+            // );
+            // assert_text(
+            //     "${foo/([A-Z][a-z])/format/funky}",
+            //     "${foo/([A-Z][a-z])/format/funky}",
+            // );
+            // assert_text("${foo/([A-Z][a-z]/format/}", "${foo/([A-Z][a-z]/format/}");
+            assert_text(
+                "${foo/regex\\/format/options}",
+                "${foo/regex\\/format/options}",
+            );
+
+            // tricky regex
+            assert_snippet(
+                "${foo/m\\/atch/$1/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: "m/atch".into(),
+                        replacement: vec![FormatItem::Capture(1)],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+
+            // incomplete
+            assert_text("${foo///", "${foo///");
+            assert_text("${foo/regex/format/options", "${foo/regex/format/options");
+
+            // format string
+            assert_snippet(
+                "${foo/.*/${0:fooo}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![FormatItem::Conditional(0, None, Some("fooo".into()))],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/${1}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![FormatItem::Capture(1)],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/$1/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![FormatItem::Capture(1)],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/This-$1-encloses/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("This-".into()),
+                            FormatItem::Capture(1),
+                            FormatItem::Text("-encloses".into()),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/complex${1:else}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("complex".into()),
+                            FormatItem::Conditional(1, None, Some("else".into())),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/complex${1:-else}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("complex".into()),
+                            FormatItem::Conditional(1, None, Some("else".into())),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/complex${1:+if}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("complex".into()),
+                            FormatItem::Conditional(1, Some("if".into()), None),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/complex${1:?if:else}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("complex".into()),
+                            FormatItem::Conditional(1, Some("if".into()), Some("else".into())),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${foo/.*/complex${1:/upcase}/i}",
+                &[Variable {
+                    name: "foo",
+                    regex: Some(Regex {
+                        value: ".*".into(),
+                        replacement: vec![
+                            FormatItem::Text("complex".into()),
+                            FormatItem::CaseChange(1, CaseChange::Upcase),
+                        ],
+                        options: "i".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${TM_DIRECTORY/src\\//$1/}",
+                &[Variable {
+                    name: "TM_DIRECTORY",
+                    regex: Some(Regex {
+                        value: "src/".into(),
+                        replacement: vec![FormatItem::Capture(1)],
+                        options: Tendril::new(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${TM_SELECTED_TEXT/a/\\/$1/g}",
+                &[Variable {
+                    name: "TM_SELECTED_TEXT",
+                    regex: Some(Regex {
+                        value: "a".into(),
+                        replacement: vec![FormatItem::Text("/".into()), FormatItem::Capture(1)],
+                        options: "g".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${TM_SELECTED_TEXT/a/in\\/$1ner/g}",
+                &[Variable {
+                    name: "TM_SELECTED_TEXT",
+                    regex: Some(Regex {
+                        value: "a".into(),
+                        replacement: vec![
+                            FormatItem::Text("in/".into()),
+                            FormatItem::Capture(1),
+                            FormatItem::Text("ner".into()),
+                        ],
+                        options: "g".into(),
+                    }),
+                    default: None,
+                }],
+            );
+            assert_snippet(
+                "${TM_SELECTED_TEXT/a/end\\//g}",
+                &[Variable {
+                    name: "TM_SELECTED_TEXT",
+                    regex: Some(Regex {
+                        value: "a".into(),
+                        replacement: vec![FormatItem::Text("end/".into())],
+                        options: "g".into(),
+                    }),
+                    default: None,
+                }],
+            );
+        }
+        // TODO port more tests from https://github.com/microsoft/vscode/blob/dce493cb6e36346ef2714e82c42ce14fc461b15c/src/vs/editor/contrib/snippet/test/browser/snippetParser.test.ts
+    }
+}
diff --git a/helix-parsec/Cargo.toml b/helix-parsec/Cargo.toml
new file mode 100644
index 000000000..505a4247e
--- /dev/null
+++ b/helix-parsec/Cargo.toml
@@ -0,0 +1,13 @@
+[package]
+name = "helix-parsec"
+version = "0.6.0"
+authors = ["Bla Hrastnik <blaz@mxxn.io>"]
+edition = "2021"
+license = "MPL-2.0"
+description = "Parser combinators for Helix"
+categories = ["editor"]
+repository = "https://github.com/helix-editor/helix"
+homepage = "https://helix-editor.com"
+include = ["src/**/*", "README.md"]
+
+[dependencies]
diff --git a/helix-parsec/src/lib.rs b/helix-parsec/src/lib.rs
new file mode 100644
index 000000000..846d02d61
--- /dev/null
+++ b/helix-parsec/src/lib.rs
@@ -0,0 +1,574 @@
+//! Parser-combinator functions
+//!
+//! This module provides parsers and parser combinators which can be used
+//! together to build parsers by functional composition.
+
+// This module implements parser combinators following https://bodil.lol/parser-combinators/.
+// `sym` (trait implementation for `&'static str`), `map`, `pred` (filter), `one_or_more`,
+// `zero_or_more`, as well as the `Parser` trait originate mostly from that post.
+// The remaining parsers and parser combinators are either based on
+// https://github.com/archseer/snippets.nvim/blob/a583da6ef130d2a4888510afd8c4e5ffd62d0dce/lua/snippet/parser.lua#L5-L138
+// or are novel.
+
+// When a parser matches the input successfully, it returns `Ok((next_input, some_value))`
+// where the type of the returned value depends on the parser. If the parser fails to match,
+// it returns `Err(input)`.
+type ParseResult<'a, Output> = Result<(&'a str, Output), &'a str>;
+
+/// A parser or parser-combinator.
+///
+/// Parser-combinators compose multiple parsers together to parse input.
+/// For example, two basic parsers (`&'static str`s) may be combined with
+/// a parser-combinator like [or] to produce a new parser.
+///
+/// ```
+/// use helix_parsec::{or, Parser};
+/// let foo = "foo"; // matches "foo" literally
+/// let bar = "bar"; // matches "bar" literally
+/// let foo_or_bar = or(foo, bar); // matches either "foo" or "bar"
+/// assert_eq!(Ok(("", "foo")), foo_or_bar.parse("foo"));
+/// assert_eq!(Ok(("", "bar")), foo_or_bar.parse("bar"));
+/// assert_eq!(Err("baz"), foo_or_bar.parse("baz"));
+/// ```
+pub trait Parser<'a> {
+    type Output;
+
+    fn parse(&self, input: &'a str) -> ParseResult<'a, Self::Output>;
+}
+
+// Most parser-combinators are written as higher-order functions which take some
+// parser(s) as input and return a new parser: a function that takes input and returns
+// a parse result. The underlying implementation of [Parser::parse] for these functions
+// is simply application.
+#[doc(hidden)]
+impl<'a, F, T> Parser<'a> for F
+where
+    F: Fn(&'a str) -> ParseResult<T>,
+{
+    type Output = T;
+
+    fn parse(&self, input: &'a str) -> ParseResult<'a, Self::Output> {
+        self(input)
+    }
+}
+
+/// A parser which matches the string literal exactly.
+///
+/// This parser succeeds if the next characters in the input are equal to the given
+/// string literal.
+///
+/// Note that [str::parse] interferes with calling [Parser::parse] on string literals
+/// directly; this trait implementation works when used within any parser combinator
+/// but does not work on its own. To call [Parser::parse] on a parser for a string
+/// literal, use the [token] parser.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{or, Parser};
+/// let parser = or("foo", "bar");
+/// assert_eq!(Ok(("", "foo")), parser.parse("foo"));
+/// assert_eq!(Ok(("", "bar")), parser.parse("bar"));
+/// assert_eq!(Err("baz"), parser.parse("baz"));
+/// ```
+impl<'a> Parser<'a> for &'static str {
+    type Output = &'a str;
+
+    fn parse(&self, input: &'a str) -> ParseResult<'a, Self::Output> {
+        match input.get(0..self.len()) {
+            Some(actual) if actual == *self => Ok((&input[self.len()..], &input[0..self.len()])),
+            _ => Err(input),
+        }
+    }
+}
+
+// Parsers
+
+/// A parser which matches the given string literally.
+///
+/// This function is a convenience for interpreting string literals as parsers
+/// and is only necessary to avoid conflict with [str::parse]. See the documentation
+/// for the `&'static str` implementation of [Parser].
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{token, Parser};
+/// let parser = token("foo");
+/// assert_eq!(Ok(("", "foo")), parser.parse("foo"));
+/// assert_eq!(Err("bar"), parser.parse("bar"));
+/// ```
+pub fn token<'a>(literal: &'static str) -> impl Parser<'a, Output = &'a str> {
+    literal
+}
+
+/// A parser which matches all values until the specified pattern is found.
+///
+/// If the pattern is not found, this parser does not match. The input up to the
+/// character which returns `true` is returned but not that character itself.
+///
+/// If the pattern function returns true on the first input character, this
+/// parser fails.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{take_until, Parser};
+/// let parser = take_until(|c| c == '.');
+/// assert_eq!(Ok((".bar", "foo")), parser.parse("foo.bar"));
+/// assert_eq!(Err(".foo"), parser.parse(".foo"));
+/// assert_eq!(Err("foo"), parser.parse("foo"));
+/// ```
+pub fn take_until<'a, F>(pattern: F) -> impl Parser<'a, Output = &'a str>
+where
+    F: Fn(char) -> bool,
+{
+    move |input: &'a str| match input.find(&pattern) {
+        Some(index) if index != 0 => Ok((&input[index..], &input[0..index])),
+        _ => Err(input),
+    }
+}
+
+/// A parser which matches all values until the specified pattern no longer match.
+///
+/// This parser only ever fails if the input has a length of zero.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{take_while, Parser};
+/// let parser = take_while(|c| c == '1');
+/// assert_eq!(Ok(("2", "11")), parser.parse("112"));
+/// assert_eq!(Err("22"), parser.parse("22"));
+/// ```
+pub fn take_while<'a, F>(pattern: F) -> impl Parser<'a, Output = &'a str>
+where
+    F: Fn(char) -> bool,
+{
+    move |input: &'a str| match input
+        .char_indices()
+        .take_while(|(_p, c)| pattern(*c))
+        .last()
+    {
+        Some((index, c)) => {
+            let index = index + c.len_utf8();
+            Ok((&input[index..], &input[0..index]))
+        }
+        _ => Err(input),
+    }
+}
+
+// Variadic parser combinators
+
+/// A parser combinator which matches a sequence of parsers in an all-or-nothing fashion.
+///
+/// The returned value is a tuple containing the outputs of all parsers in order. Each
+/// parser in the sequence may be typed differently.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{seq, Parser};
+/// let parser = seq!("<", "a", ">");
+/// assert_eq!(Ok(("", ("<", "a", ">"))), parser.parse("<a>"));
+/// assert_eq!(Err("<b>"), parser.parse("<b>"));
+/// ```
+#[macro_export]
+macro_rules! seq {
+    ($($parsers: expr),+ $(,)?) => {
+        ($($parsers),+)
+    }
+}
+
+// Seq is implemented using trait-implementations of Parser for various size tuples.
+// This allows sequences to be typed heterogeneously.
+macro_rules! seq_impl {
+    ($($parser:ident),+) => {
+        #[allow(non_snake_case)]
+        impl<'a, $($parser),+> Parser<'a> for ($($parser),+)
+        where
+            $($parser: Parser<'a>),+
+        {
+            type Output = ($($parser::Output),+);
+
+            fn parse(&self, input: &'a str) -> ParseResult<'a, Self::Output> {
+                let ($($parser),+) = self;
+                seq_body_impl!(input, input, $($parser),+ ; )
+            }
+        }
+    }
+}
+
+macro_rules! seq_body_impl {
+    ($input:expr, $next_input:expr, $head:ident, $($tail:ident),+ ; $(,)? $($acc:ident),*) => {
+        match $head.parse($next_input) {
+            Ok((next_input, $head)) => seq_body_impl!($input, next_input, $($tail),+ ; $($acc),*, $head),
+            Err(_) => Err($input),
+        }
+    };
+    ($input:expr, $next_input:expr, $last:ident ; $(,)? $($acc:ident),*) => {
+        match $last.parse($next_input) {
+            Ok((next_input, last)) => Ok((next_input, ($($acc),+, last))),
+            Err(_) => Err($input),
+        }
+    }
+}
+
+seq_impl!(A, B);
+seq_impl!(A, B, C);
+seq_impl!(A, B, C, D);
+seq_impl!(A, B, C, D, E);
+seq_impl!(A, B, C, D, E, F);
+seq_impl!(A, B, C, D, E, F, G);
+seq_impl!(A, B, C, D, E, F, G, H);
+seq_impl!(A, B, C, D, E, F, G, H, I);
+seq_impl!(A, B, C, D, E, F, G, H, I, J);
+
+/// A parser combinator which chooses the first of the input parsers which matches
+/// successfully.
+///
+/// All input parsers must have the same output type. This is a variadic form for [or].
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{choice, or, Parser};
+/// let parser = choice!("foo", "bar", "baz");
+/// assert_eq!(Ok(("", "foo")), parser.parse("foo"));
+/// assert_eq!(Ok(("", "bar")), parser.parse("bar"));
+/// assert_eq!(Err("quiz"), parser.parse("quiz"));
+/// ```
+#[macro_export]
+macro_rules! choice {
+    ($parser: expr $(,)?) => {
+        $parser
+    };
+    ($parser: expr, $($rest: expr),+ $(,)?) => {
+        or($parser, choice!($($rest),+))
+    }
+}
+
+// Ordinary parser combinators
+
+/// A parser combinator which takes a parser as input and maps the output using the
+/// given transformation function.
+///
+/// This corresponds to [Result::map]. The value is only mapped if the input parser
+/// matches against input.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{map, Parser};
+/// let parser = map("123", |s| s.parse::<i32>().unwrap());
+/// assert_eq!(Ok(("", 123)), parser.parse("123"));
+/// assert_eq!(Err("abc"), parser.parse("abc"));
+/// ```
+pub fn map<'a, P, F, T>(parser: P, map_fn: F) -> impl Parser<'a, Output = T>
+where
+    P: Parser<'a>,
+    F: Fn(P::Output) -> T,
+{
+    move |input| {
+        parser
+            .parse(input)
+            .map(|(next_input, result)| (next_input, map_fn(result)))
+    }
+}
+
+/// A parser combinator which succeeds if the given parser matches the input and
+/// the given `filter_map_fn` returns `Some`.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{filter_map, take_until, Parser};
+/// let parser = filter_map(take_until(|c| c == '.'), |s| s.parse::<i32>().ok());
+/// assert_eq!(Ok((".456", 123)), parser.parse("123.456"));
+/// assert_eq!(Err("abc.def"), parser.parse("abc.def"));
+/// ```
+pub fn filter_map<'a, P, F, T>(parser: P, filter_map_fn: F) -> impl Parser<'a, Output = T>
+where
+    P: Parser<'a>,
+    F: Fn(P::Output) -> Option<T>,
+{
+    move |input| match parser.parse(input) {
+        Ok((next_input, value)) => match filter_map_fn(value) {
+            Some(value) => Ok((next_input, value)),
+            None => Err(input),
+        },
+        Err(_) => Err(input),
+    }
+}
+
+/// A parser combinator which succeeds if the first given parser matches the input and
+/// the second given parse also matches.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{reparse_as, take_until, one_or_more, Parser};
+/// let parser = reparse_as(take_until(|c| c == '/'), one_or_more("a"));
+/// assert_eq!(Ok(("/bb", vec!["a", "a"])), parser.parse("aa/bb"));
+/// ```
+pub fn reparse_as<'a, P1, P2, T>(parser1: P1, parser2: P2) -> impl Parser<'a, Output = T>
+where
+    P1: Parser<'a, Output = &'a str>,
+    P2: Parser<'a, Output = T>,
+{
+    filter_map(parser1, move |str| {
+        parser2.parse(str).map(|(_, value)| value).ok()
+    })
+}
+
+/// A parser combinator which only matches the input when the predicate function
+/// returns true.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{filter, take_until, Parser};
+/// let parser = filter(take_until(|c| c == '.'), |s| s == &"123");
+/// assert_eq!(Ok((".456", "123")), parser.parse("123.456"));
+/// assert_eq!(Err("456.123"), parser.parse("456.123"));
+/// ```
+pub fn filter<'a, P, F, T>(parser: P, pred_fn: F) -> impl Parser<'a, Output = T>
+where
+    P: Parser<'a, Output = T>,
+    F: Fn(&P::Output) -> bool,
+{
+    move |input| {
+        if let Ok((next_input, value)) = parser.parse(input) {
+            if pred_fn(&value) {
+                return Ok((next_input, value));
+            }
+        }
+        Err(input)
+    }
+}
+
+/// A parser combinator which matches either of the input parsers.
+///
+/// Both parsers must have the same output type. For a variadic form which
+/// can take any number of parsers, use `choice!`.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{or, Parser};
+/// let parser = or("foo", "bar");
+/// assert_eq!(Ok(("", "foo")), parser.parse("foo"));
+/// assert_eq!(Ok(("", "bar")), parser.parse("bar"));
+/// assert_eq!(Err("baz"), parser.parse("baz"));
+/// ```
+pub fn or<'a, P1, P2, T>(parser1: P1, parser2: P2) -> impl Parser<'a, Output = T>
+where
+    P1: Parser<'a, Output = T>,
+    P2: Parser<'a, Output = T>,
+{
+    move |input| match parser1.parse(input) {
+        ok @ Ok(_) => ok,
+        Err(_) => parser2.parse(input),
+    }
+}
+
+/// A parser combinator which attempts to match the given parser, returning a
+/// `None` output value if the parser does not match.
+///
+/// The parser produced with this combinator always succeeds. If the given parser
+/// succeeds, `Some(value)` is returned where `value` is the output of the given
+/// parser. Otherwise, `None`.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{optional, Parser};
+/// let parser = optional("foo");
+/// assert_eq!(Ok(("bar", Some("foo"))), parser.parse("foobar"));
+/// assert_eq!(Ok(("bar", None)), parser.parse("bar"));
+/// ```
+pub fn optional<'a, P, T>(parser: P) -> impl Parser<'a, Output = Option<T>>
+where
+    P: Parser<'a, Output = T>,
+{
+    move |input| match parser.parse(input) {
+        Ok((next_input, value)) => Ok((next_input, Some(value))),
+        Err(_) => Ok((input, None)),
+    }
+}
+
+/// A parser combinator which runs the given parsers in sequence and returns the
+/// value of `left` if both are matched.
+///
+/// This is useful for two-element sequences in which you only want the output
+/// value of the `left` parser.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{left, Parser};
+/// let parser = left("foo", "bar");
+/// assert_eq!(Ok(("", "foo")), parser.parse("foobar"));
+/// ```
+pub fn left<'a, L, R, T>(left: L, right: R) -> impl Parser<'a, Output = T>
+where
+    L: Parser<'a, Output = T>,
+    R: Parser<'a>,
+{
+    map(seq!(left, right), |(left_value, _)| left_value)
+}
+
+/// A parser combinator which runs the given parsers in sequence and returns the
+/// value of `right` if both are matched.
+///
+/// This is useful for two-element sequences in which you only want the output
+/// value of the `right` parser.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{right, Parser};
+/// let parser = right("foo", "bar");
+/// assert_eq!(Ok(("", "bar")), parser.parse("foobar"));
+/// ```
+pub fn right<'a, L, R, T>(left: L, right: R) -> impl Parser<'a, Output = T>
+where
+    L: Parser<'a>,
+    R: Parser<'a, Output = T>,
+{
+    map(seq!(left, right), |(_, right_value)| right_value)
+}
+
+/// A parser combinator which matches the given parser against the input zero or
+/// more times.
+///
+/// This parser always succeeds and returns the empty Vec when it matched zero
+/// times.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{zero_or_more, Parser};
+/// let parser = zero_or_more("a");
+/// assert_eq!(Ok(("", vec![])), parser.parse(""));
+/// assert_eq!(Ok(("", vec!["a"])), parser.parse("a"));
+/// assert_eq!(Ok(("", vec!["a", "a"])), parser.parse("aa"));
+/// assert_eq!(Ok(("bb", vec![])), parser.parse("bb"));
+/// ```
+pub fn zero_or_more<'a, P, T>(parser: P) -> impl Parser<'a, Output = Vec<T>>
+where
+    P: Parser<'a, Output = T>,
+{
+    let parser = non_empty(parser);
+    move |mut input| {
+        let mut values = Vec::new();
+
+        while let Ok((next_input, value)) = parser.parse(input) {
+            input = next_input;
+            values.push(value);
+        }
+
+        Ok((input, values))
+    }
+}
+
+/// A parser combinator which matches the given parser against the input one or
+/// more times.
+///
+/// This parser combinator acts the same as [zero_or_more] but must match at
+/// least once.
+///
+/// # Examples
+///
+/// ```
+/// use helix_parsec::{one_or_more, Parser};
+/// let parser = one_or_more("a");
+/// assert_eq!(Err(""), parser.parse(""));
+/// assert_eq!(Ok(("", vec!["a"])), parser.parse("a"));
+/// assert_eq!(Ok(("", vec!["a", "a"])), parser.parse("aa"));
+/// assert_eq!(Err("bb"), parser.parse("bb"));
+/// ```
+pub fn one_or_more<'a, P, T>(parser: P) -> impl Parser<'a, Output = Vec<T>>
+where
+    P: Parser<'a, Output = T>,
+{
+    let parser = non_empty(parser);
+    move |mut input| {
+        let mut values = Vec::new();
+
+        match parser.parse(input) {
+            Ok((next_input, value)) => {
+                input = next_input;
+                values.push(value);
+            }
+            Err(err) => return Err(err),
+        }
+
+        while let Ok((next_input, value)) = parser.parse(input) {
+            input = next_input;
+            values.push(value);
+        }
+
+        Ok((input, values))
+    }
+}
+
+/// A parser combinator which matches one or more instances of the given parser
+/// interspersed with the separator parser.
+///
+/// Output values of the separator parser are discarded.
+///
+/// This is typically used to parse function arguments or list items.
+///
+/// # Examples
+///
+/// ```rust
+/// use helix_parsec::{sep, Parser};
+/// let parser = sep("a", ",");
+/// assert_eq!(Ok(("", vec!["a", "a", "a"])), parser.parse("a,a,a"));
+/// ```
+pub fn sep<'a, P, S, T>(parser: P, separator: S) -> impl Parser<'a, Output = Vec<T>>
+where
+    P: Parser<'a, Output = T>,
+    S: Parser<'a>,
+{
+    move |mut input| {
+        let mut values = Vec::new();
+
+        match parser.parse(input) {
+            Ok((next_input, value)) => {
+                input = next_input;
+                values.push(value);
+            }
+            Err(err) => return Err(err),
+        }
+
+        loop {
+            match separator.parse(input) {
+                Ok((next_input, _)) => input = next_input,
+                Err(_) => break,
+            }
+
+            match parser.parse(input) {
+                Ok((next_input, value)) => {
+                    input = next_input;
+                    values.push(value);
+                }
+                Err(_) => break,
+            }
+        }
+
+        Ok((input, values))
+    }
+}
+
+pub fn non_empty<'a, T>(p: impl Parser<'a, Output = T>) -> impl Parser<'a, Output = T> {
+    move |input| {
+        let (new_input, res) = p.parse(input)?;
+        if new_input.len() == input.len() {
+            Err(input)
+        } else {
+            Ok((new_input, res))
+        }
+    }
+}
diff --git a/helix-term/Cargo.toml b/helix-term/Cargo.toml
index 30bfc7ea3..5222ddaa1 100644
--- a/helix-term/Cargo.toml
+++ b/helix-term/Cargo.toml
@@ -10,11 +10,7 @@ repository = "https://github.com/helix-editor/helix"
 homepage = "https://helix-editor.com"
 include = ["src/**/*", "README.md"]
 default-run = "hx"
-rust-version = "1.57"
-
-[package.metadata.nix]
-build = true
-app = true
+rust-version = "1.65"
 
 [features]
 default = ["git"]
@@ -35,17 +31,17 @@ helix-vcs = { version = "0.6", path = "../helix-vcs" }
 helix-loader = { version = "0.6", path = "../helix-loader" }
 
 anyhow = "1"
-once_cell = "1.16"
+once_cell = "1.17"
 
-which = "4.2"
+which = "4.4"
 
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot"] }
 tui = { path = "../helix-tui", package = "helix-tui", default-features = false, features = ["crossterm"] }
-crossterm = { version = "0.25", features = ["event-stream"] }
+crossterm = { version = "0.26", features = ["event-stream"] }
 signal-hook = "0.3"
 tokio-stream = "0.1"
 futures-util = { version = "0.3", features = ["std", "async-await"], default-features = false }
-arc-swap = { version = "1.5.1" }
+arc-swap = { version = "1.6.0" }
 
 # Logging
 fern = "0.6"
@@ -61,22 +57,23 @@ pulldown-cmark = { version = "0.9", default-features = false }
 content_inspector = "0.2.4"
 
 # config
-toml = "0.5"
+toml = "0.7"
 
 serde_json = "1.0"
 serde = { version = "1.0", features = ["derive"] }
 
 # ripgrep for global search
-grep-regex = "0.1.10"
-grep-searcher = "0.1.10"
+grep-regex = "0.1.11"
+grep-searcher = "0.1.11"
 
 [target.'cfg(not(windows))'.dependencies]  # https://github.com/vorner/signal-hook/issues/100
 signal-hook-tokio = { version = "0.3", features = ["futures-v0_3"] }
+libc = "0.2.140"
 
 [build-dependencies]
 helix-loader = { version = "0.6", path = "../helix-loader" }
 
 [dev-dependencies]
 smallvec = "1.10"
-indoc = "1.0.6"
-tempfile = "3.3.0"
+indoc = "2.0.1"
+tempfile = "3.4.0"
diff --git a/helix-term/src/application.rs b/helix-term/src/application.rs
index 7a50e007b..f7d7fa636 100644
--- a/helix-term/src/application.rs
+++ b/helix-term/src/application.rs
@@ -25,31 +25,22 @@
     config::Config,
     job::Jobs,
     keymap::Keymaps,
-    ui::{self, overlay::overlayed},
+    ui::{self, overlay::overlaid},
 };
 
 use log::{debug, error, warn};
 use std::{
-    io::{stdin, stdout, Write},
+    io::{stdin, stdout},
+    path::Path,
     sync::Arc,
     time::{Duration, Instant},
 };
 
 use anyhow::{Context, Error};
 
-use crossterm::{
-    event::{
-        DisableBracketedPaste, DisableFocusChange, DisableMouseCapture, EnableBracketedPaste,
-        EnableFocusChange, EnableMouseCapture, Event as CrosstermEvent,
-    },
-    execute, terminal,
-    tty::IsTty,
-};
+use crossterm::{event::Event as CrosstermEvent, tty::IsTty};
 #[cfg(not(windows))]
-use {
-    signal_hook::{consts::signal, low_level},
-    signal_hook_tokio::Signals,
-};
+use {signal_hook::consts::signal, signal_hook_tokio::Signals};
 #[cfg(windows)]
 type Signals = futures_util::stream::Empty<()>;
 
@@ -62,10 +53,12 @@
 use tui::backend::TestBackend;
 
 #[cfg(not(feature = "integration"))]
-type Terminal = tui::terminal::Terminal<CrosstermBackend<std::io::Stdout>>;
+type TerminalBackend = CrosstermBackend<std::io::Stdout>;
 
 #[cfg(feature = "integration")]
-type Terminal = tui::terminal::Terminal<TestBackend>;
+type TerminalBackend = TestBackend;
+
+type Terminal = tui::terminal::Terminal<TerminalBackend>;
 
 pub struct Application {
     compositor: Compositor,
@@ -107,23 +100,6 @@ fn setup_integration_logging() {
         .apply();
 }
 
-fn restore_term() -> Result<(), Error> {
-    let mut stdout = stdout();
-    // reset cursor shape
-    write!(stdout, "\x1B[0 q")?;
-    // Ignore errors on disabling, this might trigger on windows if we call
-    // disable without calling enable previously
-    let _ = execute!(stdout, DisableMouseCapture);
-    execute!(
-        stdout,
-        DisableBracketedPaste,
-        DisableFocusChange,
-        terminal::LeaveAlternateScreen
-    )?;
-    terminal::disable_raw_mode()?;
-    Ok(())
-}
-
 impl Application {
     pub fn new(
         args: Args,
@@ -135,10 +111,9 @@ pub fn new(
 
         use helix_view::editor::Action;
 
-        let theme_loader = std::sync::Arc::new(theme::Loader::new(
-            &helix_loader::config_dir(),
-            &helix_loader::runtime_dir(),
-        ));
+        let mut theme_parent_dirs = vec![helix_loader::config_dir()];
+        theme_parent_dirs.extend(helix_loader::runtime_dirs().iter().cloned());
+        let theme_loader = std::sync::Arc::new(theme::Loader::new(&theme_parent_dirs));
 
         let true_color = config.editor.true_color || crate::true_color();
         let theme = config
@@ -159,7 +134,7 @@ pub fn new(
         let syn_loader = std::sync::Arc::new(syntax::Loader::new(syn_loader_conf));
 
         #[cfg(not(feature = "integration"))]
-        let backend = CrosstermBackend::new(stdout());
+        let backend = CrosstermBackend::new(stdout(), &config.editor);
 
         #[cfg(feature = "integration")]
         let backend = TestBackend::new(120, 150);
@@ -172,7 +147,7 @@ pub fn new(
             area,
             theme_loader.clone(),
             syn_loader.clone(),
-            Box::new(Map::new(Arc::clone(&config), |config: &Config| {
+            Arc::new(Map::new(Arc::clone(&config), |config: &Config| {
                 &config.editor
             })),
         );
@@ -184,7 +159,7 @@ pub fn new(
         compositor.push(editor_view);
 
         if args.load_tutor {
-            let path = helix_loader::runtime_dir().join("tutor");
+            let path = helix_loader::runtime_file(Path::new("tutor"));
             editor.open(&path, Action::VerticalSplit)?;
             // Unset path to prevent accidentally saving to the original tutor file.
             doc_mut!(editor).set_path(None)?;
@@ -194,7 +169,7 @@ pub fn new(
                 std::env::set_current_dir(first).context("set current dir")?;
                 editor.new_file(Action::VerticalSplit);
                 let picker = ui::file_picker(".".into(), &config.load().editor);
-                compositor.push(Box::new(overlayed(picker)));
+                compositor.push(Box::new(overlaid(picker)));
             } else {
                 let nr_of_files = args.files.len();
                 for (i, (file, pos)) in args.files.into_iter().enumerate() {
@@ -227,7 +202,11 @@ pub fn new(
                         doc.set_selection(view_id, pos);
                     }
                 }
-                editor.set_status(format!("Loaded {} files.", nr_of_files));
+                editor.set_status(format!(
+                    "Loaded {} file{}.",
+                    nr_of_files,
+                    if nr_of_files == 1 { "" } else { "s" } // avoid "Loaded 1 files." grammo
+                ));
                 // align the view to center after all files are loaded,
                 // does not affect views without pos since it is at the top
                 let (view, doc) = current!(editor);
@@ -273,10 +252,6 @@ pub fn new(
         Ok(app)
     }
 
-    #[cfg(feature = "integration")]
-    async fn render(&mut self) {}
-
-    #[cfg(not(feature = "integration"))]
     async fn render(&mut self) {
         let mut cx = crate::compositor::Context {
             editor: &mut self.editor,
@@ -305,8 +280,10 @@ async fn render(&mut self) {
         let surface = self.terminal.current_buffer_mut();
 
         self.compositor.render(area, surface, &mut cx);
-
         let (pos, kind) = self.compositor.cursor(area, &self.editor);
+        // reset cursor cache
+        self.editor.cursor_cache.set(None);
+
         let pos = pos.map(|pos| (pos.col as u16, pos.row as u16));
         self.terminal.draw(pos, kind).unwrap();
     }
@@ -339,12 +316,12 @@ pub async fn event_loop_until_idle<S>(&mut self, input_stream: &mut S) -> bool
             tokio::select! {
                 biased;
 
-                Some(event) = input_stream.next() => {
-                    self.handle_terminal_events(event).await;
-                }
                 Some(signal) = self.signals.next() => {
                     self.handle_signals(signal).await;
                 }
+                Some(event) = input_stream.next() => {
+                    self.handle_terminal_events(event).await;
+                }
                 Some(callback) = self.jobs.futures.next() => {
                     self.jobs.handle_callback(&mut self.editor, &mut self.compositor, callback);
                     self.render().await;
@@ -391,36 +368,65 @@ pub fn handle_config_events(&mut self, config_event: ConfigEvent) {
         // Update all the relevant members in the editor after updating
         // the configuration.
         self.editor.refresh_config();
+
+        // reset view position in case softwrap was enabled/disabled
+        let scrolloff = self.editor.config().scrolloff;
+        for (view, _) in self.editor.tree.views_mut() {
+            let doc = &self.editor.documents[&view.doc];
+            view.ensure_cursor_in_view(doc, scrolloff)
+        }
     }
 
-    /// Refresh theme after config change
-    fn refresh_theme(&mut self, config: &Config) {
-        if let Some(theme) = config.theme.clone() {
-            let true_color = self.true_color();
-            match self.theme_loader.load(&theme) {
-                Ok(theme) => {
-                    if true_color || theme.is_16_color() {
-                        self.editor.set_theme(theme);
-                    } else {
-                        self.editor
-                            .set_error("theme requires truecolor support, which is not available");
-                    }
-                }
-                Err(err) => {
-                    let err_string = format!("failed to load theme `{}` - {}", theme, err);
-                    self.editor.set_error(err_string);
-                }
-            }
+    /// refresh language config after config change
+    fn refresh_language_config(&mut self) -> Result<(), Error> {
+        let syntax_config = helix_core::config::user_syntax_loader()
+            .map_err(|err| anyhow::anyhow!("Failed to load language config: {}", err))?;
+
+        self.syn_loader = std::sync::Arc::new(syntax::Loader::new(syntax_config));
+        self.editor.syn_loader = self.syn_loader.clone();
+        for document in self.editor.documents.values_mut() {
+            document.detect_language(self.syn_loader.clone());
         }
+
+        Ok(())
+    }
+
+    /// Refresh theme after config change
+    fn refresh_theme(&mut self, config: &Config) -> Result<(), Error> {
+        let true_color = config.editor.true_color || crate::true_color();
+        let theme = config
+            .theme
+            .as_ref()
+            .and_then(|theme| {
+                self.theme_loader
+                    .load(theme)
+                    .map_err(|e| {
+                        log::warn!("failed to load theme `{}` - {}", theme, e);
+                        e
+                    })
+                    .ok()
+                    .filter(|theme| (true_color || theme.is_16_color()))
+            })
+            .unwrap_or_else(|| self.theme_loader.default_theme(true_color));
+
+        self.editor.set_theme(theme);
+        Ok(())
     }
 
     fn refresh_config(&mut self) {
-        match Config::load_default() {
-            Ok(config) => {
-                self.refresh_theme(&config);
+        let mut refresh_config = || -> Result<(), Error> {
+            let default_config = Config::load_default()
+                .map_err(|err| anyhow::anyhow!("Failed to load config: {}", err))?;
+            self.refresh_language_config()?;
+            self.refresh_theme(&default_config)?;
+            // Store new config
+            self.config.store(Arc::new(default_config));
+            Ok(())
+        };
 
-                // Store new config
-                self.config.store(Arc::new(config));
+        match refresh_config() {
+            Ok(_) => {
+                self.editor.set_status("Config refreshed");
             }
             Err(err) => {
                 self.editor.set_error(err.to_string());
@@ -428,10 +434,6 @@ fn refresh_config(&mut self) {
         }
     }
 
-    fn true_color(&self) -> bool {
-        self.config.load().editor.true_color || crate::true_color()
-    }
-
     #[cfg(windows)]
     // no signal handling available on windows
     pub async fn handle_signals(&mut self, _signal: ()) {}
@@ -440,14 +442,33 @@ pub async fn handle_signals(&mut self, _signal: ()) {}
     pub async fn handle_signals(&mut self, signal: i32) {
         match signal {
             signal::SIGTSTP => {
-                // restore cursor
-                use helix_view::graphics::CursorKind;
-                self.terminal
-                    .backend_mut()
-                    .show_cursor(CursorKind::Block)
-                    .ok();
-                restore_term().unwrap();
-                low_level::emulate_default_handler(signal::SIGTSTP).unwrap();
+                self.restore_term().unwrap();
+
+                // SAFETY:
+                //
+                // - helix must have permissions to send signals to all processes in its signal
+                //   group, either by already having the requisite permission, or by having the
+                //   user's UID / EUID / SUID match that of the receiving process(es).
+                let res = unsafe {
+                    // A pid of 0 sends the signal to the entire process group, allowing the user to
+                    // regain control of their terminal if the editor was spawned under another process
+                    // (e.g. when running `git commit`).
+                    //
+                    // We have to send SIGSTOP (not SIGTSTP) to the entire process group, because,
+                    // as mentioned above, the terminal will get stuck if `helix` was spawned from
+                    // an external process and that process waits for `helix` to complete. This may
+                    // be an issue with signal-hook-tokio, but the author of signal-hook believes it
+                    // could be a tokio issue instead:
+                    // https://github.com/vorner/signal-hook/issues/132
+                    libc::kill(0, signal::SIGSTOP)
+                };
+
+                if res != 0 {
+                    let err = std::io::Error::last_os_error();
+                    eprintln!("{}", err);
+                    let res = err.raw_os_error().unwrap_or(1);
+                    std::process::exit(res);
+                }
             }
             signal::SIGCONT => {
                 self.claim_term().await.unwrap();
@@ -606,6 +627,11 @@ pub async fn handle_terminal_events(
                 self.compositor
                     .handle_event(&Event::Resize(width, height), &mut cx)
             }
+            // Ignore keyboard release events.
+            CrosstermEvent::Key(crossterm::event::KeyEvent {
+                kind: crossterm::event::KeyEventKind::Release,
+                ..
+            }) => false,
             event => self.compositor.handle_event(&event.into(), &mut cx),
         };
 
@@ -675,8 +701,23 @@ pub async fn handle_language_server_message(
                         }
                     }
                     Notification::PublishDiagnostics(mut params) => {
-                        let path = params.uri.to_file_path().unwrap();
-                        let doc = self.editor.document_by_path_mut(&path);
+                        let path = match params.uri.to_file_path() {
+                            Ok(path) => path,
+                            Err(_) => {
+                                log::error!("Unsupported file URI: {}", params.uri);
+                                return;
+                            }
+                        };
+                        let doc = self.editor.document_by_path_mut(&path).filter(|doc| {
+                            if let Some(version) = params.version {
+                                if version != doc.version() {
+                                    log::info!("Version ({version}) is out of date for {path:?} (expected ({}), dropping PublishDiagnostic notification", doc.version());
+                                    return false;
+                                }
+                            }
+
+                            true
+                        });
 
                         if let Some(doc) = doc {
                             let lang_conf = doc.language_config();
@@ -917,24 +958,32 @@ pub async fn handle_language_server_message(
             Call::MethodCall(helix_lsp::jsonrpc::MethodCall {
                 method, params, id, ..
             }) => {
-                let call = match MethodCall::parse(&method, params) {
-                    Ok(call) => call,
+                let reply = match MethodCall::parse(&method, params) {
                     Err(helix_lsp::Error::Unhandled) => {
-                        error!("Language Server: Method not found {}", method);
-                        return;
+                        error!(
+                            "Language Server: Method {} not found in request {}",
+                            method, id
+                        );
+                        Err(helix_lsp::jsonrpc::Error {
+                            code: helix_lsp::jsonrpc::ErrorCode::MethodNotFound,
+                            message: format!("Method not found: {}", method),
+                            data: None,
+                        })
                     }
                     Err(err) => {
                         log::error!(
-                            "received malformed method call from Language Server: {}: {}",
+                            "Language Server: Received malformed method call {} in request {}: {}",
                             method,
+                            id,
                             err
                         );
-                        return;
+                        Err(helix_lsp::jsonrpc::Error {
+                            code: helix_lsp::jsonrpc::ErrorCode::ParseError,
+                            message: format!("Malformed method call: {}", method),
+                            data: None,
+                        })
                     }
-                };
-
-                let reply = match call {
-                    MethodCall::WorkDoneProgressCreate(params) => {
+                    Ok(MethodCall::WorkDoneProgressCreate(params)) => {
                         self.lsp_progress.create(server_id, params.token);
 
                         let editor_view = self
@@ -948,26 +997,29 @@ pub async fn handle_language_server_message(
 
                         Ok(serde_json::Value::Null)
                     }
-                    MethodCall::ApplyWorkspaceEdit(params) => {
-                        apply_workspace_edit(
+                    Ok(MethodCall::ApplyWorkspaceEdit(params)) => {
+                        let res = apply_workspace_edit(
                             &mut self.editor,
                             helix_lsp::OffsetEncoding::Utf8,
                             &params.edit,
                         );
 
                         Ok(json!(lsp::ApplyWorkspaceEditResponse {
-                            applied: true,
-                            failure_reason: None,
-                            failed_change: None,
+                            applied: res.is_ok(),
+                            failure_reason: res.as_ref().err().map(|err| err.kind.to_string()),
+                            failed_change: res
+                                .as_ref()
+                                .err()
+                                .map(|err| err.failed_change_idx as u32),
                         }))
                     }
-                    MethodCall::WorkspaceFolders => {
+                    Ok(MethodCall::WorkspaceFolders) => {
                         let language_server =
                             self.editor.language_servers.get_by_id(server_id).unwrap();
 
-                        Ok(json!(language_server.workspace_folders()))
+                        Ok(json!(&*language_server.workspace_folders().await))
                     }
-                    MethodCall::WorkspaceConfiguration(params) => {
+                    Ok(MethodCall::WorkspaceConfiguration(params)) => {
                         let result: Vec<_> = params
                             .items
                             .iter()
@@ -995,6 +1047,17 @@ pub async fn handle_language_server_message(
                             .collect();
                         Ok(json!(result))
                     }
+                    Ok(MethodCall::RegisterCapability(_params)) => {
+                        log::warn!("Ignoring a client/registerCapability request because dynamic capability registration is not enabled. Please report this upstream to the language server");
+                        // Language Servers based on the `vscode-languageserver-node` library often send
+                        // client/registerCapability even though we do not enable dynamic registration
+                        // for any capabilities. We should send a MethodNotFound JSONRPC error in this
+                        // case but that rejects the registration promise in the server which causes an
+                        // exit. So we work around this by ignoring the request and sending back an OK
+                        // response.
+
+                        Ok(serde_json::Value::Null)
+                    }
                 };
 
                 let language_server = match self.editor.language_servers.get_by_id(server_id) {
@@ -1011,24 +1074,19 @@ pub async fn handle_language_server_message(
         }
     }
 
-    async fn claim_term(&mut self) -> Result<(), Error> {
+    async fn claim_term(&mut self) -> std::io::Result<()> {
+        let terminal_config = self.config.load().editor.clone().into();
+        self.terminal.claim(terminal_config)
+    }
+
+    fn restore_term(&mut self) -> std::io::Result<()> {
+        let terminal_config = self.config.load().editor.clone().into();
         use helix_view::graphics::CursorKind;
-        terminal::enable_raw_mode()?;
-        if self.terminal.cursor_kind() == CursorKind::Hidden {
-            self.terminal.backend_mut().hide_cursor().ok();
-        }
-        let mut stdout = stdout();
-        execute!(
-            stdout,
-            terminal::EnterAlternateScreen,
-            EnableBracketedPaste,
-            EnableFocusChange
-        )?;
-        execute!(stdout, terminal::Clear(terminal::ClearType::All))?;
-        if self.config.load().editor.mouse {
-            execute!(stdout, EnableMouseCapture)?;
-        }
-        Ok(())
+        self.terminal
+            .backend_mut()
+            .show_cursor(CursorKind::Block)
+            .ok();
+        self.terminal.restore(terminal_config)
     }
 
     pub async fn run<S>(&mut self, input_stream: &mut S) -> Result<i32, Error>
@@ -1043,7 +1101,7 @@ pub async fn run<S>(&mut self, input_stream: &mut S) -> Result<i32, Error>
             // We can't handle errors properly inside this closure.  And it's
             // probably not a good idea to `unwrap()` inside a panic handler.
             // So we just ignore the `Result`.
-            let _ = restore_term();
+            let _ = TerminalBackend::force_restore();
             hook(info);
         }));
 
@@ -1051,13 +1109,7 @@ pub async fn run<S>(&mut self, input_stream: &mut S) -> Result<i32, Error>
 
         let close_errs = self.close().await;
 
-        // restore cursor
-        use helix_view::graphics::CursorKind;
-        self.terminal
-            .backend_mut()
-            .show_cursor(CursorKind::Block)
-            .ok();
-        restore_term()?;
+        self.restore_term()?;
 
         for err in close_errs {
             self.editor.exit_code = 1;
diff --git a/helix-term/src/commands.rs b/helix-term/src/commands.rs
index 1310417e4..17669924c 100644
--- a/helix-term/src/commands.rs
+++ b/helix-term/src/commands.rs
@@ -5,30 +5,32 @@
 pub use dap::*;
 use helix_vcs::Hunk;
 pub use lsp::*;
-use tui::text::Spans;
+use tokio::sync::oneshot;
+use tui::widgets::Row;
 pub use typed::*;
 
 use helix_core::{
-    comment, coords_at_pos, encoding, find_first_non_whitespace_char, find_root, graphemes,
+    char_idx_at_visual_offset, comment,
+    doc_formatter::TextFormat,
+    encoding, find_first_non_whitespace_char, find_workspace, graphemes,
     history::UndoKind,
-    increment::date_time::DateTimeIncrementor,
-    increment::{number::NumberIncrementor, Increment},
-    indent,
+    increment, indent,
     indent::IndentStyle,
     line_ending::{get_line_ending_of_str, line_end_char_index, str_is_line_ending},
     match_brackets,
-    movement::{self, Direction},
-    object, pos_at_coords, pos_at_visual_coords,
+    movement::{self, move_vertically_visual, Direction},
+    object, pos_at_coords,
     regex::{self, Regex, RegexBuilder},
     search::{self, CharMatcher},
-    selection, shellwords, surround, textobject,
+    selection, shellwords, surround,
+    text_annotations::TextAnnotations,
+    textobject,
     tree_sitter::Node,
     unicode::width::UnicodeWidthChar,
-    visual_coords_at_pos, LineEnding, Position, Range, Rope, RopeGraphemes, RopeSlice, Selection,
-    SmallVec, Tendril, Transaction,
+    visual_offset_from_block, LineEnding, Position, Range, Rope, RopeGraphemes, RopeSlice,
+    Selection, SmallVec, Tendril, Transaction,
 };
 use helix_view::{
-    apply_transaction,
     clipboard::ClipboardType,
     document::{FormatterError, Mode, SCRATCH_BUFFER_NAME},
     editor::{Action, Motion},
@@ -48,9 +50,13 @@
 use crate::{
     args,
     compositor::{self, Component, Compositor},
+    filter_picker_entry,
     job::Callback,
     keymap::ReverseKeymap,
-    ui::{self, overlay::overlayed, FilePicker, Picker, Popup, Prompt, PromptEvent},
+    ui::{
+        self, editor::InsertEvent, lsp::SignatureHelp, overlay::overlaid, FilePicker, Picker,
+        Popup, Prompt, PromptEvent,
+    },
 };
 
 use crate::job::{self, Jobs};
@@ -71,13 +77,15 @@
 use ignore::{DirEntry, WalkBuilder, WalkState};
 use tokio_stream::wrappers::UnboundedReceiverStream;
 
+pub type OnKeyCallback = Box<dyn FnOnce(&mut Context, KeyEvent)>;
+
 pub struct Context<'a> {
     pub register: Option<char>,
     pub count: Option<NonZeroUsize>,
     pub editor: &'a mut Editor,
 
     pub callback: Option<crate::compositor::Callback>,
-    pub on_next_key_callback: Option<Box<dyn FnOnce(&mut Context, KeyEvent)>>,
+    pub on_next_key_callback: Option<OnKeyCallback>,
     pub jobs: &'a mut Jobs,
 }
 
@@ -106,17 +114,7 @@ pub fn callback<T, F>(
         T: for<'de> serde::Deserialize<'de> + Send + 'static,
         F: FnOnce(&mut Editor, &mut Compositor, T) + Send + 'static,
     {
-        let callback = Box::pin(async move {
-            let json = call.await?;
-            let response = serde_json::from_value(json)?;
-            let call: job::Callback = Callback::EditorCompositor(Box::new(
-                move |editor: &mut Editor, compositor: &mut Compositor| {
-                    callback(editor, compositor, response)
-                },
-            ));
-            Ok(call)
-        });
-        self.jobs.callback(callback);
+        self.jobs.callback(make_job_callback(call, callback));
     }
 
     /// Returns 1 if no explicit count was provided
@@ -126,6 +124,27 @@ pub fn count(&self) -> usize {
     }
 }
 
+#[inline]
+fn make_job_callback<T, F>(
+    call: impl Future<Output = helix_lsp::Result<serde_json::Value>> + 'static + Send,
+    callback: F,
+) -> std::pin::Pin<Box<impl Future<Output = Result<Callback, anyhow::Error>>>>
+where
+    T: for<'de> serde::Deserialize<'de> + Send + 'static,
+    F: FnOnce(&mut Editor, &mut Compositor, T) + Send + 'static,
+{
+    Box::pin(async move {
+        let json = call.await?;
+        let response = serde_json::from_value(json)?;
+        let call: job::Callback = Callback::EditorCompositor(Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor| {
+                callback(editor, compositor, response)
+            },
+        ));
+        Ok(call)
+    })
+}
+
 use helix_view::{align_view, Align};
 
 /// A MappableCommand is either a static command like "jump_view_up" or a Typable command like
@@ -203,10 +222,14 @@ pub fn doc(&self) -> &str {
         move_char_right, "Move right",
         move_line_up, "Move up",
         move_line_down, "Move down",
+        move_visual_line_up, "Move up",
+        move_visual_line_down, "Move down",
         extend_char_left, "Extend left",
         extend_char_right, "Extend right",
         extend_line_up, "Extend up",
         extend_line_down, "Extend down",
+        extend_visual_line_up, "Extend up",
+        extend_visual_line_down, "Extend down",
         copy_selection_on_next_line, "Copy selection on next line",
         copy_selection_on_prev_line, "Copy selection on previous line",
         move_next_word_start, "Move to start of next word",
@@ -244,6 +267,7 @@ pub fn doc(&self) -> &str {
         select_regex, "Select all regex matches inside selections",
         split_selection, "Split selections on regex matches",
         split_selection_on_newline, "Split selection on newlines",
+        merge_consecutive_selections, "Merge consecutive selections",
         search, "Search for regex pattern",
         rsearch, "Reverse search for regex pattern",
         search_next, "Select next search match",
@@ -269,6 +293,7 @@ pub fn doc(&self) -> &str {
         append_mode, "Append after selection",
         command_mode, "Enter command mode",
         file_picker, "Open file picker",
+        file_picker_in_current_buffer_directory, "Open file picker at current buffers's directory",
         file_picker_in_current_directory, "Open file picker at current working directory",
         code_action, "Perform code action",
         buffer_picker, "Open buffer picker",
@@ -287,6 +312,7 @@ pub fn doc(&self) -> &str {
         select_mode, "Enter selection extend mode",
         exit_select_mode, "Exit selection mode",
         goto_definition, "Goto definition",
+        goto_declaration, "Goto declaration",
         add_newline_above, "Add newline above",
         add_newline_below, "Add newline below",
         goto_type_definition, "Goto type definition",
@@ -385,6 +411,7 @@ pub fn doc(&self) -> &str {
         swap_view_down, "Swap with split below",
         transpose_view, "Transpose splits",
         rotate_view, "Goto next window",
+        rotate_view_reverse, "Goto previous window",
         hsplit, "Horizontal bottom split",
         hsplit_new, "Horizontal bottom split scratch buffer",
         vsplit, "Vertical right split",
@@ -418,6 +445,7 @@ pub fn doc(&self) -> &str {
         goto_next_paragraph, "Goto next paragraph",
         goto_prev_paragraph, "Goto previous paragraph",
         dap_launch, "Launch debug target",
+        dap_restart, "Restart debugging session",
         dap_toggle_breakpoint, "Toggle breakpoint",
         dap_continue, "Continue program execution",
         dap_pause, "Pause program execution",
@@ -449,9 +477,16 @@ pub fn doc(&self) -> &str {
 
 impl fmt::Debug for MappableCommand {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_tuple("MappableCommand")
-            .field(&self.name())
-            .finish()
+        match self {
+            MappableCommand::Static { name, .. } => {
+                f.debug_tuple("MappableCommand").field(name).finish()
+            }
+            MappableCommand::Typable { name, args, .. } => f
+                .debug_tuple("MappableCommand")
+                .field(name)
+                .field(args)
+                .finish(),
+        }
     }
 }
 
@@ -466,7 +501,7 @@ impl std::str::FromStr for MappableCommand {
 
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         if let Some(suffix) = s.strip_prefix(':') {
-            let mut typable_command = suffix.split(' ').into_iter().map(|arg| arg.trim());
+            let mut typable_command = suffix.split(' ').map(|arg| arg.trim());
             let name = typable_command
                 .next()
                 .ok_or_else(|| anyhow!("Expected typable command name"))?;
@@ -506,12 +541,16 @@ fn eq(&self, other: &Self) -> bool {
         match (self, other) {
             (
                 MappableCommand::Typable {
-                    name: first_name, ..
+                    name: first_name,
+                    args: first_args,
+                    ..
                 },
                 MappableCommand::Typable {
-                    name: second_name, ..
+                    name: second_name,
+                    args: second_args,
+                    ..
                 },
-            ) => first_name == second_name,
+            ) => first_name == second_name && first_args == second_args,
             (
                 MappableCommand::Static {
                     name: first_name, ..
@@ -527,18 +566,27 @@ fn eq(&self, other: &Self) -> bool {
 
 fn no_op(_cx: &mut Context) {}
 
-fn move_impl<F>(cx: &mut Context, move_fn: F, dir: Direction, behaviour: Movement)
-where
-    F: Fn(RopeSlice, Range, Direction, usize, Movement, usize) -> Range,
-{
+type MoveFn =
+    fn(RopeSlice, Range, Direction, usize, Movement, &TextFormat, &mut TextAnnotations) -> Range;
+
+fn move_impl(cx: &mut Context, move_fn: MoveFn, dir: Direction, behaviour: Movement) {
     let count = cx.count();
     let (view, doc) = current!(cx.editor);
     let text = doc.text().slice(..);
+    let text_fmt = doc.text_format(view.inner_area(doc).width, None);
+    let mut annotations = view.text_annotations(doc, None);
 
-    let selection = doc
-        .selection(view.id)
-        .clone()
-        .transform(|range| move_fn(text, range, dir, count, behaviour, doc.tab_width()));
+    let selection = doc.selection(view.id).clone().transform(|range| {
+        move_fn(
+            text,
+            range,
+            dir,
+            count,
+            behaviour,
+            &text_fmt,
+            &mut annotations,
+        )
+    });
     doc.set_selection(view.id, selection);
 }
 
@@ -560,6 +608,24 @@ fn move_line_down(cx: &mut Context) {
     move_impl(cx, move_vertically, Direction::Forward, Movement::Move)
 }
 
+fn move_visual_line_up(cx: &mut Context) {
+    move_impl(
+        cx,
+        move_vertically_visual,
+        Direction::Backward,
+        Movement::Move,
+    )
+}
+
+fn move_visual_line_down(cx: &mut Context) {
+    move_impl(
+        cx,
+        move_vertically_visual,
+        Direction::Forward,
+        Movement::Move,
+    )
+}
+
 fn extend_char_left(cx: &mut Context) {
     move_impl(cx, move_horizontally, Direction::Backward, Movement::Extend)
 }
@@ -576,6 +642,24 @@ fn extend_line_down(cx: &mut Context) {
     move_impl(cx, move_vertically, Direction::Forward, Movement::Extend)
 }
 
+fn extend_visual_line_up(cx: &mut Context) {
+    move_impl(
+        cx,
+        move_vertically_visual,
+        Direction::Backward,
+        Movement::Extend,
+    )
+}
+
+fn extend_visual_line_down(cx: &mut Context) {
+    move_impl(
+        cx,
+        move_vertically_visual,
+        Direction::Forward,
+        Movement::Extend,
+    )
+}
+
 fn goto_line_end_impl(view: &mut View, doc: &mut Document, movement: Movement) {
     let text = doc.text().slice(..);
 
@@ -803,7 +887,10 @@ fn trim_selections(cx: &mut Context) {
 }
 
 // align text in selection
+#[allow(deprecated)]
 fn align_selections(cx: &mut Context) {
+    use helix_core::visual_coords_at_pos;
+
     let (view, doc) = current!(cx.editor);
     let text = doc.text().slice(..);
     let selection = doc.selection(view.id);
@@ -864,7 +951,7 @@ fn align_selections(cx: &mut Context) {
     changes.sort_unstable_by_key(|(from, _, _)| *from);
 
     let transaction = Transaction::change(doc.text(), changes.into_iter());
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn goto_window(cx: &mut Context, align: Align) {
@@ -880,17 +967,23 @@ fn goto_window(cx: &mut Context, align: Align) {
     // as we type
     let scrolloff = config.scrolloff.min(height.saturating_sub(1) / 2);
 
-    let last_line = view.last_line(doc);
+    let last_visual_line = view.last_visual_line(doc);
 
-    let line = match align {
-        Align::Top => view.offset.row + scrolloff + count,
-        Align::Center => view.offset.row + ((last_line - view.offset.row) / 2),
-        Align::Bottom => last_line.saturating_sub(scrolloff + count),
-    }
-    .max(view.offset.row + scrolloff)
-    .min(last_line.saturating_sub(scrolloff));
+    let visual_line = match align {
+        Align::Top => view.offset.vertical_offset + scrolloff + count,
+        Align::Center => view.offset.vertical_offset + (last_visual_line / 2),
+        Align::Bottom => {
+            view.offset.vertical_offset + last_visual_line.saturating_sub(scrolloff + count)
+        }
+    };
+    let visual_line = visual_line
+        .max(view.offset.vertical_offset + scrolloff)
+        .min(view.offset.vertical_offset + last_visual_line.saturating_sub(scrolloff));
+
+    let pos = view
+        .pos_at_visual_coords(doc, visual_line as u16, 0, false)
+        .expect("visual_line was constrained to the view area");
 
-    let pos = doc.text().line_to_char(line);
     let text = doc.text().slice(..);
     let selection = doc
         .selection(view.id)
@@ -1316,7 +1409,7 @@ fn replace(cx: &mut Context) {
                 }
             });
 
-            apply_transaction(&transaction, doc, view);
+            doc.apply(&transaction, view.id);
             exit_select_mode(cx);
         }
     })
@@ -1334,7 +1427,7 @@ fn switch_case_impl<F>(cx: &mut Context, change_fn: F)
         (range.from(), range.to(), Some(text))
     });
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn switch_case(cx: &mut Context) {
@@ -1374,53 +1467,73 @@ pub fn scroll(cx: &mut Context, offset: usize, direction: Direction) {
     let range = doc.selection(view.id).primary();
     let text = doc.text().slice(..);
 
-    let cursor = visual_coords_at_pos(text, range.cursor(text), doc.tab_width());
-    let doc_last_line = doc.text().len_lines().saturating_sub(1);
-
-    let last_line = view.last_line(doc);
-
-    if direction == Backward && view.offset.row == 0
-        || direction == Forward && last_line == doc_last_line
-    {
-        return;
-    }
-
+    let cursor = range.cursor(text);
     let height = view.inner_height();
 
-    let scrolloff = config.scrolloff.min(height / 2);
-
-    view.offset.row = match direction {
-        Forward => view.offset.row + offset,
-        Backward => view.offset.row.saturating_sub(offset),
-    }
-    .min(doc_last_line);
-
-    // recalculate last line
-    let last_line = view.last_line(doc);
+    let scrolloff = config.scrolloff.min(height.saturating_sub(1) / 2);
+    let offset = match direction {
+        Forward => offset as isize,
+        Backward => -(offset as isize),
+    };
 
-    // clamp into viewport
-    let line = cursor
-        .row
-        .max(view.offset.row + scrolloff)
-        .min(last_line.saturating_sub(scrolloff));
+    let doc_text = doc.text().slice(..);
+    let viewport = view.inner_area(doc);
+    let text_fmt = doc.text_format(viewport.width, None);
+    let annotations = view.text_annotations(doc, None);
+    (view.offset.anchor, view.offset.vertical_offset) = char_idx_at_visual_offset(
+        doc_text,
+        view.offset.anchor,
+        view.offset.vertical_offset as isize + offset,
+        0,
+        &text_fmt,
+        &annotations,
+    );
 
-    // If cursor needs moving, replace primary selection
-    if line != cursor.row {
-        let head = pos_at_visual_coords(text, Position::new(line, cursor.col), doc.tab_width()); // this func will properly truncate to line end
+    let mut head;
+    match direction {
+        Forward => {
+            let off;
+            (head, off) = char_idx_at_visual_offset(
+                doc_text,
+                view.offset.anchor,
+                (view.offset.vertical_offset + scrolloff) as isize,
+                0,
+                &text_fmt,
+                &annotations,
+            );
+            head += (off != 0) as usize;
+            if head <= cursor {
+                return;
+            }
+        }
+        Backward => {
+            head = char_idx_at_visual_offset(
+                doc_text,
+                view.offset.anchor,
+                (view.offset.vertical_offset + height - scrolloff - 1) as isize,
+                0,
+                &text_fmt,
+                &annotations,
+            )
+            .0;
+            if head >= cursor {
+                return;
+            }
+        }
+    }
 
-        let anchor = if cx.editor.mode == Mode::Select {
-            range.anchor
-        } else {
-            head
-        };
+    let anchor = if cx.editor.mode == Mode::Select {
+        range.anchor
+    } else {
+        head
+    };
 
-        // replace primary selection with an empty selection at cursor pos
-        let prim_sel = Range::new(anchor, head);
-        let mut sel = doc.selection(view.id).clone();
-        let idx = sel.primary_index();
-        sel = sel.replace(idx, prim_sel);
-        doc.set_selection(view.id, sel);
-    }
+    // replace primary selection with an empty selection at cursor pos
+    let prim_sel = Range::new(anchor, head);
+    let mut sel = doc.selection(view.id).clone();
+    let idx = sel.primary_index();
+    sel = sel.replace(idx, prim_sel);
+    doc.set_selection(view.id, sel);
 }
 
 fn page_up(cx: &mut Context) {
@@ -1447,7 +1560,15 @@ fn half_page_down(cx: &mut Context) {
     scroll(cx, offset, Direction::Forward);
 }
 
+#[allow(deprecated)]
+// currently uses the deprecated `visual_coords_at_pos`/`pos_at_visual_coords` functions
+// as this function ignores softwrapping (and virtual text) and instead only cares
+// about "text visual position"
+//
+// TODO: implement a variant of that uses visual lines and respects virtual text
 fn copy_selection_on_line(cx: &mut Context, direction: Direction) {
+    use helix_core::{pos_at_visual_coords, visual_coords_at_pos};
+
     let count = cx.count();
     let (view, doc) = current!(cx.editor);
     let text = doc.text().slice(..);
@@ -1514,6 +1635,10 @@ fn copy_selection_on_line(cx: &mut Context, direction: Direction) {
                 sels += 1;
             }
 
+            if anchor_row == 0 && head_row == 0 {
+                break;
+            }
+
             i += 1;
         }
     }
@@ -1589,6 +1714,12 @@ fn split_selection_on_newline(cx: &mut Context) {
     doc.set_selection(view.id, selection);
 }
 
+fn merge_consecutive_selections(cx: &mut Context) {
+    let (view, doc) = current!(cx.editor);
+    let selection = doc.selection(view.id).clone().merge_consecutive_ranges();
+    doc.set_selection(view.id, selection);
+}
+
 #[allow(clippy::too_many_arguments)]
 fn search_impl(
     editor: &mut Editor,
@@ -1858,7 +1989,7 @@ fn new(path: &Path, line_num: usize) -> Self {
     impl ui::menu::Item for FileResult {
         type Data = Option<PathBuf>;
 
-        fn label(&self, current_path: &Self::Data) -> Spans {
+        fn format(&self, current_path: &Self::Data) -> Row {
             let relative_path = helix_core::path::get_relative_path(&self.path)
                 .to_string_lossy()
                 .into_owned();
@@ -1908,6 +2039,11 @@ fn label(&self, current_path: &Self::Data) -> Spans {
 
                 let search_root = std::env::current_dir()
                     .expect("Global search error: Failed to get current dir");
+                let dedup_symlinks = file_picker_config.deduplicate_links;
+                let absolute_root = search_root
+                    .canonicalize()
+                    .unwrap_or_else(|_| search_root.clone());
+
                 WalkBuilder::new(search_root)
                     .hidden(file_picker_config.hidden)
                     .parents(file_picker_config.parents)
@@ -1917,10 +2053,9 @@ fn label(&self, current_path: &Self::Data) -> Spans {
                     .git_global(file_picker_config.git_global)
                     .git_exclude(file_picker_config.git_exclude)
                     .max_depth(file_picker_config.max_depth)
-                    // We always want to ignore the .git directory, otherwise if
-                    // `ignore` is turned off above, we end up with a lot of noise
-                    // in our picker.
-                    .filter_entry(|entry| entry.file_name() != ".git")
+                    .filter_entry(move |entry| {
+                        filter_picker_entry(entry, &absolute_root, dedup_symlinks)
+                    })
                     .build_parallel()
                     .run(|| {
                         let mut searcher = searcher.clone();
@@ -1998,6 +2133,10 @@ fn label(&self, current_path: &Self::Data) -> Spans {
                         let line_num = *line_num;
                         let (view, doc) = current!(cx.editor);
                         let text = doc.text();
+                        if line_num >= text.len_lines() {
+                            cx.editor.set_error("The line you jumped to does not exist anymore because the file has changed.");
+                            return;
+                        }
                         let start = text.line_to_char(line_num);
                         let end = text.line_to_char((line_num + 1).min(text.len_lines()));
 
@@ -2008,7 +2147,7 @@ fn label(&self, current_path: &Self::Data) -> Spans {
                         Some((path.clone().into(), Some((*line_num, *line_num))))
                     },
                 );
-                compositor.push(Box::new(overlayed(picker)));
+                compositor.push(Box::new(overlaid(picker)));
             },
         ));
         Ok(call)
@@ -2046,16 +2185,10 @@ fn extend_line_impl(cx: &mut Context, extend: Extend) {
     let selection = doc.selection(view.id).clone().transform(|range| {
         let (start_line, end_line) = range.line_range(text.slice(..));
 
-        let start = text.line_to_char(match extend {
-            Extend::Above => start_line.saturating_sub(count - 1),
-            Extend::Below => start_line,
-        });
+        let start = text.line_to_char(start_line);
         let end = text.line_to_char(
-            match extend {
-                Extend::Above => end_line + 1, // the start of next line
-                Extend::Below => end_line + count,
-            }
-            .min(text.len_lines()),
+            (end_line + 1) // newline of end_line
+                .min(text.len_lines()),
         );
 
         // extend to previous/next line if current line is selected
@@ -2069,8 +2202,11 @@ fn extend_line_impl(cx: &mut Context, extend: Extend) {
             }
         } else {
             match extend {
-                Extend::Above => (end, start),
-                Extend::Below => (start, end),
+                Extend::Above => (end, text.line_to_char(start_line.saturating_sub(count - 1))),
+                Extend::Below => (
+                    start,
+                    text.line_to_char((end_line + count).min(text.len_lines())),
+                ),
             }
         };
 
@@ -2156,7 +2292,7 @@ fn delete_selection_impl(cx: &mut Context, op: Operation) {
     let transaction = Transaction::change_by_selection(doc.text(), selection, |range| {
         (range.from(), range.to(), None)
     });
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 
     match op {
         Operation::Delete => {
@@ -2174,7 +2310,7 @@ fn delete_selection_insert_mode(doc: &mut Document, view: &mut View, selection:
     let transaction = Transaction::change_by_selection(doc.text(), selection, |range| {
         (range.from(), range.to(), None)
     });
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn delete_selection(cx: &mut Context) {
@@ -2270,7 +2406,7 @@ fn append_mode(cx: &mut Context) {
             doc.text(),
             [(end, end, Some(doc.line_ending.as_str().into()))].into_iter(),
         );
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
     }
 
     let selection = doc.selection(view.id).clone().transform(|range| {
@@ -2283,17 +2419,31 @@ fn append_mode(cx: &mut Context) {
 }
 
 fn file_picker(cx: &mut Context) {
-    // We don't specify language markers, root will be the root of the current
-    // git repo or the current dir if we're not in a repo
-    let root = find_root(None, &[]);
+    let root = find_workspace().0;
     let picker = ui::file_picker(root, &cx.editor.config());
-    cx.push_layer(Box::new(overlayed(picker)));
+    cx.push_layer(Box::new(overlaid(picker)));
 }
 
+fn file_picker_in_current_buffer_directory(cx: &mut Context) {
+    let doc_dir = doc!(cx.editor)
+        .path()
+        .and_then(|path| path.parent().map(|path| path.to_path_buf()));
+
+    let path = match doc_dir {
+        Some(path) => path,
+        None => {
+            cx.editor.set_error("current buffer has no path or parent");
+            return;
+        }
+    };
+
+    let picker = ui::file_picker(path, &cx.editor.config());
+    cx.push_layer(Box::new(overlaid(picker)));
+}
 fn file_picker_in_current_directory(cx: &mut Context) {
     let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("./"));
     let picker = ui::file_picker(cwd, &cx.editor.config());
-    cx.push_layer(Box::new(overlayed(picker)));
+    cx.push_layer(Box::new(overlaid(picker)));
 }
 
 fn buffer_picker(cx: &mut Context) {
@@ -2309,7 +2459,7 @@ struct BufferMeta {
     impl ui::menu::Item for BufferMeta {
         type Data = ();
 
-        fn label(&self, _data: &Self::Data) -> Spans {
+        fn format(&self, _data: &Self::Data) -> Row {
             let path = self
                 .path
                 .as_deref()
@@ -2319,20 +2469,15 @@ fn label(&self, _data: &Self::Data) -> Spans {
                 None => SCRATCH_BUFFER_NAME,
             };
 
-            let mut flags = Vec::new();
+            let mut flags = String::new();
             if self.is_modified {
-                flags.push("+");
+                flags.push('+');
             }
             if self.is_current {
-                flags.push("*");
+                flags.push('*');
             }
 
-            let flag = if flags.is_empty() {
-                "".into()
-            } else {
-                format!(" ({})", flags.join(""))
-            };
-            format!("{} {}{}", self.id, path, flag).into()
+            Row::new([self.id.to_string(), flags, path.to_string()])
         }
     }
 
@@ -2363,7 +2508,7 @@ fn label(&self, _data: &Self::Data) -> Spans {
             Some((meta.id.into(), Some((line, line))))
         },
     );
-    cx.push_layer(Box::new(overlayed(picker)));
+    cx.push_layer(Box::new(overlaid(picker)));
 }
 
 fn jumplist_picker(cx: &mut Context) {
@@ -2378,7 +2523,7 @@ struct JumpMeta {
     impl ui::menu::Item for JumpMeta {
         type Data = ();
 
-        fn label(&self, _data: &Self::Data) -> Spans {
+        fn format(&self, _data: &Self::Data) -> Row {
             let path = self
                 .path
                 .as_deref()
@@ -2445,13 +2590,13 @@ fn label(&self, _data: &Self::Data) -> Spans {
             Some((meta.path.clone()?.into(), Some((line, line))))
         },
     );
-    cx.push_layer(Box::new(overlayed(picker)));
+    cx.push_layer(Box::new(overlaid(picker)));
 }
 
 impl ui::menu::Item for MappableCommand {
     type Data = ReverseKeymap;
 
-    fn label(&self, keymap: &Self::Data) -> Spans {
+    fn format(&self, keymap: &Self::Data) -> Row {
         let fmt_binding = |bindings: &Vec<Vec<KeyEvent>>| -> String {
             bindings.iter().fold(String::new(), |mut acc, bind| {
                 if !acc.is_empty() {
@@ -2502,9 +2647,24 @@ pub fn command_palette(cx: &mut Context) {
                     on_next_key_callback: None,
                     jobs: cx.jobs,
                 };
+                let focus = view!(ctx.editor).id;
+
                 command.execute(&mut ctx);
+
+                if ctx.editor.tree.contains(focus) {
+                    let config = ctx.editor.config();
+                    let mode = ctx.editor.mode();
+                    let view = view_mut!(ctx.editor, focus);
+                    let doc = doc_mut!(ctx.editor, &view.doc);
+
+                    view.ensure_cursor_in_view(doc, config.scrolloff);
+
+                    if mode != Mode::Insert {
+                        doc.append_changes_to_history(view);
+                    }
+                }
             });
-            compositor.push(Box::new(overlayed(picker)));
+            compositor.push(Box::new(overlaid(picker)));
         },
     ));
 }
@@ -2565,7 +2725,7 @@ async fn make_format_callback(
 
         if let Ok(format) = format {
             if doc.version() == doc_version {
-                apply_transaction(&format, doc, view);
+                doc.apply(&format, view.id);
                 doc.append_changes_to_history(view);
                 doc.detect_indent_and_line_ending();
                 view.ensure_cursor_in_view(doc, scrolloff);
@@ -2658,7 +2818,7 @@ fn open(cx: &mut Context, open: Open) {
 
     transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 // o inserts a new line after each line with a selection
@@ -2682,10 +2842,15 @@ fn push_jump(view: &mut View, doc: &Document) {
 }
 
 fn goto_line(cx: &mut Context) {
-    goto_line_impl(cx.editor, cx.count)
+    if cx.count.is_some() {
+        let (view, doc) = current!(cx.editor);
+        push_jump(view, doc);
+
+        goto_line_without_jumplist(cx.editor, cx.count);
+    }
 }
 
-fn goto_line_impl(editor: &mut Editor, count: Option<NonZeroUsize>) {
+fn goto_line_without_jumplist(editor: &mut Editor, count: Option<NonZeroUsize>) {
     if let Some(count) = count {
         let (view, doc) = current!(editor);
         let text = doc.text().slice(..);
@@ -2702,7 +2867,6 @@ fn goto_line_impl(editor: &mut Editor, count: Option<NonZeroUsize>) {
             .clone()
             .transform(|range| range.put_cursor(text, pos, editor.mode == Mode::Select));
 
-        push_jump(view, doc);
         doc.set_selection(view.id, selection);
     }
 }
@@ -2789,35 +2953,26 @@ fn exit_select_mode(cx: &mut Context) {
     }
 }
 
-fn goto_pos(editor: &mut Editor, pos: usize) {
-    let (view, doc) = current!(editor);
-
-    push_jump(view, doc);
-    doc.set_selection(view.id, Selection::point(pos));
-    align_view(doc, view, Align::Center);
-}
-
 fn goto_first_diag(cx: &mut Context) {
-    let doc = doc!(cx.editor);
-    let pos = match doc.diagnostics().first() {
-        Some(diag) => diag.range.start,
+    let (view, doc) = current!(cx.editor);
+    let selection = match doc.diagnostics().first() {
+        Some(diag) => Selection::single(diag.range.start, diag.range.end),
         None => return,
     };
-    goto_pos(cx.editor, pos);
+    doc.set_selection(view.id, selection);
 }
 
 fn goto_last_diag(cx: &mut Context) {
-    let doc = doc!(cx.editor);
-    let pos = match doc.diagnostics().last() {
-        Some(diag) => diag.range.start,
+    let (view, doc) = current!(cx.editor);
+    let selection = match doc.diagnostics().last() {
+        Some(diag) => Selection::single(diag.range.start, diag.range.end),
         None => return,
     };
-    goto_pos(cx.editor, pos);
+    doc.set_selection(view.id, selection);
 }
 
 fn goto_next_diag(cx: &mut Context) {
-    let editor = &mut cx.editor;
-    let (view, doc) = current!(editor);
+    let (view, doc) = current!(cx.editor);
 
     let cursor_pos = doc
         .selection(view.id)
@@ -2830,17 +2985,15 @@ fn goto_next_diag(cx: &mut Context) {
         .find(|diag| diag.range.start > cursor_pos)
         .or_else(|| doc.diagnostics().first());
 
-    let pos = match diag {
-        Some(diag) => diag.range.start,
+    let selection = match diag {
+        Some(diag) => Selection::single(diag.range.start, diag.range.end),
         None => return,
     };
-
-    goto_pos(editor, pos);
+    doc.set_selection(view.id, selection);
 }
 
 fn goto_prev_diag(cx: &mut Context) {
-    let editor = &mut cx.editor;
-    let (view, doc) = current!(editor);
+    let (view, doc) = current!(cx.editor);
 
     let cursor_pos = doc
         .selection(view.id)
@@ -2854,12 +3007,13 @@ fn goto_prev_diag(cx: &mut Context) {
         .find(|diag| diag.range.start < cursor_pos)
         .or_else(|| doc.diagnostics().last());
 
-    let pos = match diag {
-        Some(diag) => diag.range.start,
+    let selection = match diag {
+        // NOTE: the selection is reversed because we're jumping to the
+        // previous diagnostic.
+        Some(diag) => Selection::single(diag.range.end, diag.range.start),
         None => return,
     };
-
-    goto_pos(editor, pos);
+    doc.set_selection(view.id, selection);
 }
 
 fn goto_first_change(cx: &mut Context) {
@@ -2872,20 +3026,20 @@ fn goto_last_change(cx: &mut Context) {
 
 fn goto_first_change_impl(cx: &mut Context, reverse: bool) {
     let editor = &mut cx.editor;
-    let (_, doc) = current!(editor);
+    let (view, doc) = current!(editor);
     if let Some(handle) = doc.diff_handle() {
         let hunk = {
-            let hunks = handle.hunks();
+            let diff = handle.load();
             let idx = if reverse {
-                hunks.len().saturating_sub(1)
+                diff.len().saturating_sub(1)
             } else {
                 0
             };
-            hunks.nth_hunk(idx)
+            diff.nth_hunk(idx)
         };
         if hunk != Hunk::NONE {
-            let pos = doc.text().line_to_char(hunk.after.start as usize);
-            goto_pos(editor, pos)
+            let range = hunk_range(hunk, doc.text().slice(..));
+            doc.set_selection(view.id, Selection::single(range.anchor, range.head));
         }
     }
 }
@@ -2913,30 +3067,20 @@ fn goto_next_change_impl(cx: &mut Context, direction: Direction) {
         let selection = doc.selection(view.id).clone().transform(|range| {
             let cursor_line = range.cursor_line(doc_text) as u32;
 
-            let hunks = diff_handle.hunks();
+            let diff = diff_handle.load();
             let hunk_idx = match direction {
-                Direction::Forward => hunks
+                Direction::Forward => diff
                     .next_hunk(cursor_line)
-                    .map(|idx| (idx + count).min(hunks.len() - 1)),
-                Direction::Backward => hunks
+                    .map(|idx| (idx + count).min(diff.len() - 1)),
+                Direction::Backward => diff
                     .prev_hunk(cursor_line)
                     .map(|idx| idx.saturating_sub(count)),
             };
-            // TODO refactor with let..else once MSRV reaches 1.65
-            let hunk_idx = if let Some(hunk_idx) = hunk_idx {
-                hunk_idx
-            } else {
+            let Some(hunk_idx) = hunk_idx else {
                 return range;
             };
-            let hunk = hunks.nth_hunk(hunk_idx);
-
-            let hunk_start = doc_text.line_to_char(hunk.after.start as usize);
-            let hunk_end = if hunk.after.is_empty() {
-                hunk_start + 1
-            } else {
-                doc_text.line_to_char(hunk.after.end as usize)
-            };
-            let new_range = Range::new(hunk_start, hunk_end);
+            let hunk = diff.nth_hunk(hunk_idx);
+            let new_range = hunk_range(hunk, doc_text);
             if editor.mode == Mode::Select {
                 let head = if new_range.head < range.anchor {
                     new_range.anchor
@@ -2956,6 +3100,20 @@ fn goto_next_change_impl(cx: &mut Context, direction: Direction) {
     cx.editor.last_motion = Some(Motion(Box::new(motion)));
 }
 
+/// Returns the [Range] for a [Hunk] in the given text.
+/// Additions and modifications cover the added and modified ranges.
+/// Deletions are represented as the point at the start of the deletion hunk.
+fn hunk_range(hunk: Hunk, text: RopeSlice) -> Range {
+    let anchor = text.line_to_char(hunk.after.start as usize);
+    let head = if hunk.after.is_empty() {
+        anchor + 1
+    } else {
+        text.line_to_char(hunk.after.end as usize)
+    };
+
+    Range::new(anchor, head)
+}
+
 pub mod insert {
     use super::*;
     pub type Hook = fn(&Rope, &Selection, char) -> Option<Transaction>;
@@ -3084,7 +3242,7 @@ pub fn insert_char(cx: &mut Context, c: char) {
 
         let (view, doc) = current!(cx.editor);
         if let Some(t) = transaction {
-            apply_transaction(&t, doc, view);
+            doc.apply(&t, view.id);
         }
 
         // TODO: need a post insert hook too for certain triggers (autocomplete, signature help, etc)
@@ -3106,7 +3264,7 @@ pub fn insert_tab(cx: &mut Context) {
             &doc.selection(view.id).clone().cursors(doc.text().slice(..)),
             indent,
         );
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
     }
 
     pub fn insert_newline(cx: &mut Context) {
@@ -3164,8 +3322,7 @@ pub fn insert_newline(cx: &mut Context) {
                 let on_auto_pair = doc
                     .auto_pairs(cx.editor)
                     .and_then(|pairs| pairs.get(prev))
-                    .and_then(|pair| if pair.close == curr { Some(pair) } else { None })
-                    .is_some();
+                    .map_or(false, |pair| pair.open == prev && pair.close == curr);
 
                 let local_offs = if on_auto_pair {
                     let inner_indent = indent.clone() + doc.indent_style.as_str();
@@ -3212,15 +3369,15 @@ pub fn insert_newline(cx: &mut Context) {
         transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
 
         let (view, doc) = current!(cx.editor);
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
     }
 
     pub fn delete_char_backward(cx: &mut Context) {
         let count = cx.count();
         let (view, doc) = current_ref!(cx.editor);
         let text = doc.text().slice(..);
-        let indent_unit = doc.indent_style.as_str();
-        let tab_size = doc.tab_width();
+        let tab_width = doc.tab_width();
+        let indent_width = doc.indent_width();
         let auto_pairs = doc.auto_pairs(cx.editor);
 
         let transaction =
@@ -3241,18 +3398,11 @@ pub fn delete_char_backward(cx: &mut Context) {
                             None,
                         )
                     } else {
-                        let unit_len = indent_unit.chars().count();
-                        // NOTE: indent_unit always contains 'only spaces' or 'only tab' according to `IndentStyle` definition.
-                        let unit_size = if indent_unit.starts_with('\t') {
-                            tab_size * unit_len
-                        } else {
-                            unit_len
-                        };
                         let width: usize = fragment
                             .chars()
                             .map(|ch| {
                                 if ch == '\t' {
-                                    tab_size
+                                    tab_width
                                 } else {
                                     // it can be none if it still meet control characters other than '\t'
                                     // here just set the width to 1 (or some value better?).
@@ -3260,9 +3410,9 @@ pub fn delete_char_backward(cx: &mut Context) {
                                 }
                             })
                             .sum();
-                        let mut drop = width % unit_size; // round down to nearest unit
+                        let mut drop = width % indent_width; // round down to nearest unit
                         if drop == 0 {
-                            drop = unit_size
+                            drop = indent_width
                         }; // if it's already at a unit, consume a whole unit
                         let mut chars = fragment.chars().rev();
                         let mut start = pos;
@@ -3307,7 +3457,7 @@ pub fn delete_char_backward(cx: &mut Context) {
                 }
             });
         let (view, doc) = current!(cx.editor);
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
 
         lsp::signature_help_impl(cx, SignatureHelpInvoked::Automatic);
     }
@@ -3325,7 +3475,7 @@ pub fn delete_char_forward(cx: &mut Context) {
                     None,
                 )
             });
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
 
         lsp::signature_help_impl(cx, SignatureHelpInvoked::Automatic);
     }
@@ -3606,7 +3756,8 @@ fn paste_impl(
         transaction = transaction.with_selection(Selection::new(ranges, selection.primary_index()));
     }
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
+    doc.append_changes_to_history(view);
 }
 
 pub(crate) fn paste_bracketed_value(cx: &mut Context, contents: String) {
@@ -3698,7 +3849,7 @@ fn replace_with_yanked(cx: &mut Context) {
                 }
             });
 
-            apply_transaction(&transaction, doc, view);
+            doc.apply(&transaction, view.id);
             exit_select_mode(cx);
         }
     }
@@ -3722,7 +3873,7 @@ fn replace_selections_with_clipboard_impl(
                 )
             });
 
-            apply_transaction(&transaction, doc, view);
+            doc.apply(&transaction, view.id);
             doc.append_changes_to_history(view);
         }
         Err(e) => return Err(e.context("Couldn't get system clipboard contents")),
@@ -3794,7 +3945,7 @@ fn indent(cx: &mut Context) {
             Some((pos, pos, Some(indent.clone())))
         }),
     );
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn unindent(cx: &mut Context) {
@@ -3803,7 +3954,7 @@ fn unindent(cx: &mut Context) {
     let lines = get_lines(doc, view.id);
     let mut changes = Vec::with_capacity(lines.len());
     let tab_width = doc.tab_width();
-    let indent_width = count * tab_width;
+    let indent_width = count * doc.indent_width();
 
     for line_idx in lines {
         let line = doc.text().line(line_idx);
@@ -3833,7 +3984,7 @@ fn unindent(cx: &mut Context) {
 
     let transaction = Transaction::change(doc.text(), changes.into_iter());
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn format_selections(cx: &mut Context) {
@@ -3888,7 +4039,7 @@ fn format_selections(cx: &mut Context) {
         language_server.offset_encoding(),
     );
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn join_selections_impl(cx: &mut Context, select_space: bool) {
@@ -3920,6 +4071,11 @@ fn join_selections_impl(cx: &mut Context, select_space: bool) {
         }
     }
 
+    // nothing to do, bail out early to avoid crashes later
+    if changes.is_empty() {
+        return;
+    }
+
     changes.sort_unstable_by_key(|(from, _to, _text)| *from);
     changes.dedup();
 
@@ -3942,7 +4098,7 @@ fn join_selections_impl(cx: &mut Context, select_space: bool) {
         Transaction::change(doc.text(), changes.into_iter())
     };
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn keep_or_remove_selections_impl(cx: &mut Context, remove: bool) {
@@ -4029,6 +4185,24 @@ pub fn completion(cx: &mut Context) {
         None => return,
     };
 
+    // setup a channel that allows the request to be canceled
+    let (tx, rx) = oneshot::channel();
+    // set completion_request so that this request can be canceled
+    // by setting completion_request, the old channel stored there is dropped
+    // and the associated request is automatically dropped
+    cx.editor.completion_request_handle = Some(tx);
+    let future = async move {
+        tokio::select! {
+            biased;
+            _ = rx => {
+                Ok(serde_json::Value::Null)
+            }
+            res = future => {
+                res
+            }
+        }
+    };
+
     let trigger_offset = cursor;
 
     // TODO: trigger_offset should be the cursor offset but we also need a starting offset from where we want to apply
@@ -4039,12 +4213,35 @@ pub fn completion(cx: &mut Context) {
     iter.reverse();
     let offset = iter.take_while(|ch| chars::char_is_word(*ch)).count();
     let start_offset = cursor.saturating_sub(offset);
+    let savepoint = doc.savepoint(view);
+
+    let trigger_doc = doc.id();
+    let trigger_view = view.id;
+
+    // FIXME: The commands Context can only have a single callback
+    // which means it gets overwritten when executing keybindings
+    // with multiple commands or macros. This would mean that completion
+    // might be incorrectly applied when repeating the insertmode action
+    //
+    // TODO: to solve this either make cx.callback a Vec of callbacks or
+    // alternatively move `last_insert` to `helix_view::Editor`
+    cx.callback = Some(Box::new(
+        move |compositor: &mut Compositor, _cx: &mut compositor::Context| {
+            let ui = compositor.find::<ui::EditorView>().unwrap();
+            ui.last_insert.1.push(InsertEvent::RequestCompletion);
+        },
+    ));
 
     cx.callback(
         future,
         move |editor, compositor, response: Option<lsp::CompletionResponse>| {
-            if editor.mode != Mode::Insert {
-                // we're not in insert mode anymore
+            let (view, doc) = current_ref!(editor);
+            // check if the completion request is stale.
+            //
+            // Completions are completed asynchronously and therefore the user could
+            //switch document/view or leave insert mode. In all of thoise cases the
+            // completion should be discarded
+            if editor.mode != Mode::Insert || view.id != trigger_view || doc.id() != trigger_doc {
                 return;
             }
 
@@ -4064,14 +4261,24 @@ pub fn completion(cx: &mut Context) {
             }
             let size = compositor.size();
             let ui = compositor.find::<ui::EditorView>().unwrap();
-            ui.set_completion(
+            let completion_area = ui.set_completion(
                 editor,
+                savepoint,
                 items,
                 offset_encoding,
                 start_offset,
                 trigger_offset,
                 size,
             );
+            let size = compositor.size();
+            let signature_help_area = compositor
+                .find_id::<Popup<SignatureHelp>>(SignatureHelp::ID)
+                .map(|signature_help| signature_help.area(size, editor));
+            // Delete the signature help popup if they intersect.
+            if matches!((completion_area, signature_help_area),(Some(a), Some(b)) if a.intersects(b))
+            {
+                compositor.remove(SignatureHelp::ID);
+            }
         },
     );
 }
@@ -4085,7 +4292,7 @@ fn toggle_comments(cx: &mut Context) {
         .map(|tc| tc.as_ref());
     let transaction = comment::toggle_line_comments(doc.text(), doc.selection(view.id), token);
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
     exit_select_mode(cx);
 }
 
@@ -4141,7 +4348,7 @@ fn rotate_selection_contents(cx: &mut Context, direction: Direction) {
             .map(|(range, fragment)| (range.from(), range.to(), Some(fragment))),
     );
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 fn rotate_selection_contents_forward(cx: &mut Context) {
@@ -4183,7 +4390,6 @@ fn shrink_selection(cx: &mut Context) {
         // try to restore previous selection
         if let Some(prev_selection) = view.object_selections.pop() {
             if current_selection.contains(&prev_selection) {
-                // allow shrinking the selection only if current selection contains the previous object selection
                 doc.set_selection(view.id, prev_selection);
                 return;
             } else {
@@ -4299,6 +4505,10 @@ fn rotate_view(cx: &mut Context) {
     cx.editor.focus_next()
 }
 
+fn rotate_view_reverse(cx: &mut Context) {
+    cx.editor.focus_prev()
+}
+
 fn jump_view_right(cx: &mut Context) {
     cx.editor.focus_direction(tree::Direction::Right)
 }
@@ -4432,11 +4642,19 @@ fn align_view_bottom(cx: &mut Context) {
 
 fn align_view_middle(cx: &mut Context) {
     let (view, doc) = current!(cx.editor);
-    let text = doc.text().slice(..);
-    let pos = doc.selection(view.id).primary().cursor(text);
-    let pos = coords_at_pos(text, pos);
+    let inner_width = view.inner_width(doc);
+    let text_fmt = doc.text_format(inner_width, None);
+    // there is no horizontal position when softwrap is enabled
+    if text_fmt.soft_wrap {
+        return;
+    }
+    let doc_text = doc.text().slice(..);
+    let annotations = view.text_annotations(doc, None);
+    let pos = doc.selection(view.id).primary().cursor(doc_text);
+    let pos =
+        visual_offset_from_block(doc_text, view.offset.anchor, pos, &text_fmt, &annotations).0;
 
-    view.offset.col = pos
+    view.offset.horizontal_offset = pos
         .col
         .saturating_sub((view.inner_area(doc).width as usize) / 2);
 }
@@ -4571,14 +4789,14 @@ fn select_textobject(cx: &mut Context, objtype: textobject::TextObject) {
 
                 let textobject_change = |range: Range| -> Range {
                     let diff_handle = doc.diff_handle().unwrap();
-                    let hunks = diff_handle.hunks();
+                    let diff = diff_handle.load();
                     let line = range.cursor_line(text);
-                    let hunk_idx = if let Some(hunk_idx) = hunks.hunk_at(line as u32, false) {
+                    let hunk_idx = if let Some(hunk_idx) = diff.hunk_at(line as u32, false) {
                         hunk_idx
                     } else {
                         return range;
                     };
-                    let hunk = hunks.nth_hunk(hunk_idx).after;
+                    let hunk = diff.nth_hunk(hunk_idx).after;
 
                     let start = text.line_to_char(hunk.start as usize);
                     let end = text.line_to_char(hunk.end as usize);
@@ -4627,7 +4845,7 @@ fn select_textobject(cx: &mut Context, objtype: textobject::TextObject) {
         ("a", "Argument/parameter (tree-sitter)"),
         ("c", "Comment (tree-sitter)"),
         ("T", "Test (tree-sitter)"),
-        ("m", "Closest surrounding pair to cursor"),
+        ("m", "Closest surrounding pair"),
         (" ", "... or any character acting as a pair"),
     ];
 
@@ -4636,41 +4854,45 @@ fn select_textobject(cx: &mut Context, objtype: textobject::TextObject) {
 
 fn surround_add(cx: &mut Context) {
     cx.on_next_key(move |cx, event| {
-        let ch = match event.char() {
-            Some(ch) => ch,
+        let (view, doc) = current!(cx.editor);
+        // surround_len is the number of new characters being added.
+        let (open, close, surround_len) = match event.char() {
+            Some(ch) => {
+                let (o, c) = surround::get_pair(ch);
+                let mut open = Tendril::new();
+                open.push(o);
+                let mut close = Tendril::new();
+                close.push(c);
+                (open, close, 2)
+            }
+            None if event.code == KeyCode::Enter => (
+                doc.line_ending.as_str().into(),
+                doc.line_ending.as_str().into(),
+                2 * doc.line_ending.len_chars(),
+            ),
             None => return,
         };
-        let (view, doc) = current!(cx.editor);
-        let selection = doc.selection(view.id);
-        let (open, close) = surround::get_pair(ch);
-        // The number of chars in get_pair
-        let surround_len = 2;
 
+        let selection = doc.selection(view.id);
         let mut changes = Vec::with_capacity(selection.len() * 2);
         let mut ranges = SmallVec::with_capacity(selection.len());
         let mut offs = 0;
 
         for range in selection.iter() {
-            let mut o = Tendril::new();
-            o.push(open);
-            let mut c = Tendril::new();
-            c.push(close);
-            changes.push((range.from(), range.from(), Some(o)));
-            changes.push((range.to(), range.to(), Some(c)));
-
-            // Add 2 characters to the range to select them
+            changes.push((range.from(), range.from(), Some(open.clone())));
+            changes.push((range.to(), range.to(), Some(close.clone())));
+
             ranges.push(
                 Range::new(offs + range.from(), offs + range.to() + surround_len)
                     .with_direction(range.direction()),
             );
 
-            // Add 2 characters to the offset for the next ranges
             offs += surround_len;
         }
 
         let transaction = Transaction::change(doc.text(), changes.into_iter())
             .with_selection(Selection::new(ranges, selection.primary_index()));
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
         exit_select_mode(cx);
     })
 }
@@ -4710,7 +4932,7 @@ fn surround_replace(cx: &mut Context) {
                     (pos, pos + 1, Some(t))
                 }),
             );
-            apply_transaction(&transaction, doc, view);
+            doc.apply(&transaction, view.id);
             exit_select_mode(cx);
         });
     })
@@ -4738,7 +4960,7 @@ fn surround_delete(cx: &mut Context) {
 
         let transaction =
             Transaction::change(doc.text(), change_pos.into_iter().map(|p| (p, p + 1, None)));
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
         exit_select_mode(cx);
     })
 }
@@ -4875,7 +5097,10 @@ async fn shell_impl_async(
             log::error!("Shell error: {}", err);
             bail!("Shell error: {}", err);
         }
-        bail!("Shell command failed");
+        match output.status.code() {
+            Some(exit_code) => bail!("Shell command failed: status {}", exit_code),
+            None => bail!("Shell command failed"),
+        }
     } else if !output.stderr.is_empty() {
         log::debug!(
             "Command printed to stderr: {}",
@@ -4953,7 +5178,7 @@ fn shell(cx: &mut compositor::Context, cmd: &str, behavior: &ShellBehavior) {
     if behavior != &ShellBehavior::Ignore {
         let transaction = Transaction::change(doc.text(), changes.into_iter())
             .with_selection(Selection::new(ranges, selection.primary_index()));
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
         doc.append_changes_to_history(view);
     }
 
@@ -5016,64 +5241,32 @@ fn add_newline_impl(cx: &mut Context, open: Open) {
     });
 
     let transaction = Transaction::change(text, changes);
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 }
 
 enum IncrementDirection {
     Increase,
     Decrease,
 }
-/// Increment object under cursor by count.
+
+/// Increment objects within selections by count.
 fn increment(cx: &mut Context) {
     increment_impl(cx, IncrementDirection::Increase);
 }
 
-/// Decrement object under cursor by count.
+/// Decrement objects within selections by count.
 fn decrement(cx: &mut Context) {
     increment_impl(cx, IncrementDirection::Decrease);
 }
 
-/// This function differs from find_next_char_impl in that it stops searching at the newline, but also
-/// starts searching at the current character, instead of the next.
-/// It does not want to start at the next character because this function is used for incrementing
-/// number and we don't want to move forward if we're already on a digit.
-fn find_next_char_until_newline<M: CharMatcher>(
-    text: RopeSlice,
-    char_matcher: M,
-    pos: usize,
-    _count: usize,
-    _inclusive: bool,
-) -> Option<usize> {
-    // Since we send the current line to find_nth_next instead of the whole text, we need to adjust
-    // the position we send to this function so that it's relative to that line and its returned
-    // position since it's expected this function returns a global position.
-    let line_index = text.char_to_line(pos);
-    let pos_delta = text.line_to_char(line_index);
-    let pos = pos - pos_delta;
-    search::find_nth_next(text.line(line_index), char_matcher, pos, 1).map(|pos| pos + pos_delta)
-}
-
-/// Decrement object under cursor by `amount`.
+/// Increment objects within selections by `amount`.
+/// A negative `amount` will decrement objects within selections.
 fn increment_impl(cx: &mut Context, increment_direction: IncrementDirection) {
-    // TODO: when incrementing or decrementing a number that gets a new digit or lose one, the
-    // selection is updated improperly.
-    find_char_impl(
-        cx.editor,
-        &find_next_char_until_newline,
-        true,
-        true,
-        char::is_ascii_digit,
-        1,
-    );
-
-    // Increase by 1 if `IncrementDirection` is `Increase`
-    // Decrease by 1 if `IncrementDirection` is `Decrease`
     let sign = match increment_direction {
         IncrementDirection::Increase => 1,
         IncrementDirection::Decrease => -1,
     };
     let mut amount = sign * cx.count() as i64;
-
     // If the register is `#` then increase or decrease the `amount` by 1 per element
     let increase_by = if cx.register == Some('#') { sign } else { 0 };
 
@@ -5081,56 +5274,41 @@ fn increment_impl(cx: &mut Context, increment_direction: IncrementDirection) {
     let selection = doc.selection(view.id);
     let text = doc.text().slice(..);
 
-    let changes: Vec<_> = selection
-        .ranges()
-        .iter()
-        .filter_map(|range| {
-            let incrementor: Box<dyn Increment> =
-                if let Some(incrementor) = DateTimeIncrementor::from_range(text, *range) {
-                    Box::new(incrementor)
-                } else if let Some(incrementor) = NumberIncrementor::from_range(text, *range) {
-                    Box::new(incrementor)
-                } else {
-                    return None;
-                };
-
-            let (range, new_text) = incrementor.increment(amount);
+    let mut new_selection_ranges = SmallVec::new();
+    let mut cumulative_length_diff: i128 = 0;
+    let mut changes = vec![];
 
-            amount += increase_by;
+    for range in selection {
+        let selected_text: Cow<str> = range.fragment(text);
+        let new_from = ((range.from() as i128) + cumulative_length_diff) as usize;
+        let incremented = [increment::integer, increment::date_time]
+            .iter()
+            .find_map(|incrementor| incrementor(selected_text.as_ref(), amount));
 
-            Some((range.from(), range.to(), Some(new_text)))
-        })
-        .collect();
+        amount += increase_by;
 
-    // Overlapping changes in a transaction will panic, so we need to find and remove them.
-    // For example, if there are cursors on each of the year, month, and day of `2021-11-29`,
-    // incrementing will give overlapping changes, with each change incrementing a different part of
-    // the date. Since these conflict with each other we remove these changes from the transaction
-    // so nothing happens.
-    let mut overlapping_indexes = HashSet::new();
-    for (i, changes) in changes.windows(2).enumerate() {
-        if changes[0].1 > changes[1].0 {
-            overlapping_indexes.insert(i);
-            overlapping_indexes.insert(i + 1);
+        match incremented {
+            None => {
+                let new_range = Range::new(
+                    new_from,
+                    (range.to() as i128 + cumulative_length_diff) as usize,
+                );
+                new_selection_ranges.push(new_range);
+            }
+            Some(new_text) => {
+                let new_range = Range::new(new_from, new_from + new_text.len());
+                cumulative_length_diff += new_text.len() as i128 - selected_text.len() as i128;
+                new_selection_ranges.push(new_range);
+                changes.push((range.from(), range.to(), Some(new_text.into())));
+            }
         }
     }
-    let changes: Vec<_> = changes
-        .into_iter()
-        .enumerate()
-        .filter_map(|(i, change)| {
-            if overlapping_indexes.contains(&i) {
-                None
-            } else {
-                Some(change)
-            }
-        })
-        .collect();
 
     if !changes.is_empty() {
+        let new_selection = Selection::new(new_selection_ranges, selection.primary_index());
         let transaction = Transaction::change(doc.text(), changes.into_iter());
-        let transaction = transaction.with_selection(selection.clone());
-
-        apply_transaction(&transaction, doc, view);
+        let transaction = transaction.with_selection(new_selection);
+        doc.apply(&transaction, view.id);
     }
 }
 
diff --git a/helix-term/src/commands/dap.rs b/helix-term/src/commands/dap.rs
index b182f28c4..8efdc9cfa 100644
--- a/helix-term/src/commands/dap.rs
+++ b/helix-term/src/commands/dap.rs
@@ -2,7 +2,7 @@
 use crate::{
     compositor::{self, Compositor},
     job::{Callback, Jobs},
-    ui::{self, overlay::overlayed, FilePicker, Picker, Popup, Prompt, PromptEvent, Text},
+    ui::{self, overlay::overlaid, FilePicker, Picker, Popup, Prompt, PromptEvent, Text},
 };
 use dap::{StackFrame, Thread, ThreadStates};
 use helix_core::syntax::{DebugArgumentValue, DebugConfigCompletion, DebugTemplate};
@@ -12,7 +12,7 @@
 
 use serde_json::{to_value, Value};
 use tokio_stream::wrappers::UnboundedReceiverStream;
-use tui::text::Spans;
+use tui::{text::Spans, widgets::Row};
 
 use std::collections::HashMap;
 use std::future::Future;
@@ -25,7 +25,7 @@
 impl ui::menu::Item for StackFrame {
     type Data = ();
 
-    fn label(&self, _data: &Self::Data) -> Spans {
+    fn format(&self, _data: &Self::Data) -> Row {
         self.name.as_str().into() // TODO: include thread_states in the label
     }
 }
@@ -33,7 +33,7 @@ fn label(&self, _data: &Self::Data) -> Spans {
 impl ui::menu::Item for DebugTemplate {
     type Data = ();
 
-    fn label(&self, _data: &Self::Data) -> Spans {
+    fn format(&self, _data: &Self::Data) -> Row {
         self.name.as_str().into()
     }
 }
@@ -41,7 +41,7 @@ fn label(&self, _data: &Self::Data) -> Spans {
 impl ui::menu::Item for Thread {
     type Data = ThreadStates;
 
-    fn label(&self, thread_states: &Self::Data) -> Spans {
+    fn format(&self, thread_states: &Self::Data) -> Row {
         format!(
             "{} ({})",
             self.name,
@@ -270,7 +270,7 @@ pub fn dap_launch(cx: &mut Context) {
 
     let templates = config.templates.clone();
 
-    cx.push_layer(Box::new(overlayed(Picker::new(
+    cx.push_layer(Box::new(overlaid(Picker::new(
         templates,
         (),
         |cx, template, _action| {
@@ -289,6 +289,36 @@ pub fn dap_launch(cx: &mut Context) {
     ))));
 }
 
+pub fn dap_restart(cx: &mut Context) {
+    let debugger = match &cx.editor.debugger {
+        Some(debugger) => debugger,
+        None => {
+            cx.editor.set_error("Debugger is not running");
+            return;
+        }
+    };
+    if !debugger
+        .capabilities()
+        .supports_restart_request
+        .unwrap_or(false)
+    {
+        cx.editor
+            .set_error("Debugger does not support session restarts");
+        return;
+    }
+    if debugger.starting_request_args().is_none() {
+        cx.editor
+            .set_error("No arguments found with which to restart the sessions");
+        return;
+    }
+
+    dap_callback(
+        cx.jobs,
+        debugger.restart(),
+        |editor, _compositor, _resp: ()| editor.set_status("Debugging session restarted"),
+    );
+}
+
 fn debug_parameter_prompt(
     completions: Vec<DebugConfigCompletion>,
     config_name: String,
@@ -475,19 +505,36 @@ pub fn dap_variables(cx: &mut Context) {
 
     if debugger.thread_id.is_none() {
         cx.editor
-            .set_status("Cannot access variables while target is running");
+            .set_status("Cannot access variables while target is running.");
         return;
     }
     let (frame, thread_id) = match (debugger.active_frame, debugger.thread_id) {
         (Some(frame), Some(thread_id)) => (frame, thread_id),
         _ => {
             cx.editor
-                .set_status("Cannot find current stack frame to access variables");
+                .set_status("Cannot find current stack frame to access variables.");
+            return;
+        }
+    };
+
+    let thread_frame = match debugger.stack_frames.get(&thread_id) {
+        Some(thread_frame) => thread_frame,
+        None => {
+            cx.editor
+                .set_error("Failed to get stack frame for thread: {thread_id}");
+            return;
+        }
+    };
+    let stack_frame = match thread_frame.get(frame) {
+        Some(stack_frame) => stack_frame,
+        None => {
+            cx.editor
+                .set_error("Failed to get stack frame for thread {thread_id} and frame {frame}.");
             return;
         }
     };
 
-    let frame_id = debugger.stack_frames[&thread_id][frame].id;
+    let frame_id = stack_frame.id;
     let scopes = match block_on(debugger.scopes(frame_id)) {
         Ok(s) => s,
         Err(e) => {
@@ -539,7 +586,7 @@ pub fn dap_variables(cx: &mut Context) {
 pub fn dap_terminate(cx: &mut Context) {
     let debugger = debugger!(cx.editor);
 
-    let request = debugger.disconnect();
+    let request = debugger.disconnect(None);
     dap_callback(cx.jobs, request, |editor, _compositor, _response: ()| {
         // editor.set_error(format!("Failed to disconnect: {}", e));
         editor.debugger = None;
diff --git a/helix-term/src/commands/lsp.rs b/helix-term/src/commands/lsp.rs
index 810e3adf1..7a26b3cf6 100644
--- a/helix-term/src/commands/lsp.rs
+++ b/helix-term/src/commands/lsp.rs
@@ -1,25 +1,38 @@
+use futures_util::FutureExt;
 use helix_lsp::{
     block_on,
-    lsp::{self, CodeAction, CodeActionOrCommand, DiagnosticSeverity, NumberOrString},
-    util::{diagnostic_to_lsp_diagnostic, lsp_pos_to_pos, lsp_range_to_range, range_to_lsp_range},
+    lsp::{
+        self, CodeAction, CodeActionOrCommand, CodeActionTriggerKind, DiagnosticSeverity,
+        NumberOrString,
+    },
+    util::{diagnostic_to_lsp_diagnostic, lsp_range_to_range, range_to_lsp_range},
     OffsetEncoding,
 };
-use tui::text::{Span, Spans};
+use tui::{
+    text::{Span, Spans},
+    widgets::Row,
+};
 
 use super::{align_view, push_jump, Align, Context, Editor, Open};
 
-use helix_core::{path, Selection};
-use helix_view::{apply_transaction, document::Mode, editor::Action, theme::Style};
+use helix_core::{path, text_annotations::InlineAnnotation, Selection};
+use helix_view::{
+    document::{DocumentInlayHints, DocumentInlayHintsId, Mode},
+    editor::Action,
+    theme::Style,
+    Document, View,
+};
 
 use crate::{
     compositor::{self, Compositor},
     ui::{
-        self, lsp::SignatureHelp, overlay::overlayed, FileLocation, FilePicker, Popup, PromptEvent,
+        self, lsp::SignatureHelp, overlay::overlaid, DynamicPicker, FileLocation, FilePicker,
+        Popup, PromptEvent,
     },
 };
 
 use std::{
-    borrow::Cow, cmp::Ordering, collections::BTreeMap, fmt::Write, path::PathBuf, sync::Arc,
+    cmp::Ordering, collections::BTreeMap, fmt::Write, future::Future, path::PathBuf, sync::Arc,
 };
 
 /// Gets the language server that is attached to a document, and
@@ -44,7 +57,7 @@ impl ui::menu::Item for lsp::Location {
     /// Current working directory.
     type Data = PathBuf;
 
-    fn label(&self, cwdir: &Self::Data) -> Spans {
+    fn format(&self, cwdir: &Self::Data) -> Row {
         // The preallocation here will overallocate a few characters since it will account for the
         // URL's scheme, which is not used most of the time since that scheme will be "file://".
         // Those extra chars will be used to avoid allocating when writing the line number (in the
@@ -68,7 +81,7 @@ fn label(&self, cwdir: &Self::Data) -> Spans {
 
         // Most commonly, this will not allocate, especially on Unix systems where the root prefix
         // is a simple `/` and not `C:\` (with whatever drive letter)
-        write!(&mut res, ":{}", self.range.start.line)
+        write!(&mut res, ":{}", self.range.start.line + 1)
             .expect("Will only failed if allocating fail");
         res.into()
     }
@@ -78,7 +91,7 @@ impl ui::menu::Item for lsp::SymbolInformation {
     /// Path to currently focussed document
     type Data = Option<lsp::Url>;
 
-    fn label(&self, current_doc_path: &Self::Data) -> Spans {
+    fn format(&self, current_doc_path: &Self::Data) -> Row {
         if current_doc_path.as_ref() == Some(&self.location.uri) {
             self.name.as_str().into()
         } else {
@@ -108,7 +121,7 @@ struct PickerDiagnostic {
 impl ui::menu::Item for PickerDiagnostic {
     type Data = (DiagnosticStyles, DiagnosticsFormat);
 
-    fn label(&self, (styles, format): &Self::Data) -> Spans {
+    fn format(&self, (styles, format): &Self::Data) -> Row {
         let mut style = self
             .diag
             .severity
@@ -124,20 +137,17 @@ fn label(&self, (styles, format): &Self::Data) -> Spans {
         // remove background as it is distracting in the picker list
         style.bg = None;
 
-        let code: Cow<'_, str> = self
-            .diag
-            .code
-            .as_ref()
-            .map(|c| match c {
-                NumberOrString::Number(n) => n.to_string().into(),
-                NumberOrString::String(s) => s.as_str().into(),
-            })
-            .unwrap_or_default();
+        let code = match self.diag.code.as_ref() {
+            Some(NumberOrString::Number(n)) => format!(" ({n})"),
+            Some(NumberOrString::String(s)) => format!(" ({s})"),
+            None => String::new(),
+        };
 
         let path = match format {
             DiagnosticsFormat::HideSourcePath => String::new(),
             DiagnosticsFormat::ShowSourcePath => {
-                let path = path::get_truncated_path(self.url.path());
+                let file_path = self.url.to_file_path().unwrap();
+                let path = path::get_truncated_path(file_path);
                 format!("{}: ", path.to_string_lossy())
             }
         };
@@ -147,6 +157,7 @@ fn label(&self, (styles, format): &Self::Data) -> Spans {
             Span::styled(&self.diag.message, style),
             Span::styled(code, style),
         ])
+        .into()
     }
 }
 
@@ -186,15 +197,15 @@ fn jump_to_location(
         }
     }
     let (view, doc) = current!(editor);
-    let definition_pos = location.range.start;
     // TODO: convert inside server
-    let new_pos = if let Some(new_pos) = lsp_pos_to_pos(doc.text(), definition_pos, offset_encoding)
-    {
-        new_pos
-    } else {
-        return;
-    };
-    doc.set_selection(view.id, Selection::point(new_pos));
+    let new_range =
+        if let Some(new_range) = lsp_range_to_range(doc.text(), location.range, offset_encoding) {
+            new_range
+        } else {
+            log::warn!("lsp position out of bounds - {:?}", location.range);
+            return;
+        };
+    doc.set_selection(view.id, Selection::single(new_range.anchor, new_range.head));
     align_view(doc, view, Align::Center);
 }
 
@@ -361,7 +372,7 @@ fn nested_to_flat(
                 };
 
                 let picker = sym_picker(symbols, current_url, offset_encoding);
-                compositor.push(Box::new(overlayed(picker)))
+                compositor.push(Box::new(overlaid(picker)))
             }
         },
     )
@@ -384,10 +395,43 @@ pub fn workspace_symbol_picker(cx: &mut Context) {
     cx.callback(
         future,
         move |_editor, compositor, response: Option<Vec<lsp::SymbolInformation>>| {
-            if let Some(symbols) = response {
-                let picker = sym_picker(symbols, current_url, offset_encoding);
-                compositor.push(Box::new(overlayed(picker)))
-            }
+            let symbols = response.unwrap_or_default();
+            let picker = sym_picker(symbols, current_url, offset_encoding);
+            let get_symbols = |query: String, editor: &mut Editor| {
+                let doc = doc!(editor);
+                let language_server = match doc.language_server() {
+                    Some(s) => s,
+                    None => {
+                        // This should not generally happen since the picker will not
+                        // even open in the first place if there is no server.
+                        return async move { Err(anyhow::anyhow!("LSP not active")) }.boxed();
+                    }
+                };
+                let symbol_request = match language_server.workspace_symbols(query) {
+                    Some(future) => future,
+                    None => {
+                        // This should also not happen since the language server must have
+                        // supported workspace symbols before to reach this block.
+                        return async move {
+                            Err(anyhow::anyhow!(
+                                "Language server does not support workspace symbols"
+                            ))
+                        }
+                        .boxed();
+                    }
+                };
+
+                let future = async move {
+                    let json = symbol_request.await?;
+                    let response: Option<Vec<lsp::SymbolInformation>> =
+                        serde_json::from_value(json)?;
+
+                    Ok(response.unwrap_or_default())
+                };
+                future.boxed()
+            };
+            let dyn_picker = DynamicPicker::new(picker, Box::new(get_symbols));
+            compositor.push(Box::new(overlaid(dyn_picker)))
         },
     )
 }
@@ -410,7 +454,7 @@ pub fn diagnostics_picker(cx: &mut Context) {
             DiagnosticsFormat::HideSourcePath,
             offset_encoding,
         );
-        cx.push_layer(Box::new(overlayed(picker)));
+        cx.push_layer(Box::new(overlaid(picker)));
     }
 }
 
@@ -427,12 +471,12 @@ pub fn workspace_diagnostics_picker(cx: &mut Context) {
         DiagnosticsFormat::ShowSourcePath,
         offset_encoding,
     );
-    cx.push_layer(Box::new(overlayed(picker)));
+    cx.push_layer(Box::new(overlaid(picker)));
 }
 
 impl ui::menu::Item for lsp::CodeActionOrCommand {
     type Data = ();
-    fn label(&self, _data: &Self::Data) -> Spans {
+    fn format(&self, _data: &Self::Data) -> Row {
         match self {
             lsp::CodeActionOrCommand::CodeAction(action) => action.title.as_str().into(),
             lsp::CodeActionOrCommand::Command(command) => command.title.as_str().into(),
@@ -447,7 +491,7 @@ fn label(&self, _data: &Self::Data) -> Spans {
 ///
 /// While the `kind` field is defined as open ended in the LSP spec (any value may be used)
 /// in practice a closed set of common values (mostly suggested in the LSP spec) are used.
-/// VSCode displays each of these categories seperatly (seperated by a heading in the codeactions picker)
+/// VSCode displays each of these categories separately (separated by a heading in the codeactions picker)
 /// to make them easier to navigate. Helix does not display these  headings to the user.
 /// However it does sort code actions by their categories to achieve the same order as the VScode picker,
 /// just without the headings.
@@ -477,7 +521,7 @@ fn action_category(action: &CodeActionOrCommand) -> u32 {
     }
 }
 
-fn action_prefered(action: &CodeActionOrCommand) -> bool {
+fn action_preferred(action: &CodeActionOrCommand) -> bool {
     matches!(
         action,
         CodeActionOrCommand::CodeAction(CodeAction {
@@ -522,6 +566,7 @@ pub fn code_action(cx: &mut Context) {
                 .map(|diag| diagnostic_to_lsp_diagnostic(doc.text(), diag, offset_encoding))
                 .collect(),
             only: None,
+            trigger_kind: Some(CodeActionTriggerKind::INVOKED),
         },
     ) {
         Some(future) => future,
@@ -555,12 +600,12 @@ pub fn code_action(cx: &mut Context) {
             }
 
             // Sort codeactions into a useful order. This behaviour is only partially described in the LSP spec.
-            // Many details are modeled after vscode because langauge servers are usually tested against it.
+            // Many details are modeled after vscode because language servers are usually tested against it.
             // VScode sorts the codeaction two times:
             //
             // First the codeactions that fix some diagnostics are moved to the front.
             // If both codeactions fix some diagnostics (or both fix none) the codeaction
-            // that is marked with `is_preffered` is shown first. The codeactions are then shown in seperate
+            // that is marked with `is_preferred` is shown first. The codeactions are then shown in separate
             // submenus that only contain a certain category (see `action_category`) of actions.
             //
             // Below this done in in a single sorting step
@@ -582,10 +627,10 @@ pub fn code_action(cx: &mut Context) {
                     return order;
                 }
 
-                // if one of the codeactions is marked as prefered show it first
+                // if one of the codeactions is marked as preferred show it first
                 // otherwise keep the original LSP sorting
-                action_prefered(action1)
-                    .cmp(&action_prefered(action2))
+                action_preferred(action1)
+                    .cmp(&action_preferred(action2))
                     .reverse()
             });
 
@@ -606,7 +651,7 @@ pub fn code_action(cx: &mut Context) {
                         log::debug!("code action: {:?}", code_action);
                         if let Some(ref workspace_edit) = code_action.edit {
                             log::debug!("edit: {:?}", workspace_edit);
-                            apply_workspace_edit(editor, offset_encoding, workspace_edit);
+                            let _ = apply_workspace_edit(editor, offset_encoding, workspace_edit);
                         }
 
                         // if code action provides both edit and command first the edit
@@ -627,7 +672,7 @@ pub fn code_action(cx: &mut Context) {
 
 impl ui::menu::Item for lsp::Command {
     type Data = ();
-    fn label(&self, _data: &Self::Data) -> Spans {
+    fn format(&self, _data: &Self::Data) -> Row {
         self.title.as_str().into()
     }
 }
@@ -712,19 +757,50 @@ pub fn apply_document_resource_op(op: &lsp::ResourceOp) -> std::io::Result<()> {
     }
 }
 
+#[derive(Debug)]
+pub struct ApplyEditError {
+    pub kind: ApplyEditErrorKind,
+    pub failed_change_idx: usize,
+}
+
+#[derive(Debug)]
+pub enum ApplyEditErrorKind {
+    DocumentChanged,
+    FileNotFound,
+    UnknownURISchema,
+    IoError(std::io::Error),
+    // TODO: check edits before applying and propagate failure
+    // InvalidEdit,
+}
+
+impl ToString for ApplyEditErrorKind {
+    fn to_string(&self) -> String {
+        match self {
+            ApplyEditErrorKind::DocumentChanged => "document has changed".to_string(),
+            ApplyEditErrorKind::FileNotFound => "file not found".to_string(),
+            ApplyEditErrorKind::UnknownURISchema => "URI schema not supported".to_string(),
+            ApplyEditErrorKind::IoError(err) => err.to_string(),
+        }
+    }
+}
+
+///TODO make this transactional (and set failureMode to transactional)
 pub fn apply_workspace_edit(
     editor: &mut Editor,
     offset_encoding: OffsetEncoding,
     workspace_edit: &lsp::WorkspaceEdit,
-) {
-    let mut apply_edits = |uri: &helix_lsp::Url, text_edits: Vec<lsp::TextEdit>| {
+) -> Result<(), ApplyEditError> {
+    let mut apply_edits = |uri: &helix_lsp::Url,
+                           version: Option<i32>,
+                           text_edits: Vec<lsp::TextEdit>|
+     -> Result<(), ApplyEditErrorKind> {
         let path = match uri.to_file_path() {
             Ok(path) => path,
             Err(_) => {
                 let err = format!("unable to convert URI to filepath: {}", uri);
                 log::error!("{}", err);
                 editor.set_error(err);
-                return;
+                return Err(ApplyEditErrorKind::UnknownURISchema);
             }
         };
 
@@ -735,11 +811,19 @@ pub fn apply_workspace_edit(
                 let err = format!("failed to open document: {}: {}", uri, err);
                 log::error!("{}", err);
                 editor.set_error(err);
-                return;
+                return Err(ApplyEditErrorKind::FileNotFound);
             }
         };
 
         let doc = doc_mut!(editor, &doc_id);
+        if let Some(version) = version {
+            if version != doc.version() {
+                let err = format!("outdated workspace edit for {path:?}");
+                log::error!("{err}, expected {} but got {version}", doc.version());
+                editor.set_error(err);
+                return Err(ApplyEditErrorKind::DocumentChanged);
+            }
+        }
 
         // Need to determine a view for apply/append_changes_to_history
         let selections = doc.selections();
@@ -761,33 +845,15 @@ pub fn apply_workspace_edit(
             offset_encoding,
         );
         let view = view_mut!(editor, view_id);
-        apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
         doc.append_changes_to_history(view);
+        Ok(())
     };
 
-    if let Some(ref changes) = workspace_edit.changes {
-        log::debug!("workspace changes: {:?}", changes);
-        for (uri, text_edits) in changes {
-            let text_edits = text_edits.to_vec();
-            apply_edits(uri, text_edits)
-        }
-        return;
-        // Not sure if it works properly, it'll be safer to just panic here to avoid breaking some parts of code on which code actions will be used
-        // TODO: find some example that uses workspace changes, and test it
-        // for (url, edits) in changes.iter() {
-        //     let file_path = url.origin().ascii_serialization();
-        //     let file_path = std::path::PathBuf::from(file_path);
-        //     let file = std::fs::File::open(file_path).unwrap();
-        //     let mut text = Rope::from_reader(file).unwrap();
-        //     let transaction = edits_to_changes(&text, edits);
-        //     transaction.apply(&mut text);
-        // }
-    }
-
     if let Some(ref document_changes) = workspace_edit.document_changes {
         match document_changes {
             lsp::DocumentChanges::Edits(document_edits) => {
-                for document_edit in document_edits {
+                for (i, document_edit) in document_edits.iter().enumerate() {
                     let edits = document_edit
                         .edits
                         .iter()
@@ -799,15 +865,26 @@ pub fn apply_workspace_edit(
                         })
                         .cloned()
                         .collect();
-                    apply_edits(&document_edit.text_document.uri, edits);
+                    apply_edits(
+                        &document_edit.text_document.uri,
+                        document_edit.text_document.version,
+                        edits,
+                    )
+                    .map_err(|kind| ApplyEditError {
+                        kind,
+                        failed_change_idx: i,
+                    })?;
                 }
             }
             lsp::DocumentChanges::Operations(operations) => {
                 log::debug!("document changes - operations: {:?}", operations);
-                for operation in operations {
+                for (i, operation) in operations.iter().enumerate() {
                     match operation {
                         lsp::DocumentChangeOperation::Op(op) => {
-                            apply_document_resource_op(op).unwrap();
+                            apply_document_resource_op(op).map_err(|io| ApplyEditError {
+                                kind: ApplyEditErrorKind::IoError(io),
+                                failed_change_idx: i,
+                            })?;
                         }
 
                         lsp::DocumentChangeOperation::Edit(document_edit) => {
@@ -822,13 +899,36 @@ pub fn apply_workspace_edit(
                                 })
                                 .cloned()
                                 .collect();
-                            apply_edits(&document_edit.text_document.uri, edits);
+                            apply_edits(
+                                &document_edit.text_document.uri,
+                                document_edit.text_document.version,
+                                edits,
+                            )
+                            .map_err(|kind| ApplyEditError {
+                                kind,
+                                failed_change_idx: i,
+                            })?;
                         }
                     }
                 }
             }
         }
+
+        return Ok(());
+    }
+
+    if let Some(ref changes) = workspace_edit.changes {
+        log::debug!("workspace changes: {:?}", changes);
+        for (i, (uri, text_edits)) in changes.iter().enumerate() {
+            let text_edits = text_edits.to_vec();
+            apply_edits(uri, None, text_edits).map_err(|kind| ApplyEditError {
+                kind,
+                failed_change_idx: i,
+            })?;
+        }
     }
+
+    Ok(())
 }
 
 fn goto_impl(
@@ -855,7 +955,7 @@ fn goto_impl(
                 },
                 move |_editor, location| Some(location_to_file_location(location)),
             );
-            compositor.push(Box::new(overlayed(picker)));
+            compositor.push(Box::new(overlaid(picker)));
         }
     }
 }
@@ -875,6 +975,31 @@ fn to_locations(definitions: Option<lsp::GotoDefinitionResponse>) -> Vec<lsp::Lo
     }
 }
 
+pub fn goto_declaration(cx: &mut Context) {
+    let (view, doc) = current!(cx.editor);
+    let language_server = language_server!(cx.editor, doc);
+    let offset_encoding = language_server.offset_encoding();
+
+    let pos = doc.position(view.id, offset_encoding);
+
+    let future = match language_server.goto_declaration(doc.identifier(), pos, None) {
+        Some(future) => future,
+        None => {
+            cx.editor
+                .set_error("Language server does not support goto-declaration");
+            return;
+        }
+    };
+
+    cx.callback(
+        future,
+        move |editor, compositor, response: Option<lsp::GotoDefinitionResponse>| {
+            let items = to_locations(response);
+            goto_impl(editor, compositor, items, offset_encoding);
+        },
+    );
+}
+
 pub fn goto_definition(cx: &mut Context) {
     let (view, doc) = current!(cx.editor);
     let language_server = language_server!(cx.editor, doc);
@@ -1096,10 +1221,25 @@ pub fn signature_help_impl(cx: &mut Context, invoked: SignatureHelpInvoked) {
             contents.set_active_param_range(active_param_range());
 
             let old_popup = compositor.find_id::<Popup<SignatureHelp>>(SignatureHelp::ID);
-            let popup = Popup::new(SignatureHelp::ID, contents)
+            let mut popup = Popup::new(SignatureHelp::ID, contents)
                 .position(old_popup.and_then(|p| p.get_position()))
                 .position_bias(Open::Above)
                 .ignore_escape_key(true);
+
+            // Don't create a popup if it intersects the auto-complete menu.
+            let size = compositor.size();
+            if compositor
+                .find::<ui::EditorView>()
+                .unwrap()
+                .completion
+                .as_mut()
+                .map(|completion| completion.area(size, editor))
+                .filter(|area| area.intersects(popup.area(size, editor)))
+                .is_some()
+            {
+                return;
+            }
+
             compositor.replace_or_push(SignatureHelp::ID, popup);
         },
     );
@@ -1163,49 +1303,123 @@ fn marked_string_to_markdown(contents: lsp::MarkedString) -> String {
 }
 
 pub fn rename_symbol(cx: &mut Context) {
-    let (view, doc) = current_ref!(cx.editor);
-    let text = doc.text().slice(..);
-    let primary_selection = doc.selection(view.id).primary();
-    let prefill = if primary_selection.len() > 1 {
-        primary_selection
-    } else {
-        use helix_core::textobject::{textobject_word, TextObject};
-        textobject_word(text, primary_selection, TextObject::Inside, 1, false)
+    fn get_prefill_from_word_boundary(editor: &Editor) -> String {
+        let (view, doc) = current_ref!(editor);
+        let text = doc.text().slice(..);
+        let primary_selection = doc.selection(view.id).primary();
+        if primary_selection.len() > 1 {
+            primary_selection
+        } else {
+            use helix_core::textobject::{textobject_word, TextObject};
+            textobject_word(text, primary_selection, TextObject::Inside, 1, false)
+        }
+        .fragment(text)
+        .into()
     }
-    .fragment(text)
-    .into();
-    ui::prompt_with_input(
-        cx,
-        "rename-to:".into(),
-        prefill,
-        None,
-        ui::completers::none,
-        move |cx: &mut compositor::Context, input: &str, event: PromptEvent| {
-            if event != PromptEvent::Validate {
-                return;
+
+    fn get_prefill_from_lsp_response(
+        editor: &Editor,
+        offset_encoding: OffsetEncoding,
+        response: Option<lsp::PrepareRenameResponse>,
+    ) -> Result<String, &'static str> {
+        match response {
+            Some(lsp::PrepareRenameResponse::Range(range)) => {
+                let text = doc!(editor).text();
+
+                Ok(lsp_range_to_range(text, range, offset_encoding)
+                    .ok_or("lsp sent invalid selection range for rename")?
+                    .fragment(text.slice(..))
+                    .into())
             }
+            Some(lsp::PrepareRenameResponse::RangeWithPlaceholder { placeholder, .. }) => {
+                Ok(placeholder)
+            }
+            Some(lsp::PrepareRenameResponse::DefaultBehavior { .. }) => {
+                Ok(get_prefill_from_word_boundary(editor))
+            }
+            None => Err("lsp did not respond to prepare rename request"),
+        }
+    }
 
-            let (view, doc) = current!(cx.editor);
-            let language_server = language_server!(cx.editor, doc);
-            let offset_encoding = language_server.offset_encoding();
+    fn create_rename_prompt(editor: &Editor, prefill: String) -> Box<ui::Prompt> {
+        let prompt = ui::Prompt::new(
+            "rename-to:".into(),
+            None,
+            ui::completers::none,
+            move |cx: &mut compositor::Context, input: &str, event: PromptEvent| {
+                if event != PromptEvent::Validate {
+                    return;
+                }
 
-            let pos = doc.position(view.id, offset_encoding);
+                let (view, doc) = current!(cx.editor);
+                let language_server = language_server!(cx.editor, doc);
+                let offset_encoding = language_server.offset_encoding();
+
+                let pos = doc.position(view.id, offset_encoding);
+
+                let future =
+                    match language_server.rename_symbol(doc.identifier(), pos, input.to_string()) {
+                        Some(future) => future,
+                        None => {
+                            cx.editor
+                                .set_error("Language server does not support symbol renaming");
+                            return;
+                        }
+                    };
+                match block_on(future) {
+                    Ok(edits) => {
+                        let _ = apply_workspace_edit(cx.editor, offset_encoding, &edits);
+                    }
+                    Err(err) => cx.editor.set_error(err.to_string()),
+                }
+            },
+        )
+        .with_line(prefill, editor);
 
-            let future =
-                match language_server.rename_symbol(doc.identifier(), pos, input.to_string()) {
-                    Some(future) => future,
-                    None => {
-                        cx.editor
-                            .set_error("Language server does not support symbol renaming");
+        Box::new(prompt)
+    }
+
+    let (view, doc) = current!(cx.editor);
+    let language_server = language_server!(cx.editor, doc);
+    let offset_encoding = language_server.offset_encoding();
+
+    if !language_server.supports_rename() {
+        cx.editor
+            .set_error("Language server does not support symbol renaming");
+        return;
+    }
+
+    let pos = doc.position(view.id, offset_encoding);
+
+    match language_server.prepare_rename(doc.identifier(), pos) {
+        // Language server supports textDocument/prepareRename, use it.
+        Some(future) => cx.callback(
+            future,
+            move |editor, compositor, response: Option<lsp::PrepareRenameResponse>| {
+                let prefill = match get_prefill_from_lsp_response(editor, offset_encoding, response)
+                {
+                    Ok(p) => p,
+                    Err(e) => {
+                        editor.set_error(e);
                         return;
                     }
                 };
-            match block_on(future) {
-                Ok(edits) => apply_workspace_edit(cx.editor, offset_encoding, &edits),
-                Err(err) => cx.editor.set_error(err.to_string()),
-            }
-        },
-    );
+
+                let prompt = create_rename_prompt(editor, prefill);
+
+                compositor.push(prompt);
+            },
+        ),
+        // Language server does not support textDocument/prepareRename, fall back
+        // to word boundary selection.
+        None => {
+            let prefill = get_prefill_from_word_boundary(cx.editor);
+
+            let prompt = create_rename_prompt(cx.editor, prefill);
+
+            cx.push_layer(prompt);
+        }
+    };
 }
 
 pub fn select_references_to_symbol_under_cursor(cx: &mut Context) {
@@ -1256,3 +1470,174 @@ pub fn select_references_to_symbol_under_cursor(cx: &mut Context) {
         },
     );
 }
+
+pub fn compute_inlay_hints_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {
+    if !editor.config().lsp.display_inlay_hints {
+        return;
+    }
+
+    for (view, _) in editor.tree.views() {
+        let doc = match editor.documents.get(&view.doc) {
+            Some(doc) => doc,
+            None => continue,
+        };
+        if let Some(callback) = compute_inlay_hints_for_view(view, doc) {
+            jobs.callback(callback);
+        }
+    }
+}
+
+fn compute_inlay_hints_for_view(
+    view: &View,
+    doc: &Document,
+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {
+    let view_id = view.id;
+    let doc_id = view.doc;
+
+    let language_server = doc.language_server()?;
+
+    let capabilities = language_server.capabilities();
+
+    let (future, new_doc_inlay_hints_id) = match capabilities.inlay_hint_provider {
+        Some(
+            lsp::OneOf::Left(true)
+            | lsp::OneOf::Right(lsp::InlayHintServerCapabilities::Options(_)),
+        ) => {
+            let doc_text = doc.text();
+            let len_lines = doc_text.len_lines();
+
+            // Compute ~3 times the current view height of inlay hints, that way some scrolling
+            // will not show half the view with hints and half without while still being faster
+            // than computing all the hints for the full file (which could be dozens of time
+            // longer than the view is).
+            let view_height = view.inner_height();
+            let first_visible_line = doc_text.char_to_line(view.offset.anchor);
+            let first_line = first_visible_line.saturating_sub(view_height);
+            let last_line = first_visible_line
+                .saturating_add(view_height.saturating_mul(2))
+                .min(len_lines);
+
+            let new_doc_inlay_hint_id = DocumentInlayHintsId {
+                first_line,
+                last_line,
+            };
+            // Don't recompute the annotations in case nothing has changed about the view
+            if !doc.inlay_hints_oudated
+                && doc
+                    .inlay_hints(view_id)
+                    .map_or(false, |dih| dih.id == new_doc_inlay_hint_id)
+            {
+                return None;
+            }
+
+            let doc_slice = doc_text.slice(..);
+            let first_char_in_range = doc_slice.line_to_char(first_line);
+            let last_char_in_range = doc_slice.line_to_char(last_line);
+
+            let range = helix_lsp::util::range_to_lsp_range(
+                doc_text,
+                helix_core::Range::new(first_char_in_range, last_char_in_range),
+                language_server.offset_encoding(),
+            );
+
+            (
+                language_server.text_document_range_inlay_hints(doc.identifier(), range, None),
+                new_doc_inlay_hint_id,
+            )
+        }
+        _ => return None,
+    };
+
+    let callback = super::make_job_callback(
+        future?,
+        move |editor, _compositor, response: Option<Vec<lsp::InlayHint>>| {
+            // The config was modified or the window was closed while the request was in flight
+            if !editor.config().lsp.display_inlay_hints || editor.tree.try_get(view_id).is_none() {
+                return;
+            }
+
+            // Add annotations to relevant document, not the current one (it may have changed in between)
+            let doc = match editor.documents.get_mut(&doc_id) {
+                Some(doc) => doc,
+                None => return,
+            };
+
+            // If we have neither hints nor an LSP, empty the inlay hints since they're now oudated
+            let (mut hints, offset_encoding) = match (response, doc.language_server()) {
+                (Some(h), Some(ls)) if !h.is_empty() => (h, ls.offset_encoding()),
+                _ => {
+                    doc.set_inlay_hints(
+                        view_id,
+                        DocumentInlayHints::empty_with_id(new_doc_inlay_hints_id),
+                    );
+                    doc.inlay_hints_oudated = false;
+                    return;
+                }
+            };
+
+            // Most language servers will already send them sorted but ensure this is the case to
+            // avoid errors on our end.
+            hints.sort_unstable_by_key(|inlay_hint| inlay_hint.position);
+
+            let mut padding_before_inlay_hints = Vec::new();
+            let mut type_inlay_hints = Vec::new();
+            let mut parameter_inlay_hints = Vec::new();
+            let mut other_inlay_hints = Vec::new();
+            let mut padding_after_inlay_hints = Vec::new();
+
+            let doc_text = doc.text();
+
+            for hint in hints {
+                let char_idx =
+                    match helix_lsp::util::lsp_pos_to_pos(doc_text, hint.position, offset_encoding)
+                    {
+                        Some(pos) => pos,
+                        // Skip inlay hints that have no "real" position
+                        None => continue,
+                    };
+
+                let label = match hint.label {
+                    lsp::InlayHintLabel::String(s) => s,
+                    lsp::InlayHintLabel::LabelParts(parts) => parts
+                        .into_iter()
+                        .map(|p| p.value)
+                        .collect::<Vec<_>>()
+                        .join(""),
+                };
+
+                let inlay_hints_vec = match hint.kind {
+                    Some(lsp::InlayHintKind::TYPE) => &mut type_inlay_hints,
+                    Some(lsp::InlayHintKind::PARAMETER) => &mut parameter_inlay_hints,
+                    // We can't warn on unknown kind here since LSPs are free to set it or not, for
+                    // example Rust Analyzer does not: every kind will be `None`.
+                    _ => &mut other_inlay_hints,
+                };
+
+                if let Some(true) = hint.padding_left {
+                    padding_before_inlay_hints.push(InlineAnnotation::new(char_idx, " "));
+                }
+
+                inlay_hints_vec.push(InlineAnnotation::new(char_idx, label));
+
+                if let Some(true) = hint.padding_right {
+                    padding_after_inlay_hints.push(InlineAnnotation::new(char_idx, " "));
+                }
+            }
+
+            doc.set_inlay_hints(
+                view_id,
+                DocumentInlayHints {
+                    id: new_doc_inlay_hints_id,
+                    type_inlay_hints: type_inlay_hints.into(),
+                    parameter_inlay_hints: parameter_inlay_hints.into(),
+                    other_inlay_hints: other_inlay_hints.into(),
+                    padding_before_inlay_hints: padding_before_inlay_hints.into(),
+                    padding_after_inlay_hints: padding_after_inlay_hints.into(),
+                },
+            );
+            doc.inlay_hints_oudated = false;
+        },
+    );
+
+    Some(callback)
+}
diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index 2119a48d6..3c954d20f 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -1,13 +1,14 @@
+use std::fmt::Write;
 use std::ops::Deref;
 
 use crate::job::Job;
 
 use super::*;
 
-use helix_view::{
-    apply_transaction,
-    editor::{Action, CloseError, ConfigEvent},
-};
+use helix_core::{encoding, shellwords::Shellwords};
+use helix_view::document::DEFAULT_LANGUAGE_NAME;
+use helix_view::editor::{Action, CloseError, ConfigEvent};
+use serde_json::Value;
 use ui::completers::{self, Completer};
 
 #[derive(Clone)]
@@ -17,7 +18,49 @@ pub struct TypableCommand {
     pub doc: &'static str,
     // params, flags, helper, completer
     pub fun: fn(&mut compositor::Context, &[Cow<str>], PromptEvent) -> anyhow::Result<()>,
-    pub completer: Option<Completer>,
+    /// What completion methods, if any, does this command have?
+    pub signature: CommandSignature,
+}
+
+impl TypableCommand {
+    fn completer_for_argument_number(&self, n: usize) -> &Completer {
+        match self.signature.positional_args.get(n) {
+            Some(completer) => completer,
+            _ => &self.signature.var_args,
+        }
+    }
+}
+
+#[derive(Clone)]
+pub struct CommandSignature {
+    // Arguments with specific completion methods based on their position.
+    positional_args: &'static [Completer],
+
+    // All remaining arguments will use this completion method, if set.
+    var_args: Completer,
+}
+
+impl CommandSignature {
+    const fn none() -> Self {
+        Self {
+            positional_args: &[],
+            var_args: completers::none,
+        }
+    }
+
+    const fn positional(completers: &'static [Completer]) -> Self {
+        Self {
+            positional_args: completers,
+            var_args: completers::none,
+        }
+    }
+
+    const fn all(completer: Completer) -> Self {
+        Self {
+            positional_args: &[],
+            var_args: completer,
+        }
+    }
 }
 
 fn quit(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) -> anyhow::Result<()> {
@@ -65,12 +108,29 @@ fn open(cx: &mut compositor::Context, args: &[Cow<str>], event: PromptEvent) ->
     ensure!(!args.is_empty(), "wrong argument count");
     for arg in args {
         let (path, pos) = args::parse_file(arg);
-        let _ = cx.editor.open(&path, Action::Replace)?;
-        let (view, doc) = current!(cx.editor);
-        let pos = Selection::point(pos_at_coords(doc.text().slice(..), pos, true));
-        doc.set_selection(view.id, pos);
-        // does not affect opening a buffer without pos
-        align_view(doc, view, Align::Center);
+        let path = helix_core::path::expand_tilde(&path);
+        // If the path is a directory, open a file picker on that directory and update the status
+        // message
+        if let Ok(true) = std::fs::canonicalize(&path).map(|p| p.is_dir()) {
+            let callback = async move {
+                let call: job::Callback = job::Callback::EditorCompositor(Box::new(
+                    move |editor: &mut Editor, compositor: &mut Compositor| {
+                        let picker = ui::file_picker(path, &editor.config());
+                        compositor.push(Box::new(overlaid(picker)));
+                    },
+                ));
+                Ok(call)
+            };
+            cx.jobs.callback(callback);
+        } else {
+            // Otherwise, just open the file
+            let _ = cx.editor.open(&path, Action::Replace)?;
+            let (view, doc) = current!(cx.editor);
+            let pos = Selection::point(pos_at_coords(doc.text().slice(..), pos, true));
+            doc.set_selection(view.id, pos);
+            // does not affect opening a buffer without pos
+            align_view(doc, view, Align::Center);
+        }
     }
     Ok(())
 }
@@ -463,7 +523,7 @@ fn set_line_ending(
             }
         }),
     );
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
     doc.append_changes_to_history(view);
 
     Ok(())
@@ -777,7 +837,7 @@ fn theme(
                     .editor
                     .theme_loader
                     .load(theme_name)
-                    .with_context(|| "Theme does not exist")?;
+                    .map_err(|err| anyhow::anyhow!("Could not load theme: {}", err))?;
                 if !(true_color || theme.is_16_color()) {
                     bail!("Unsupported theme: theme requires true color support");
                 }
@@ -899,6 +959,7 @@ fn replace_selections_with_clipboard_impl(
     cx: &mut compositor::Context,
     clipboard_type: ClipboardType,
 ) -> anyhow::Result<()> {
+    let scrolloff = cx.editor.config().scrolloff;
     let (view, doc) = current!(cx.editor);
 
     match cx.editor.clipboard_provider.get_contents(clipboard_type) {
@@ -908,8 +969,9 @@ fn replace_selections_with_clipboard_impl(
                 (range.from(), range.to(), Some(contents.as_str().into()))
             });
 
-            apply_transaction(&transaction, doc, view);
+            doc.apply(&transaction, view.id);
             doc.append_changes_to_history(view);
+            view.ensure_cursor_in_view(doc, scrolloff);
             Ok(())
         }
         Err(e) => Err(e.context("Couldn't get system clipboard contents")),
@@ -1017,6 +1079,131 @@ fn set_encoding(
     }
 }
 
+/// Shows info about the character under the primary cursor.
+fn get_character_info(
+    cx: &mut compositor::Context,
+    _args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    let (view, doc) = current_ref!(cx.editor);
+    let text = doc.text().slice(..);
+
+    let grapheme_start = doc.selection(view.id).primary().cursor(text);
+    let grapheme_end = graphemes::next_grapheme_boundary(text, grapheme_start);
+
+    if grapheme_start == grapheme_end {
+        return Ok(());
+    }
+
+    let grapheme = text.slice(grapheme_start..grapheme_end).to_string();
+    let encoding = doc.encoding();
+
+    let printable = grapheme.chars().fold(String::new(), |mut s, c| {
+        match c {
+            '\0' => s.push_str("\\0"),
+            '\t' => s.push_str("\\t"),
+            '\n' => s.push_str("\\n"),
+            '\r' => s.push_str("\\r"),
+            _ => s.push(c),
+        }
+
+        s
+    });
+
+    // Convert to Unicode codepoints if in UTF-8
+    let unicode = if encoding == encoding::UTF_8 {
+        let mut unicode = " (".to_owned();
+
+        for (i, char) in grapheme.chars().enumerate() {
+            if i != 0 {
+                unicode.push(' ');
+            }
+
+            unicode.push_str("U+");
+
+            let codepoint: u32 = if char.is_ascii() {
+                char.into()
+            } else {
+                // Not ascii means it will be multi-byte, so strip out the extra
+                // bits that encode the length & mark continuation bytes
+
+                let s = String::from(char);
+                let bytes = s.as_bytes();
+
+                // First byte starts with 2-4 ones then a zero, so strip those off
+                let first = bytes[0];
+                let codepoint = first & (0xFF >> (first.leading_ones() + 1));
+                let mut codepoint = u32::from(codepoint);
+
+                // Following bytes start with 10
+                for byte in bytes.iter().skip(1) {
+                    codepoint <<= 6;
+                    codepoint += u32::from(*byte) & 0x3F;
+                }
+
+                codepoint
+            };
+
+            write!(unicode, "{codepoint:0>4x}").unwrap();
+        }
+
+        unicode.push(')');
+        unicode
+    } else {
+        String::new()
+    };
+
+    // Give the decimal value for ascii characters
+    let dec = if encoding.is_ascii_compatible() && grapheme.len() == 1 {
+        format!(" Dec {}", grapheme.as_bytes()[0])
+    } else {
+        String::new()
+    };
+
+    let hex = {
+        let mut encoder = encoding.new_encoder();
+        let max_encoded_len = encoder
+            .max_buffer_length_from_utf8_without_replacement(grapheme.len())
+            .unwrap();
+        let mut bytes = Vec::with_capacity(max_encoded_len);
+        let mut current_byte = 0;
+        let mut hex = String::new();
+
+        for (i, char) in grapheme.chars().enumerate() {
+            if i != 0 {
+                hex.push_str(" +");
+            }
+
+            let (result, _input_bytes_read) = encoder.encode_from_utf8_to_vec_without_replacement(
+                &char.to_string(),
+                &mut bytes,
+                true,
+            );
+
+            if let encoding::EncoderResult::Unmappable(char) = result {
+                bail!("{char:?} cannot be mapped to {}", encoding.name());
+            }
+
+            for byte in &bytes[current_byte..] {
+                write!(hex, " {byte:0>2x}").unwrap();
+            }
+
+            current_byte = bytes.len();
+        }
+
+        hex
+    };
+
+    cx.editor
+        .set_status(format!("\"{printable}\"{unicode}{dec} Hex{hex}"));
+
+    Ok(())
+}
+
 /// Reload the [`Document`] from its source file.
 fn reload(
     cx: &mut compositor::Context,
@@ -1148,7 +1335,7 @@ fn lsp_workspace_command(
                     let picker = ui::Picker::new(commands, (), |cx, command, _action| {
                         execute_lsp_command(cx.editor, command.clone());
                     });
-                    compositor.push(Box::new(overlayed(picker)))
+                    compositor.push(Box::new(overlaid(picker)))
                 },
             ));
             Ok(call)
@@ -1184,13 +1371,19 @@ fn lsp_restart(
         return Ok(());
     }
 
+    let editor_config = cx.editor.config.load();
     let (_view, doc) = current!(cx.editor);
     let config = doc
         .language_config()
         .context("LSP not defined for the current document")?;
 
     let scope = config.scope.clone();
-    cx.editor.language_servers.restart(config, doc.path())?;
+    cx.editor.language_servers.restart(
+        config,
+        doc.path(),
+        &editor_config.workspace_lsp_roots,
+        editor_config.lsp.snippets,
+    )?;
 
     // This collect is needed because refresh_language_server would need to re-borrow editor.
     let document_ids_to_refresh: Vec<DocumentId> = cx
@@ -1209,6 +1402,37 @@ fn lsp_restart(
     Ok(())
 }
 
+fn lsp_stop(
+    cx: &mut compositor::Context,
+    _args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    let doc = doc!(cx.editor);
+
+    let ls_id = doc
+        .language_server()
+        .map(|ls| ls.id())
+        .context("LSP not running for the current document")?;
+
+    let config = doc
+        .language_config()
+        .context("LSP not defined for the current document")?;
+    cx.editor.language_servers.stop(config);
+
+    for doc in cx.editor.documents_mut() {
+        if doc.language_server().map_or(false, |ls| ls.id() == ls_id) {
+            doc.set_language_server(None);
+            doc.set_diagnostics(Default::default());
+        }
+    }
+
+    Ok(())
+}
+
 fn tree_sitter_scopes(
     cx: &mut compositor::Context,
     _args: &[Cow<str>],
@@ -1389,54 +1613,74 @@ fn tutor(
         return Ok(());
     }
 
-    let path = helix_loader::runtime_dir().join("tutor");
+    let path = helix_loader::runtime_file(Path::new("tutor"));
     cx.editor.open(&path, Action::Replace)?;
     // Unset path to prevent accidentally saving to the original tutor file.
     doc_mut!(cx.editor).set_path(None)?;
     Ok(())
 }
 
+fn abort_goto_line_number_preview(cx: &mut compositor::Context) {
+    if let Some(last_selection) = cx.editor.last_selection.take() {
+        let scrolloff = cx.editor.config().scrolloff;
+
+        let (view, doc) = current!(cx.editor);
+        doc.set_selection(view.id, last_selection);
+        view.ensure_cursor_in_view(doc, scrolloff);
+    }
+}
+
+fn update_goto_line_number_preview(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+) -> anyhow::Result<()> {
+    cx.editor.last_selection.get_or_insert_with(|| {
+        let (view, doc) = current!(cx.editor);
+        doc.selection(view.id).clone()
+    });
+
+    let scrolloff = cx.editor.config().scrolloff;
+    let line = args[0].parse::<usize>()?;
+    goto_line_without_jumplist(cx.editor, NonZeroUsize::new(line));
+
+    let (view, doc) = current!(cx.editor);
+    view.ensure_cursor_in_view(doc, scrolloff);
+
+    Ok(())
+}
+
 pub(super) fn goto_line_number(
     cx: &mut compositor::Context,
     args: &[Cow<str>],
     event: PromptEvent,
 ) -> anyhow::Result<()> {
     match event {
-        PromptEvent::Abort => {
-            if let Some(line_number) = cx.editor.last_line_number {
-                goto_line_impl(cx.editor, NonZeroUsize::new(line_number));
-                let (view, doc) = current!(cx.editor);
-                view.ensure_cursor_in_view(doc, line_number);
-                cx.editor.last_line_number = None;
-            }
-            return Ok(());
-        }
+        PromptEvent::Abort => abort_goto_line_number_preview(cx),
         PromptEvent::Validate => {
             ensure!(!args.is_empty(), "Line number required");
-            cx.editor.last_line_number = None;
-        }
-        PromptEvent::Update => {
-            if args.is_empty() {
-                if let Some(line_number) = cx.editor.last_line_number {
-                    // When a user hits backspace and there are no numbers left,
-                    // we can bring them back to their original line
-                    goto_line_impl(cx.editor, NonZeroUsize::new(line_number));
-                    let (view, doc) = current!(cx.editor);
-                    view.ensure_cursor_in_view(doc, line_number);
-                    cx.editor.last_line_number = None;
-                }
-                return Ok(());
-            }
+
+            // If we are invoked directly via a keybinding, Validate is
+            // sent without any prior Update events. Ensure the cursor
+            // is moved to the appropriate location.
+            update_goto_line_number_preview(cx, args)?;
+
+            let last_selection = cx
+                .editor
+                .last_selection
+                .take()
+                .expect("update_goto_line_number_preview should always set last_selection");
+
             let (view, doc) = current!(cx.editor);
-            let text = doc.text().slice(..);
-            let line = doc.selection(view.id).primary().cursor_line(text);
-            cx.editor.last_line_number.get_or_insert(line + 1);
+            view.jumps.push((doc.id(), last_selection));
         }
+
+        // When a user hits backspace and there are no numbers left,
+        // we can bring them back to their original selection. If they
+        // begin typing numbers again, we'll start a new preview session.
+        PromptEvent::Update if args.is_empty() => abort_goto_line_number_preview(cx),
+        PromptEvent::Update => update_goto_line_number_preview(cx, args)?,
     }
-    let line = args[0].parse::<usize>()?;
-    goto_line_impl(cx.editor, NonZeroUsize::new(line));
-    let (view, doc) = current!(cx.editor);
-    view.ensure_cursor_in_view(doc, line);
+
     Ok(())
 }
 
@@ -1503,6 +1747,46 @@ fn set_option(
     Ok(())
 }
 
+/// Toggle boolean config option at runtime. Access nested values by dot
+/// syntax, for example to toggle smart case search, use `:toggle search.smart-
+/// case`.
+fn toggle_option(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    if args.len() != 1 {
+        anyhow::bail!("Bad arguments. Usage: `:toggle key`");
+    }
+    let key = &args[0].to_lowercase();
+
+    let key_error = || anyhow::anyhow!("Unknown key `{}`", key);
+
+    let mut config = serde_json::json!(&cx.editor.config().deref());
+    let pointer = format!("/{}", key.replace('.', "/"));
+    let value = config.pointer_mut(&pointer).ok_or_else(key_error)?;
+
+    if let Value::Bool(b) = *value {
+        *value = Value::Bool(!b);
+    } else {
+        anyhow::bail!("Key `{}` is not toggle-able", key)
+    }
+
+    // This unwrap should never fail because we only replace one boolean value
+    // with another, maintaining a valid json config
+    let config = serde_json::from_value(config).unwrap();
+
+    cx.editor
+        .config_events
+        .0
+        .send(ConfigEvent::Update(config))?;
+    Ok(())
+}
+
 /// Change the language of the current buffer at runtime.
 fn language(
     cx: &mut compositor::Context,
@@ -1513,13 +1797,20 @@ fn language(
         return Ok(());
     }
 
+    if args.is_empty() {
+        let doc = doc!(cx.editor);
+        let language = &doc.language_name().unwrap_or(DEFAULT_LANGUAGE_NAME);
+        cx.editor.set_status(language.to_string());
+        return Ok(());
+    }
+
     if args.len() != 1 {
         anyhow::bail!("Bad arguments. Usage: `:set-language language`");
     }
 
     let doc = doc_mut!(cx.editor);
 
-    if args[0] == "text" {
+    if args[0] == DEFAULT_LANGUAGE_NAME {
         doc.set_language(None, None)
     } else {
         doc.set_language_by_language_id(&args[0], cx.editor.syn_loader.clone())?;
@@ -1556,6 +1847,7 @@ fn sort_impl(
     _args: &[Cow<str>],
     reverse: bool,
 ) -> anyhow::Result<()> {
+    let scrolloff = cx.editor.config().scrolloff;
     let (view, doc) = current!(cx.editor);
     let text = doc.text().slice(..);
 
@@ -1579,8 +1871,9 @@ fn sort_impl(
             .map(|(s, fragment)| (s.from(), s.to(), Some(fragment))),
     );
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
     doc.append_changes_to_history(view);
+    view.ensure_cursor_in_view(doc, scrolloff);
 
     Ok(())
 }
@@ -1595,35 +1888,31 @@ fn reflow(
     }
 
     let scrolloff = cx.editor.config().scrolloff;
+    let cfg_text_width: usize = cx.editor.config().text_width;
     let (view, doc) = current!(cx.editor);
 
-    const DEFAULT_MAX_LEN: usize = 79;
-
-    // Find the max line length by checking the following sources in order:
+    // Find the text_width by checking the following sources in order:
     //   - The passed argument in `args`
-    //   - The configured max_line_len for this language in languages.toml
-    //   - The const default we set above
-    let max_line_len: usize = args
+    //   - The configured text-width for this language in languages.toml
+    //   - The configured text-width in the config.toml
+    let text_width: usize = args
         .get(0)
         .map(|num| num.parse::<usize>())
         .transpose()?
-        .or_else(|| {
-            doc.language_config()
-                .and_then(|config| config.max_line_length)
-        })
-        .unwrap_or(DEFAULT_MAX_LEN);
+        .or_else(|| doc.language_config().and_then(|config| config.text_width))
+        .unwrap_or(cfg_text_width);
 
     let rope = doc.text();
 
     let selection = doc.selection(view.id);
     let transaction = Transaction::change_by_selection(rope, selection, |range| {
         let fragment = range.fragment(rope.slice(..));
-        let reflowed_text = helix_core::wrap::reflow_hard_wrap(&fragment, max_line_len);
+        let reflowed_text = helix_core::wrap::reflow_hard_wrap(&fragment, text_width);
 
         (range.from(), range.to(), Some(reflowed_text))
     });
 
-    apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
     doc.append_changes_to_history(view);
     view.ensure_cursor_in_view(doc, scrolloff);
 
@@ -1687,6 +1976,20 @@ fn open_config(
     Ok(())
 }
 
+fn open_workspace_config(
+    cx: &mut compositor::Context,
+    _args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
+    }
+
+    cx.editor
+        .open(&helix_loader::workspace_config_file(), Action::Replace)?;
+    Ok(())
+}
+
 fn open_log(
     cx: &mut compositor::Context,
     _args: &[Cow<str>],
@@ -1777,18 +2080,14 @@ fn run_shell_command(
         return Ok(());
     }
 
-    let shell = &cx.editor.config().shell;
-    let (output, success) = shell_impl(shell, &args.join(" "), None)?;
-    if success {
-        cx.editor.set_status("Command succeed");
-    } else {
-        cx.editor.set_error("Command failed");
-    }
+    let shell = cx.editor.config().shell.clone();
+    let args = args.join(" ");
 
-    if !output.is_empty() {
-        let callback = async move {
-            let call: job::Callback = Callback::EditorCompositor(Box::new(
-                move |editor: &mut Editor, compositor: &mut Compositor| {
+    let callback = async move {
+        let (output, success) = shell_impl_async(&shell, &args, None).await?;
+        let call: job::Callback = Callback::EditorCompositor(Box::new(
+            move |editor: &mut Editor, compositor: &mut Compositor| {
+                if !output.is_empty() {
                     let contents = ui::Markdown::new(
                         format!("```sh\n{}\n```", output),
                         editor.syn_loader.clone(),
@@ -1797,14 +2096,72 @@ fn run_shell_command(
                         helix_core::Position::new(editor.cursor().0.unwrap_or_default().row, 2),
                     ));
                     compositor.replace_or_push("shell", popup);
-                },
-            ));
-            Ok(call)
-        };
+                }
+                if success {
+                    editor.set_status("Command succeeded");
+                } else {
+                    editor.set_error("Command failed");
+                }
+            },
+        ));
+        Ok(call)
+    };
+    cx.jobs.callback(callback);
 
-        cx.jobs.callback(callback);
+    Ok(())
+}
+
+fn reset_diff_change(
+    cx: &mut compositor::Context,
+    args: &[Cow<str>],
+    event: PromptEvent,
+) -> anyhow::Result<()> {
+    if event != PromptEvent::Validate {
+        return Ok(());
     }
+    ensure!(args.is_empty(), ":reset-diff-change takes no arguments");
+
+    let editor = &mut cx.editor;
+    let scrolloff = editor.config().scrolloff;
+
+    let (view, doc) = current!(editor);
+    let Some(handle) = doc.diff_handle() else {
+        bail!("Diff is not available in the current buffer")
+    };
+
+    let diff = handle.load();
+    let doc_text = doc.text().slice(..);
+    let line = doc.selection(view.id).primary().cursor_line(doc_text);
 
+    let Some(hunk_idx) = diff.hunk_at(line as u32, true) else {
+        bail!("There is no change at the cursor")
+    };
+    let hunk = diff.nth_hunk(hunk_idx);
+    let diff_base = diff.diff_base();
+    let before_start = diff_base.line_to_char(hunk.before.start as usize);
+    let before_end = diff_base.line_to_char(hunk.before.end as usize);
+    let text: Tendril = diff
+        .diff_base()
+        .slice(before_start..before_end)
+        .chunks()
+        .collect();
+    let anchor = doc_text.line_to_char(hunk.after.start as usize);
+    let transaction = Transaction::change(
+        doc.text(),
+        [(
+            anchor,
+            doc_text.line_to_char(hunk.after.end as usize),
+            (!text.is_empty()).then_some(text),
+        )]
+        .into_iter(),
+    );
+    drop(diff); // make borrow check happy
+    doc.apply(&transaction, view.id);
+    // select inserted text
+    let text_len = before_end - before_start;
+    doc.set_selection(view.id, Selection::single(anchor, anchor + text_len));
+    doc.append_changes_to_history(view);
+    view.ensure_cursor_in_view(doc, scrolloff);
     Ok(())
 }
 
@@ -1814,112 +2171,114 @@ fn run_shell_command(
             aliases: &["q"],
             doc: "Close the current view.",
             fun: quit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "quit!",
             aliases: &["q!"],
             doc: "Force close the current view, ignoring unsaved changes.",
             fun: force_quit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "open",
             aliases: &["o"],
             doc: "Open a file from disk into the current view.",
             fun: open,
-            completer: Some(completers::filename),
+            signature: CommandSignature::all(completers::filename),
         },
         TypableCommand {
             name: "buffer-close",
             aliases: &["bc", "bclose"],
             doc: "Close the current buffer.",
             fun: buffer_close,
-            completer: Some(completers::buffer),
+            signature: CommandSignature::all(completers::buffer),
         },
         TypableCommand {
             name: "buffer-close!",
             aliases: &["bc!", "bclose!"],
             doc: "Close the current buffer forcefully, ignoring unsaved changes.",
             fun: force_buffer_close,
-            completer: Some(completers::buffer),
+            signature: CommandSignature::all(completers::buffer)
         },
         TypableCommand {
             name: "buffer-close-others",
             aliases: &["bco", "bcloseother"],
             doc: "Close all buffers but the currently focused one.",
             fun: buffer_close_others,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "buffer-close-others!",
             aliases: &["bco!", "bcloseother!"],
             doc: "Force close all buffers but the currently focused one.",
             fun: force_buffer_close_others,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "buffer-close-all",
             aliases: &["bca", "bcloseall"],
             doc: "Close all buffers without quitting.",
             fun: buffer_close_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "buffer-close-all!",
             aliases: &["bca!", "bcloseall!"],
             doc: "Force close all buffers ignoring unsaved changes without quitting.",
             fun: force_buffer_close_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "buffer-next",
             aliases: &["bn", "bnext"],
             doc: "Goto next buffer.",
             fun: buffer_next,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "buffer-previous",
             aliases: &["bp", "bprev"],
             doc: "Goto previous buffer.",
             fun: buffer_previous,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "write",
             aliases: &["w"],
             doc: "Write changes to disk. Accepts an optional path (:write some/path.txt)",
             fun: write,
-            completer: Some(completers::filename),
+            signature: CommandSignature::positional(&[completers::filename]),
         },
         TypableCommand {
             name: "write!",
             aliases: &["w!"],
             doc: "Force write changes to disk creating necessary subdirectories. Accepts an optional path (:write some/path.txt)",
             fun: force_write,
-            completer: Some(completers::filename),
+            signature: CommandSignature::positional(&[completers::filename]),
         },
         TypableCommand {
             name: "new",
             aliases: &["n"],
             doc: "Create a new scratch buffer.",
             fun: new_file,
-            completer: Some(completers::filename),
+            // TODO: This seems to complete with a filename, but doesn't use that filename to
+            //       set the path of the newly created buffer.
+            signature: CommandSignature::positional(&[completers::filename]),
         },
         TypableCommand {
             name: "format",
             aliases: &["fmt"],
             doc: "Format the file using the LSP formatter.",
             fun: format,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "indent-style",
             aliases: &[],
             doc: "Set the indentation style for editing. ('t' for tabs or 1-8 for number of spaces.)",
             fun: set_indent_style,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "line-ending",
@@ -1929,399 +2288,435 @@ fn run_shell_command(
             #[cfg(feature = "unicode-lines")]
             doc: "Set the document's default line ending. Options: crlf, lf, cr, ff, nel.",
             fun: set_line_ending,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "earlier",
             aliases: &["ear"],
             doc: "Jump back to an earlier point in edit history. Accepts a number of steps or a time span.",
             fun: earlier,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "later",
             aliases: &["lat"],
             doc: "Jump to a later point in edit history. Accepts a number of steps or a time span.",
             fun: later,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "write-quit",
             aliases: &["wq", "x"],
             doc: "Write changes to disk and close the current view. Accepts an optional path (:wq some/path.txt)",
             fun: write_quit,
-            completer: Some(completers::filename),
+            signature: CommandSignature::positional(&[completers::filename]),
         },
         TypableCommand {
             name: "write-quit!",
             aliases: &["wq!", "x!"],
             doc: "Write changes to disk and close the current view forcefully. Accepts an optional path (:wq! some/path.txt)",
             fun: force_write_quit,
-            completer: Some(completers::filename),
+            signature: CommandSignature::positional(&[completers::filename]),
         },
         TypableCommand {
             name: "write-all",
             aliases: &["wa"],
             doc: "Write changes from all buffers to disk.",
             fun: write_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "write-quit-all",
             aliases: &["wqa", "xa"],
             doc: "Write changes from all buffers to disk and close all views.",
             fun: write_all_quit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "write-quit-all!",
             aliases: &["wqa!", "xa!"],
             doc: "Write changes from all buffers to disk and close all views forcefully (ignoring unsaved changes).",
             fun: force_write_all_quit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "quit-all",
             aliases: &["qa"],
             doc: "Close all views.",
             fun: quit_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "quit-all!",
             aliases: &["qa!"],
             doc: "Force close all views ignoring unsaved changes.",
             fun: force_quit_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "cquit",
             aliases: &["cq"],
             doc: "Quit with exit code (default 1). Accepts an optional integer exit code (:cq 2).",
             fun: cquit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "cquit!",
             aliases: &["cq!"],
             doc: "Force quit with exit code (default 1) ignoring unsaved changes. Accepts an optional integer exit code (:cq! 2).",
             fun: force_cquit,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "theme",
             aliases: &[],
             doc: "Change the editor theme (show current theme if no name specified).",
             fun: theme,
-            completer: Some(completers::theme),
+            signature: CommandSignature::positional(&[completers::theme]),
         },
         TypableCommand {
             name: "clipboard-yank",
             aliases: &[],
             doc: "Yank main selection into system clipboard.",
             fun: yank_main_selection_to_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "clipboard-yank-join",
             aliases: &[],
             doc: "Yank joined selections into system clipboard. A separator can be provided as first argument. Default value is newline.", // FIXME: current UI can't display long doc.
             fun: yank_joined_to_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "primary-clipboard-yank",
             aliases: &[],
             doc: "Yank main selection into system primary clipboard.",
             fun: yank_main_selection_to_primary_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "primary-clipboard-yank-join",
             aliases: &[],
             doc: "Yank joined selections into system primary clipboard. A separator can be provided as first argument. Default value is newline.", // FIXME: current UI can't display long doc.
             fun: yank_joined_to_primary_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "clipboard-paste-after",
             aliases: &[],
             doc: "Paste system clipboard after selections.",
             fun: paste_clipboard_after,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "clipboard-paste-before",
             aliases: &[],
             doc: "Paste system clipboard before selections.",
             fun: paste_clipboard_before,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "clipboard-paste-replace",
             aliases: &[],
             doc: "Replace selections with content of system clipboard.",
             fun: replace_selections_with_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "primary-clipboard-paste-after",
             aliases: &[],
             doc: "Paste primary clipboard after selections.",
             fun: paste_primary_clipboard_after,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "primary-clipboard-paste-before",
             aliases: &[],
             doc: "Paste primary clipboard before selections.",
             fun: paste_primary_clipboard_before,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "primary-clipboard-paste-replace",
             aliases: &[],
             doc: "Replace selections with content of system primary clipboard.",
             fun: replace_selections_with_primary_clipboard,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "show-clipboard-provider",
             aliases: &[],
             doc: "Show clipboard provider name in status bar.",
             fun: show_clipboard_provider,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "change-current-directory",
             aliases: &["cd"],
             doc: "Change the current working directory.",
             fun: change_current_directory,
-            completer: Some(completers::directory),
+            signature: CommandSignature::positional(&[completers::directory]),
         },
         TypableCommand {
             name: "show-directory",
             aliases: &["pwd"],
             doc: "Show the current working directory.",
             fun: show_current_directory,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "encoding",
             aliases: &[],
             doc: "Set encoding. Based on `https://encoding.spec.whatwg.org`.",
             fun: set_encoding,
-            completer: None,
+            signature: CommandSignature::none(),
+        },
+        TypableCommand {
+            name: "character-info",
+            aliases: &["char"],
+            doc: "Get info about the character under the primary cursor.",
+            fun: get_character_info,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "reload",
             aliases: &[],
             doc: "Discard changes and reload from the source file.",
             fun: reload,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "reload-all",
             aliases: &[],
             doc: "Discard changes and reload all documents from the source files.",
             fun: reload_all,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "update",
             aliases: &[],
             doc: "Write changes only if the file has been modified.",
             fun: update,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "lsp-workspace-command",
             aliases: &[],
             doc: "Open workspace command picker",
             fun: lsp_workspace_command,
-            completer: Some(completers::lsp_workspace_command),
+            signature: CommandSignature::positional(&[completers::lsp_workspace_command]),
         },
         TypableCommand {
             name: "lsp-restart",
             aliases: &[],
             doc: "Restarts the Language Server that is in use by the current doc",
             fun: lsp_restart,
-            completer: None,
+            signature: CommandSignature::none(),
+        },
+        TypableCommand {
+            name: "lsp-stop",
+            aliases: &[],
+            doc: "Stops the Language Server that is in use by the current doc",
+            fun: lsp_stop,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "tree-sitter-scopes",
             aliases: &[],
             doc: "Display tree sitter scopes, primarily for theming and development.",
             fun: tree_sitter_scopes,
-            completer: None,
-       },
+            signature: CommandSignature::none(),
+        },
         TypableCommand {
             name: "debug-start",
             aliases: &["dbg"],
             doc: "Start a debug session from a given template with given parameters.",
             fun: debug_start,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "debug-remote",
             aliases: &["dbg-tcp"],
             doc: "Connect to a debug adapter by TCP address and start a debugging session from a given template with given parameters.",
             fun: debug_remote,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "debug-eval",
             aliases: &[],
             doc: "Evaluate expression in current debug context.",
             fun: debug_eval,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "vsplit",
             aliases: &["vs"],
             doc: "Open the file in a vertical split.",
             fun: vsplit,
-            completer: Some(completers::filename),
+            signature: CommandSignature::all(completers::filename)
         },
         TypableCommand {
             name: "vsplit-new",
             aliases: &["vnew"],
             doc: "Open a scratch buffer in a vertical split.",
             fun: vsplit_new,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "hsplit",
             aliases: &["hs", "sp"],
             doc: "Open the file in a horizontal split.",
             fun: hsplit,
-            completer: Some(completers::filename),
+            signature: CommandSignature::all(completers::filename)
         },
         TypableCommand {
             name: "hsplit-new",
             aliases: &["hnew"],
             doc: "Open a scratch buffer in a horizontal split.",
             fun: hsplit_new,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "tutor",
             aliases: &[],
             doc: "Open the tutorial.",
             fun: tutor,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "goto",
             aliases: &["g"],
             doc: "Goto line number.",
             fun: goto_line_number,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "set-language",
             aliases: &["lang"],
-            doc: "Set the language of current buffer.",
+            doc: "Set the language of current buffer (show current language if no value specified).",
             fun: language,
-            completer: Some(completers::language),
+            signature: CommandSignature::positional(&[completers::language]),
         },
         TypableCommand {
             name: "set-option",
             aliases: &["set"],
             doc: "Set a config option at runtime.\nFor example to disable smart case search, use `:set search.smart-case false`.",
             fun: set_option,
-            completer: Some(completers::setting),
+            // TODO: Add support for completion of the options value(s), when appropriate.
+            signature: CommandSignature::positional(&[completers::setting]),
+        },
+        TypableCommand {
+            name: "toggle-option",
+            aliases: &["toggle"],
+            doc: "Toggle a boolean config option at runtime.\nFor example to toggle smart case search, use `:toggle search.smart-case`.",
+            fun: toggle_option,
+            signature: CommandSignature::positional(&[completers::setting]),
         },
         TypableCommand {
             name: "get-option",
             aliases: &["get"],
             doc: "Get the current value of a config option.",
             fun: get_option,
-            completer: Some(completers::setting),
+            signature: CommandSignature::positional(&[completers::setting]),
         },
         TypableCommand {
             name: "sort",
             aliases: &[],
             doc: "Sort ranges in selection.",
             fun: sort,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "rsort",
             aliases: &[],
             doc: "Sort ranges in selection in reverse order.",
             fun: sort_reverse,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "reflow",
             aliases: &[],
             doc: "Hard-wrap the current selection of lines to a given width.",
             fun: reflow,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "tree-sitter-subtree",
             aliases: &["ts-subtree"],
             doc: "Display tree sitter subtree under cursor, primarily for debugging queries.",
             fun: tree_sitter_subtree,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "config-reload",
             aliases: &[],
             doc: "Refresh user config.",
             fun: refresh_config,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "config-open",
             aliases: &[],
             doc: "Open the user config.toml file.",
             fun: open_config,
-            completer: None,
+            signature: CommandSignature::none(),
+        },
+        TypableCommand {
+            name: "config-open-workspace",
+            aliases: &[],
+            doc: "Open the workspace config.toml file.",
+            fun: open_workspace_config,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "log-open",
             aliases: &[],
             doc: "Open the helix log file.",
             fun: open_log,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "insert-output",
             aliases: &[],
             doc: "Run shell command, inserting output before each selection.",
             fun: insert_output,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "append-output",
             aliases: &[],
             doc: "Run shell command, appending output after each selection.",
             fun: append_output,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "pipe",
             aliases: &[],
             doc: "Pipe each selection to the shell command.",
             fun: pipe,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "pipe-to",
             aliases: &[],
             doc: "Pipe each selection to the shell command, ignoring output.",
             fun: pipe_to,
-            completer: None,
+            signature: CommandSignature::none(),
         },
         TypableCommand {
             name: "run-shell-command",
             aliases: &["sh"],
             doc: "Run a shell command",
             fun: run_shell_command,
-            completer: Some(completers::directory),
+            signature: CommandSignature::all(completers::filename)
+        },
+       TypableCommand {
+            name: "reset-diff-change",
+            aliases: &["diffget", "diffg"],
+            doc: "Reset the diff change at the cursor position.",
+            fun: reset_diff_change,
+            signature: CommandSignature::none(),
         },
     ];
 
@@ -2338,8 +2733,6 @@ fn run_shell_command(
 
 #[allow(clippy::unnecessary_unwrap)]
 pub(super) fn command_mode(cx: &mut Context) {
-    use shellwords::Shellwords;
-
     let mut prompt = Prompt::new(
         ":".into(),
         Some(':'),
@@ -2378,10 +2771,11 @@ pub(super) fn command_mode(cx: &mut Context) {
                     )
                 };
 
-                if let Some(typed::TypableCommand {
-                    completer: Some(completer),
-                    ..
-                }) = typed::TYPABLE_COMMAND_MAP.get(&words[0] as &str)
+                let argument_number = argument_number_of(&shellwords);
+
+                if let Some(completer) = TYPABLE_COMMAND_MAP
+                    .get(&words[0] as &str)
+                    .map(|tc| tc.completer_for_argument_number(argument_number))
                 {
                     completer(editor, part)
                         .into_iter()
@@ -2446,3 +2840,29 @@ pub(super) fn command_mode(cx: &mut Context) {
     prompt.recalculate_completion(cx.editor);
     cx.push_layer(Box::new(prompt));
 }
+
+fn argument_number_of(shellwords: &Shellwords) -> usize {
+    if shellwords.ends_with_whitespace() {
+        shellwords.words().len().saturating_sub(1)
+    } else {
+        shellwords.words().len().saturating_sub(2)
+    }
+}
+
+#[test]
+fn test_argument_number_of() {
+    let cases = vec![
+        ("set-option", 0),
+        ("set-option ", 0),
+        ("set-option a", 0),
+        ("set-option asdf", 0),
+        ("set-option asdf ", 1),
+        ("set-option asdf xyz", 1),
+        ("set-option asdf xyz abc", 2),
+        ("set-option asdf xyz abc ", 3),
+    ];
+
+    for case in cases {
+        assert_eq!(case.1, argument_number_of(&Shellwords::from(case.0)));
+    }
+}
diff --git a/helix-term/src/compositor.rs b/helix-term/src/compositor.rs
index 9dad36209..bcb3e4490 100644
--- a/helix-term/src/compositor.rs
+++ b/helix-term/src/compositor.rs
@@ -1,4 +1,4 @@
-// Each component declares it's own size constraints and gets fitted based on it's parent.
+// Each component declares its own size constraints and gets fitted based on its parent.
 // Q: how does this work with popups?
 // cursive does compositor.screen_mut().add_layer_at(pos::absolute(x, y), <component>)
 use helix_core::Position;
@@ -7,6 +7,7 @@
 use tui::buffer::Buffer as Surface;
 
 pub type Callback = Box<dyn FnOnce(&mut Compositor, &mut Context)>;
+pub type SyncCallback = Box<dyn FnOnce(&mut Compositor, &mut Context) + Sync>;
 
 // Cursive-inspired
 pub enum EventResult {
@@ -97,6 +98,7 @@ pub fn resize(&mut self, area: Rect) {
         self.area = area;
     }
 
+    /// Add a layer to be rendered in front of all existing layers.
     pub fn push(&mut self, mut layer: Box<dyn Component>) {
         let size = self.size();
         // trigger required_size on init
@@ -136,7 +138,8 @@ pub fn handle_event(&mut self, event: &Event, cx: &mut Context) -> bool {
         let mut consumed = false;
 
         // propagate events through the layers until we either find a layer that consumes it or we
-        // run out of layers (event bubbling)
+        // run out of layers (event bubbling), starting at the front layer and then moving to the
+        // background.
         for layer in self.layers.iter_mut().rev() {
             match layer.handle_event(event, cx) {
                 EventResult::Consumed(Some(callback)) => {
diff --git a/helix-term/src/config.rs b/helix-term/src/config.rs
index 4407a882f..9776ef7a4 100644
--- a/helix-term/src/config.rs
+++ b/helix-term/src/config.rs
@@ -1,27 +1,34 @@
-use crate::keymap::{default::default, merge_keys, Keymap};
+use crate::keymap;
+use crate::keymap::{merge_keys, Keymap};
+use helix_loader::merge_toml_values;
 use helix_view::document::Mode;
 use serde::Deserialize;
 use std::collections::HashMap;
 use std::fmt::Display;
+use std::fs;
 use std::io::Error as IOError;
-use std::path::PathBuf;
 use toml::de::Error as TomlError;
 
-#[derive(Debug, Clone, PartialEq, Deserialize)]
-#[serde(deny_unknown_fields)]
+#[derive(Debug, Clone, PartialEq)]
 pub struct Config {
     pub theme: Option<String>,
-    #[serde(default = "default")]
     pub keys: HashMap<Mode, Keymap>,
-    #[serde(default)]
     pub editor: helix_view::editor::Config,
 }
 
+#[derive(Debug, Clone, PartialEq, Deserialize)]
+#[serde(deny_unknown_fields)]
+pub struct ConfigRaw {
+    pub theme: Option<String>,
+    pub keys: Option<HashMap<Mode, Keymap>>,
+    pub editor: Option<toml::Value>,
+}
+
 impl Default for Config {
     fn default() -> Config {
         Config {
             theme: None,
-            keys: default(),
+            keys: keymap::default(),
             editor: helix_view::editor::Config::default(),
         }
     }
@@ -33,6 +40,12 @@ pub enum ConfigLoadError {
     Error(IOError),
 }
 
+impl Default for ConfigLoadError {
+    fn default() -> Self {
+        ConfigLoadError::Error(IOError::new(std::io::ErrorKind::NotFound, "place holder"))
+    }
+}
+
 impl Display for ConfigLoadError {
     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
         match self {
@@ -43,17 +56,72 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 }
 
 impl Config {
-    pub fn load(config_path: PathBuf) -> Result<Config, ConfigLoadError> {
-        match std::fs::read_to_string(config_path) {
-            Ok(config) => toml::from_str(&config)
-                .map(merge_keys)
-                .map_err(ConfigLoadError::BadConfig),
-            Err(err) => Err(ConfigLoadError::Error(err)),
-        }
+    pub fn load(
+        global: Result<String, ConfigLoadError>,
+        local: Result<String, ConfigLoadError>,
+    ) -> Result<Config, ConfigLoadError> {
+        let global_config: Result<ConfigRaw, ConfigLoadError> =
+            global.and_then(|file| toml::from_str(&file).map_err(ConfigLoadError::BadConfig));
+        let local_config: Result<ConfigRaw, ConfigLoadError> =
+            local.and_then(|file| toml::from_str(&file).map_err(ConfigLoadError::BadConfig));
+        let res = match (global_config, local_config) {
+            (Ok(global), Ok(local)) => {
+                let mut keys = keymap::default();
+                if let Some(global_keys) = global.keys {
+                    merge_keys(&mut keys, global_keys)
+                }
+                if let Some(local_keys) = local.keys {
+                    merge_keys(&mut keys, local_keys)
+                }
+
+                let editor = match (global.editor, local.editor) {
+                    (None, None) => helix_view::editor::Config::default(),
+                    (None, Some(val)) | (Some(val), None) => {
+                        val.try_into().map_err(ConfigLoadError::BadConfig)?
+                    }
+                    (Some(global), Some(local)) => merge_toml_values(global, local, 3)
+                        .try_into()
+                        .map_err(ConfigLoadError::BadConfig)?,
+                };
+
+                Config {
+                    theme: local.theme.or(global.theme),
+                    keys,
+                    editor,
+                }
+            }
+            // if any configs are invalid return that first
+            (_, Err(ConfigLoadError::BadConfig(err)))
+            | (Err(ConfigLoadError::BadConfig(err)), _) => {
+                return Err(ConfigLoadError::BadConfig(err))
+            }
+            (Ok(config), Err(_)) | (Err(_), Ok(config)) => {
+                let mut keys = keymap::default();
+                if let Some(keymap) = config.keys {
+                    merge_keys(&mut keys, keymap);
+                }
+                Config {
+                    theme: config.theme,
+                    keys,
+                    editor: config.editor.map_or_else(
+                        || Ok(helix_view::editor::Config::default()),
+                        |val| val.try_into().map_err(ConfigLoadError::BadConfig),
+                    )?,
+                }
+            }
+            // these are just two io errors return the one for the global config
+            (Err(err), Err(_)) => return Err(err),
+        };
+
+        Ok(res)
     }
 
     pub fn load_default() -> Result<Config, ConfigLoadError> {
-        Config::load(helix_loader::config_file())
+        let global_config =
+            fs::read_to_string(helix_loader::config_file()).map_err(ConfigLoadError::Error);
+        let local_config = fs::read_to_string(helix_loader::workspace_config_file())
+            .map_err(ConfigLoadError::Error);
+        Config::load(global_config, local_config)
     }
 }
 
@@ -61,6 +129,12 @@ pub fn load_default() -> Result<Config, ConfigLoadError> {
 mod tests {
     use super::*;
 
+    impl Config {
+        fn load_test(config: &str) -> Config {
+            Config::load(Ok(config.to_owned()), Err(ConfigLoadError::default())).unwrap()
+        }
+    }
+
     #[test]
     fn parsing_keymaps_config_file() {
         use crate::keymap;
@@ -77,18 +151,24 @@ fn parsing_keymaps_config_file() {
             A-F12 = "move_next_word_end"
         "#;
 
+        let mut keys = keymap::default();
+        merge_keys(
+            &mut keys,
+            hashmap! {
+                Mode::Insert => Keymap::new(keymap!({ "Insert mode"
+                    "y" => move_line_down,
+                    "S-C-a" => delete_selection,
+                })),
+                Mode::Normal => Keymap::new(keymap!({ "Normal mode"
+                    "A-F12" => move_next_word_end,
+                })),
+            },
+        );
+
         assert_eq!(
-            toml::from_str::<Config>(sample_keymaps).unwrap(),
+            Config::load_test(sample_keymaps),
             Config {
-                keys: hashmap! {
-                    Mode::Insert => Keymap::new(keymap!({ "Insert mode"
-                        "y" => move_line_down,
-                        "S-C-a" => delete_selection,
-                    })),
-                    Mode::Normal => Keymap::new(keymap!({ "Normal mode"
-                        "A-F12" => move_next_word_end,
-                    })),
-                },
+                keys,
                 ..Default::default()
             }
         );
@@ -97,11 +177,11 @@ fn parsing_keymaps_config_file() {
     #[test]
     fn keys_resolve_to_correct_defaults() {
         // From serde default
-        let default_keys = toml::from_str::<Config>("").unwrap().keys;
-        assert_eq!(default_keys, default());
+        let default_keys = Config::load_test("").keys;
+        assert_eq!(default_keys, keymap::default());
 
         // From the Default trait
         let default_keys = Config::default().keys;
-        assert_eq!(default_keys, default());
+        assert_eq!(default_keys, keymap::default());
     }
 }
diff --git a/helix-term/src/health.rs b/helix-term/src/health.rs
index e8fbb84d0..480c2c675 100644
--- a/helix-term/src/health.rs
+++ b/helix-term/src/health.rs
@@ -52,7 +52,7 @@ pub fn general() -> std::io::Result<()> {
     let config_file = helix_loader::config_file();
     let lang_file = helix_loader::lang_config_file();
     let log_file = helix_loader::log_file();
-    let rt_dir = helix_loader::runtime_dir();
+    let rt_dirs = helix_loader::runtime_dirs();
     let clipboard_provider = get_clipboard_provider();
 
     if config_file.exists() {
@@ -66,17 +66,31 @@ pub fn general() -> std::io::Result<()> {
         writeln!(stdout, "Language file: default")?;
     }
     writeln!(stdout, "Log file: {}", log_file.display())?;
-    writeln!(stdout, "Runtime directory: {}", rt_dir.display())?;
-
-    if let Ok(path) = std::fs::read_link(&rt_dir) {
-        let msg = format!("Runtime directory is symlinked to {}", path.display());
-        writeln!(stdout, "{}", msg.yellow())?;
-    }
-    if !rt_dir.exists() {
-        writeln!(stdout, "{}", "Runtime directory does not exist.".red())?;
-    }
-    if rt_dir.read_dir().ok().map(|it| it.count()) == Some(0) {
-        writeln!(stdout, "{}", "Runtime directory is empty.".red())?;
+    writeln!(
+        stdout,
+        "Runtime directories: {}",
+        rt_dirs
+            .iter()
+            .map(|d| d.to_string_lossy())
+            .collect::<Vec<_>>()
+            .join(";")
+    )?;
+    for rt_dir in rt_dirs.iter() {
+        if let Ok(path) = std::fs::read_link(rt_dir) {
+            let msg = format!(
+                "Runtime directory {} is symlinked to: {}",
+                rt_dir.display(),
+                path.display()
+            );
+            writeln!(stdout, "{}", msg.yellow())?;
+        }
+        if !rt_dir.exists() {
+            let msg = format!("Runtime directory does not exist: {}", rt_dir.display());
+            writeln!(stdout, "{}", msg.yellow())?;
+        } else if rt_dir.read_dir().ok().map(|it| it.count()) == Some(0) {
+            let msg = format!("Runtime directory is empty: {}", rt_dir.display());
+            writeln!(stdout, "{}", msg.yellow())?;
+        }
     }
     writeln!(stdout, "Clipboard provider: {}", clipboard_provider.name())?;
 
@@ -281,9 +295,9 @@ fn probe_protocol(protocol_name: &str, server_cmd: Option<String>) -> std::io::R
     writeln!(stdout, "Configured {}: {}", protocol_name, cmd_name)?;
 
     if let Some(cmd) = server_cmd {
-        let path = match which::which(cmd) {
+        let path = match which::which(&cmd) {
             Ok(path) => path.display().to_string().green(),
-            Err(_) => "Not found in $PATH".to_string().red(),
+            Err(_) => format!("'{}' not found in $PATH", cmd).red(),
         };
         writeln!(stdout, "Binary for {}: {}", protocol_name, path)?;
     }
diff --git a/helix-term/src/job.rs b/helix-term/src/job.rs
index 2888b6eb1..19f2521a5 100644
--- a/helix-term/src/job.rs
+++ b/helix-term/src/job.rs
@@ -5,9 +5,12 @@
 use futures_util::future::{BoxFuture, Future, FutureExt};
 use futures_util::stream::{FuturesUnordered, StreamExt};
 
+pub type EditorCompositorCallback = Box<dyn FnOnce(&mut Editor, &mut Compositor) + Send>;
+pub type EditorCallback = Box<dyn FnOnce(&mut Editor) + Send>;
+
 pub enum Callback {
-    EditorCompositor(Box<dyn FnOnce(&mut Editor, &mut Compositor) + Send>),
-    Editor(Box<dyn FnOnce(&mut Editor) + Send>),
+    EditorCompositor(EditorCompositorCallback),
+    Editor(EditorCallback),
 }
 
 pub type JobFuture = BoxFuture<'static, anyhow::Result<Option<Callback>>>;
diff --git a/helix-term/src/keymap.rs b/helix-term/src/keymap.rs
index 4a131f0a5..3033c6a48 100644
--- a/helix-term/src/keymap.rs
+++ b/helix-term/src/keymap.rs
@@ -2,7 +2,6 @@
 pub mod macros;
 
 pub use crate::commands::MappableCommand;
-use crate::config::Config;
 use arc_swap::{
     access::{DynAccess, DynGuard},
     ArcSwap,
@@ -16,7 +15,7 @@
     sync::Arc,
 };
 
-use default::default;
+pub use default::default;
 use macros::key;
 
 #[derive(Debug, Clone)]
@@ -184,7 +183,7 @@ fn visit_seq<S>(self, mut seq: S) -> Result<Self::Value, S::Error>
         S: serde::de::SeqAccess<'de>,
     {
         let mut commands = Vec::new();
-        while let Some(command) = seq.next_element::<&str>()? {
+        while let Some(command) = seq.next_element::<String>()? {
             commands.push(
                 command
                     .parse::<MappableCommand>()
@@ -417,12 +416,10 @@ fn default() -> Self {
 }
 
 /// Merge default config keys with user overwritten keys for custom user config.
-pub fn merge_keys(mut config: Config) -> Config {
-    let mut delta = std::mem::replace(&mut config.keys, default());
-    for (mode, keys) in &mut config.keys {
+pub fn merge_keys(dst: &mut HashMap<Mode, Keymap>, mut delta: HashMap<Mode, Keymap>) {
+    for (mode, keys) in dst {
         keys.merge(delta.remove(mode).unwrap_or_default())
     }
-    config
 }
 
 #[cfg(test)]
@@ -449,26 +446,24 @@ fn check_duplicate_keys_in_default_keymap() {
 
     #[test]
     fn merge_partial_keys() {
-        let config = Config {
-            keys: hashmap! {
-                Mode::Normal => Keymap::new(
-                    keymap!({ "Normal mode"
-                        "i" => normal_mode,
-                        "" => insert_mode,
-                        "z" => jump_backward,
-                        "g" => { "Merge into goto mode"
-                            "$" => goto_line_end,
-                            "g" => delete_char_forward,
-                        },
-                    })
-                )
-            },
-            ..Default::default()
+        let keymap = hashmap! {
+            Mode::Normal => Keymap::new(
+                keymap!({ "Normal mode"
+                    "i" => normal_mode,
+                    "" => insert_mode,
+                    "z" => jump_backward,
+                    "g" => { "Merge into goto mode"
+                        "$" => goto_line_end,
+                        "g" => delete_char_forward,
+                    },
+                })
+            )
         };
-        let mut merged_config = merge_keys(config.clone());
-        assert_ne!(config, merged_config);
+        let mut merged_keyamp = default();
+        merge_keys(&mut merged_keyamp, keymap.clone());
+        assert_ne!(keymap, merged_keyamp);
 
-        let mut keymap = Keymaps::new(Box::new(Constant(merged_config.keys.clone())));
+        let mut keymap = Keymaps::new(Box::new(Constant(merged_keyamp.clone())));
         assert_eq!(
             keymap.get(Mode::Normal, key!('i')),
             KeymapResult::Matched(MappableCommand::normal_mode),
@@ -486,7 +481,7 @@ fn merge_partial_keys() {
             "Leaf should replace node"
         );
 
-        let keymap = merged_config.keys.get_mut(&Mode::Normal).unwrap();
+        let keymap = merged_keyamp.get_mut(&Mode::Normal).unwrap();
         // Assumes that `g` is a node in default keymap
         assert_eq!(
             keymap.root().search(&[key!('g'), key!('$')]).unwrap(),
@@ -506,30 +501,28 @@ fn merge_partial_keys() {
             "Old leaves in subnode should be present in merged node"
         );
 
-        assert!(merged_config.keys.get(&Mode::Normal).unwrap().len() > 1);
-        assert!(merged_config.keys.get(&Mode::Insert).unwrap().len() > 0);
+        assert!(merged_keyamp.get(&Mode::Normal).unwrap().len() > 1);
+        assert!(merged_keyamp.get(&Mode::Insert).unwrap().len() > 0);
     }
 
     #[test]
     fn order_should_be_set() {
-        let config = Config {
-            keys: hashmap! {
-                Mode::Normal => Keymap::new(
-                    keymap!({ "Normal mode"
-                        "space" => { ""
-                            "s" => { ""
-                                "v" => vsplit,
-                                "c" => hsplit,
-                            },
+        let keymap = hashmap! {
+            Mode::Normal => Keymap::new(
+                keymap!({ "Normal mode"
+                    "space" => { ""
+                        "s" => { ""
+                            "v" => vsplit,
+                            "c" => hsplit,
                         },
-                    })
-                )
-            },
-            ..Default::default()
+                    },
+                })
+            )
         };
-        let mut merged_config = merge_keys(config.clone());
-        assert_ne!(config, merged_config);
-        let keymap = merged_config.keys.get_mut(&Mode::Normal).unwrap();
+        let mut merged_keyamp = default();
+        merge_keys(&mut merged_keyamp, keymap.clone());
+        assert_ne!(keymap, merged_keyamp);
+        let keymap = merged_keyamp.get_mut(&Mode::Normal).unwrap();
         // Make sure mapping works
         assert_eq!(
             keymap
@@ -600,4 +593,43 @@ fn reverse_map() {
             "Mismatch"
         )
     }
+
+    #[test]
+    fn escaped_keymap() {
+        use crate::commands::MappableCommand;
+        use helix_view::input::{KeyCode, KeyEvent, KeyModifiers};
+
+        let keys = r#"
+"+" = [
+    "select_all",
+    ":pipe sed -E 's/\\s+$//g'",
+]
+        "#;
+
+        let key = KeyEvent {
+            code: KeyCode::Char('+'),
+            modifiers: KeyModifiers::NONE,
+        };
+
+        let expectation = Keymap::new(KeyTrie::Node(KeyTrieNode::new(
+            "",
+            hashmap! {
+                key => KeyTrie::Sequence(vec!{
+                    MappableCommand::select_all,
+                    MappableCommand::Typable {
+                        name: "pipe".to_string(),
+                        args: vec!{
+                            "sed".to_string(),
+                            "-E".to_string(),
+                            "'s/\\s+$//g'".to_string()
+                        },
+                        doc: "".to_string(),
+                    },
+                })
+            },
+            vec![key],
+        )));
+
+        assert_eq!(toml::from_str(keys), Ok(expectation));
+    }
 }
diff --git a/helix-term/src/keymap/default.rs b/helix-term/src/keymap/default.rs
index ebcd125aa..9bd002809 100644
--- a/helix-term/src/keymap/default.rs
+++ b/helix-term/src/keymap/default.rs
@@ -7,8 +7,8 @@
 pub fn default() -> HashMap<Mode, Keymap> {
     let normal = keymap!({ "Normal mode"
         "h" | "left" => move_char_left,
-        "j" | "down" => move_line_down,
-        "k" | "up" => move_line_up,
+        "j" | "down" => move_visual_line_down,
+        "k" | "up" => move_visual_line_up,
         "l" | "right" => move_char_right,
 
         "t" => find_till_char,
@@ -44,6 +44,7 @@ pub fn default() -> HashMap<Mode, Keymap> {
             "l" => goto_line_end,
             "s" => goto_first_nonwhitespace,
             "d" => goto_definition,
+            "D" => goto_declaration,
             "y" => goto_type_definition,
             "r" => goto_reference,
             "i" => goto_implementation,
@@ -54,6 +55,8 @@ pub fn default() -> HashMap<Mode, Keymap> {
             "m" => goto_last_modified_file,
             "n" => goto_next_buffer,
             "p" => goto_previous_buffer,
+            "k" => move_line_up,
+            "j" => move_line_down,
             "." => goto_last_modification,
         },
         ":" => command_mode,
@@ -76,6 +79,7 @@ pub fn default() -> HashMap<Mode, Keymap> {
 
         "s" => select_regex,
         "A-s" => split_selection_on_newline,
+        "A-_" => merge_consecutive_selections,
         "S" => split_selection,
         ";" => collapse_selection,
         "A-;" => flip_selections,
@@ -219,6 +223,7 @@ pub fn default() -> HashMap<Mode, Keymap> {
             "'" => last_picker,
             "g" => { "Debug (experimental)" sticky=true
                 "l" => dap_launch,
+                "r" => dap_restart,
                 "b" => dap_toggle_breakpoint,
                 "c" => dap_continue,
                 "h" => dap_pause,
@@ -319,8 +324,8 @@ pub fn default() -> HashMap<Mode, Keymap> {
     let mut select = normal.clone();
     select.merge_nodes(keymap!({ "Select mode"
         "h" | "left" => extend_char_left,
-        "j" | "down" => extend_line_down,
-        "k" | "up" => extend_line_up,
+        "j" | "down" => extend_visual_line_down,
+        "k" | "up" => extend_visual_line_up,
         "l" | "right" => extend_char_right,
 
         "w" => extend_next_word_start,
@@ -343,6 +348,10 @@ pub fn default() -> HashMap<Mode, Keymap> {
         "esc" => exit_select_mode,
 
         "v" => normal_mode,
+        "g" => { "Goto"
+            "k" => extend_line_up,
+            "j" => extend_line_down,
+        },
     }));
     let insert = keymap!({ "Insert mode"
         "esc" => normal_mode,
@@ -355,13 +364,13 @@ pub fn default() -> HashMap<Mode, Keymap> {
         "A-d" | "A-del" => delete_word_forward,
         "C-u" => kill_to_line_start,
         "C-k" => kill_to_line_end,
-        "C-h" | "backspace" => delete_char_backward,
+        "C-h" | "backspace" | "S-backspace" => delete_char_backward,
         "C-d" | "del" => delete_char_forward,
         "C-j" | "ret" => insert_newline,
         "tab" => insert_tab,
 
-        "up" => move_line_up,
-        "down" => move_line_down,
+        "up" => move_visual_line_up,
+        "down" => move_visual_line_down,
         "left" => move_char_left,
         "right" => move_char_right,
         "pageup" => page_up,
diff --git a/helix-term/src/lib.rs b/helix-term/src/lib.rs
index a945b20de..2f6ec12b1 100644
--- a/helix-term/src/lib.rs
+++ b/helix-term/src/lib.rs
@@ -10,6 +10,9 @@
 pub mod job;
 pub mod keymap;
 pub mod ui;
+use std::path::Path;
+
+use ignore::DirEntry;
 pub use keymap::macros::*;
 
 #[cfg(not(windows))]
@@ -22,3 +25,25 @@ fn true_color() -> bool {
 fn true_color() -> bool {
     true
 }
+
+/// Function used for filtering dir entries in the various file pickers.
+fn filter_picker_entry(entry: &DirEntry, root: &Path, dedup_symlinks: bool) -> bool {
+    // We always want to ignore the .git directory, otherwise if
+    // `ignore` is turned off, we end up with a lot of noise
+    // in our picker.
+    if entry.file_name() == ".git" {
+        return false;
+    }
+
+    // We also ignore symlinks that point inside the current directory
+    // if `dedup_links` is enabled.
+    if dedup_symlinks && entry.path_is_symlink() {
+        return entry
+            .path()
+            .canonicalize()
+            .ok()
+            .map_or(false, |path| !path.starts_with(root));
+    }
+
+    true
+}
diff --git a/helix-term/src/main.rs b/helix-term/src/main.rs
index aac5c5379..e0c3f6e70 100644
--- a/helix-term/src/main.rs
+++ b/helix-term/src/main.rs
@@ -3,7 +3,7 @@
 use helix_loader::VERSION_AND_GIT_HASH;
 use helix_term::application::Application;
 use helix_term::args::Args;
-use helix_term::config::Config;
+use helix_term::config::{Config, ConfigLoadError};
 use std::path::PathBuf;
 
 fn setup_logging(logpath: PathBuf, verbosity: u64) -> Result<()> {
@@ -126,18 +126,19 @@ async fn main_impl() -> Result<i32> {
 
     helix_loader::initialize_config_file(args.config_file.clone());
 
-    let config = match std::fs::read_to_string(helix_loader::config_file()) {
-        Ok(config) => toml::from_str(&config)
-            .map(helix_term::keymap::merge_keys)
-            .unwrap_or_else(|err| {
-                eprintln!("Bad config: {}", err);
-                eprintln!("Press <ENTER> to continue with default config");
-                use std::io::Read;
-                let _ = std::io::stdin().read(&mut []);
-                Config::default()
-            }),
-        Err(err) if err.kind() == std::io::ErrorKind::NotFound => Config::default(),
-        Err(err) => return Err(Error::new(err)),
+    let config = match Config::load_default() {
+        Ok(config) => config,
+        Err(ConfigLoadError::Error(err)) if err.kind() == std::io::ErrorKind::NotFound => {
+            Config::default()
+        }
+        Err(ConfigLoadError::Error(err)) => return Err(Error::new(err)),
+        Err(ConfigLoadError::BadConfig(err)) => {
+            eprintln!("Bad config: {}", err);
+            eprintln!("Press <ENTER> to continue with default config");
+            use std::io::Read;
+            let _ = std::io::stdin().read(&mut []);
+            Config::default()
+        }
     };
 
     let syn_loader_conf = helix_core::config::user_syntax_loader().unwrap_or_else(|err| {
diff --git a/helix-term/src/ui/completion.rs b/helix-term/src/ui/completion.rs
index 11d7886a3..bc216509f 100644
--- a/helix-term/src/ui/completion.rs
+++ b/helix-term/src/ui/completion.rs
@@ -1,16 +1,16 @@
 use crate::compositor::{Component, Context, Event, EventResult};
-use helix_view::{apply_transaction, editor::CompleteAction, ViewId};
-use tui::buffer::Buffer as Surface;
-use tui::text::Spans;
+use helix_view::{
+    document::SavePoint,
+    editor::CompleteAction,
+    theme::{Modifier, Style},
+    ViewId,
+};
+use tui::{buffer::Buffer as Surface, text::Span};
 
-use std::borrow::Cow;
+use std::{borrow::Cow, sync::Arc};
 
 use helix_core::{Change, Transaction};
-use helix_view::{
-    graphics::Rect,
-    input::{KeyCode, KeyEvent},
-    Document, Editor,
-};
+use helix_view::{graphics::Rect, Document, Editor};
 
 use crate::commands;
 use crate::ui::{menu, Markdown, Menu, Popup, PromptEvent};
@@ -33,13 +33,20 @@ fn filter_text(&self, _data: &Self::Data) -> Cow<str> {
             .into()
     }
 
-    fn label(&self, _data: &Self::Data) -> Spans {
-        self.label.as_str().into()
-    }
-
-    fn row(&self, _data: &Self::Data) -> menu::Row {
+    fn format(&self, _data: &Self::Data) -> menu::Row {
+        let deprecated = self.deprecated.unwrap_or_default()
+            || self.tags.as_ref().map_or(false, |tags| {
+                tags.contains(&lsp::CompletionItemTag::DEPRECATED)
+            });
         menu::Row::new(vec![
-            menu::Cell::from(self.label.as_str()),
+            menu::Cell::from(Span::styled(
+                self.label.as_str(),
+                if deprecated {
+                    Style::default().add_modifier(Modifier::CROSSED_OUT)
+                } else {
+                    Style::default()
+                },
+            )),
             menu::Cell::from(match self.kind {
                 Some(lsp::CompletionItemKind::TEXT) => "text",
                 Some(lsp::CompletionItemKind::METHOD) => "method",
@@ -95,11 +102,13 @@ impl Completion {
 
     pub fn new(
         editor: &Editor,
+        savepoint: Arc<SavePoint>,
         mut items: Vec<CompletionItem>,
         offset_encoding: helix_lsp::OffsetEncoding,
         start_offset: usize,
         trigger_offset: usize,
     ) -> Self {
+        let replace_mode = editor.config().completion_replace;
         // Sort completion items according to their preselect status (given by the LSP server)
         items.sort_by_key(|item| !item.preselect.unwrap_or(false));
 
@@ -110,50 +119,85 @@ fn item_to_transaction(
                 view_id: ViewId,
                 item: &CompletionItem,
                 offset_encoding: helix_lsp::OffsetEncoding,
-                start_offset: usize,
                 trigger_offset: usize,
+                include_placeholder: bool,
+                replace_mode: bool,
             ) -> Transaction {
-                let transaction = if let Some(edit) = &item.text_edit {
+                use helix_lsp::snippet;
+                let selection = doc.selection(view_id);
+                let text = doc.text().slice(..);
+                let primary_cursor = selection.primary().cursor(text);
+
+                let (edit_offset, new_text) = if let Some(edit) = &item.text_edit {
                     let edit = match edit {
                         lsp::CompletionTextEdit::Edit(edit) => edit.clone(),
                         lsp::CompletionTextEdit::InsertAndReplace(item) => {
-                            // TODO: support using "insert" instead of "replace" via user config
-                            lsp::TextEdit::new(item.replace, item.new_text.clone())
+                            let range = if replace_mode {
+                                item.replace
+                            } else {
+                                item.insert
+                            };
+                            lsp::TextEdit::new(range, item.new_text.clone())
                         }
                     };
 
-                    util::generate_transaction_from_completion_edit(
-                        doc.text(),
-                        doc.selection(view_id),
-                        edit,
-                        offset_encoding, // TODO: should probably transcode in Client
-                    )
-                } else {
-                    let text = item.insert_text.as_ref().unwrap_or(&item.label);
-                    // Some LSPs just give you an insertText with no offset \_()_/
-                    // in these cases we need to check for a common prefix and remove it
-                    let prefix = Cow::from(doc.text().slice(start_offset..trigger_offset));
-                    let text = text.trim_start_matches::<&str>(&prefix);
-
-                    // TODO: this needs to be true for the numbers to work out correctly
-                    // in the closure below. It's passed in to a callback as this same
-                    // formula, but can the value change between the LSP request and
-                    // response? If it does, can we recover?
-                    debug_assert!(
-                        doc.selection(view_id)
-                            .primary()
-                            .cursor(doc.text().slice(..))
-                            == trigger_offset
-                    );
+                    let Some(range) = util::lsp_range_to_range(doc.text(), edit.range, offset_encoding) else{
+                        return Transaction::new(doc.text());
+                    };
 
-                    Transaction::change_by_selection(doc.text(), doc.selection(view_id), |range| {
-                        let cursor = range.cursor(doc.text().slice(..));
+                    let start_offset = range.anchor as i128 - primary_cursor as i128;
+                    let end_offset = range.head as i128 - primary_cursor as i128;
 
-                        (cursor, cursor, Some(text.into()))
-                    })
+                    (Some((start_offset, end_offset)), edit.new_text)
+                } else {
+                    let new_text = item
+                        .insert_text
+                        .clone()
+                        .unwrap_or_else(|| item.label.clone());
+                    // check that we are still at the correct savepoint
+                    // we can still generate a transaction regardless but if the
+                    // document changed (and not just the selection) then we will
+                    // likely delete the wrong text (same if we applied an edit sent by the LS)
+                    debug_assert!(primary_cursor == trigger_offset);
+                    (None, new_text)
                 };
 
-                transaction
+                if matches!(item.kind, Some(lsp::CompletionItemKind::SNIPPET))
+                    || matches!(
+                        item.insert_text_format,
+                        Some(lsp::InsertTextFormat::SNIPPET)
+                    )
+                {
+                    match snippet::parse(&new_text) {
+                        Ok(snippet) => util::generate_transaction_from_snippet(
+                            doc.text(),
+                            selection,
+                            edit_offset,
+                            replace_mode,
+                            snippet,
+                            doc.line_ending.as_str(),
+                            include_placeholder,
+                            doc.tab_width(),
+                            doc.indent_width(),
+                        ),
+                        Err(err) => {
+                            log::error!(
+                                "Failed to parse snippet: {:?}, remaining output: {}",
+                                &new_text,
+                                err
+                            );
+                            Transaction::new(doc.text())
+                        }
+                    }
+                } else {
+                    util::generate_transaction_from_completion_edit(
+                        doc.text(),
+                        selection,
+                        edit_offset,
+                        replace_mode,
+                        new_text,
+                    )
+                }
             }
 
             fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<Change> {
@@ -166,11 +210,10 @@ fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<C
             let (view, doc) = current!(editor);
 
             // if more text was entered, remove it
-            doc.restore(view);
+            doc.restore(view, &savepoint);
 
             match event {
                 PromptEvent::Abort => {
-                    doc.restore(view);
                     editor.last_completion = None;
                 }
                 PromptEvent::Update => {
@@ -182,13 +225,13 @@ fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<C
                         view.id,
                         item,
                         offset_encoding,
-                        start_offset,
                         trigger_offset,
+                        true,
+                        replace_mode,
                     );
 
                     // initialize a savepoint
-                    doc.savepoint();
-                    apply_transaction(&transaction, doc, view);
+                    doc.apply(&transaction, view.id);
 
                     editor.last_completion = Some(CompleteAction {
                         trigger_offset,
@@ -204,11 +247,12 @@ fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<C
                         view.id,
                         item,
                         offset_encoding,
-                        start_offset,
                         trigger_offset,
+                        false,
+                        replace_mode,
                     );
 
-                    apply_transaction(&transaction, doc, view);
+                    doc.apply(&transaction, view.id);
 
                     editor.last_completion = Some(CompleteAction {
                         trigger_offset,
@@ -238,13 +282,15 @@ fn completion_changes(transaction: &Transaction, trigger_offset: usize) -> Vec<C
                                 additional_edits.clone(),
                                 offset_encoding, // TODO: should probably transcode in Client
                             );
-                            apply_transaction(&transaction, doc, view);
+                            doc.apply(&transaction, view.id);
                         }
                     }
                 }
             };
         });
-        let popup = Popup::new(Self::ID, menu).with_scrollbar(false);
+        let popup = Popup::new(Self::ID, menu)
+            .with_scrollbar(false)
+            .ignore_escape_key(true);
         let mut completion = Self {
             popup,
             start_offset,
@@ -364,17 +410,14 @@ pub fn ensure_item_resolved(&mut self, cx: &mut commands::Context) -> bool {
 
         true
     }
+
+    pub fn area(&mut self, viewport: Rect, editor: &Editor) -> Rect {
+        self.popup.area(viewport, editor)
+    }
 }
 
 impl Component for Completion {
     fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
-        // let the Editor handle Esc instead
-        if let Event::Key(KeyEvent {
-            code: KeyCode::Esc, ..
-        }) = event
-        {
-            return EventResult::Ignored(None);
-        }
         self.popup.handle_event(event, cx)
     }
 
@@ -386,102 +429,102 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         self.popup.render(area, surface, cx);
 
         // if we have a selection, render a markdown popup on top/below with info
-        if let Some(option) = self.popup.contents().selection() {
-            // need to render:
-            // option.detail
-            // ---
-            // option.documentation
-
-            let (view, doc) = current!(cx.editor);
-            let language = doc.language_name().unwrap_or("");
-            let text = doc.text().slice(..);
-            let cursor_pos = doc.selection(view.id).primary().cursor(text);
-            let coords = helix_core::visual_coords_at_pos(text, cursor_pos, doc.tab_width());
-            let cursor_pos = (coords.row - view.offset.row) as u16;
-
-            let mut markdown_doc = match &option.documentation {
-                Some(lsp::Documentation::String(contents))
-                | Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
-                    kind: lsp::MarkupKind::PlainText,
-                    value: contents,
-                })) => {
-                    // TODO: convert to wrapped text
-                    Markdown::new(
-                        format!(
-                            "```{}\n{}\n```\n{}",
-                            language,
-                            option.detail.as_deref().unwrap_or_default(),
-                            contents
-                        ),
-                        cx.editor.syn_loader.clone(),
-                    )
-                }
-                Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
-                    kind: lsp::MarkupKind::Markdown,
-                    value: contents,
-                })) => {
-                    // TODO: set language based on doc scope
-                    if let Some(detail) = &option.detail.as_deref() {
-                        Markdown::new(
-                            format!("```{}\n{}\n```\n{}", language, detail, contents),
-                            cx.editor.syn_loader.clone(),
-                        )
-                    } else {
-                        Markdown::new(contents.to_string(), cx.editor.syn_loader.clone())
-                    }
-                }
-                None if option.detail.is_some() => {
-                    // TODO: copied from above
-
-                    // TODO: set language based on doc scope
-                    Markdown::new(
-                        format!(
-                            "```{}\n{}\n```",
-                            language,
-                            option.detail.as_deref().unwrap_or_default(),
-                        ),
-                        cx.editor.syn_loader.clone(),
-                    )
-                }
-                None => return,
+        let option = match self.popup.contents().selection() {
+            Some(option) => option,
+            None => return,
+        };
+        // need to render:
+        // option.detail
+        // ---
+        // option.documentation
+
+        let (view, doc) = current!(cx.editor);
+        let language = doc.language_name().unwrap_or("");
+        let text = doc.text().slice(..);
+        let cursor_pos = doc.selection(view.id).primary().cursor(text);
+        let coords = view
+            .screen_coords_at_pos(doc, text, cursor_pos)
+            .expect("cursor must be in view");
+        let cursor_pos = coords.row as u16;
+
+        let markdowned = |lang: &str, detail: Option<&str>, doc: Option<&str>| {
+            let md = match (detail, doc) {
+                (Some(detail), Some(doc)) => format!("```{lang}\n{detail}\n```\n{doc}"),
+                (Some(detail), None) => format!("```{lang}\n{detail}\n```"),
+                (None, Some(doc)) => doc.to_string(),
+                (None, None) => String::new(),
             };
+            Markdown::new(md, cx.editor.syn_loader.clone())
+        };
 
-            let (popup_x, popup_y) = self.popup.get_rel_position(area, cx);
-            let (popup_width, _popup_height) = self.popup.get_size();
-            let mut width = area
-                .width
-                .saturating_sub(popup_x)
-                .saturating_sub(popup_width);
-            let area = if width > 30 {
-                let mut height = area.height.saturating_sub(popup_y);
-                let x = popup_x + popup_width;
-                let y = popup_y;
-
-                if let Some((rel_width, rel_height)) = markdown_doc.required_size((width, height)) {
-                    width = rel_width.min(width);
-                    height = rel_height.min(height);
-                }
-                Rect::new(x, y, width, height)
-            } else {
-                let half = area.height / 2;
-                let height = 15.min(half);
-                // we want to make sure the cursor is visible (not hidden behind the documentation)
-                let y = if cursor_pos + area.y
-                    >= (cx.editor.tree.area().height - height - 2/* statusline + commandline */)
-                {
-                    0
-                } else {
-                    // -2 to subtract command line + statusline. a bit of a hack, because of splits.
-                    area.height.saturating_sub(height).saturating_sub(2)
-                };
+        let mut markdown_doc = match &option.documentation {
+            Some(lsp::Documentation::String(contents))
+            | Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
+                kind: lsp::MarkupKind::PlainText,
+                value: contents,
+            })) => {
+                // TODO: convert to wrapped text
+                markdowned(language, option.detail.as_deref(), Some(contents))
+            }
+            Some(lsp::Documentation::MarkupContent(lsp::MarkupContent {
+                kind: lsp::MarkupKind::Markdown,
+                value: contents,
+            })) => {
+                // TODO: set language based on doc scope
+                markdowned(language, option.detail.as_deref(), Some(contents))
+            }
+            None if option.detail.is_some() => {
+                // TODO: set language based on doc scope
+                markdowned(language, option.detail.as_deref(), None)
+            }
+            None => return,
+        };
+
+        let popup_area = {
+            let (popup_x, popup_y) = self.popup.get_rel_position(area, cx.editor);
+            let (popup_width, popup_height) = self.popup.get_size();
+            Rect::new(popup_x, popup_y, popup_width, popup_height)
+        };
 
-                Rect::new(0, y, area.width, height)
+        let doc_width_available = area.width.saturating_sub(popup_area.right());
+        let doc_area = if doc_width_available > 30 {
+            let mut doc_width = doc_width_available;
+            let mut doc_height = area.height.saturating_sub(popup_area.top());
+            let x = popup_area.right();
+            let y = popup_area.top();
+
+            if let Some((rel_width, rel_height)) =
+                markdown_doc.required_size((doc_width, doc_height))
+            {
+                doc_width = rel_width.min(doc_width);
+                doc_height = rel_height.min(doc_height);
+            }
+            Rect::new(x, y, doc_width, doc_height)
+        } else {
+            // Documentation should not cover the cursor or the completion popup
+            // Completion popup could be above or below the current line
+            let avail_height_above = cursor_pos.min(popup_area.top()).saturating_sub(1);
+            let avail_height_below = area
+                .height
+                .saturating_sub(cursor_pos.max(popup_area.bottom()) + 1 /* padding */);
+            let (y, avail_height) = if avail_height_below >= avail_height_above {
+                (
+                    area.height.saturating_sub(avail_height_below),
+                    avail_height_below,
+                )
+            } else {
+                (0, avail_height_above)
             };
+            if avail_height <= 1 {
+                return;
+            }
 
-            // clear area
-            let background = cx.editor.theme.get("ui.popup");
-            surface.clear_with(area, background);
-            markdown_doc.render(area, surface, cx);
-        }
+            Rect::new(0, y, area.width, avail_height.min(15))
+        };
+
+        // clear area
+        let background = cx.editor.theme.get("ui.popup");
+        surface.clear_with(doc_area, background);
+        markdown_doc.render(doc_area, surface, cx);
     }
 }
diff --git a/helix-term/src/ui/document.rs b/helix-term/src/ui/document.rs
new file mode 100644
index 000000000..80da1c542
--- /dev/null
+++ b/helix-term/src/ui/document.rs
@@ -0,0 +1,484 @@
+use std::cmp::min;
+
+use helix_core::doc_formatter::{DocumentFormatter, GraphemeSource, TextFormat};
+use helix_core::graphemes::Grapheme;
+use helix_core::str_utils::char_to_byte_idx;
+use helix_core::syntax::Highlight;
+use helix_core::syntax::HighlightEvent;
+use helix_core::text_annotations::TextAnnotations;
+use helix_core::{visual_offset_from_block, Position, RopeSlice};
+use helix_view::editor::{WhitespaceConfig, WhitespaceRenderValue};
+use helix_view::graphics::Rect;
+use helix_view::theme::Style;
+use helix_view::view::ViewPosition;
+use helix_view::Document;
+use helix_view::Theme;
+use tui::buffer::Buffer as Surface;
+
+pub trait LineDecoration {
+    fn render_background(&mut self, _renderer: &mut TextRenderer, _pos: LinePos) {}
+    fn render_foreground(
+        &mut self,
+        _renderer: &mut TextRenderer,
+        _pos: LinePos,
+        _end_char_idx: usize,
+    ) {
+    }
+}
+
+impl<F: FnMut(&mut TextRenderer, LinePos)> LineDecoration for F {
+    fn render_background(&mut self, renderer: &mut TextRenderer, pos: LinePos) {
+        self(renderer, pos)
+    }
+}
+
+/// A wrapper around a HighlightIterator
+/// that merges the layered highlights to create the final text style
+/// and yields the active text style and the char_idx where the active
+/// style will have to be recomputed.
+struct StyleIter<'a, H: Iterator<Item = HighlightEvent>> {
+    text_style: Style,
+    active_highlights: Vec<Highlight>,
+    highlight_iter: H,
+    theme: &'a Theme,
+}
+
+impl<H: Iterator<Item = HighlightEvent>> Iterator for StyleIter<'_, H> {
+    type Item = (Style, usize);
+    fn next(&mut self) -> Option<(Style, usize)> {
+        while let Some(event) = self.highlight_iter.next() {
+            match event {
+                HighlightEvent::HighlightStart(highlights) => {
+                    self.active_highlights.push(highlights)
+                }
+                HighlightEvent::HighlightEnd => {
+                    self.active_highlights.pop();
+                }
+                HighlightEvent::Source { start, end } => {
+                    if start == end {
+                        continue;
+                    }
+                    let style = self
+                        .active_highlights
+                        .iter()
+                        .fold(self.text_style, |acc, span| {
+                            acc.patch(self.theme.highlight(span.0))
+                        });
+                    return Some((style, end));
+                }
+            }
+        }
+        None
+    }
+}
+
+#[derive(Debug, PartialEq, Eq, Copy, Clone)]
+pub struct LinePos {
+    /// Indicates whether the given visual line
+    /// is the first visual line of the given document line
+    pub first_visual_line: bool,
+    /// The line index of the document line that contains the given visual line
+    pub doc_line: usize,
+    /// Vertical offset from the top of the inner view area
+    pub visual_line: u16,
+    /// The first char index of this visual line.
+    /// Note that if the visual line is entirely filled by
+    /// a very long inline virtual text then this index will point
+    /// at the next (non-virtual) char after this visual line
+    pub start_char_idx: usize,
+}
+
+pub type TranslatedPosition<'a> = (usize, Box<dyn FnMut(&mut TextRenderer, Position) + 'a>);
+
+#[allow(clippy::too_many_arguments)]
+pub fn render_document(
+    surface: &mut Surface,
+    viewport: Rect,
+    doc: &Document,
+    offset: ViewPosition,
+    doc_annotations: &TextAnnotations,
+    highlight_iter: impl Iterator<Item = HighlightEvent>,
+    theme: &Theme,
+    line_decoration: &mut [Box<dyn LineDecoration + '_>],
+    translated_positions: &mut [TranslatedPosition],
+) {
+    let mut renderer = TextRenderer::new(surface, doc, theme, offset.horizontal_offset, viewport);
+    render_text(
+        &mut renderer,
+        doc.text().slice(..),
+        offset,
+        &doc.text_format(viewport.width, Some(theme)),
+        doc_annotations,
+        highlight_iter,
+        theme,
+        line_decoration,
+        translated_positions,
+    )
+}
+
+fn translate_positions(
+    char_pos: usize,
+    first_visible_char_idx: usize,
+    translated_positions: &mut [TranslatedPosition],
+    text_fmt: &TextFormat,
+    renderer: &mut TextRenderer,
+    pos: Position,
+) {
+    // check if any positions translated on the fly (like cursor) has been reached
+    for (char_idx, callback) in &mut *translated_positions {
+        if *char_idx < char_pos && *char_idx >= first_visible_char_idx {
+            // by replacing the char_index with usize::MAX large number we ensure
+            // that the same position is only translated once
+            // text will never reach usize::MAX as rust memory allocations are limited
+            // to isize::MAX
+            *char_idx = usize::MAX;
+
+            if text_fmt.soft_wrap {
+                callback(renderer, pos)
+            } else if pos.col >= renderer.col_offset
+                && pos.col - renderer.col_offset < renderer.viewport.width as usize
+            {
+                callback(
+                    renderer,
+                    Position {
+                        row: pos.row,
+                        col: pos.col - renderer.col_offset,
+                    },
+                )
+            }
+        }
+    }
+}
+
+#[allow(clippy::too_many_arguments)]
+pub fn render_text<'t>(
+    renderer: &mut TextRenderer,
+    text: RopeSlice<'t>,
+    offset: ViewPosition,
+    text_fmt: &TextFormat,
+    text_annotations: &TextAnnotations,
+    highlight_iter: impl Iterator<Item = HighlightEvent>,
+    theme: &Theme,
+    line_decorations: &mut [Box<dyn LineDecoration + '_>],
+    translated_positions: &mut [TranslatedPosition],
+) {
+    let (
+        Position {
+            row: mut row_off, ..
+        },
+        mut char_pos,
+    ) = visual_offset_from_block(
+        text,
+        offset.anchor,
+        offset.anchor,
+        text_fmt,
+        text_annotations,
+    );
+    row_off += offset.vertical_offset;
+
+    let (mut formatter, mut first_visible_char_idx) =
+        DocumentFormatter::new_at_prev_checkpoint(text, text_fmt, text_annotations, offset.anchor);
+    let mut styles = StyleIter {
+        text_style: renderer.text_style,
+        active_highlights: Vec::with_capacity(64),
+        highlight_iter,
+        theme,
+    };
+
+    let mut last_line_pos = LinePos {
+        first_visual_line: false,
+        doc_line: usize::MAX,
+        visual_line: u16::MAX,
+        start_char_idx: usize::MAX,
+    };
+    let mut is_in_indent_area = true;
+    let mut last_line_indent_level = 0;
+    let mut style_span = styles
+        .next()
+        .unwrap_or_else(|| (Style::default(), usize::MAX));
+
+    loop {
+        // formattter.line_pos returns to line index of the next grapheme
+        // so it must be called before formatter.next
+        let doc_line = formatter.line_pos();
+        let Some((grapheme, mut pos)) = formatter.next() else {
+            let mut last_pos = formatter.visual_pos();
+            if last_pos.row >= row_off {
+                last_pos.col -= 1;
+                last_pos.row -= row_off;
+                // check if any positions translated on the fly (like cursor) are at the EOF
+                translate_positions(
+                    char_pos + 1,
+                    first_visible_char_idx,
+                    translated_positions,
+                    text_fmt,
+                    renderer,
+                    last_pos,
+                );
+            }
+            break;
+        };
+
+        // skip any graphemes on visual lines before the block start
+        if pos.row < row_off {
+            if char_pos >= style_span.1 {
+                style_span = if let Some(style_span) = styles.next() {
+                    style_span
+                } else {
+                    break;
+                }
+            }
+            char_pos += grapheme.doc_chars();
+            first_visible_char_idx = char_pos + 1;
+            continue;
+        }
+        pos.row -= row_off;
+
+        // if the end of the viewport is reached stop rendering
+        if pos.row as u16 >= renderer.viewport.height {
+            break;
+        }
+
+        // apply decorations before rendering a new line
+        if pos.row as u16 != last_line_pos.visual_line {
+            if pos.row > 0 {
+                renderer.draw_indent_guides(last_line_indent_level, last_line_pos.visual_line);
+                is_in_indent_area = true;
+                for line_decoration in &mut *line_decorations {
+                    line_decoration.render_foreground(renderer, last_line_pos, char_pos);
+                }
+            }
+            last_line_pos = LinePos {
+                first_visual_line: doc_line != last_line_pos.doc_line,
+                doc_line,
+                visual_line: pos.row as u16,
+                start_char_idx: char_pos,
+            };
+            for line_decoration in &mut *line_decorations {
+                line_decoration.render_background(renderer, last_line_pos);
+            }
+        }
+
+        // acquire the correct grapheme style
+        if char_pos >= style_span.1 {
+            style_span = styles.next().unwrap_or((Style::default(), usize::MAX));
+        }
+        char_pos += grapheme.doc_chars();
+
+        // check if any positions translated on the fly (like cursor) has been reached
+        translate_positions(
+            char_pos,
+            first_visible_char_idx,
+            translated_positions,
+            text_fmt,
+            renderer,
+            pos,
+        );
+
+        let grapheme_style = if let GraphemeSource::VirtualText { highlight } = grapheme.source {
+            let style = renderer.text_style;
+            if let Some(highlight) = highlight {
+                style.patch(theme.highlight(highlight.0))
+            } else {
+                style
+            }
+        } else {
+            style_span.0
+        };
+
+        let virt = grapheme.is_virtual();
+        renderer.draw_grapheme(
+            grapheme.grapheme,
+            grapheme_style,
+            virt,
+            &mut last_line_indent_level,
+            &mut is_in_indent_area,
+            pos,
+        );
+    }
+
+    renderer.draw_indent_guides(last_line_indent_level, last_line_pos.visual_line);
+    for line_decoration in &mut *line_decorations {
+        line_decoration.render_foreground(renderer, last_line_pos, char_pos);
+    }
+}
+
+#[derive(Debug)]
+pub struct TextRenderer<'a> {
+    pub surface: &'a mut Surface,
+    pub text_style: Style,
+    pub whitespace_style: Style,
+    pub indent_guide_char: String,
+    pub indent_guide_style: Style,
+    pub newline: String,
+    pub nbsp: String,
+    pub space: String,
+    pub tab: String,
+    pub virtual_tab: String,
+    pub indent_width: u16,
+    pub starting_indent: usize,
+    pub draw_indent_guides: bool,
+    pub col_offset: usize,
+    pub viewport: Rect,
+}
+
+impl<'a> TextRenderer<'a> {
+    pub fn new(
+        surface: &'a mut Surface,
+        doc: &Document,
+        theme: &Theme,
+        col_offset: usize,
+        viewport: Rect,
+    ) -> TextRenderer<'a> {
+        let editor_config = doc.config.load();
+        let WhitespaceConfig {
+            render: ws_render,
+            characters: ws_chars,
+        } = &editor_config.whitespace;
+
+        let tab_width = doc.tab_width();
+        let tab = if ws_render.tab() == WhitespaceRenderValue::All {
+            std::iter::once(ws_chars.tab)
+                .chain(std::iter::repeat(ws_chars.tabpad).take(tab_width - 1))
+                .collect()
+        } else {
+            " ".repeat(tab_width)
+        };
+        let virtual_tab = " ".repeat(tab_width);
+        let newline = if ws_render.newline() == WhitespaceRenderValue::All {
+            ws_chars.newline.into()
+        } else {
+            " ".to_owned()
+        };
+
+        let space = if ws_render.space() == WhitespaceRenderValue::All {
+            ws_chars.space.into()
+        } else {
+            " ".to_owned()
+        };
+        let nbsp = if ws_render.nbsp() == WhitespaceRenderValue::All {
+            ws_chars.nbsp.into()
+        } else {
+            " ".to_owned()
+        };
+
+        let text_style = theme.get("ui.text");
+
+        let indent_width = doc.indent_style.indent_width(tab_width) as u16;
+
+        TextRenderer {
+            surface,
+            indent_guide_char: editor_config.indent_guides.character.into(),
+            newline,
+            nbsp,
+            space,
+            tab,
+            virtual_tab,
+            whitespace_style: theme.get("ui.virtual.whitespace"),
+            indent_width,
+            starting_indent: col_offset / indent_width as usize
+                + (col_offset % indent_width as usize != 0) as usize
+                + editor_config.indent_guides.skip_levels as usize,
+            indent_guide_style: text_style.patch(
+                theme
+                    .try_get("ui.virtual.indent-guide")
+                    .unwrap_or_else(|| theme.get("ui.virtual.whitespace")),
+            ),
+            text_style,
+            draw_indent_guides: editor_config.indent_guides.render,
+            viewport,
+            col_offset,
+        }
+    }
+
+    /// Draws a single `grapheme` at the current render position with a specified `style`.
+    pub fn draw_grapheme(
+        &mut self,
+        grapheme: Grapheme,
+        mut style: Style,
+        is_virtual: bool,
+        last_indent_level: &mut usize,
+        is_in_indent_area: &mut bool,
+        position: Position,
+    ) {
+        let cut_off_start = self.col_offset.saturating_sub(position.col);
+        let is_whitespace = grapheme.is_whitespace();
+
+        // TODO is it correct to apply the whitespace style to all unicode white spaces?
+        if is_whitespace {
+            style = style.patch(self.whitespace_style);
+        }
+
+        let width = grapheme.width();
+        let space = if is_virtual { " " } else { &self.space };
+        let nbsp = if is_virtual { " " } else { &self.nbsp };
+        let tab = if is_virtual {
+            &self.virtual_tab
+        } else {
+            &self.tab
+        };
+        let grapheme = match grapheme {
+            Grapheme::Tab { width } => {
+                let grapheme_tab_width = char_to_byte_idx(tab, width);
+                &tab[..grapheme_tab_width]
+            }
+            // TODO special rendering for other whitespaces?
+            Grapheme::Other { ref g } if g == " " => space,
+            Grapheme::Other { ref g } if g == "\u{00A0}" => nbsp,
+            Grapheme::Other { ref g } => g,
+            Grapheme::Newline => &self.newline,
+        };
+
+        let in_bounds = self.col_offset <= position.col
+            && position.col < self.viewport.width as usize + self.col_offset;
+
+        if in_bounds {
+            self.surface.set_string(
+                self.viewport.x + (position.col - self.col_offset) as u16,
+                self.viewport.y + position.row as u16,
+                grapheme,
+                style,
+            );
+        } else if cut_off_start != 0 && cut_off_start < width {
+            // partially on screen
+            let rect = Rect::new(
+                self.viewport.x,
+                self.viewport.y + position.row as u16,
+                (width - cut_off_start) as u16,
+                1,
+            );
+            self.surface.set_style(rect, style);
+        }
+
+        if *is_in_indent_area && !is_whitespace {
+            *last_indent_level = position.col;
+            *is_in_indent_area = false;
+        }
+    }
+
+    /// Overlay indentation guides ontop of a rendered line
+    /// The indentation level is computed in `draw_lines`.
+    /// Therefore this function must always be called afterwards.
+    pub fn draw_indent_guides(&mut self, indent_level: usize, row: u16) {
+        if !self.draw_indent_guides {
+            return;
+        }
+
+        // Don't draw indent guides outside of view
+        let end_indent = min(
+            indent_level,
+            // Add indent_width - 1 to round up, since the first visible
+            // indent might be a bit after offset.col
+            self.col_offset + self.viewport.width as usize + (self.indent_width as usize - 1),
+        ) / self.indent_width as usize;
+
+        for i in self.starting_indent..end_indent {
+            let x = (self.viewport.x as usize + (i * self.indent_width as usize) - self.col_offset)
+                as u16;
+            let y = self.viewport.y + row;
+            debug_assert!(self.surface.in_bounds(x, y));
+            self.surface
+                .set_string(x, y, &self.indent_guide_char, self.indent_guide_style);
+        }
+    }
+}
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 8b6ac255c..fd8e8fb21 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -1,42 +1,46 @@
 use crate::{
-    commands,
+    commands::{self, OnKeyCallback},
     compositor::{Component, Context, Event, EventResult},
     job::{self, Callback},
     key,
     keymap::{KeymapResult, Keymaps},
-    ui::{Completion, ProgressSpinners},
+    ui::{
+        document::{render_document, LinePos, TextRenderer, TranslatedPosition},
+        Completion, ProgressSpinners,
+    },
 };
 
 use helix_core::{
+    diagnostic::NumberOrString,
     graphemes::{
         ensure_grapheme_boundary_next_byte, next_grapheme_boundary, prev_grapheme_boundary,
     },
     movement::Direction,
     syntax::{self, HighlightEvent},
+    text_annotations::TextAnnotations,
     unicode::width::UnicodeWidthStr,
-    visual_coords_at_pos, LineEnding, Position, Range, Selection, Transaction,
+    visual_offset_from_block, Position, Range, Selection, Transaction,
 };
 use helix_view::{
-    apply_transaction,
-    document::{Mode, SCRATCH_BUFFER_NAME},
+    document::{Mode, SavePoint, SCRATCH_BUFFER_NAME},
     editor::{CompleteAction, CursorShapeConfig},
     graphics::{Color, CursorKind, Modifier, Rect, Style},
     input::{KeyEvent, MouseButton, MouseEvent, MouseEventKind},
     keyboard::{KeyCode, KeyModifiers},
     Document, Editor, Theme, View,
 };
-use std::{borrow::Cow, cmp::min, num::NonZeroUsize, path::PathBuf};
+use std::{mem::take, num::NonZeroUsize, path::PathBuf, rc::Rc, sync::Arc};
 
-use tui::buffer::Buffer as Surface;
+use tui::{buffer::Buffer as Surface, text::Span};
 
-use super::lsp::SignatureHelp;
 use super::statusline;
+use super::{document::LineDecoration, lsp::SignatureHelp};
 
 pub struct EditorView {
     pub keymaps: Keymaps,
-    on_next_key: Option<Box<dyn FnOnce(&mut commands::Context, KeyEvent)>>,
+    on_next_key: Option<OnKeyCallback>,
     pseudo_pending: Vec<KeyEvent>,
-    last_insert: (commands::MappableCommand, Vec<InsertEvent>),
+    pub(crate) last_insert: (commands::MappableCommand, Vec<InsertEvent>),
     pub(crate) completion: Option<Completion>,
     spinners: ProgressSpinners,
 }
@@ -46,6 +50,7 @@ pub enum InsertEvent {
     Key(KeyEvent),
     CompletionApply(CompleteAction),
     TriggerCompletion,
+    RequestCompletion,
 }
 
 impl Default for EditorView {
@@ -84,48 +89,47 @@ pub fn render_view(
         let theme = &editor.theme;
         let config = editor.config();
 
-        // DAP: Highlight current stack frame position
-        let stack_frame = editor.debugger.as_ref().and_then(|debugger| {
-            if let (Some(frame), Some(thread_id)) = (debugger.active_frame, debugger.thread_id) {
-                debugger
-                    .stack_frames
-                    .get(&thread_id)
-                    .and_then(|bt| bt.get(frame))
-            } else {
-                None
-            }
-        });
-        if let Some(frame) = stack_frame {
-            if doc.path().is_some()
-                && frame
-                    .source
-                    .as_ref()
-                    .and_then(|source| source.path.as_ref())
-                    == doc.path()
-            {
-                let line = frame.line - 1; // convert to 0-indexing
-                if line >= view.offset.row && line < view.offset.row + area.height as usize {
-                    surface.set_style(
-                        Rect::new(
-                            area.x,
-                            area.y + (line - view.offset.row) as u16,
-                            area.width,
-                            1,
-                        ),
-                        theme.get("ui.highlight"),
-                    );
-                }
-            }
-        }
+        let text_annotations = view.text_annotations(doc, Some(theme));
+        let mut line_decorations: Vec<Box<dyn LineDecoration>> = Vec::new();
+        let mut translated_positions: Vec<TranslatedPosition> = Vec::new();
 
         if is_focused && config.cursorline {
-            Self::highlight_cursorline(doc, view, surface, theme);
+            line_decorations.push(Self::cursorline_decorator(doc, view, theme))
         }
+
         if is_focused && config.cursorcolumn {
-            Self::highlight_cursorcolumn(doc, view, surface, theme);
+            Self::highlight_cursorcolumn(doc, view, surface, theme, inner, &text_annotations);
+        }
+
+        // Set DAP highlights, if needed.
+        if let Some(frame) = editor.current_stack_frame() {
+            let dap_line = frame.line.saturating_sub(1) as usize;
+            let style = theme.get("ui.highlight.frameline");
+            let line_decoration = move |renderer: &mut TextRenderer, pos: LinePos| {
+                if pos.doc_line != dap_line {
+                    return;
+                }
+                renderer.surface.set_style(
+                    Rect::new(inner.x, inner.y + pos.visual_line, inner.width, 1),
+                    style,
+                );
+            };
+
+            line_decorations.push(Box::new(line_decoration));
+        }
+
+        let mut highlights =
+            Self::doc_syntax_highlights(doc, view.offset.anchor, inner.height, theme);
+        let overlay_highlights = Self::overlay_syntax_highlights(
+            doc,
+            view.offset.anchor,
+            inner.height,
+            &text_annotations,
+        );
+        if !overlay_highlights.is_empty() {
+            highlights = Box::new(syntax::merge(highlights, overlay_highlights));
         }
 
-        let mut highlights = Self::doc_syntax_highlights(doc, view.offset, inner.height, theme);
         for diagnostic in Self::doc_diagnostics_highlights(doc, theme) {
             // Most of the `diagnostic` Vecs are empty most of the time. Skipping
             // a merge for any empty Vec saves a significant amount of work.
@@ -134,8 +138,9 @@ pub fn render_view(
             }
             highlights = Box::new(syntax::merge(highlights, diagnostic));
         }
+
         let highlights: Box<dyn Iterator<Item = HighlightEvent>> = if is_focused {
-            Box::new(syntax::merge(
+            let highlights = syntax::merge(
                 highlights,
                 Self::doc_selection_highlights(
                     editor.mode(),
@@ -144,19 +149,52 @@ pub fn render_view(
                     theme,
                     &config.cursor_shape,
                 ),
-            ))
+            );
+            let focused_view_elements = Self::highlight_focused_view_elements(view, doc, theme);
+            if focused_view_elements.is_empty() {
+                Box::new(highlights)
+            } else {
+                Box::new(syntax::merge(highlights, focused_view_elements))
+            }
         } else {
             Box::new(highlights)
         };
 
-        Self::render_text_highlights(doc, view.offset, inner, surface, theme, highlights, &config);
-        Self::render_gutter(editor, doc, view, view.area, surface, theme, is_focused);
-        Self::render_rulers(editor, doc, view, inner, surface, theme);
+        Self::render_gutter(
+            editor,
+            doc,
+            view,
+            view.area,
+            theme,
+            is_focused,
+            &mut line_decorations,
+        );
 
         if is_focused {
-            Self::render_focused_view_elements(view, doc, inner, theme, surface);
+            let cursor = doc
+                .selection(view.id)
+                .primary()
+                .cursor(doc.text().slice(..));
+            // set the cursor_cache to out of view in case the position is not found
+            editor.cursor_cache.set(Some(None));
+            let update_cursor_cache =
+                |_: &mut TextRenderer, pos| editor.cursor_cache.set(Some(Some(pos)));
+            translated_positions.push((cursor, Box::new(update_cursor_cache)));
         }
 
+        render_document(
+            surface,
+            inner,
+            doc,
+            view.offset,
+            &text_annotations,
+            highlights,
+            theme,
+            &mut line_decorations,
+            &mut translated_positions,
+        );
+        Self::render_rulers(editor, doc, view, inner, surface, theme);
+
         // if we're not at the edge of the screen, draw a right border
         if viewport.right() != view.area.right() {
             let x = area.right();
@@ -204,31 +242,53 @@ pub fn render_rulers(
             .iter()
             // View might be horizontally scrolled, convert from absolute distance
             // from the 1st column to relative distance from left of viewport
-            .filter_map(|ruler| ruler.checked_sub(1 + view.offset.col as u16))
+            .filter_map(|ruler| ruler.checked_sub(1 + view.offset.horizontal_offset as u16))
             .filter(|ruler| ruler < &viewport.width)
             .map(|ruler| viewport.clip_left(ruler).with_width(1))
             .for_each(|area| surface.set_style(area, ruler_theme))
     }
 
+    pub fn overlay_syntax_highlights(
+        doc: &Document,
+        anchor: usize,
+        height: u16,
+        text_annotations: &TextAnnotations,
+    ) -> Vec<(usize, std::ops::Range<usize>)> {
+        let text = doc.text().slice(..);
+        let row = text.char_to_line(anchor.min(text.len_chars()));
+
+        let range = {
+            // Calculate viewport byte ranges:
+            // Saturating subs to make it inclusive zero indexing.
+            let last_line = text.len_lines().saturating_sub(1);
+            let last_visible_line = (row + height as usize).saturating_sub(1).min(last_line);
+            let start = text.line_to_byte(row.min(last_line));
+            let end = text.line_to_byte(last_visible_line + 1);
+
+            start..end
+        };
+
+        text_annotations.collect_overlay_highlights(range)
+    }
+
     /// Get syntax highlights for a document in a view represented by the first line
     /// and column (`offset`) and the last line. This is done instead of using a view
     /// directly to enable rendering syntax highlighted docs anywhere (eg. picker preview)
     pub fn doc_syntax_highlights<'doc>(
         doc: &'doc Document,
-        offset: Position,
+        anchor: usize,
         height: u16,
         _theme: &Theme,
     ) -> Box<dyn Iterator<Item = HighlightEvent> + 'doc> {
         let text = doc.text().slice(..);
+        let row = text.char_to_line(anchor.min(text.len_chars()));
 
         let range = {
             // Calculate viewport byte ranges:
             // Saturating subs to make it inclusive zero indexing.
-            let last_line = doc.text().len_lines().saturating_sub(1);
-            let last_visible_line = (offset.row + height as usize)
-                .saturating_sub(1)
-                .min(last_line);
-            let start = text.line_to_byte(offset.row.min(last_line));
+            let last_line = text.len_lines().saturating_sub(1);
+            let last_visible_line = (row + height as usize).saturating_sub(1).min(last_line);
+            let start = text.line_to_byte(row.min(last_line));
             let end = text.line_to_byte(last_visible_line + 1);
 
             start..end
@@ -273,11 +333,11 @@ pub fn doc_diagnostics_highlights(
         use helix_core::diagnostic::Severity;
         let get_scope_of = |scope| {
             theme
-            .find_scope_index(scope)
+            .find_scope_index_exact(scope)
             // get one of the themes below as fallback values
-            .or_else(|| theme.find_scope_index("diagnostic"))
-            .or_else(|| theme.find_scope_index("ui.cursor"))
-            .or_else(|| theme.find_scope_index("ui.selection"))
+            .or_else(|| theme.find_scope_index_exact("diagnostic"))
+            .or_else(|| theme.find_scope_index_exact("ui.cursor"))
+            .or_else(|| theme.find_scope_index_exact("ui.selection"))
             .expect(
                 "at least one of the following scopes must be defined in the theme: `diagnostic`, `ui.cursor`, or `ui.selection`",
             )
@@ -340,25 +400,32 @@ pub fn doc_selection_highlights(
         let cursor_is_block = cursorkind == CursorKind::Block;
 
         let selection_scope = theme
-            .find_scope_index("ui.selection")
+            .find_scope_index_exact("ui.selection")
             .expect("could not find `ui.selection` scope in the theme!");
+        let primary_selection_scope = theme
+            .find_scope_index_exact("ui.selection.primary")
+            .unwrap_or(selection_scope);
+
         let base_cursor_scope = theme
-            .find_scope_index("ui.cursor")
+            .find_scope_index_exact("ui.cursor")
             .unwrap_or(selection_scope);
+        let base_primary_cursor_scope = theme
+            .find_scope_index("ui.cursor.primary")
+            .unwrap_or(base_cursor_scope);
 
         let cursor_scope = match mode {
-            Mode::Insert => theme.find_scope_index("ui.cursor.insert"),
-            Mode::Select => theme.find_scope_index("ui.cursor.select"),
-            Mode::Normal => Some(base_cursor_scope),
+            Mode::Insert => theme.find_scope_index_exact("ui.cursor.insert"),
+            Mode::Select => theme.find_scope_index_exact("ui.cursor.select"),
+            Mode::Normal => theme.find_scope_index_exact("ui.cursor.normal"),
         }
         .unwrap_or(base_cursor_scope);
 
-        let primary_cursor_scope = theme
-            .find_scope_index("ui.cursor.primary")
-            .unwrap_or(cursor_scope);
-        let primary_selection_scope = theme
-            .find_scope_index("ui.selection.primary")
-            .unwrap_or(selection_scope);
+        let primary_cursor_scope = match mode {
+            Mode::Insert => theme.find_scope_index_exact("ui.cursor.primary.insert"),
+            Mode::Select => theme.find_scope_index_exact("ui.cursor.primary.select"),
+            Mode::Normal => theme.find_scope_index_exact("ui.cursor.primary.normal"),
+        }
+        .unwrap_or(base_primary_cursor_scope);
 
         let mut spans: Vec<(usize, std::ops::Range<usize>)> = Vec::new();
         for (i, range) in selection.iter().enumerate() {
@@ -386,7 +453,14 @@ pub fn doc_selection_highlights(
             if range.head > range.anchor {
                 // Standard case.
                 let cursor_start = prev_grapheme_boundary(text, range.head);
-                spans.push((selection_scope, range.anchor..cursor_start));
+                // non block cursors look like they exclude the cursor
+                let selection_end =
+                    if selection_is_primary && !cursor_is_block && mode != Mode::Insert {
+                        range.head
+                    } else {
+                        cursor_start
+                    };
+                spans.push((selection_scope, range.anchor..selection_end));
                 if !selection_is_primary || cursor_is_block {
                     spans.push((cursor_scope, cursor_start..range.head));
                 }
@@ -396,255 +470,42 @@ pub fn doc_selection_highlights(
                 if !selection_is_primary || cursor_is_block {
                     spans.push((cursor_scope, range.head..cursor_end));
                 }
-                spans.push((selection_scope, cursor_end..range.anchor));
+                // non block cursors look like they exclude the cursor
+                let selection_start = if selection_is_primary
+                    && !cursor_is_block
+                    && !(mode == Mode::Insert && cursor_end == range.anchor)
+                {
+                    range.head
+                } else {
+                    cursor_end
+                };
+                spans.push((selection_scope, selection_start..range.anchor));
             }
         }
 
         spans
     }
 
-    pub fn render_text_highlights<H: Iterator<Item = HighlightEvent>>(
-        doc: &Document,
-        offset: Position,
-        viewport: Rect,
-        surface: &mut Surface,
-        theme: &Theme,
-        highlights: H,
-        config: &helix_view::editor::Config,
-    ) {
-        let whitespace = &config.whitespace;
-        use helix_view::editor::WhitespaceRenderValue;
-
-        // It's slightly more efficient to produce a full RopeSlice from the Rope, then slice that a bunch
-        // of times than it is to always call Rope::slice/get_slice (it will internally always hit RSEnum::Light).
-        let text = doc.text().slice(..);
-
-        let characters = &whitespace.characters;
-
-        let mut spans = Vec::new();
-        let mut visual_x = 0usize;
-        let mut line = 0u16;
-        let tab_width = doc.tab_width();
-        let tab = if whitespace.render.tab() == WhitespaceRenderValue::All {
-            std::iter::once(characters.tab)
-                .chain(std::iter::repeat(characters.tabpad).take(tab_width - 1))
-                .collect()
-        } else {
-            " ".repeat(tab_width)
-        };
-        let space = characters.space.to_string();
-        let nbsp = characters.nbsp.to_string();
-        let newline = if whitespace.render.newline() == WhitespaceRenderValue::All {
-            characters.newline.to_string()
-        } else {
-            " ".to_string()
-        };
-        let indent_guide_char = config.indent_guides.character.to_string();
-
-        let text_style = theme.get("ui.text");
-        let whitespace_style = theme.get("ui.virtual.whitespace");
-
-        let mut is_in_indent_area = true;
-        let mut last_line_indent_level = 0;
-
-        // use whitespace style as fallback for indent-guide
-        let indent_guide_style = text_style.patch(
-            theme
-                .try_get("ui.virtual.indent-guide")
-                .unwrap_or_else(|| theme.get("ui.virtual.whitespace")),
-        );
-
-        let draw_indent_guides = |indent_level, line, surface: &mut Surface| {
-            if !config.indent_guides.render {
-                return;
-            }
-
-            let starting_indent =
-                (offset.col / tab_width) + config.indent_guides.skip_levels as usize;
-
-            // Don't draw indent guides outside of view
-            let end_indent = min(
-                indent_level,
-                // Add tab_width - 1 to round up, since the first visible
-                // indent might be a bit after offset.col
-                offset.col + viewport.width as usize + (tab_width - 1),
-            ) / tab_width;
-
-            for i in starting_indent..end_indent {
-                let x = (viewport.x as usize + (i * tab_width) - offset.col) as u16;
-                let y = viewport.y + line;
-                debug_assert!(surface.in_bounds(x, y));
-                surface.set_string(x, y, &indent_guide_char, indent_guide_style);
-            }
-        };
-
-        'outer: for event in highlights {
-            match event {
-                HighlightEvent::HighlightStart(span) => {
-                    spans.push(span);
-                }
-                HighlightEvent::HighlightEnd => {
-                    spans.pop();
-                }
-                HighlightEvent::Source { start, end } => {
-                    let is_trailing_cursor = text.len_chars() < end;
-
-                    // `unwrap_or_else` part is for off-the-end indices of
-                    // the rope, to allow cursor highlighting at the end
-                    // of the rope.
-                    let text = text.get_slice(start..end).unwrap_or_else(|| " ".into());
-                    let style = spans
-                        .iter()
-                        .fold(text_style, |acc, span| acc.patch(theme.highlight(span.0)));
-
-                    let space = if whitespace.render.space() == WhitespaceRenderValue::All
-                        && !is_trailing_cursor
-                    {
-                        &space
-                    } else {
-                        " "
-                    };
-
-                    let nbsp = if whitespace.render.nbsp() == WhitespaceRenderValue::All
-                        && text.len_chars() < end
-                    {
-                        &nbsp
-                    } else {
-                        " "
-                    };
-
-                    use helix_core::graphemes::{grapheme_width, RopeGraphemes};
-
-                    for grapheme in RopeGraphemes::new(text) {
-                        let out_of_bounds = offset.col > visual_x
-                            || visual_x >= viewport.width as usize + offset.col;
-
-                        if LineEnding::from_rope_slice(&grapheme).is_some() {
-                            if !out_of_bounds {
-                                // we still want to render an empty cell with the style
-                                surface.set_string(
-                                    (viewport.x as usize + visual_x - offset.col) as u16,
-                                    viewport.y + line,
-                                    &newline,
-                                    style.patch(whitespace_style),
-                                );
-                            }
-
-                            draw_indent_guides(last_line_indent_level, line, surface);
-
-                            visual_x = 0;
-                            line += 1;
-                            is_in_indent_area = true;
-
-                            // TODO: with proper iter this shouldn't be necessary
-                            if line >= viewport.height {
-                                break 'outer;
-                            }
-                        } else {
-                            let grapheme = Cow::from(grapheme);
-                            let is_whitespace;
-
-                            let (display_grapheme, width) = if grapheme == "\t" {
-                                is_whitespace = true;
-                                // make sure we display tab as appropriate amount of spaces
-                                let visual_tab_width = tab_width - (visual_x % tab_width);
-                                let grapheme_tab_width =
-                                    helix_core::str_utils::char_to_byte_idx(&tab, visual_tab_width);
-
-                                (&tab[..grapheme_tab_width], visual_tab_width)
-                            } else if grapheme == " " {
-                                is_whitespace = true;
-                                (space, 1)
-                            } else if grapheme == "\u{00A0}" {
-                                is_whitespace = true;
-                                (nbsp, 1)
-                            } else {
-                                is_whitespace = false;
-                                // Cow will prevent allocations if span contained in a single slice
-                                // which should really be the majority case
-                                let width = grapheme_width(&grapheme);
-                                (grapheme.as_ref(), width)
-                            };
-
-                            let cut_off_start = offset.col.saturating_sub(visual_x);
-
-                            if !out_of_bounds {
-                                // if we're offscreen just keep going until we hit a new line
-                                surface.set_string(
-                                    (viewport.x as usize + visual_x - offset.col) as u16,
-                                    viewport.y + line,
-                                    display_grapheme,
-                                    if is_whitespace {
-                                        style.patch(whitespace_style)
-                                    } else {
-                                        style
-                                    },
-                                );
-                            } else if cut_off_start != 0 && cut_off_start < width {
-                                // partially on screen
-                                let rect = Rect::new(
-                                    viewport.x,
-                                    viewport.y + line,
-                                    (width - cut_off_start) as u16,
-                                    1,
-                                );
-                                surface.set_style(
-                                    rect,
-                                    if is_whitespace {
-                                        style.patch(whitespace_style)
-                                    } else {
-                                        style
-                                    },
-                                );
-                            }
-
-                            if is_in_indent_area && !(grapheme == " " || grapheme == "\t") {
-                                draw_indent_guides(visual_x, line, surface);
-                                is_in_indent_area = false;
-                                last_line_indent_level = visual_x;
-                            }
-
-                            visual_x = visual_x.saturating_add(width);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
     /// Render brace match, etc (meant for the focused view only)
-    pub fn render_focused_view_elements(
+    pub fn highlight_focused_view_elements(
         view: &View,
         doc: &Document,
-        viewport: Rect,
         theme: &Theme,
-        surface: &mut Surface,
-    ) {
+    ) -> Vec<(usize, std::ops::Range<usize>)> {
         // Highlight matching braces
         if let Some(syntax) = doc.syntax() {
             let text = doc.text().slice(..);
             use helix_core::match_brackets;
             let pos = doc.selection(view.id).primary().cursor(text);
 
-            let pos = match_brackets::find_matching_bracket(syntax, doc.text(), pos)
-                .and_then(|pos| view.screen_coords_at_pos(doc, text, pos));
-
-            if let Some(pos) = pos {
+            if let Some(pos) = match_brackets::find_matching_bracket(syntax, doc.text(), pos) {
                 // ensure col is on screen
-                if (pos.col as u16) < viewport.width + view.offset.col as u16
-                    && pos.col >= view.offset.col
-                {
-                    let style = theme.try_get("ui.cursor.match").unwrap_or_else(|| {
-                        Style::default()
-                            .add_modifier(Modifier::REVERSED)
-                            .add_modifier(Modifier::DIM)
-                    });
-
-                    surface[(viewport.x + pos.col as u16, viewport.y + pos.row as u16)]
-                        .set_style(style);
+                if let Some(highlight) = theme.find_scope_index_exact("ui.cursor.match") {
+                    return vec![(highlight, pos..pos + 1)];
                 }
             }
         }
+        Vec::new()
     }
 
     /// Render bufferline at the top
@@ -671,9 +532,6 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
         let mut x = viewport.x;
         let current_doc = view!(editor).doc;
 
-        use std::collections::HashMap;
-        let mut names_map: HashMap<&str, usize> = HashMap::new();
-
         for doc in editor.documents() {
             let fname = doc
                 .path()
@@ -683,24 +541,6 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
                 .to_str()
                 .unwrap_or_default();
 
-            *names_map.entry(fname).or_insert(0) += 1;
-        }
-
-        for doc in editor.documents() {
-            let mut fname = doc
-                .path()
-                .unwrap_or(&scratch)
-                .file_name()
-                .unwrap_or_default()
-                .to_str()
-                .unwrap_or_default();
-
-            let rel_path = doc.relative_path().unwrap_or_default();
-
-            if *names_map.get(fname).unwrap() > 1 {
-                fname = rel_path.to_str().unwrap_or_default();
-            }
-
             let style = if current_doc == doc.id() {
                 bufferline_active
             } else {
@@ -721,22 +561,17 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
         }
     }
 
-    pub fn render_gutter(
-        editor: &Editor,
-        doc: &Document,
+    pub fn render_gutter<'d>(
+        editor: &'d Editor,
+        doc: &'d Document,
         view: &View,
         viewport: Rect,
-        surface: &mut Surface,
         theme: &Theme,
         is_focused: bool,
+        line_decorations: &mut Vec<Box<(dyn LineDecoration + 'd)>>,
     ) {
         let text = doc.text().slice(..);
-        let last_line = view.last_line(doc);
-
-        // it's used inside an iterator so the collect isn't needless:
-        // https://github.com/rust-lang/rust-clippy/issues/6164
-        #[allow(clippy::needless_collect)]
-        let cursors: Vec<_> = doc
+        let cursors: Rc<[_]> = doc
             .selection(view.id)
             .iter()
             .map(|range| range.cursor_line(text))
@@ -746,29 +581,36 @@ pub fn render_gutter(
 
         let gutter_style = theme.get("ui.gutter");
         let gutter_selected_style = theme.get("ui.gutter.selected");
-
-        // avoid lots of small allocations by reusing a text buffer for each line
-        let mut text = String::with_capacity(8);
+        let gutter_style_virtual = theme.get("ui.gutter.virtual");
+        let gutter_selected_style_virtual = theme.get("ui.gutter.selected.virtual");
 
         for gutter_type in view.gutters() {
             let mut gutter = gutter_type.style(editor, doc, view, theme, is_focused);
             let width = gutter_type.width(view, doc);
-            text.reserve(width); // ensure there's enough space for the gutter
-            for (i, line) in (view.offset.row..(last_line + 1)).enumerate() {
-                let selected = cursors.contains(&line);
+            // avoid lots of small allocations by reusing a text buffer for each line
+            let mut text = String::with_capacity(width);
+            let cursors = cursors.clone();
+            let gutter_decoration = move |renderer: &mut TextRenderer, pos: LinePos| {
+                // TODO handle softwrap in gutters
+                let selected = cursors.contains(&pos.doc_line);
                 let x = viewport.x + offset;
-                let y = viewport.y + i as u16;
+                let y = viewport.y + pos.visual_line;
 
-                let gutter_style = if selected {
-                    gutter_selected_style
-                } else {
-                    gutter_style
+                let gutter_style = match (selected, pos.first_visual_line) {
+                    (false, true) => gutter_style,
+                    (true, true) => gutter_selected_style,
+                    (false, false) => gutter_style_virtual,
+                    (true, false) => gutter_selected_style_virtual,
                 };
 
-                if let Some(style) = gutter(line, selected, &mut text) {
-                    surface.set_stringn(x, y, &text, width, gutter_style.patch(style));
+                if let Some(style) =
+                    gutter(pos.doc_line, selected, pos.first_visual_line, &mut text)
+                {
+                    renderer
+                        .surface
+                        .set_stringn(x, y, &text, width, gutter_style.patch(style));
                 } else {
-                    surface.set_style(
+                    renderer.surface.set_style(
                         Rect {
                             x,
                             y,
@@ -779,7 +621,8 @@ pub fn render_gutter(
                     );
                 }
                 text.clear();
-            }
+            };
+            line_decorations.push(Box::new(gutter_decoration));
 
             offset += width as u16;
         }
@@ -826,6 +669,14 @@ pub fn render_diagnostics(
                 });
             let text = Text::styled(&diagnostic.message, style);
             lines.extend(text.lines);
+            let code = diagnostic.code.as_ref().map(|x| match x {
+                NumberOrString::Number(n) => format!("({n})"),
+                NumberOrString::String(s) => format!("({s})"),
+            });
+            if let Some(code) = code {
+                let span = Span::styled(code, style);
+                lines.push(span.into());
+            }
         }
 
         let paragraph = Paragraph::new(lines)
@@ -840,10 +691,13 @@ pub fn render_diagnostics(
     }
 
     /// Apply the highlighting on the lines where a cursor is active
-    pub fn highlight_cursorline(doc: &Document, view: &View, surface: &mut Surface, theme: &Theme) {
+    pub fn cursorline_decorator(
+        doc: &Document,
+        view: &View,
+        theme: &Theme,
+    ) -> Box<dyn LineDecoration> {
         let text = doc.text().slice(..);
-        let last_line = view.last_line(doc);
-
+        // TODO only highlight the visual line that contains the cursor instead of the full visual line
         let primary_line = doc.selection(view.id).primary().cursor_line(text);
 
         // The secondary_lines do contain the primary_line, it doesn't matter
@@ -860,20 +714,18 @@ pub fn highlight_cursorline(doc: &Document, view: &View, surface: &mut Surface,
 
         let primary_style = theme.get("ui.cursorline.primary");
         let secondary_style = theme.get("ui.cursorline.secondary");
-
-        for line in view.offset.row..(last_line + 1) {
-            let area = Rect::new(
-                view.area.x,
-                view.area.y + (line - view.offset.row) as u16,
-                view.area.width,
-                1,
-            );
-            if primary_line == line {
-                surface.set_style(area, primary_style);
-            } else if secondary_lines.binary_search(&line).is_ok() {
-                surface.set_style(area, secondary_style);
+        let viewport = view.area;
+
+        let line_decoration = move |renderer: &mut TextRenderer, pos: LinePos| {
+            let area = Rect::new(viewport.x, viewport.y + pos.visual_line, viewport.width, 1);
+            if primary_line == pos.doc_line {
+                renderer.surface.set_style(area, primary_style);
+            } else if secondary_lines.binary_search(&pos.doc_line).is_ok() {
+                renderer.surface.set_style(area, secondary_style);
             }
-        }
+        };
+
+        Box::new(line_decoration)
     }
 
     /// Apply the highlighting on the columns where a cursor is active
@@ -882,6 +734,8 @@ pub fn highlight_cursorcolumn(
         view: &View,
         surface: &mut Surface,
         theme: &Theme,
+        viewport: Rect,
+        text_annotations: &TextAnnotations,
     ) {
         let text = doc.text().slice(..);
 
@@ -897,19 +751,23 @@ pub fn highlight_cursorcolumn(
             .unwrap_or_else(|| theme.get("ui.cursorline.secondary"));
 
         let inner_area = view.inner_area(doc);
-        let offset = view.offset.col;
 
         let selection = doc.selection(view.id);
         let primary = selection.primary();
+        let text_format = doc.text_format(viewport.width, None);
         for range in selection.iter() {
             let is_primary = primary == *range;
+            let cursor = range.cursor(text);
+
+            let Position { col, .. } =
+                visual_offset_from_block(text, cursor, cursor, &text_format, text_annotations).0;
 
-            let Position { row: _, col } =
-                visual_coords_at_pos(text, range.cursor(text), doc.tab_width());
             // if the cursor is horizontally in the view
-            if col >= offset && inner_area.width > (col - offset) as u16 {
+            if col >= view.offset.horizontal_offset
+                && inner_area.width > (col - view.offset.horizontal_offset) as u16
+            {
                 let area = Rect::new(
-                    inner_area.x + (col - offset) as u16,
+                    inner_area.x + (col - view.offset.horizontal_offset) as u16,
                     view.area.y,
                     1,
                     view.area.height,
@@ -956,6 +814,7 @@ fn handle_keymap_event(
                 (Mode::Insert, Mode::Normal) => {
                     // if exiting insert mode, remove completion
                     self.completion = None;
+                    cxt.editor.completion_request_handle = None;
 
                     // TODO: Use an on_mode_change hook to remove signature help
                     cxt.jobs.callback(async {
@@ -1026,6 +885,8 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
                 for _ in 0..cxt.editor.count.map_or(1, NonZeroUsize::into) {
                     // first execute whatever put us into insert mode
                     self.last_insert.0.execute(cxt);
+                    let mut last_savepoint = None;
+                    let mut last_request_savepoint = None;
                     // then replay the inputs
                     for key in self.last_insert.1.clone() {
                         match key {
@@ -1033,7 +894,9 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
                             InsertEvent::CompletionApply(compl) => {
                                 let (view, doc) = current!(cxt.editor);
 
-                                doc.restore(view);
+                                if let Some(last_savepoint) = last_savepoint.as_deref() {
+                                    doc.restore(view, last_savepoint);
+                                }
 
                                 let text = doc.text().slice(..);
                                 let cursor = doc.selection(view.id).primary().cursor(text);
@@ -1047,11 +910,14 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
                                         (shift_position(start), shift_position(end), t)
                                     }),
                                 );
-                                apply_transaction(&tx, doc, view);
+                                doc.apply(&tx, view.id);
                             }
                             InsertEvent::TriggerCompletion => {
-                                let (_, doc) = current!(cxt.editor);
-                                doc.savepoint();
+                                last_savepoint = take(&mut last_request_savepoint);
+                            }
+                            InsertEvent::RequestCompletion => {
+                                let (view, doc) = current!(cxt.editor);
+                                last_request_savepoint = Some(doc.savepoint(view));
                             }
                         }
                     }
@@ -1076,44 +942,51 @@ fn command_mode(&mut self, mode: Mode, cxt: &mut commands::Context, event: KeyEv
         }
     }
 
+    #[allow(clippy::too_many_arguments)]
     pub fn set_completion(
         &mut self,
         editor: &mut Editor,
+        savepoint: Arc<SavePoint>,
         items: Vec<helix_lsp::lsp::CompletionItem>,
         offset_encoding: helix_lsp::OffsetEncoding,
         start_offset: usize,
         trigger_offset: usize,
         size: Rect,
-    ) {
-        let mut completion =
-            Completion::new(editor, items, offset_encoding, start_offset, trigger_offset);
+    ) -> Option<Rect> {
+        let mut completion = Completion::new(
+            editor,
+            savepoint,
+            items,
+            offset_encoding,
+            start_offset,
+            trigger_offset,
+        );
 
         if completion.is_empty() {
             // skip if we got no completion results
-            return;
+            return None;
         }
 
-        // Immediately initialize a savepoint
-        doc_mut!(editor).savepoint();
-
+        let area = completion.area(size, editor);
         editor.last_completion = None;
         self.last_insert.1.push(InsertEvent::TriggerCompletion);
 
         // TODO : propagate required size on resize to completion too
         completion.required_size((size.width, size.height));
         self.completion = Some(completion);
+        Some(area)
     }
 
     pub fn clear_completion(&mut self, editor: &mut Editor) {
         self.completion = None;
 
         // Clear any savepoints
-        let doc = doc_mut!(editor);
-        doc.savepoint = None;
         editor.clear_idle_timer(); // don't retrigger
     }
 
     pub fn handle_idle_timeout(&mut self, cx: &mut commands::Context) -> EventResult {
+        commands::compute_inlay_hints_for_all_views(cx.editor, cx.jobs);
+
         if let Some(completion) = &mut self.completion {
             return if completion.ensure_item_resolved(cx) {
                 EventResult::Consumed(None)
@@ -1138,6 +1011,10 @@ fn handle_mouse_event(
         event: &MouseEvent,
         cxt: &mut commands::Context,
     ) -> EventResult {
+        if event.kind != MouseEventKind::Moved {
+            cxt.editor.reset_idle_timer();
+        }
+
         let config = cxt.editor.config();
         let MouseEvent {
             kind,
@@ -1147,10 +1024,15 @@ fn handle_mouse_event(
             ..
         } = *event;
 
-        let pos_and_view = |editor: &Editor, row, column| {
+        let pos_and_view = |editor: &Editor, row, column, ignore_virtual_text| {
             editor.tree.views().find_map(|(view, _focus)| {
-                view.pos_at_screen_coords(&editor.documents[&view.doc], row, column)
-                    .map(|pos| (pos, view.id))
+                view.pos_at_screen_coords(
+                    &editor.documents[&view.doc],
+                    row,
+                    column,
+                    ignore_virtual_text,
+                )
+                .map(|pos| (pos, view.id))
             })
         };
 
@@ -1165,7 +1047,7 @@ fn handle_mouse_event(
             MouseEventKind::Down(MouseButton::Left) => {
                 let editor = &mut cxt.editor;
 
-                if let Some((pos, view_id)) = pos_and_view(editor, row, column) {
+                if let Some((pos, view_id)) = pos_and_view(editor, row, column, true) {
                     let doc = doc_mut!(editor, &view!(editor, view_id).doc);
 
                     if modifiers == KeyModifiers::ALT {
@@ -1176,6 +1058,7 @@ fn handle_mouse_event(
                     }
 
                     editor.focus(view_id);
+                    editor.ensure_cursor_in_view(view_id);
 
                     return EventResult::Consumed(None);
                 }
@@ -1190,8 +1073,10 @@ fn handle_mouse_event(
                         None => return EventResult::Ignored(None),
                     };
 
-                    let line = coords.row + view.offset.row;
-                    if line < doc.text().len_lines() {
+                    if let Some(char_idx) =
+                        view.pos_at_visual_coords(doc, coords.row as u16, coords.col as u16, true)
+                    {
+                        let line = doc.text().char_to_line(char_idx);
                         commands::dap_toggle_breakpoint_impl(cxt, path, line);
                         return EventResult::Consumed(None);
                     }
@@ -1203,7 +1088,7 @@ fn handle_mouse_event(
             MouseEventKind::Drag(MouseButton::Left) => {
                 let (view, doc) = current!(cxt.editor);
 
-                let pos = match view.pos_at_screen_coords(doc, row, column) {
+                let pos = match view.pos_at_screen_coords(doc, row, column, true) {
                     Some(pos) => pos,
                     None => return EventResult::Ignored(None),
                 };
@@ -1212,7 +1097,8 @@ fn handle_mouse_event(
                 let primary = selection.primary_mut();
                 *primary = primary.put_cursor(doc.text().slice(..), pos, true);
                 doc.set_selection(view.id, selection);
-
+                let view_id = view.id;
+                cxt.editor.ensure_cursor_in_view(view_id);
                 EventResult::Consumed(None)
             }
 
@@ -1225,7 +1111,7 @@ fn handle_mouse_event(
                     _ => unreachable!(),
                 };
 
-                match pos_and_view(cxt.editor, row, column) {
+                match pos_and_view(cxt.editor, row, column, false) {
                     Some((_, view_id)) => cxt.editor.tree.focus = view_id,
                     None => return EventResult::Ignored(None),
                 }
@@ -1234,6 +1120,7 @@ fn handle_mouse_event(
                 commands::scroll(cxt, offset, direction);
 
                 cxt.editor.tree.focus = current_view;
+                cxt.editor.ensure_cursor_in_view(current_view);
 
                 EventResult::Consumed(None)
             }
@@ -1265,8 +1152,9 @@ fn handle_mouse_event(
                     cxt.editor.focus(view_id);
 
                     let (view, doc) = current!(cxt.editor);
-                    let line = coords.row + view.offset.row;
-                    if let Ok(pos) = doc.text().try_line_to_char(line) {
+                    if let Some(pos) =
+                        view.pos_at_visual_coords(doc, coords.row as u16, coords.col as u16, true)
+                    {
                         doc.set_selection(view_id, Selection::point(pos));
                         if modifiers == KeyModifiers::ALT {
                             commands::MappableCommand::dap_edit_log.execute(cxt);
@@ -1294,7 +1182,7 @@ fn handle_mouse_event(
                     return EventResult::Consumed(None);
                 }
 
-                if let Some((pos, view_id)) = pos_and_view(editor, row, column) {
+                if let Some((pos, view_id)) = pos_and_view(editor, row, column, true) {
                     let doc = doc_mut!(editor, &view!(editor, view_id).doc);
                     doc.set_selection(view_id, Selection::point(pos));
                     cxt.editor.focus(view_id);
@@ -1370,13 +1258,15 @@ fn handle_event(
                             // let completion swallow the event if necessary
                             let mut consumed = false;
                             if let Some(completion) = &mut self.completion {
-                                // use a fake context here
-                                let mut cx = Context {
-                                    editor: cx.editor,
-                                    jobs: cx.jobs,
-                                    scroll: None,
+                                let res = {
+                                    // use a fake context here
+                                    let mut cx = Context {
+                                        editor: cx.editor,
+                                        jobs: cx.jobs,
+                                        scroll: None,
+                                    };
+                                    completion.handle_event(event, &mut cx)
                                 };
-                                let res = completion.handle_event(event, &mut cx);
 
                                 if let EventResult::Consumed(callback) = res {
                                     consumed = true;
@@ -1384,6 +1274,12 @@ fn handle_event(
                                     if callback.is_some() {
                                         // assume close_fn
                                         self.clear_completion(cx.editor);
+
+                                        // In case the popup was deleted because of an intersection w/ the auto-complete menu.
+                                        commands::signature_help_impl(
+                                            &mut cx,
+                                            commands::SignatureHelpInvoked::Automatic,
+                                        );
                                     }
                                 }
                             }
diff --git a/helix-term/src/ui/fuzzy_match.rs b/helix-term/src/ui/fuzzy_match.rs
index e25d73285..22dc3a7fa 100644
--- a/helix-term/src/ui/fuzzy_match.rs
+++ b/helix-term/src/ui/fuzzy_match.rs
@@ -4,71 +4,236 @@
 #[cfg(test)]
 mod test;
 
+struct QueryAtom {
+    kind: QueryAtomKind,
+    atom: String,
+    ignore_case: bool,
+    inverse: bool,
+}
+impl QueryAtom {
+    fn new(atom: &str) -> Option<QueryAtom> {
+        let mut atom = atom.to_string();
+        let inverse = atom.starts_with('!');
+        if inverse {
+            atom.remove(0);
+        }
+
+        let mut kind = match atom.chars().next() {
+            Some('^') => QueryAtomKind::Prefix,
+            Some('\'') => QueryAtomKind::Substring,
+            _ if inverse => QueryAtomKind::Substring,
+            _ => QueryAtomKind::Fuzzy,
+        };
+
+        if atom.starts_with(['^', '\'']) {
+            atom.remove(0);
+        }
+
+        if atom.is_empty() {
+            return None;
+        }
+
+        if atom.ends_with('$') && !atom.ends_with("\\$") {
+            atom.pop();
+            kind = if kind == QueryAtomKind::Prefix {
+                QueryAtomKind::Exact
+            } else {
+                QueryAtomKind::Postfix
+            }
+        }
+
+        Some(QueryAtom {
+            kind,
+            atom: atom.replace('\\', ""),
+            // not ideal but fuzzy_matches only knows ascii uppercase so more consistent
+            // to behave the same
+            ignore_case: kind != QueryAtomKind::Fuzzy
+                && atom.chars().all(|c| c.is_ascii_lowercase()),
+            inverse,
+        })
+    }
+
+    fn indices(&self, matcher: &Matcher, item: &str, indices: &mut Vec<usize>) -> bool {
+        // for inverse there are no indices to return
+        // just return whether we matched
+        if self.inverse {
+            return self.matches(matcher, item);
+        }
+        let buf;
+        let item = if self.ignore_case {
+            buf = item.to_ascii_lowercase();
+            &buf
+        } else {
+            item
+        };
+        let off = match self.kind {
+            QueryAtomKind::Fuzzy => {
+                if let Some((_, fuzzy_indices)) = matcher.fuzzy_indices(item, &self.atom) {
+                    indices.extend_from_slice(&fuzzy_indices);
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+            QueryAtomKind::Substring => {
+                if let Some(off) = item.find(&self.atom) {
+                    off
+                } else {
+                    return false;
+                }
+            }
+            QueryAtomKind::Prefix if item.starts_with(&self.atom) => 0,
+            QueryAtomKind::Postfix if item.ends_with(&self.atom) => item.len() - self.atom.len(),
+            QueryAtomKind::Exact if item == self.atom => 0,
+            _ => return false,
+        };
+
+        indices.extend(off..(off + self.atom.len()));
+        true
+    }
+
+    fn matches(&self, matcher: &Matcher, item: &str) -> bool {
+        let buf;
+        let item = if self.ignore_case {
+            buf = item.to_ascii_lowercase();
+            &buf
+        } else {
+            item
+        };
+        let mut res = match self.kind {
+            QueryAtomKind::Fuzzy => matcher.fuzzy_match(item, &self.atom).is_some(),
+            QueryAtomKind::Substring => item.contains(&self.atom),
+            QueryAtomKind::Prefix => item.starts_with(&self.atom),
+            QueryAtomKind::Postfix => item.ends_with(&self.atom),
+            QueryAtomKind::Exact => item == self.atom,
+        };
+        if self.inverse {
+            res = !res;
+        }
+        res
+    }
+}
+
+#[derive(Debug, PartialEq, Eq, Clone, Copy)]
+enum QueryAtomKind {
+    /// Item is a fuzzy match of this behaviour
+    ///
+    /// Usage: `foo`
+    Fuzzy,
+    /// Item contains query atom as a continuous substring
+    ///
+    /// Usage `'foo`
+    Substring,
+    /// Item starts with query atom
+    ///
+    /// Usage: `^foo`
+    Prefix,
+    /// Item ends with query atom
+    ///
+    /// Usage: `foo$`
+    Postfix,
+    /// Item is equal to query atom
+    ///
+    /// Usage `^foo$`
+    Exact,
+}
+
+#[derive(Default)]
 pub struct FuzzyQuery {
-    queries: Vec<String>,
+    first_fuzzy_atom: Option<String>,
+    query_atoms: Vec<QueryAtom>,
+}
+
+fn query_atoms(query: &str) -> impl Iterator<Item = &str> + '_ {
+    let mut saw_backslash = false;
+    query.split(move |c| {
+        saw_backslash = match c {
+            ' ' if !saw_backslash => return true,
+            '\\' => true,
+            _ => false,
+        };
+        false
+    })
 }
 
 impl FuzzyQuery {
+    pub fn refine(&self, query: &str, old_query: &str) -> (FuzzyQuery, bool) {
+        // TODO: we could be a lot smarter about this
+        let new_query = Self::new(query);
+        let mut is_refinement = query.starts_with(old_query);
+
+        // if the last atom is an inverse atom adding more text to it
+        // will actually increase the number of matches and we can not refine
+        // the matches.
+        if is_refinement && !self.query_atoms.is_empty() {
+            let last_idx = self.query_atoms.len() - 1;
+            if self.query_atoms[last_idx].inverse
+                && self.query_atoms[last_idx].atom != new_query.query_atoms[last_idx].atom
+            {
+                is_refinement = false;
+            }
+        }
+
+        (new_query, is_refinement)
+    }
+
     pub fn new(query: &str) -> FuzzyQuery {
-        let mut saw_backslash = false;
-        let queries = query
-            .split(|c| {
-                saw_backslash = match c {
-                    ' ' if !saw_backslash => return true,
-                    '\\' => true,
-                    _ => false,
-                };
-                false
-            })
-            .filter_map(|query| {
-                if query.is_empty() {
+        let mut first_fuzzy_query = None;
+        let query_atoms = query_atoms(query)
+            .filter_map(|atom| {
+                let atom = QueryAtom::new(atom)?;
+                if atom.kind == QueryAtomKind::Fuzzy && first_fuzzy_query.is_none() {
+                    first_fuzzy_query = Some(atom.atom);
                     None
                 } else {
-                    Some(query.replace("\\ ", " "))
+                    Some(atom)
                 }
             })
             .collect();
-        FuzzyQuery { queries }
+        FuzzyQuery {
+            first_fuzzy_atom: first_fuzzy_query,
+            query_atoms,
+        }
     }
 
     pub fn fuzzy_match(&self, item: &str, matcher: &Matcher) -> Option<i64> {
-        // use the rank of the first query for the rank, because merging ranks is not really possible
+        // use the rank of the first fuzzzy query for the rank, because merging ranks is not really possible
         // this behaviour matches fzf and skim
-        let score = matcher.fuzzy_match(item, self.queries.get(0)?)?;
+        let score = self
+            .first_fuzzy_atom
+            .as_ref()
+            .map_or(Some(0), |atom| matcher.fuzzy_match(item, atom))?;
         if self
-            .queries
+            .query_atoms
             .iter()
-            .any(|query| matcher.fuzzy_match(item, query).is_none())
+            .any(|atom| !atom.matches(matcher, item))
         {
             return None;
         }
         Some(score)
     }
 
-    pub fn fuzzy_indicies(&self, item: &str, matcher: &Matcher) -> Option<(i64, Vec<usize>)> {
-        if self.queries.len() == 1 {
-            return matcher.fuzzy_indices(item, &self.queries[0]);
-        }
-
-        // use the rank of the first query for the rank, because merging ranks is not really possible
-        // this behaviour matches fzf and skim
-        let (score, mut indicies) = matcher.fuzzy_indices(item, self.queries.get(0)?)?;
+    pub fn fuzzy_indices(&self, item: &str, matcher: &Matcher) -> Option<(i64, Vec<usize>)> {
+        let (score, mut indices) = self.first_fuzzy_atom.as_ref().map_or_else(
+            || Some((0, Vec::new())),
+            |atom| matcher.fuzzy_indices(item, atom),
+        )?;
 
-        // fast path for the common case of not using a space
-        // during matching this branch should be free thanks to branch prediction
-        if self.queries.len() == 1 {
-            return Some((score, indicies));
+        // fast path for the common case of just a single atom
+        if self.query_atoms.is_empty() {
+            return Some((score, indices));
         }
 
-        for query in &self.queries[1..] {
-            let (_, matched_indicies) = matcher.fuzzy_indices(item, query)?;
-            indicies.extend_from_slice(&matched_indicies);
+        for atom in &self.query_atoms {
+            if !atom.indices(matcher, item, &mut indices) {
+                return None;
+            }
         }
 
         // deadup and remove duplicate matches
-        indicies.sort_unstable();
-        indicies.dedup();
+        indices.sort_unstable();
+        indices.dedup();
 
-        Some((score, indicies))
+        Some((score, indices))
     }
 }
diff --git a/helix-term/src/ui/fuzzy_match/test.rs b/helix-term/src/ui/fuzzy_match/test.rs
index 3f90ef681..5df79eeb1 100644
--- a/helix-term/src/ui/fuzzy_match/test.rs
+++ b/helix-term/src/ui/fuzzy_match/test.rs
@@ -7,8 +7,8 @@ fn run_test<'a>(query: &str, items: &'a [&'a str]) -> Vec<String> {
     items
         .iter()
         .filter_map(|item| {
-            let (_, indicies) = query.fuzzy_indicies(item, &matcher)?;
-            let matched_string = indicies
+            let (_, indices) = query.fuzzy_indices(item, &matcher)?;
+            let matched_string = indices
                 .iter()
                 .map(|&pos| item.chars().nth(pos).unwrap())
                 .collect();
diff --git a/helix-term/src/ui/lsp.rs b/helix-term/src/ui/lsp.rs
index 393d24c46..44050aa12 100644
--- a/helix-term/src/ui/lsp.rs
+++ b/helix-term/src/ui/lsp.rs
@@ -53,7 +53,10 @@ fn render(&mut self, area: Rect, surface: &mut Buffer, cx: &mut Context) {
 
         let active_param_span = self.active_param_range.map(|(start, end)| {
             vec![(
-                cx.editor.theme.find_scope_index("ui.selection").unwrap(),
+                cx.editor
+                    .theme
+                    .find_scope_index_exact("ui.selection")
+                    .unwrap(),
                 start..end,
             )]
         });
diff --git a/helix-term/src/ui/markdown.rs b/helix-term/src/ui/markdown.rs
index 923dd73a1..87136992c 100644
--- a/helix-term/src/ui/markdown.rs
+++ b/helix-term/src/ui/markdown.rs
@@ -342,13 +342,10 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
 
     fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
         let padding = 2;
-        if padding >= viewport.1 || padding >= viewport.0 {
-            return None;
-        }
         let contents = self.parse(None);
 
         // TODO: account for tab width
-        let max_text_width = (viewport.0 - padding).min(120);
+        let max_text_width = (viewport.0.saturating_sub(padding)).min(120);
         let (width, height) = crate::ui::text::required_size(&contents, max_text_width);
 
         Some((width + padding, height + padding))
diff --git a/helix-term/src/ui/menu.rs b/helix-term/src/ui/menu.rs
index b9c1f9ded..bdad2e408 100644
--- a/helix-term/src/ui/menu.rs
+++ b/helix-term/src/ui/menu.rs
@@ -4,7 +4,7 @@
     compositor::{Callback, Component, Compositor, Context, Event, EventResult},
     ctrl, key, shift,
 };
-use tui::{buffer::Buffer as Surface, text::Spans, widgets::Table};
+use tui::{buffer::Buffer as Surface, widgets::Table};
 
 pub use tui::widgets::{Cell, Row};
 
@@ -18,28 +18,24 @@ pub trait Item {
     /// Additional editor state that is used for label calculation.
     type Data;
 
-    fn label(&self, data: &Self::Data) -> Spans;
+    fn format(&self, data: &Self::Data) -> Row;
 
     fn sort_text(&self, data: &Self::Data) -> Cow<str> {
-        let label: String = self.label(data).into();
+        let label: String = self.format(data).cell_text().collect();
         label.into()
     }
 
     fn filter_text(&self, data: &Self::Data) -> Cow<str> {
-        let label: String = self.label(data).into();
+        let label: String = self.format(data).cell_text().collect();
         label.into()
     }
-
-    fn row(&self, data: &Self::Data) -> Row {
-        Row::new(vec![Cell::from(self.label(data))])
-    }
 }
 
 impl Item for PathBuf {
     /// Root prefix to strip.
     type Data = PathBuf;
 
-    fn label(&self, root_path: &Self::Data) -> Spans {
+    fn format(&self, root_path: &Self::Data) -> Row {
         self.strip_prefix(root_path)
             .unwrap_or(self)
             .to_string_lossy()
@@ -47,6 +43,8 @@ fn label(&self, root_path: &Self::Data) -> Spans {
     }
 }
 
+pub type MenuCallback<T> = Box<dyn Fn(&mut Editor, Option<&T>, MenuEvent)>;
+
 pub struct Menu<T: Item> {
     options: Vec<T>,
     editor_data: T::Data,
@@ -59,7 +57,7 @@ pub struct Menu<T: Item> {
 
     widths: Vec<Constraint>,
 
-    callback_fn: Box<dyn Fn(&mut Editor, Option<&T>, MenuEvent)>,
+    callback_fn: MenuCallback<T>,
 
     scroll: usize,
     size: (u16, u16),
@@ -81,7 +79,7 @@ pub fn new(
         Self {
             options,
             editor_data,
-            matcher: Box::new(Matcher::default()),
+            matcher: Box::new(Matcher::default().ignore_case()),
             matches,
             cursor: None,
             widths: Vec::new(),
@@ -144,10 +142,10 @@ fn recalculate_size(&mut self, viewport: (u16, u16)) {
         let n = self
             .options
             .first()
-            .map(|option| option.row(&self.editor_data).cells.len())
+            .map(|option| option.format(&self.editor_data).cells.len())
             .unwrap_or_default();
         let max_lens = self.options.iter().fold(vec![0; n], |mut acc, option| {
-            let row = option.row(&self.editor_data);
+            let row = option.format(&self.editor_data);
             // maintain max for each column
             for (acc, cell) in acc.iter_mut().zip(row.cells.iter()) {
                 let width = cell.content.width();
@@ -256,12 +254,12 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
                 return EventResult::Consumed(close_fn);
             }
             // arrow up/ctrl-p/shift-tab prev completion choice (including updating the doc)
-            shift!(Tab) | key!(Up) | ctrl!('p') | ctrl!('k') => {
+            shift!(Tab) | key!(Up) | ctrl!('p') => {
                 self.move_up();
                 (self.callback_fn)(cx.editor, self.selection(), MenuEvent::Update);
                 return EventResult::Consumed(None);
             }
-            key!(Tab) | key!(Down) | ctrl!('n') | ctrl!('j') => {
+            key!(Tab) | key!(Down) | ctrl!('n') => {
                 // arrow down/ctrl-n/tab advances completion choice (including updating the doc)
                 self.move_down();
                 (self.callback_fn)(cx.editor, self.selection(), MenuEvent::Update);
@@ -331,7 +329,9 @@ const fn div_ceil(a: usize, b: usize) -> usize {
             (a + b - 1) / b
         }
 
-        let rows = options.iter().map(|option| option.row(&self.editor_data));
+        let rows = options
+            .iter()
+            .map(|option| option.format(&self.editor_data));
         let table = Table::new(rows)
             .style(style)
             .highlight_style(selected)
@@ -347,6 +347,7 @@ const fn div_ceil(a: usize, b: usize) -> usize {
                 offset: scroll,
                 selected: self.cursor,
             },
+            false,
         );
 
         if let Some(cursor) = self.cursor {
diff --git a/helix-term/src/ui/mod.rs b/helix-term/src/ui/mod.rs
index 107e48dd1..3e9a14b06 100644
--- a/helix-term/src/ui/mod.rs
+++ b/helix-term/src/ui/mod.rs
@@ -1,4 +1,5 @@
 mod completion;
+mod document;
 pub(crate) mod editor;
 mod fuzzy_match;
 mod info;
@@ -14,12 +15,13 @@
 mod text;
 
 use crate::compositor::{Component, Compositor};
+use crate::filter_picker_entry;
 use crate::job::{self, Callback};
 pub use completion::Completion;
 pub use editor::EditorView;
 pub use markdown::Markdown;
 pub use menu::Menu;
-pub use picker::{FileLocation, FilePicker, Picker};
+pub use picker::{DynamicPicker, FileLocation, FilePicker, Picker};
 pub use popup::Popup;
 pub use prompt::{Prompt, PromptEvent};
 pub use spinner::{ProgressSpinners, Spinner};
@@ -162,6 +164,9 @@ pub fn file_picker(root: PathBuf, config: &helix_view::editor::Config) -> FilePi
 
     let now = Instant::now();
 
+    let dedup_symlinks = config.file_picker.deduplicate_links;
+    let absolute_root = root.canonicalize().unwrap_or_else(|_| root.clone());
+
     let mut walk_builder = WalkBuilder::new(&root);
     walk_builder
         .hidden(config.file_picker.hidden)
@@ -172,10 +177,7 @@ pub fn file_picker(root: PathBuf, config: &helix_view::editor::Config) -> FilePi
         .git_global(config.file_picker.git_global)
         .git_exclude(config.file_picker.git_exclude)
         .max_depth(config.file_picker.max_depth)
-        // We always want to ignore the .git directory, otherwise if
-        // `ignore` is turned off above, we end up with a lot of noise
-        // in our picker.
-        .filter_entry(|entry| entry.file_name() != ".git");
+        .filter_entry(move |entry| filter_picker_entry(entry, &absolute_root, dedup_symlinks));
 
     // We want to exclude files that the editor can't handle yet
     let mut type_builder = TypesBuilder::new();
@@ -194,26 +196,24 @@ pub fn file_picker(root: PathBuf, config: &helix_view::editor::Config) -> FilePi
     // We want files along with their modification date for sorting
     let files = walk_builder.build().filter_map(|entry| {
         let entry = entry.ok()?;
-
         // This is faster than entry.path().is_dir() since it uses cached fs::Metadata fetched by ignore/walkdir
-        let is_dir = entry.file_type().map_or(false, |ft| ft.is_dir());
-        if is_dir {
-            // Will give a false positive if metadata cannot be read (eg. permission error)
-            None
-        } else {
+        if entry.file_type()?.is_file() {
             Some(entry.into_path())
+        } else {
+            None
         }
     });
 
     // Cap the number of files if we aren't in a git project, preventing
     // hangs when using the picker in your home directory
-    let files: Vec<_> = if root.join(".git").exists() {
+    let mut files: Vec<PathBuf> = if root.join(".git").exists() {
         files.collect()
     } else {
         // const MAX: usize = 8192;
         const MAX: usize = 100_000;
         files.take(MAX).collect()
     };
+    files.sort();
 
     log::debug!("file_picker init {:?}", Instant::now().duration_since(now));
 
@@ -280,10 +280,10 @@ pub fn buffer(editor: &Editor, input: &str) -> Vec<Completion> {
     }
 
     pub fn theme(_editor: &Editor, input: &str) -> Vec<Completion> {
-        let mut names = theme::Loader::read_names(&helix_loader::runtime_dir().join("themes"));
-        names.extend(theme::Loader::read_names(
-            &helix_loader::config_dir().join("themes"),
-        ));
+        let mut names = theme::Loader::read_names(&helix_loader::config_dir().join("themes"));
+        for rt_dir in helix_loader::runtime_dirs() {
+            names.extend(theme::Loader::read_names(&rt_dir.join("themes")));
+        }
         names.push("default".into());
         names.push("base16_default".into());
         names.sort();
@@ -462,20 +462,30 @@ fn filename_impl<F>(_editor: &Editor, input: &str, filter_fn: F) -> Vec<Completi
         use ignore::WalkBuilder;
         use std::path::Path;
 
-        let is_tilde = input.starts_with('~') && input.len() == 1;
+        let is_tilde = input == "~";
         let path = helix_core::path::expand_tilde(Path::new(input));
 
         let (dir, file_name) = if input.ends_with(std::path::MAIN_SEPARATOR) {
             (path, None)
         } else {
-            let file_name = path
-                .file_name()
-                .and_then(|file| file.to_str().map(|path| path.to_owned()));
-
-            let path = match path.parent() {
-                Some(path) if !path.as_os_str().is_empty() => path.to_path_buf(),
-                // Path::new("h")'s parent is Some("")...
-                _ => std::env::current_dir().expect("couldn't determine current directory"),
+            let is_period = (input.ends_with((format!("{}.", std::path::MAIN_SEPARATOR)).as_str())
+                && input.len() > 2)
+                || input == ".";
+            let file_name = if is_period {
+                Some(String::from("."))
+            } else {
+                path.file_name()
+                    .and_then(|file| file.to_str().map(|path| path.to_owned()))
+            };
+
+            let path = if is_period {
+                path
+            } else {
+                match path.parent() {
+                    Some(path) if !path.as_os_str().is_empty() => path.to_path_buf(),
+                    // Path::new("h")'s parent is Some("")...
+                    _ => std::env::current_dir().expect("couldn't determine current directory"),
+                }
             };
 
             (path, file_name)
diff --git a/helix-term/src/ui/overlay.rs b/helix-term/src/ui/overlay.rs
index 0b8a93ae8..ff184d407 100644
--- a/helix-term/src/ui/overlay.rs
+++ b/helix-term/src/ui/overlay.rs
@@ -16,7 +16,7 @@ pub struct Overlay<T> {
 }
 
 /// Surrounds the component with a margin of 5% on each side, and an additional 2 rows at the bottom
-pub fn overlayed<T>(content: T) -> Overlay<T> {
+pub fn overlaid<T>(content: T) -> Overlay<T> {
     Overlay {
         content,
         calc_child_size: Box::new(|rect: Rect| clip_rect_relative(rect.clip_bottom(2), 90, 90)),
@@ -69,4 +69,8 @@ fn cursor(&self, area: Rect, ctx: &Editor) -> (Option<Position>, CursorKind) {
         let dimensions = (self.calc_child_size)(area);
         self.content.cursor(dimensions, ctx)
     }
+
+    fn id(&self) -> Option<&'static str> {
+        self.content.id()
+    }
 }
diff --git a/helix-term/src/ui/picker.rs b/helix-term/src/ui/picker.rs
index 5e9ca3d88..e7a7de909 100644
--- a/helix-term/src/ui/picker.rs
+++ b/helix-term/src/ui/picker.rs
@@ -1,28 +1,42 @@
 use crate::{
+    alt,
     compositor::{Component, Compositor, Context, Event, EventResult},
     ctrl, key, shift,
-    ui::{self, fuzzy_match::FuzzyQuery, EditorView},
+    ui::{
+        self,
+        document::{render_document, LineDecoration, LinePos, TextRenderer},
+        fuzzy_match::FuzzyQuery,
+        EditorView,
+    },
 };
+use futures_util::future::BoxFuture;
 use tui::{
     buffer::Buffer as Surface,
-    widgets::{Block, BorderType, Borders},
+    layout::Constraint,
+    text::{Span, Spans},
+    widgets::{Block, BorderType, Borders, Cell, Table},
 };
 
 use fuzzy_matcher::skim::SkimMatcherV2 as Matcher;
 use tui::widgets::Widget;
 
-use std::{cmp::Ordering, time::Instant};
+use std::cmp::{self, Ordering};
 use std::{collections::HashMap, io::Read, path::PathBuf};
 
 use crate::ui::{Prompt, PromptEvent};
-use helix_core::{movement::Direction, Position};
+use helix_core::{
+    movement::Direction, text_annotations::TextAnnotations,
+    unicode::segmentation::UnicodeSegmentation, Position,
+};
 use helix_view::{
     editor::Action,
     graphics::{CursorKind, Margin, Modifier, Rect},
+    theme::Style,
+    view::ViewPosition,
     Document, DocumentId, Editor,
 };
 
-use super::menu::Item;
+use super::{menu::Item, overlay::Overlay};
 
 pub const MIN_AREA_WIDTH_FOR_PREVIEW: u16 = 72;
 /// Biggest file size to preview in bytes
@@ -56,6 +70,8 @@ fn from(v: DocumentId) -> Self {
     }
 }
 
+type FileCallback<T> = Box<dyn Fn(&Editor, &T) -> Option<FileLocation>>;
+
 /// File path and range of lines (used to align and highlight lines)
 pub type FileLocation = (PathOrId, Option<(usize, usize)>);
 
@@ -66,7 +82,7 @@ pub struct FilePicker<T: Item> {
     preview_cache: HashMap<PathBuf, CachedPreview>,
     read_buffer: Vec<u8>,
     /// Given an item in the picker, return the file path and line number to display.
-    file_fn: Box<dyn Fn(&Editor, &T) -> Option<FileLocation>>,
+    file_fn: FileCallback<T>,
 }
 
 pub enum CachedPreview {
@@ -174,7 +190,7 @@ fn get_preview<'picker, 'editor>(
                             }
                             _ => {
                                 // TODO: enable syntax highlighting; blocked by async rendering
-                                Document::open(path, None, None)
+                                Document::open(path, None, None, editor.config.clone())
                                     .map(|doc| CachedPreview::Document(Box::new(doc)))
                                     .unwrap_or(CachedPreview::NotFound)
                             }
@@ -209,6 +225,9 @@ fn handle_idle_timeout(&mut self, cx: &mut Context) -> EventResult {
                 let loader = cx.editor.syn_loader.clone();
                 doc.detect_language(loader);
             }
+
+            // QUESTION: do we want to compute inlay hints in pickers too ? Probably not for now
+            // but it could be interesting in the future
         }
 
         EventResult::Consumed(None)
@@ -278,43 +297,58 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
                 })
                 .unwrap_or(0);
 
-            let offset = Position::new(first_line, 0);
+            let offset = ViewPosition {
+                anchor: doc.text().line_to_char(first_line),
+                horizontal_offset: 0,
+                vertical_offset: 0,
+            };
 
-            let mut highlights =
-                EditorView::doc_syntax_highlights(doc, offset, area.height, &cx.editor.theme);
+            let mut highlights = EditorView::doc_syntax_highlights(
+                doc,
+                offset.anchor,
+                area.height,
+                &cx.editor.theme,
+            );
             for spans in EditorView::doc_diagnostics_highlights(doc, &cx.editor.theme) {
                 if spans.is_empty() {
                     continue;
                 }
                 highlights = Box::new(helix_core::syntax::merge(highlights, spans));
             }
-            EditorView::render_text_highlights(
+            let mut decorations: Vec<Box<dyn LineDecoration>> = Vec::new();
+
+            if let Some((start, end)) = range {
+                let style = cx
+                    .editor
+                    .theme
+                    .try_get("ui.highlight")
+                    .unwrap_or_else(|| cx.editor.theme.get("ui.selection"));
+                let draw_highlight = move |renderer: &mut TextRenderer, pos: LinePos| {
+                    if (start..=end).contains(&pos.doc_line) {
+                        let area = Rect::new(
+                            renderer.viewport.x,
+                            renderer.viewport.y + pos.visual_line,
+                            renderer.viewport.width,
+                            1,
+                        );
+                        renderer.surface.set_style(area, style)
+                    }
+                };
+                decorations.push(Box::new(draw_highlight))
+            }
+
+            render_document(
+                surface,
+                inner,
                 doc,
                 offset,
-                inner,
-                surface,
-                &cx.editor.theme,
+                // TODO: compute text annotations asynchronously here (like inlay hints)
+                &TextAnnotations::default(),
                 highlights,
-                &cx.editor.config(),
+                &cx.editor.theme,
+                &mut decorations,
+                &mut [],
             );
-
-            // highlight the line
-            if let Some((start, end)) = range {
-                let offset = start.saturating_sub(first_line) as u16;
-                surface.set_style(
-                    Rect::new(
-                        inner.x,
-                        inner.y + offset,
-                        inner.width,
-                        (end.saturating_sub(start) as u16 + 1)
-                            .min(inner.height.saturating_sub(offset)),
-                    ),
-                    cx.editor
-                        .theme
-                        .try_get("ui.highlight")
-                        .unwrap_or_else(|| cx.editor.theme.get("ui.selection")),
-                );
-            }
         }
     }
 
@@ -343,11 +377,17 @@ fn required_size(&mut self, (width, height): (u16, u16)) -> Option<(u16, u16)> {
 
 #[derive(PartialEq, Eq, Debug)]
 struct PickerMatch {
-    index: usize,
     score: i64,
+    index: usize,
     len: usize,
 }
 
+impl PickerMatch {
+    fn key(&self) -> impl Ord {
+        (cmp::Reverse(self.score), self.len, self.index)
+    }
+}
+
 impl PartialOrd for PickerMatch {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
         Some(self.cmp(other))
@@ -356,13 +396,12 @@ fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
 
 impl Ord for PickerMatch {
     fn cmp(&self, other: &Self) -> Ordering {
-        self.score
-            .cmp(&other.score)
-            .reverse()
-            .then_with(|| self.len.cmp(&other.len))
+        self.key().cmp(&other.key())
     }
 }
 
+type PickerCallback<T> = Box<dyn Fn(&mut Context, &T, Action)>;
+
 pub struct Picker<T: Item> {
     options: Vec<T>,
     editor_data: T::Data,
@@ -376,13 +415,15 @@ pub struct Picker<T: Item> {
     cursor: usize,
     // pattern: String,
     prompt: Prompt,
-    previous_pattern: String,
+    previous_pattern: (String, FuzzyQuery),
     /// Whether to truncate the start (default true)
     pub truncate_start: bool,
     /// Whether to show the preview panel (default true)
     show_preview: bool,
+    /// Constraints for tabular formatting
+    widths: Vec<Constraint>,
 
-    callback_fn: Box<dyn Fn(&mut Context, &T, Action)>,
+    callback_fn: PickerCallback<T>,
 }
 
 impl<T: Item> Picker<T> {
@@ -401,18 +442,21 @@ pub fn new(
         let mut picker = Self {
             options,
             editor_data,
-            matcher: Box::new(Matcher::default()),
+            matcher: Box::default(),
             matches: Vec::new(),
             cursor: 0,
             prompt,
-            previous_pattern: String::new(),
+            previous_pattern: (String::new(), FuzzyQuery::default()),
             truncate_start: true,
             show_preview: true,
             callback_fn: Box::new(callback_fn),
             completion_height: 0,
+            widths: Vec::new(),
         };
 
-        // scoring on empty input:
+        picker.calculate_column_widths();
+
+        // scoring on empty input
         // TODO: just reuse score()
         picker
             .matches
@@ -428,15 +472,50 @@ pub fn new(
         picker
     }
 
-    pub fn score(&mut self) {
-        let now = Instant::now();
+    pub fn set_options(&mut self, new_options: Vec<T>) {
+        self.options = new_options;
+        self.cursor = 0;
+        self.force_score();
+        self.calculate_column_widths();
+    }
 
+    /// Calculate the width constraints using the maximum widths of each column
+    /// for the current options.
+    fn calculate_column_widths(&mut self) {
+        let n = self
+            .options
+            .first()
+            .map(|option| option.format(&self.editor_data).cells.len())
+            .unwrap_or_default();
+        let max_lens = self.options.iter().fold(vec![0; n], |mut acc, option| {
+            let row = option.format(&self.editor_data);
+            // maintain max for each column
+            for (acc, cell) in acc.iter_mut().zip(row.cells.iter()) {
+                let width = cell.content.width();
+                if width > *acc {
+                    *acc = width;
+                }
+            }
+            acc
+        });
+        self.widths = max_lens
+            .into_iter()
+            .map(|len| Constraint::Length(len as u16))
+            .collect();
+    }
+
+    pub fn score(&mut self) {
         let pattern = self.prompt.line();
 
-        if pattern == &self.previous_pattern {
+        if pattern == &self.previous_pattern.0 {
             return;
         }
 
+        let (query, is_refined) = self
+            .previous_pattern
+            .1
+            .refine(pattern, &self.previous_pattern.0);
+
         if pattern.is_empty() {
             // Fast path for no pattern.
             self.matches.clear();
@@ -449,8 +528,7 @@ pub fn score(&mut self) {
                         len: text.chars().count(),
                     }
                 }));
-        } else if pattern.starts_with(&self.previous_pattern) {
-            let query = FuzzyQuery::new(pattern);
+        } else if is_refined {
             // optimization: if the pattern is a more specific version of the previous one
             // then we can score the filtered set.
             self.matches.retain_mut(|pmatch| {
@@ -469,32 +547,39 @@ pub fn score(&mut self) {
 
             self.matches.sort_unstable();
         } else {
-            let query = FuzzyQuery::new(pattern);
-            self.matches.clear();
-            self.matches.extend(
-                self.options
-                    .iter()
-                    .enumerate()
-                    .filter_map(|(index, option)| {
-                        let text = option.filter_text(&self.editor_data);
-
-                        query
-                            .fuzzy_match(&text, &self.matcher)
-                            .map(|score| PickerMatch {
-                                index,
-                                score,
-                                len: text.chars().count(),
-                            })
-                    }),
-            );
-            self.matches.sort_unstable();
+            self.force_score();
         }
 
-        log::debug!("picker score {:?}", Instant::now().duration_since(now));
-
         // reset cursor position
         self.cursor = 0;
-        self.previous_pattern.clone_from(pattern);
+        let pattern = self.prompt.line();
+        self.previous_pattern.0.clone_from(pattern);
+        self.previous_pattern.1 = query;
+    }
+
+    pub fn force_score(&mut self) {
+        let pattern = self.prompt.line();
+
+        let query = FuzzyQuery::new(pattern);
+        self.matches.clear();
+        self.matches.extend(
+            self.options
+                .iter()
+                .enumerate()
+                .filter_map(|(index, option)| {
+                    let text = option.filter_text(&self.editor_data);
+
+                    query
+                        .fuzzy_match(&text, &self.matcher)
+                        .map(|score| PickerMatch {
+                            index,
+                            score,
+                            len: text.chars().count(),
+                        })
+                }),
+        );
+
+        self.matches.sort_unstable();
     }
 
     /// Move the cursor by a number of lines, either down (`Forward`) or up (`Backward`)
@@ -604,6 +689,11 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
             key!(Esc) | ctrl!('c') => {
                 return close_fn;
             }
+            alt!(Enter) => {
+                if let Some(option) = self.selection() {
+                    (self.callback_fn)(cx, option, Action::Load);
+                }
+            }
             key!(Enter) => {
                 if let Some(option) = self.selection() {
                     (self.callback_fn)(cx, option, Action::Replace);
@@ -636,7 +726,7 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
     fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         let text_style = cx.editor.theme.get("ui.text");
         let selected = cx.editor.theme.get("ui.text.focus");
-        let highlighted = cx.editor.theme.get("special").add_modifier(Modifier::BOLD);
+        let highlight_style = cx.editor.theme.get("special").add_modifier(Modifier::BOLD);
 
         // -- Render the frame:
         // clear area
@@ -676,61 +766,127 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         }
 
         // -- Render the contents:
-        // subtract area of prompt from top and current item marker " > " from left
-        let inner = inner.clip_top(2).clip_left(3);
+        // subtract area of prompt from top
+        let inner = inner.clip_top(2);
 
         let rows = inner.height;
         let offset = self.cursor - (self.cursor % std::cmp::max(1, rows as usize));
+        let cursor = self.cursor.saturating_sub(offset);
 
-        let files = self
+        let options = self
             .matches
             .iter()
             .skip(offset)
-            .map(|pmatch| (pmatch.index, self.options.get(pmatch.index).unwrap()));
-
-        for (i, (_index, option)) in files.take(rows as usize).enumerate() {
-            let is_active = i == (self.cursor - offset);
-            if is_active {
-                surface.set_string(
-                    inner.x.saturating_sub(3),
-                    inner.y + i as u16,
-                    " > ",
-                    selected,
-                );
-                surface.set_style(
-                    Rect::new(inner.x, inner.y + i as u16, inner.width, 1),
-                    selected,
-                );
-            }
+            .take(rows as usize)
+            .map(|pmatch| &self.options[pmatch.index])
+            .map(|option| option.format(&self.editor_data))
+            .map(|mut row| {
+                const TEMP_CELL_SEP: &str = " ";
+
+                let line = row.cell_text().fold(String::new(), |mut s, frag| {
+                    s.push_str(&frag);
+                    s.push_str(TEMP_CELL_SEP);
+                    s
+                });
+
+                // Items are filtered by using the text returned by menu::Item::filter_text
+                // but we do highlighting here using the text in Row and therefore there
+                // might be inconsistencies. This is the best we can do since only the
+                // text in Row is displayed to the end user.
+                let (_score, highlights) = FuzzyQuery::new(self.prompt.line())
+                    .fuzzy_indices(&line, &self.matcher)
+                    .unwrap_or_default();
 
-            let spans = option.label(&self.editor_data);
-            let (_score, highlights) = FuzzyQuery::new(self.prompt.line())
-                .fuzzy_indicies(&String::from(&spans), &self.matcher)
-                .unwrap_or_default();
-
-            spans.0.into_iter().fold(inner, |pos, span| {
-                let new_x = surface
-                    .set_string_truncated(
-                        pos.x,
-                        pos.y + i as u16,
-                        &span.content,
-                        pos.width as usize,
-                        |idx| {
-                            if highlights.contains(&idx) {
-                                highlighted.patch(span.style)
-                            } else if is_active {
-                                selected.patch(span.style)
+                let highlight_byte_ranges: Vec<_> = line
+                    .char_indices()
+                    .enumerate()
+                    .filter_map(|(char_idx, (byte_offset, ch))| {
+                        highlights
+                            .contains(&char_idx)
+                            .then(|| byte_offset..byte_offset + ch.len_utf8())
+                    })
+                    .collect();
+
+                // The starting byte index of the current (iterating) cell
+                let mut cell_start_byte_offset = 0;
+                for cell in row.cells.iter_mut() {
+                    let spans = match cell.content.lines.get(0) {
+                        Some(s) => s,
+                        None => {
+                            cell_start_byte_offset += TEMP_CELL_SEP.len();
+                            continue;
+                        }
+                    };
+
+                    let mut cell_len = 0;
+
+                    let graphemes_with_style: Vec<_> = spans
+                        .0
+                        .iter()
+                        .flat_map(|span| {
+                            span.content
+                                .grapheme_indices(true)
+                                .zip(std::iter::repeat(span.style))
+                        })
+                        .map(|((grapheme_byte_offset, grapheme), style)| {
+                            cell_len += grapheme.len();
+                            let start = cell_start_byte_offset;
+
+                            let grapheme_byte_range =
+                                grapheme_byte_offset..grapheme_byte_offset + grapheme.len();
+
+                            if highlight_byte_ranges.iter().any(|hl_rng| {
+                                hl_rng.start >= start + grapheme_byte_range.start
+                                    && hl_rng.end <= start + grapheme_byte_range.end
+                            }) {
+                                (grapheme, style.patch(highlight_style))
                             } else {
-                                text_style.patch(span.style)
+                                (grapheme, style)
                             }
-                        },
-                        true,
-                        self.truncate_start,
-                    )
-                    .0;
-                pos.clip_left(new_x - pos.x)
+                        })
+                        .collect();
+
+                    let mut span_list: Vec<(String, Style)> = Vec::new();
+                    for (grapheme, style) in graphemes_with_style {
+                        if span_list.last().map(|(_, sty)| sty) == Some(&style) {
+                            let (string, _) = span_list.last_mut().unwrap();
+                            string.push_str(grapheme);
+                        } else {
+                            span_list.push((String::from(grapheme), style))
+                        }
+                    }
+
+                    let spans: Vec<Span> = span_list
+                        .into_iter()
+                        .map(|(string, style)| Span::styled(string, style))
+                        .collect();
+                    let spans: Spans = spans.into();
+                    *cell = Cell::from(spans);
+
+                    cell_start_byte_offset += cell_len + TEMP_CELL_SEP.len();
+                }
+
+                row
             });
-        }
+
+        let table = Table::new(options)
+            .style(text_style)
+            .highlight_style(selected)
+            .highlight_symbol(" > ")
+            .column_spacing(1)
+            .widths(&self.widths);
+
+        use tui::widgets::TableState;
+
+        table.render_table(
+            inner,
+            surface,
+            &mut TableState {
+                offset: 0,
+                selected: Some(cursor),
+            },
+            self.truncate_start,
+        );
     }
 
     fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind) {
@@ -744,3 +900,76 @@ fn cursor(&self, area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
         self.prompt.cursor(area, editor)
     }
 }
+
+/// Returns a new list of options to replace the contents of the picker
+/// when called with the current picker query,
+pub type DynQueryCallback<T> =
+    Box<dyn Fn(String, &mut Editor) -> BoxFuture<'static, anyhow::Result<Vec<T>>>>;
+
+/// A picker that updates its contents via a callback whenever the
+/// query string changes. Useful for live grep, workspace symbols, etc.
+pub struct DynamicPicker<T: ui::menu::Item + Send> {
+    file_picker: FilePicker<T>,
+    query_callback: DynQueryCallback<T>,
+    query: String,
+}
+
+impl<T: ui::menu::Item + Send> DynamicPicker<T> {
+    pub const ID: &'static str = "dynamic-picker";
+
+    pub fn new(file_picker: FilePicker<T>, query_callback: DynQueryCallback<T>) -> Self {
+        Self {
+            file_picker,
+            query_callback,
+            query: String::new(),
+        }
+    }
+}
+
+impl<T: Item + Send + 'static> Component for DynamicPicker<T> {
+    fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
+        self.file_picker.render(area, surface, cx);
+    }
+
+    fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
+        let event_result = self.file_picker.handle_event(event, cx);
+        let current_query = self.file_picker.picker.prompt.line();
+
+        if !matches!(event, Event::IdleTimeout) || self.query == *current_query {
+            return event_result;
+        }
+
+        self.query.clone_from(current_query);
+
+        let new_options = (self.query_callback)(current_query.to_owned(), cx.editor);
+
+        cx.jobs.callback(async move {
+            let new_options = new_options.await?;
+            let callback =
+                crate::job::Callback::EditorCompositor(Box::new(move |editor, compositor| {
+                    // Wrapping of pickers in overlay is done outside the picker code,
+                    // so this is fragile and will break if wrapped in some other widget.
+                    let picker = match compositor.find_id::<Overlay<DynamicPicker<T>>>(Self::ID) {
+                        Some(overlay) => &mut overlay.content.file_picker.picker,
+                        None => return,
+                    };
+                    picker.set_options(new_options);
+                    editor.reset_idle_timer();
+                }));
+            anyhow::Ok(callback)
+        });
+        EventResult::Consumed(None)
+    }
+
+    fn cursor(&self, area: Rect, ctx: &Editor) -> (Option<Position>, CursorKind) {
+        self.file_picker.cursor(area, ctx)
+    }
+
+    fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
+        self.file_picker.required_size(viewport)
+    }
+
+    fn id(&self) -> Option<&'static str> {
+        Some(Self::ID)
+    }
+}
diff --git a/helix-term/src/ui/popup.rs b/helix-term/src/ui/popup.rs
index 62a6785a4..dff7b2319 100644
--- a/helix-term/src/ui/popup.rs
+++ b/helix-term/src/ui/popup.rs
@@ -6,7 +6,10 @@
 use tui::buffer::Buffer as Surface;
 
 use helix_core::Position;
-use helix_view::graphics::{Margin, Rect};
+use helix_view::{
+    graphics::{Margin, Rect},
+    Editor,
+};
 
 // TODO: share logic with Menu, it's essentially Popup(render_fn), but render fn needs to return
 // a width/height hint. maybe Popup(Box<Component>)
@@ -42,6 +45,10 @@ pub fn new(id: &'static str, contents: T) -> Self {
         }
     }
 
+    /// Set the anchor position next to which the popup should be drawn.
+    ///
+    /// Note that this is not the position of the top-left corner of the rendered popup itself,
+    /// but rather the screen-space position of the information to which the popup refers.
     pub fn position(mut self, pos: Option<Position>) -> Self {
         self.position = pos;
         self
@@ -51,6 +58,10 @@ pub fn get_position(&self) -> Option<Position> {
         self.position
     }
 
+    /// Set the popup to prefer to render above or below the anchor position.
+    ///
+    /// This preference will be ignored if the viewport doesn't have enough space in the
+    /// chosen direction.
     pub fn position_bias(mut self, bias: Open) -> Self {
         self.position_bias = bias;
         self
@@ -78,10 +89,12 @@ pub fn ignore_escape_key(mut self, ignore: bool) -> Self {
         self
     }
 
-    pub fn get_rel_position(&mut self, viewport: Rect, cx: &Context) -> (u16, u16) {
+    /// Calculate the position where the popup should be rendered and return the coordinates of the
+    /// top left corner.
+    pub fn get_rel_position(&mut self, viewport: Rect, editor: &Editor) -> (u16, u16) {
         let position = self
             .position
-            .get_or_insert_with(|| cx.editor.cursor().0.unwrap_or_default());
+            .get_or_insert_with(|| editor.cursor().0.unwrap_or_default());
 
         let (width, height) = self.size;
 
@@ -145,6 +158,16 @@ pub fn contents(&self) -> &T {
     pub fn contents_mut(&mut self) -> &mut T {
         &mut self.contents
     }
+
+    pub fn area(&mut self, viewport: Rect, editor: &Editor) -> Rect {
+        // trigger required_size so we recalculate if the child changed
+        self.required_size((viewport.width, viewport.height));
+
+        let (rel_x, rel_y) = self.get_rel_position(viewport, editor);
+
+        // clip to viewport
+        viewport.intersection(Rect::new(rel_x, rel_y, self.size.0, self.size.1))
+    }
 }
 
 impl<T: Component> Component for Popup<T> {
@@ -222,16 +245,9 @@ fn required_size(&mut self, viewport: (u16, u16)) -> Option<(u16, u16)> {
     }
 
     fn render(&mut self, viewport: Rect, surface: &mut Surface, cx: &mut Context) {
-        // trigger required_size so we recalculate if the child changed
-        self.required_size((viewport.width, viewport.height));
-
+        let area = self.area(viewport, cx.editor);
         cx.scroll = Some(self.scroll);
 
-        let (rel_x, rel_y) = self.get_rel_position(viewport, cx);
-
-        // clip to viewport
-        let area = viewport.intersection(Rect::new(rel_x, rel_y, self.size.0, self.size.1));
-
         // clear area
         let background = cx.editor.theme.get("ui.popup");
         surface.clear_with(area, background);
diff --git a/helix-term/src/ui/prompt.rs b/helix-term/src/ui/prompt.rs
index b19b9a9fc..35ae8c2a8 100644
--- a/helix-term/src/ui/prompt.rs
+++ b/helix-term/src/ui/prompt.rs
@@ -14,8 +14,11 @@
     Editor,
 };
 
-pub type Completion = (RangeFrom<usize>, Cow<'static, str>);
 type PromptCharHandler = Box<dyn Fn(&mut Prompt, char, &Context)>;
+pub type Completion = (RangeFrom<usize>, Cow<'static, str>);
+type CompletionFn = Box<dyn FnMut(&Editor, &str) -> Vec<Completion>>;
+type CallbackFn = Box<dyn FnMut(&mut Context, &str, PromptEvent)>;
+pub type DocFn = Box<dyn Fn(&str) -> Option<Cow<str>>>;
 
 pub struct Prompt {
     prompt: Cow<'static, str>,
@@ -25,9 +28,9 @@ pub struct Prompt {
     selection: Option<usize>,
     history_register: Option<char>,
     history_pos: Option<usize>,
-    completion_fn: Box<dyn FnMut(&Editor, &str) -> Vec<Completion>>,
-    callback_fn: Box<dyn FnMut(&mut Context, &str, PromptEvent)>,
-    pub doc_fn: Box<dyn Fn(&str) -> Option<Cow<str>>>,
+    completion_fn: CompletionFn,
+    callback_fn: CallbackFn,
+    pub doc_fn: DocFn,
     next_char_handler: Option<PromptCharHandler>,
 }
 
@@ -352,6 +355,7 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
         let prompt_color = theme.get("ui.text");
         let completion_color = theme.get("ui.menu");
         let selected_color = theme.get("ui.menu.selected");
+        let suggestion_color = theme.get("ui.text.inactive");
         // completion
 
         let max_len = self
@@ -450,21 +454,29 @@ pub fn render_prompt(&self, area: Rect, surface: &mut Surface, cx: &mut Context)
         // render buffer text
         surface.set_string(area.x, area.y + line, &self.prompt, prompt_color);
 
-        let input: Cow<str> = if self.line.is_empty() {
+        let (input, is_suggestion): (Cow<str>, bool) = if self.line.is_empty() {
             // latest value in the register list
-            self.history_register
+            match self
+                .history_register
                 .and_then(|reg| cx.editor.registers.last(reg))
                 .map(|entry| entry.into())
-                .unwrap_or_else(|| Cow::from(""))
+            {
+                Some(value) => (value, true),
+                None => (Cow::from(""), false),
+            }
         } else {
-            self.line.as_str().into()
+            (self.line.as_str().into(), false)
         };
 
         surface.set_string(
             area.x + self.prompt.len() as u16,
             area.y + line,
             &input,
-            prompt_color,
+            if is_suggestion {
+                suggestion_color
+            } else {
+                prompt_color
+            },
         );
     }
 }
@@ -504,7 +516,7 @@ fn handle_event(&mut self, event: &Event, cx: &mut Context) -> EventResult {
             alt!('d') | alt!(Delete) | ctrl!(Delete) => self.delete_word_forwards(cx.editor),
             ctrl!('k') => self.kill_to_end_of_line(cx.editor),
             ctrl!('u') => self.kill_to_start_of_line(cx.editor),
-            ctrl!('h') | key!(Backspace) => {
+            ctrl!('h') | key!(Backspace) | shift!(Backspace) => {
                 self.delete_char_backwards(cx.editor);
                 (self.callback_fn)(cx, &self.line, PromptEvent::Update);
             }
diff --git a/helix-term/src/ui/statusline.rs b/helix-term/src/ui/statusline.rs
index 501faea39..887863519 100644
--- a/helix-term/src/ui/statusline.rs
+++ b/helix-term/src/ui/statusline.rs
@@ -1,5 +1,6 @@
 use helix_core::{coords_at_pos, encoding, Position};
 use helix_lsp::lsp::DiagnosticSeverity;
+use helix_view::document::DEFAULT_LANGUAGE_NAME;
 use helix_view::{
     document::{Mode, SCRATCH_BUFFER_NAME},
     graphics::Rect,
@@ -139,7 +140,11 @@ fn get_render_function<F>(element_id: StatusLineElementID) -> impl Fn(&mut Rende
     match element_id {
         helix_view::editor::StatusLineElement::Mode => render_mode,
         helix_view::editor::StatusLineElement::Spinner => render_lsp_spinner,
+        helix_view::editor::StatusLineElement::FileBaseName => render_file_base_name,
         helix_view::editor::StatusLineElement::FileName => render_file_name,
+        helix_view::editor::StatusLineElement::FileModificationIndicator => {
+            render_file_modification_indicator
+        }
         helix_view::editor::StatusLineElement::FileEncoding => render_file_encoding,
         helix_view::editor::StatusLineElement::FileLineEnding => render_file_line_ending,
         helix_view::editor::StatusLineElement::FileType => render_file_type,
@@ -154,6 +159,7 @@ fn get_render_function<F>(element_id: StatusLineElementID) -> impl Fn(&mut Rende
         helix_view::editor::StatusLineElement::TotalLineNumbers => render_total_line_numbers,
         helix_view::editor::StatusLineElement::Separator => render_separator,
         helix_view::editor::StatusLineElement::Spacer => render_spacer,
+        helix_view::editor::StatusLineElement::VersionControl => render_version_control,
     }
 }
 
@@ -401,7 +407,7 @@ fn render_file_type<F>(context: &mut RenderContext, write: F)
 where
     F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
 {
-    let file_type = context.doc.language_name().unwrap_or("text");
+    let file_type = context.doc.language_name().unwrap_or(DEFAULT_LANGUAGE_NAME);
 
     write(context, format!(" {} ", file_type), None);
 }
@@ -416,11 +422,37 @@ fn render_file_name<F>(context: &mut RenderContext, write: F)
             .as_ref()
             .map(|p| p.to_string_lossy())
             .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into());
-        format!(
-            " {}{} ",
-            path,
-            if context.doc.is_modified() { "[+]" } else { "" }
-        )
+        format!(" {} ", path)
+    };
+
+    write(context, title, None);
+}
+
+fn render_file_modification_indicator<F>(context: &mut RenderContext, write: F)
+where
+    F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
+{
+    let title = (if context.doc.is_modified() {
+        "[+]"
+    } else {
+        "   "
+    })
+    .to_string();
+
+    write(context, title, None);
+}
+
+fn render_file_base_name<F>(context: &mut RenderContext, write: F)
+where
+    F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
+{
+    let title = {
+        let rel_path = context.doc.relative_path();
+        let path = rel_path
+            .as_ref()
+            .and_then(|p| p.as_path().file_name().map(|s| s.to_string_lossy()))
+            .unwrap_or_else(|| SCRATCH_BUFFER_NAME.into());
+        format!(" {} ", path)
     };
 
     write(context, title, None);
@@ -445,3 +477,16 @@ fn render_spacer<F>(context: &mut RenderContext, write: F)
 {
     write(context, String::from(" "), None);
 }
+
+fn render_version_control<F>(context: &mut RenderContext, write: F)
+where
+    F: Fn(&mut RenderContext, String, Option<Style>) + Copy,
+{
+    let head = context
+        .doc
+        .version_control_head()
+        .unwrap_or_default()
+        .to_string();
+
+    write(context, head, None);
+}
diff --git a/helix-term/src/ui/text.rs b/helix-term/src/ui/text.rs
index c318052b2..a379536f8 100644
--- a/helix-term/src/ui/text.rs
+++ b/helix-term/src/ui/text.rs
@@ -58,7 +58,7 @@ pub fn required_size(text: &tui::text::Text, max_text_width: u16) -> (u16, u16)
         let content_width = content.width() as u16;
         if content_width > max_text_width {
             text_width = max_text_width;
-            height += content_width / max_text_width;
+            height += content_width.checked_div(max_text_width).unwrap_or(0);
         } else if content_width > text_width {
             text_width = content_width;
         }
diff --git a/helix-term/tests/integration.rs b/helix-term/tests/integration.rs
index a378af7a9..d77eefed0 100644
--- a/helix-term/tests/integration.rs
+++ b/helix-term/tests/integration.rs
@@ -2,10 +2,8 @@
 mod test {
     mod helpers;
 
-    use std::path::PathBuf;
-
-    use helix_core::{syntax::AutoPairConfig, Position, Selection};
-    use helix_term::{args::Args, config::Config};
+    use helix_core::{syntax::AutoPairConfig, Selection};
+    use helix_term::config::Config;
 
     use indoc::indoc;
 
@@ -23,5 +21,4 @@ async fn hello_world() -> anyhow::Result<()> {
     mod movement;
     mod prompt;
     mod splits;
-    mod write;
 }
diff --git a/helix-term/tests/test/auto_indent.rs b/helix-term/tests/test/auto_indent.rs
index d5c220b7a..5132d44d9 100644
--- a/helix-term/tests/test/auto_indent.rs
+++ b/helix-term/tests/test/auto_indent.rs
@@ -3,22 +3,16 @@
 #[tokio::test(flavor = "multi_thread")]
 async fn auto_indent_c() -> anyhow::Result<()> {
     test_with_config(
-        Args {
-            files: vec![(PathBuf::from("foo.c"), Position::default())],
-            ..Default::default()
-        },
-        Config::default(),
-        helpers::test_syntax_conf(None),
+        AppBuilder::new().with_file("foo.c", None),
         // switches to append mode?
         (
-            helpers::platform_line("void foo() {#[|}]#").as_ref(),
+            helpers::platform_line("void foo() {#[|}]#"),
             "i<ret><esc>",
             helpers::platform_line(indoc! {"\
                 void foo() {
                   #[|\n]#\
                 }
-            "})
-            .as_ref(),
+            "}),
         ),
     )
     .await?;
diff --git a/helix-term/tests/test/auto_pairs.rs b/helix-term/tests/test/auto_pairs.rs
index e18c71195..e10e0840b 100644
--- a/helix-term/tests/test/auto_pairs.rs
+++ b/helix-term/tests/test/auto_pairs.rs
@@ -41,9 +41,7 @@ async fn insert_configured_multi_byte_chars() -> anyhow::Result<()> {
 
     for (open, close) in pairs.iter() {
         test_with_config(
-            Args::default(),
-            config.clone(),
-            helpers::test_syntax_conf(None),
+            AppBuilder::new().with_config(config.clone()),
             (
                 format!("#[{}|]#", LINE_END),
                 format!("i{}", open),
@@ -53,9 +51,7 @@ async fn insert_configured_multi_byte_chars() -> anyhow::Result<()> {
         .await?;
 
         test_with_config(
-            Args::default(),
-            config.clone(),
-            helpers::test_syntax_conf(None),
+            AppBuilder::new().with_config(config.clone()),
             (
                 format!("{}#[{}|]#{}", open, close, LINE_END),
                 format!("i{}", close),
@@ -170,15 +166,13 @@ async fn insert_before_eol() -> anyhow::Result<()> {
 async fn insert_auto_pairs_disabled() -> anyhow::Result<()> {
     for pair in DEFAULT_PAIRS {
         test_with_config(
-            Args::default(),
-            Config {
+            AppBuilder::new().with_config(Config {
                 editor: helix_view::editor::Config {
                     auto_pairs: AutoPairConfig::Enable(false),
                     ..Default::default()
                 },
                 ..Default::default()
-            },
-            helpers::test_syntax_conf(None),
+            }),
             (
                 format!("#[{}|]#", LINE_END),
                 format!("i{}", pair.0),
diff --git a/helix-term/tests/test/commands.rs b/helix-term/tests/test/commands.rs
index 95bd95b73..342a849be 100644
--- a/helix-term/tests/test/commands.rs
+++ b/helix-term/tests/test/commands.rs
@@ -1,99 +1,8 @@
-use std::ops::RangeInclusive;
-
-use helix_core::diagnostic::Severity;
 use helix_term::application::Application;
 
 use super::*;
 
-#[tokio::test(flavor = "multi_thread")]
-async fn test_write_quit_fail() -> anyhow::Result<()> {
-    let file = helpers::new_readonly_tempfile()?;
-    let mut app = helpers::AppBuilder::new()
-        .with_file(file.path(), None)
-        .build()?;
-
-    test_key_sequence(
-        &mut app,
-        Some("ihello<esc>:wq<ret>"),
-        Some(&|app| {
-            let mut docs: Vec<_> = app.editor.documents().collect();
-            assert_eq!(1, docs.len());
-
-            let doc = docs.pop().unwrap();
-            assert_eq!(Some(file.path()), doc.path().map(PathBuf::as_path));
-            assert_eq!(&Severity::Error, app.editor.get_status().unwrap().1);
-        }),
-        false,
-    )
-    .await?;
-
-    Ok(())
-}
-
-#[tokio::test(flavor = "multi_thread")]
-async fn test_buffer_close_concurrent() -> anyhow::Result<()> {
-    test_key_sequences(
-        &mut helpers::AppBuilder::new().build()?,
-        vec![
-            (
-                None,
-                Some(&|app| {
-                    assert_eq!(1, app.editor.documents().count());
-                    assert!(!app.editor.is_err());
-                }),
-            ),
-            (
-                Some("ihello<esc>:new<ret>"),
-                Some(&|app| {
-                    assert_eq!(2, app.editor.documents().count());
-                    assert!(!app.editor.is_err());
-                }),
-            ),
-            (
-                Some(":buffer<minus>close<ret>"),
-                Some(&|app| {
-                    assert_eq!(1, app.editor.documents().count());
-                    assert!(!app.editor.is_err());
-                }),
-            ),
-        ],
-        false,
-    )
-    .await?;
-
-    // verify if writes are queued up, it finishes them before closing the buffer
-    let mut file = tempfile::NamedTempFile::new()?;
-    let mut command = String::new();
-    const RANGE: RangeInclusive<i32> = 1..=1000;
-
-    for i in RANGE {
-        let cmd = format!("%c{}<esc>:w<ret>", i);
-        command.push_str(&cmd);
-    }
-
-    command.push_str(":buffer<minus>close<ret>");
-
-    let mut app = helpers::AppBuilder::new()
-        .with_file(file.path(), None)
-        .build()?;
-
-    test_key_sequence(
-        &mut app,
-        Some(&command),
-        Some(&|app| {
-            assert!(!app.editor.is_err(), "error: {:?}", app.editor.get_status());
-
-            let doc = app.editor.document_by_path(file.path());
-            assert!(doc.is_none(), "found doc: {:?}", doc);
-        }),
-        false,
-    )
-    .await?;
-
-    helpers::assert_file_has_content(file.as_file_mut(), &RANGE.end().to_string())?;
-
-    Ok(())
-}
+mod write;
 
 #[tokio::test(flavor = "multi_thread")]
 async fn test_selection_duplication() -> anyhow::Result<()> {
@@ -132,6 +41,70 @@ async fn test_selection_duplication() -> anyhow::Result<()> {
         .as_str(),
     ))
     .await?;
+
+    // Copy the selection to previous line, skipping the first line in the file
+    test((
+        platform_line(indoc! {"\
+            test
+            #[testitem|]#
+            "})
+        .as_str(),
+        "<A-C>",
+        platform_line(indoc! {"\
+            test
+            #[testitem|]#
+            "})
+        .as_str(),
+    ))
+    .await?;
+
+    // Copy the selection to previous line, including the first line in the file
+    test((
+        platform_line(indoc! {"\
+            test
+            #[test|]#
+            "})
+        .as_str(),
+        "<A-C>",
+        platform_line(indoc! {"\
+            #[test|]#
+            #(test|)#
+            "})
+        .as_str(),
+    ))
+    .await?;
+
+    // Copy the selection to next line, skipping the last line in the file
+    test((
+        platform_line(indoc! {"\
+            #[testitem|]#
+            test
+            "})
+        .as_str(),
+        "C",
+        platform_line(indoc! {"\
+            #[testitem|]#
+            test
+            "})
+        .as_str(),
+    ))
+    .await?;
+
+    // Copy the selection to next line, including the last line in the file
+    test((
+        platform_line(indoc! {"\
+            #[test|]#
+            test
+            "})
+        .as_str(),
+        "C",
+        platform_line(indoc! {"\
+            #(test|)#
+            #[test|]#
+            "})
+        .as_str(),
+    ))
+    .await?;
     Ok(())
 }
 
@@ -228,12 +201,12 @@ async fn test_multi_selection_shell_commands() -> anyhow::Result<()> {
         .as_str(),
         "|echo foo<ret>",
         platform_line(indoc! {"\
-            #[|foo
-            ]#
-            #(|foo
-            )#
-            #(|foo
-            )#
+            #[|foo\n]#
+            
+            #(|foo\n)#
+            
+            #(|foo\n)#
+            
             "})
         .as_str(),
     ))
@@ -249,12 +222,12 @@ async fn test_multi_selection_shell_commands() -> anyhow::Result<()> {
         .as_str(),
         "!echo foo<ret>",
         platform_line(indoc! {"\
-            #[|foo
-            ]#lorem
-            #(|foo
-            )#ipsum
-            #(|foo
-            )#dolor
+            #[|foo\n]#
+            lorem
+            #(|foo\n)#
+            ipsum
+            #(|foo\n)#
+            dolor
             "})
         .as_str(),
     ))
@@ -270,12 +243,12 @@ async fn test_multi_selection_shell_commands() -> anyhow::Result<()> {
         .as_str(),
         "<A-!>echo foo<ret>",
         platform_line(indoc! {"\
-            lorem#[|foo
-            ]#
-            ipsum#(|foo
-            )#
-            dolor#(|foo
-            )#
+            lorem#[|foo\n]#
+            
+            ipsum#(|foo\n)#
+            
+            dolor#(|foo\n)#
+            
             "})
         .as_str(),
     ))
@@ -311,3 +284,104 @@ async fn test_undo_redo() -> anyhow::Result<()> {
 
     Ok(())
 }
+
+#[tokio::test(flavor = "multi_thread")]
+async fn test_extend_line() -> anyhow::Result<()> {
+    // extend with line selected then count
+    test((
+        platform_line(indoc! {"\
+            #[l|]#orem
+            ipsum
+            dolor
+            
+            "})
+        .as_str(),
+        "x2x",
+        platform_line(indoc! {"\
+            #[lorem
+            ipsum
+            dolor\n|]#
+            
+            "})
+        .as_str(),
+    ))
+    .await?;
+
+    // extend with count on partial selection
+    test((
+        platform_line(indoc! {"\
+            #[l|]#orem
+            ipsum
+            
+            "})
+        .as_str(),
+        "2x",
+        platform_line(indoc! {"\
+            #[lorem
+            ipsum\n|]#
+            
+            "})
+        .as_str(),
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn test_character_info() -> anyhow::Result<()> {
+    // UTF-8, single byte
+    test_key_sequence(
+        &mut helpers::AppBuilder::new().build()?,
+        Some("ih<esc>h:char<ret>"),
+        Some(&|app| {
+            assert_eq!(
+                r#""h" (U+0068) Dec 104 Hex 68"#,
+                app.editor.get_status().unwrap().0
+            );
+        }),
+        false,
+    )
+    .await?;
+
+    // UTF-8, multi-byte
+    test_key_sequence(
+        &mut helpers::AppBuilder::new().build()?,
+        Some("ie<esc>h:char<ret>"),
+        Some(&|app| {
+            assert_eq!(
+                r#""e" (U+0065 U+0308) Hex 65 + cc 88"#,
+                app.editor.get_status().unwrap().0
+            );
+        }),
+        false,
+    )
+    .await?;
+
+    // Multiple characters displayed as one, escaped characters
+    test_key_sequence(
+        &mut helpers::AppBuilder::new().build()?,
+        Some(":line<minus>ending crlf<ret>:char<ret>"),
+        Some(&|app| {
+            assert_eq!(
+                r#""\r\n" (U+000d U+000a) Hex 0d + 0a"#,
+                app.editor.get_status().unwrap().0
+            );
+        }),
+        false,
+    )
+    .await?;
+
+    // Non-UTF-8
+    test_key_sequence(
+        &mut helpers::AppBuilder::new().build()?,
+        Some(":encoding ascii<ret>ih<esc>h:char<ret>"),
+        Some(&|app| {
+            assert_eq!(r#""h" Dec 104 Hex 68"#, app.editor.get_status().unwrap().0);
+        }),
+        false,
+    )
+    .await?;
+
+    Ok(())
+}
diff --git a/helix-term/tests/test/write.rs b/helix-term/tests/test/commands/write.rs
similarity index 66%
rename from helix-term/tests/test/write.rs
rename to helix-term/tests/test/commands/write.rs
index d0128edca..26515b7ae 100644
--- a/helix-term/tests/test/write.rs
+++ b/helix-term/tests/test/commands/write.rs
@@ -1,13 +1,103 @@
 use std::{
-    io::{Read, Write},
+    io::{Read, Seek, Write},
     ops::RangeInclusive,
 };
 
-use helix_core::diagnostic::Severity;
+use helix_core::{diagnostic::Severity, path::get_normalized_path};
 use helix_view::doc;
 
 use super::*;
 
+#[tokio::test(flavor = "multi_thread")]
+async fn test_write_quit_fail() -> anyhow::Result<()> {
+    let file = helpers::new_readonly_tempfile()?;
+    let mut app = helpers::AppBuilder::new()
+        .with_file(file.path(), None)
+        .build()?;
+
+    test_key_sequence(
+        &mut app,
+        Some("ihello<esc>:wq<ret>"),
+        Some(&|app| {
+            let mut docs: Vec<_> = app.editor.documents().collect();
+            assert_eq!(1, docs.len());
+
+            let doc = docs.pop().unwrap();
+            assert_eq!(Some(&get_normalized_path(file.path())), doc.path());
+            assert_eq!(&Severity::Error, app.editor.get_status().unwrap().1);
+        }),
+        false,
+    )
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn test_buffer_close_concurrent() -> anyhow::Result<()> {
+    test_key_sequences(
+        &mut helpers::AppBuilder::new().build()?,
+        vec![
+            (
+                None,
+                Some(&|app| {
+                    assert_eq!(1, app.editor.documents().count());
+                    assert!(!app.editor.is_err());
+                }),
+            ),
+            (
+                Some("ihello<esc>:new<ret>"),
+                Some(&|app| {
+                    assert_eq!(2, app.editor.documents().count());
+                    assert!(!app.editor.is_err());
+                }),
+            ),
+            (
+                Some(":buffer<minus>close<ret>"),
+                Some(&|app| {
+                    assert_eq!(1, app.editor.documents().count());
+                    assert!(!app.editor.is_err());
+                }),
+            ),
+        ],
+        false,
+    )
+    .await?;
+
+    // verify if writes are queued up, it finishes them before closing the buffer
+    let mut file = tempfile::NamedTempFile::new()?;
+    let mut command = String::new();
+    const RANGE: RangeInclusive<i32> = 1..=1000;
+
+    for i in RANGE {
+        let cmd = format!("%c{}<esc>:w!<ret>", i);
+        command.push_str(&cmd);
+    }
+
+    command.push_str(":buffer<minus>close<ret>");
+
+    let mut app = helpers::AppBuilder::new()
+        .with_file(file.path(), None)
+        .build()?;
+
+    test_key_sequence(
+        &mut app,
+        Some(&command),
+        Some(&|app| {
+            assert!(!app.editor.is_err(), "error: {:?}", app.editor.get_status());
+
+            let doc = app.editor.document_by_path(file.path());
+            assert!(doc.is_none(), "found doc: {:?}", doc);
+        }),
+        false,
+    )
+    .await?;
+
+    helpers::assert_file_has_content(file.as_file_mut(), &RANGE.end().to_string())?;
+
+    Ok(())
+}
+
 #[tokio::test(flavor = "multi_thread")]
 async fn test_write() -> anyhow::Result<()> {
     let mut file = tempfile::NamedTempFile::new()?;
@@ -37,6 +127,38 @@ async fn test_write() -> anyhow::Result<()> {
     Ok(())
 }
 
+#[tokio::test(flavor = "multi_thread")]
+async fn test_overwrite_protection() -> anyhow::Result<()> {
+    let mut file = tempfile::NamedTempFile::new()?;
+    let mut app = helpers::AppBuilder::new()
+        .with_file(file.path(), None)
+        .build()?;
+
+    helpers::run_event_loop_until_idle(&mut app).await;
+
+    file.as_file_mut()
+        .write_all(helpers::platform_line("extremely important content").as_bytes())?;
+
+    file.as_file_mut().flush()?;
+    file.as_file_mut().sync_all()?;
+
+    test_key_sequence(&mut app, Some(":x<ret>"), None, false).await?;
+
+    file.as_file_mut().flush()?;
+    file.as_file_mut().sync_all()?;
+
+    file.rewind()?;
+    let mut file_content = String::new();
+    file.as_file_mut().read_to_string(&mut file_content)?;
+
+    assert_eq!(
+        helpers::platform_line("extremely important content"),
+        file_content
+    );
+
+    Ok(())
+}
+
 #[tokio::test(flavor = "multi_thread")]
 async fn test_write_quit() -> anyhow::Result<()> {
     let mut file = tempfile::NamedTempFile::new()?;
@@ -70,13 +192,13 @@ async fn test_write_quit() -> anyhow::Result<()> {
 async fn test_write_concurrent() -> anyhow::Result<()> {
     let mut file = tempfile::NamedTempFile::new()?;
     let mut command = String::new();
-    const RANGE: RangeInclusive<i32> = 1..=5000;
+    const RANGE: RangeInclusive<i32> = 1..=1000;
     let mut app = helpers::AppBuilder::new()
         .with_file(file.path(), None)
         .build()?;
 
     for i in RANGE {
-        let cmd = format!("%c{}<esc>:w<ret>", i);
+        let cmd = format!("%c{}<esc>:w!<ret>", i);
         command.push_str(&cmd);
     }
 
@@ -147,7 +269,7 @@ async fn test_write_scratch_to_new_path() -> anyhow::Result<()> {
             assert_eq!(1, docs.len());
 
             let doc = docs.pop().unwrap();
-            assert_eq!(Some(&file.path().to_path_buf()), doc.path());
+            assert_eq!(Some(&get_normalized_path(file.path())), doc.path());
         }),
         false,
     )
@@ -219,7 +341,7 @@ async fn test_write_new_path() -> anyhow::Result<()> {
                 Some(&|app| {
                     let doc = doc!(app.editor);
                     assert!(!app.editor.is_err());
-                    assert_eq!(file1.path(), doc.path().unwrap());
+                    assert_eq!(&get_normalized_path(file1.path()), doc.path().unwrap());
                 }),
             ),
             (
@@ -227,7 +349,7 @@ async fn test_write_new_path() -> anyhow::Result<()> {
                 Some(&|app| {
                     let doc = doc!(app.editor);
                     assert!(!app.editor.is_err());
-                    assert_eq!(file2.path(), doc.path().unwrap());
+                    assert_eq!(&get_normalized_path(file2.path()), doc.path().unwrap());
                     assert!(app.editor.document_by_path(file1.path()).is_none());
                 }),
             ),
diff --git a/helix-term/tests/test/helpers.rs b/helix-term/tests/test/helpers.rs
index 2c5043d68..30fe7d0ed 100644
--- a/helix-term/tests/test/helpers.rs
+++ b/helix-term/tests/test/helpers.rs
@@ -1,6 +1,7 @@
 use std::{
     fs::File,
     io::{Read, Write},
+    mem::replace,
     path::PathBuf,
     time::Duration,
 };
@@ -8,8 +9,8 @@
 use anyhow::bail;
 use crossterm::event::{Event, KeyEvent};
 use helix_core::{diagnostic::Severity, test, Selection, Transaction};
-use helix_term::{application::Application, args::Args, config::Config};
-use helix_view::{doc, input::parse_macro, Editor};
+use helix_term::{application::Application, args::Args, config::Config, keymap::merge_keys};
+use helix_view::{current_ref, doc, editor::LspConfig, input::parse_macro, Editor};
 use tempfile::NamedTempFile;
 use tokio_stream::wrappers::UnboundedReceiverStream;
 
@@ -22,8 +23,13 @@ pub struct TestCase {
     pub out_selection: Selection,
 }
 
-impl<S: Into<String>> From<(S, S, S)> for TestCase {
-    fn from((input, keys, output): (S, S, S)) -> Self {
+impl<S, R, V> From<(S, R, V)> for TestCase
+where
+    S: Into<String>,
+    R: Into<String>,
+    V: Into<String>,
+{
+    fn from((input, keys, output): (S, R, V)) -> Self {
         let (in_text, in_selection) = test::print(&input.into());
         let (out_text, out_selection) = test::print(&output.into());
 
@@ -59,6 +65,11 @@ pub async fn test_key_sequences(
     let num_inputs = inputs.len();
 
     for (i, (in_keys, test_fn)) in inputs.into_iter().enumerate() {
+        let (view, doc) = current_ref!(app.editor);
+        let state = test::plain(doc.text().slice(..), doc.selection(view.id));
+
+        log::debug!("executing test with document state:\n\n-----\n\n{}", state);
+
         if let Some(in_keys) = in_keys {
             for key_event in parse_macro(in_keys)?.into_iter() {
                 let key = Event::Key(KeyEvent::from(key_event));
@@ -69,6 +80,16 @@ pub async fn test_key_sequences(
 
         let app_exited = !app.event_loop_until_idle(&mut rx_stream).await;
 
+        if !app_exited {
+            let (view, doc) = current_ref!(app.editor);
+            let state = test::plain(doc.text().slice(..), doc.selection(view.id));
+
+            log::debug!(
+                "finished running test with document state:\n\n-----\n\n{}",
+                state
+            );
+        }
+
         // the app should not exit from any test until the last one
         if i < num_inputs - 1 && app_exited {
             bail!("application exited before test function could run");
@@ -118,7 +139,7 @@ pub async fn test_key_sequence_with_input_text<T: Into<TestCase>>(
     let test_case = test_case.into();
     let mut app = match app {
         Some(app) => app,
-        None => Application::new(Args::default(), Config::default(), test_syntax_conf(None))?,
+        None => Application::new(Args::default(), test_config(), test_syntax_conf(None))?,
     };
 
     let (view, doc) = helix_view::current!(app.editor);
@@ -130,7 +151,7 @@ pub async fn test_key_sequence_with_input_text<T: Into<TestCase>>(
     })
     .with_selection(test_case.in_selection.clone());
 
-    helix_view::apply_transaction(&transaction, doc, view);
+    doc.apply(&transaction, view.id);
 
     test_key_sequence(
         &mut app,
@@ -143,27 +164,9 @@ pub async fn test_key_sequence_with_input_text<T: Into<TestCase>>(
 
 /// Generates language configs that merge in overrides, like a user language
 /// config. The argument string must be a raw TOML document.
-///
-/// By default, language server configuration is dropped from the languages.toml
-/// document. If a language-server is necessary for a test, it must be explicitly
-/// added in `overrides`.
 pub fn test_syntax_conf(overrides: Option<String>) -> helix_core::syntax::Configuration {
     let mut lang = helix_loader::config::default_lang_config();
 
-    for lang_config in lang
-        .as_table_mut()
-        .expect("Expected languages.toml to be a table")
-        .get_mut("language")
-        .expect("Expected languages.toml to have \"language\" keys")
-        .as_array_mut()
-        .expect("Expected an array of language configurations")
-    {
-        lang_config
-            .as_table_mut()
-            .expect("Expected language config to be a TOML table")
-            .remove("language-server");
-    }
-
     if let Some(overrides) = overrides {
         let override_toml = toml::from_str(&overrides).unwrap();
         lang = helix_loader::merge_toml_values(lang, override_toml, 3);
@@ -176,13 +179,11 @@ pub fn test_syntax_conf(overrides: Option<String>) -> helix_core::syntax::Config
 /// document, selection, and sequence of key presses, and you just
 /// want to verify the resulting document and selection.
 pub async fn test_with_config<T: Into<TestCase>>(
-    args: Args,
-    config: Config,
-    syn_conf: helix_core::syntax::Configuration,
+    app_builder: AppBuilder,
     test_case: T,
 ) -> anyhow::Result<()> {
     let test_case = test_case.into();
-    let app = Application::new(args, config, syn_conf)?;
+    let app = app_builder.build()?;
 
     test_key_sequence_with_input_text(
         Some(app),
@@ -203,13 +204,7 @@ pub async fn test_with_config<T: Into<TestCase>>(
 }
 
 pub async fn test<T: Into<TestCase>>(test_case: T) -> anyhow::Result<()> {
-    test_with_config(
-        Args::default(),
-        Config::default(),
-        test_syntax_conf(None),
-        test_case,
-    )
-    .await
+    test_with_config(AppBuilder::default(), test_case).await
 }
 
 pub fn temp_file_with_contents<S: AsRef<str>>(
@@ -226,6 +221,25 @@ pub fn temp_file_with_contents<S: AsRef<str>>(
     Ok(temp_file)
 }
 
+/// Generates a config with defaults more suitable for integration tests
+pub fn test_config() -> Config {
+    Config {
+        editor: test_editor_config(),
+        keys: helix_term::keymap::default(),
+        ..Default::default()
+    }
+}
+
+pub fn test_editor_config() -> helix_view::editor::Config {
+    helix_view::editor::Config {
+        lsp: LspConfig {
+            enable: false,
+            ..Default::default()
+        },
+        ..Default::default()
+    }
+}
+
 /// Replaces all LF chars with the system's appropriate line feed
 /// character, and if one doesn't exist already, appends the system's
 /// appropriate line ending to the end of a string.
@@ -265,7 +279,7 @@ impl Default for AppBuilder {
     fn default() -> Self {
         Self {
             args: Args::default(),
-            config: Config::default(),
+            config: test_config(),
             syn_conf: test_syntax_conf(None),
             input: None,
         }
@@ -288,7 +302,9 @@ pub fn with_file<P: Into<PathBuf>>(
 
     // Remove this attribute once `with_config` is used in a test:
     #[allow(dead_code)]
-    pub fn with_config(mut self, config: Config) -> Self {
+    pub fn with_config(mut self, mut config: Config) -> Self {
+        let keys = replace(&mut config.keys, helix_term::keymap::default());
+        merge_keys(&mut config.keys, keys);
         self.config = config;
         self
     }
@@ -315,13 +331,19 @@ pub fn build(self) -> anyhow::Result<Application> {
             .with_selection(selection);
 
             // replace the initial text with the input text
-            helix_view::apply_transaction(&trans, doc, view);
+            doc.apply(&trans, view.id);
         }
 
         Ok(app)
     }
 }
 
+pub async fn run_event_loop_until_idle(app: &mut Application) {
+    let (_, rx) = tokio::sync::mpsc::unbounded_channel();
+    let mut rx_stream = UnboundedReceiverStream::new(rx);
+    app.event_loop_until_idle(&mut rx_stream).await;
+}
+
 pub fn assert_file_has_content(file: &mut File, content: &str) -> anyhow::Result<()> {
     file.flush()?;
     file.sync_all()?;
diff --git a/helix-term/tests/test/movement.rs b/helix-term/tests/test/movement.rs
index fedf4b0e6..9a48cdbcb 100644
--- a/helix-term/tests/test/movement.rs
+++ b/helix-term/tests/test/movement.rs
@@ -64,6 +64,307 @@ async fn insert_to_normal_mode_cursor_position() -> anyhow::Result<()> {
     Ok(())
 }
 
+#[tokio::test(flavor = "multi_thread")]
+async fn surround_by_character() -> anyhow::Result<()> {
+    // Only pairs matching the passed character count
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "mi{",
+        "(so [many {#[good|]#} text] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "mi[",
+        "(so [#[many {good} text|]#] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "mi(",
+        "(#[so [many {good} text] here|]#)",
+    ))
+    .await?;
+
+    // Works with characters that aren't pairs too
+    test((
+        "'so 'many 'go#[o|]#d' text' here'",
+        "mi'",
+        "'so 'many '#[good|]#' text' here'",
+    ))
+    .await?;
+    test((
+        "'so 'many 'go#[o|]#d' text' here'",
+        "2mi'",
+        "'so '#[many 'good' text|]#' here'",
+    ))
+    .await?;
+    test((
+        "'so \"many 'go#[o|]#d' text\" here'",
+        "mi\"",
+        "'so \"#[many 'good' text|]#\" here'",
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn surround_inside_pair() -> anyhow::Result<()> {
+    // Works at first character of buffer
+    // TODO: Adjust test when opening pair failure is fixed
+    test(("#[(|]#something)", "mim", "#[(|]#something)")).await?;
+
+    // Inside a valid pair selects pair
+    test(("some (#[t|]#ext) here", "mim", "some (#[text|]#) here")).await?;
+
+    // On pair character selects pair
+    // TODO: Opening pair character is a known failure case that needs addressing
+    // test(("some #[(|]#text) here", "mim", "some (#[text|]#) here")).await?;
+    test(("some (text#[)|]# here", "mim", "some (#[text|]#) here")).await?;
+
+    // No valid pair does nothing
+    test(("so#[m|]#e (text) here", "mim", "so#[m|]#e (text) here")).await?;
+
+    // Count skips to outer pairs
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "1mim",
+        "(so (many (#[good|]#) text) here)",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "2mim",
+        "(so (#[many (good) text|]#) here)",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "3mim",
+        "(#[so (many (good) text) here|]#)",
+    ))
+    .await?;
+
+    // Matching pairs outside selection don't match
+    test((
+        "((so)((many) go#[o|]#d (text))(here))",
+        "mim",
+        "((so)(#[(many) good (text)|]#)(here))",
+    ))
+    .await?;
+    test((
+        "((so)((many) go#[o|]#d (text))(here))",
+        "2mim",
+        "(#[(so)((many) good (text))(here)|]#)",
+    ))
+    .await?;
+
+    // Works with mixed braces
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "mim",
+        "(so [many {#[good|]#} text] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "2mim",
+        "(so [#[many {good} text|]#] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "3mim",
+        "(#[so [many {good} text] here|]#)",
+    ))
+    .await?;
+
+    // Selection direction is preserved
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "mim",
+        "(so [many {#[|good]#} text] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "2mim",
+        "(so [#[|many {good} text]#] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "3mim",
+        "(#[|so [many {good} text] here]#)",
+    ))
+    .await?;
+
+    // Only pairs outside of full selection range are considered
+    test((
+        "(so (many (go#[od) |]#text) here)",
+        "mim",
+        "(so (#[many (good) text|]#) here)",
+    ))
+    .await?;
+    test((
+        "(so (many#[ (go|]#od) text) here)",
+        "mim",
+        "(so (#[many (good) text|]#) here)",
+    ))
+    .await?;
+    test((
+        "(so#[ (many (go|]#od) text) here)",
+        "mim",
+        "(#[so (many (good) text) here|]#)",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[od) text) |]#here)",
+        "mim",
+        "(#[so (many (good) text) here|]#)",
+    ))
+    .await?;
+
+    // Works with multiple cursors
+    test((
+        "(so (many (good) text) #[he|]#re\nso (many (good) text) #(|he)#re)",
+        "mim",
+        "(#[so (many (good) text) here\nso (many (good) text) here|]#)",
+    ))
+    .await?;
+
+    Ok(())
+}
+
+#[tokio::test(flavor = "multi_thread")]
+async fn surround_around_pair() -> anyhow::Result<()> {
+    // Works at first character of buffer
+    // TODO: Adjust test when opening pair failure is fixed
+    test(("#[(|]#something)", "mam", "#[(|]#something)")).await?;
+
+    // Inside a valid pair selects pair
+    test(("some (#[t|]#ext) here", "mam", "some #[(text)|]# here")).await?;
+
+    // On pair character selects pair
+    // TODO: Opening pair character is a known failure case that needs addressing
+    // test(("some #[(|]#text) here", "mam", "some #[(text)|]# here")).await?;
+    test(("some (text#[)|]# here", "mam", "some #[(text)|]# here")).await?;
+
+    // No valid pair does nothing
+    test(("so#[m|]#e (text) here", "mam", "so#[m|]#e (text) here")).await?;
+
+    // Count skips to outer pairs
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "1mam",
+        "(so (many #[(good)|]# text) here)",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "2mam",
+        "(so #[(many (good) text)|]# here)",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[o|]#d) text) here)",
+        "3mam",
+        "#[(so (many (good) text) here)|]#",
+    ))
+    .await?;
+
+    // Matching pairs outside selection don't match
+    test((
+        "((so)((many) go#[o|]#d (text))(here))",
+        "mam",
+        "((so)#[((many) good (text))|]#(here))",
+    ))
+    .await?;
+    test((
+        "((so)((many) go#[o|]#d (text))(here))",
+        "2mam",
+        "#[((so)((many) good (text))(here))|]#",
+    ))
+    .await?;
+
+    // Works with mixed braces
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "mam",
+        "(so [many #[{good}|]# text] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "2mam",
+        "(so #[[many {good} text]|]# here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[o|]#d} text] here)",
+        "3mam",
+        "#[(so [many {good} text] here)|]#",
+    ))
+    .await?;
+
+    // Selection direction is preserved
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "mam",
+        "(so [many #[|{good}]# text] here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "2mam",
+        "(so #[|[many {good} text]]# here)",
+    ))
+    .await?;
+    test((
+        "(so [many {go#[|od]#} text] here)",
+        "3mam",
+        "#[|(so [many {good} text] here)]#",
+    ))
+    .await?;
+
+    // Only pairs outside of full selection range are considered
+    test((
+        "(so (many (go#[od) |]#text) here)",
+        "mam",
+        "(so #[(many (good) text)|]# here)",
+    ))
+    .await?;
+    test((
+        "(so (many#[ (go|]#od) text) here)",
+        "mam",
+        "(so #[(many (good) text)|]# here)",
+    ))
+    .await?;
+    test((
+        "(so#[ (many (go|]#od) text) here)",
+        "mam",
+        "#[(so (many (good) text) here)|]#",
+    ))
+    .await?;
+    test((
+        "(so (many (go#[od) text) |]#here)",
+        "mam",
+        "#[(so (many (good) text) here)|]#",
+    ))
+    .await?;
+
+    // Works with multiple cursors
+    test((
+        "(so (many (good) text) #[he|]#re\nso (many (good) text) #(|he)#re)",
+        "mam",
+        "#[(so (many (good) text) here\nso (many (good) text) here)|]#",
+    ))
+    .await?;
+
+    Ok(())
+}
+
 /// Ensure the very initial cursor in an opened file is the width of
 /// the first grapheme
 #[tokio::test(flavor = "multi_thread")]
@@ -90,11 +391,11 @@ async fn cursor_position_newly_opened_file() -> anyhow::Result<()> {
 
 #[tokio::test(flavor = "multi_thread")]
 async fn cursor_position_append_eof() -> anyhow::Result<()> {
-    // Selection is fowards
+    // Selection is forwards
     test((
         "#[foo|]#",
         "abar<esc>",
-        helpers::platform_line("#[foobar|]#\n").as_ref(),
+        helpers::platform_line("#[foobar|]#\n"),
     ))
     .await?;
 
@@ -102,7 +403,7 @@ async fn cursor_position_append_eof() -> anyhow::Result<()> {
     test((
         "#[|foo]#",
         "abar<esc>",
-        helpers::platform_line("#[foobar|]#\n").as_ref(),
+        helpers::platform_line("#[foobar|]#\n"),
     ))
     .await?;
 
@@ -112,28 +413,21 @@ async fn cursor_position_append_eof() -> anyhow::Result<()> {
 #[tokio::test(flavor = "multi_thread")]
 async fn select_mode_tree_sitter_next_function_is_union_of_objects() -> anyhow::Result<()> {
     test_with_config(
-        Args {
-            files: vec![(PathBuf::from("foo.rs"), Position::default())],
-            ..Default::default()
-        },
-        Config::default(),
-        helpers::test_syntax_conf(None),
+        AppBuilder::new().with_file("foo.rs", None),
         (
             helpers::platform_line(indoc! {"\
                 #[/|]#// Increments
                 fn inc(x: usize) -> usize { x + 1 }
                 /// Decrements
                 fn dec(x: usize) -> usize { x - 1 }
-            "})
-            .as_ref(),
+            "}),
             "]fv]f",
             helpers::platform_line(indoc! {"\
                 /// Increments
                 #[fn inc(x: usize) -> usize { x + 1 }
                 /// Decrements
                 fn dec(x: usize) -> usize { x - 1 }|]#
-            "})
-            .as_ref(),
+            "}),
         ),
     )
     .await?;
@@ -144,28 +438,21 @@ fn dec(x: usize) -> usize { x - 1 }|]#
 #[tokio::test(flavor = "multi_thread")]
 async fn select_mode_tree_sitter_prev_function_unselects_object() -> anyhow::Result<()> {
     test_with_config(
-        Args {
-            files: vec![(PathBuf::from("foo.rs"), Position::default())],
-            ..Default::default()
-        },
-        Config::default(),
-        helpers::test_syntax_conf(None),
+        AppBuilder::new().with_file("foo.rs", None),
         (
             helpers::platform_line(indoc! {"\
                 /// Increments
                 #[fn inc(x: usize) -> usize { x + 1 }
                 /// Decrements
                 fn dec(x: usize) -> usize { x - 1 }|]#
-            "})
-            .as_ref(),
+            "}),
             "v[f",
             helpers::platform_line(indoc! {"\
                 /// Increments
                 #[fn inc(x: usize) -> usize { x + 1 }|]#
                 /// Decrements
                 fn dec(x: usize) -> usize { x - 1 }
-            "})
-            .as_ref(),
+            "}),
         ),
     )
     .await?;
@@ -177,12 +464,7 @@ fn dec(x: usize) -> usize { x - 1 }
 async fn select_mode_tree_sitter_prev_function_goes_backwards_to_object() -> anyhow::Result<()> {
     // Note: the anchor stays put and the head moves back.
     test_with_config(
-        Args {
-            files: vec![(PathBuf::from("foo.rs"), Position::default())],
-            ..Default::default()
-        },
-        Config::default(),
-        helpers::test_syntax_conf(None),
+        AppBuilder::new().with_file("foo.rs", None),
         (
             helpers::platform_line(indoc! {"\
                 /// Increments
@@ -191,8 +473,7 @@ fn inc(x: usize) -> usize { x + 1 }
                 fn dec(x: usize) -> usize { x - 1 }
                 /// Identity
                 #[fn ident(x: usize) -> usize { x }|]#
-            "})
-            .as_ref(),
+            "}),
             "v[f",
             helpers::platform_line(indoc! {"\
                 /// Increments
@@ -201,19 +482,13 @@ fn inc(x: usize) -> usize { x + 1 }
                 #[|fn dec(x: usize) -> usize { x - 1 }
                 /// Identity
                 ]#fn ident(x: usize) -> usize { x }
-            "})
-            .as_ref(),
+            "}),
         ),
     )
     .await?;
 
     test_with_config(
-        Args {
-            files: vec![(PathBuf::from("foo.rs"), Position::default())],
-            ..Default::default()
-        },
-        Config::default(),
-        helpers::test_syntax_conf(None),
+        AppBuilder::new().with_file("foo.rs", None),
         (
             helpers::platform_line(indoc! {"\
                 /// Increments
@@ -222,8 +497,7 @@ fn inc(x: usize) -> usize { x + 1 }
                 fn dec(x: usize) -> usize { x - 1 }
                 /// Identity
                 #[fn ident(x: usize) -> usize { x }|]#
-            "})
-            .as_ref(),
+            "}),
             "v[f[f",
             helpers::platform_line(indoc! {"\
                 /// Increments
@@ -232,8 +506,7 @@ fn dec(x: usize) -> usize { x - 1 }
                 fn dec(x: usize) -> usize { x - 1 }
                 /// Identity
                 ]#fn ident(x: usize) -> usize { x }
-            "})
-            .as_ref(),
+            "}),
         ),
     )
     .await?;
diff --git a/helix-term/tests/test/splits.rs b/helix-term/tests/test/splits.rs
index 96ced21a5..1d70f24a6 100644
--- a/helix-term/tests/test/splits.rs
+++ b/helix-term/tests/test/splits.rs
@@ -1,5 +1,7 @@
 use super::*;
 
+use helix_core::path::get_normalized_path;
+
 #[tokio::test(flavor = "multi_thread")]
 async fn test_split_write_quit_all() -> anyhow::Result<()> {
     let mut file1 = tempfile::NamedTempFile::new()?;
@@ -25,21 +27,21 @@ async fn test_split_write_quit_all() -> anyhow::Result<()> {
 
                     let doc1 = docs
                         .iter()
-                        .find(|doc| doc.path().unwrap() == file1.path())
+                        .find(|doc| doc.path().unwrap() == &get_normalized_path(file1.path()))
                         .unwrap();
 
                     assert_eq!("hello1", doc1.text().to_string());
 
                     let doc2 = docs
                         .iter()
-                        .find(|doc| doc.path().unwrap() == file2.path())
+                        .find(|doc| doc.path().unwrap() == &get_normalized_path(file2.path()))
                         .unwrap();
 
                     assert_eq!("hello2", doc2.text().to_string());
 
                     let doc3 = docs
                         .iter()
-                        .find(|doc| doc.path().unwrap() == file3.path())
+                        .find(|doc| doc.path().unwrap() == &get_normalized_path(file3.path()))
                         .unwrap();
 
                     assert_eq!("hello3", doc3.text().to_string());
diff --git a/helix-tui/Cargo.toml b/helix-tui/Cargo.toml
index a4a1c389f..5a250bdc1 100644
--- a/helix-tui/Cargo.toml
+++ b/helix-tui/Cargo.toml
@@ -16,11 +16,13 @@ include = ["src/**/*", "README.md"]
 default = ["crossterm"]
 
 [dependencies]
-bitflags = "1.3"
+bitflags = "2.0"
 cassowary = "0.3"
 unicode-segmentation = "1.10"
-crossterm = { version = "0.25", optional = true }
+crossterm = { version = "0.26", optional = true }
 termini = "0.1"
 serde = { version = "1", "optional" = true, features = ["derive"]}
+once_cell = "1.17"
+log = "~0.4"
 helix-view = { version = "0.6", path = "../helix-view", features = ["term"] }
 helix-core = { version = "0.6", path = "../helix-core" }
diff --git a/helix-tui/src/backend/crossterm.rs b/helix-tui/src/backend/crossterm.rs
index c00e1f406..9d70a9fb0 100644
--- a/helix-tui/src/backend/crossterm.rs
+++ b/helix-tui/src/backend/crossterm.rs
@@ -1,6 +1,11 @@
-use crate::{backend::Backend, buffer::Cell};
+use crate::{backend::Backend, buffer::Cell, terminal::Config};
 use crossterm::{
-    cursor::{CursorShape, Hide, MoveTo, SetCursorShape, Show},
+    cursor::{Hide, MoveTo, SetCursorStyle, Show},
+    event::{
+        DisableBracketedPaste, DisableFocusChange, DisableMouseCapture, EnableBracketedPaste,
+        EnableFocusChange, EnableMouseCapture, KeyboardEnhancementFlags,
+        PopKeyboardEnhancementFlags, PushKeyboardEnhancementFlags,
+    },
     execute, queue,
     style::{
         Attribute as CAttribute, Color as CColor, Print, SetAttribute, SetBackgroundColor,
@@ -9,7 +14,11 @@
     terminal::{self, Clear, ClearType},
     Command,
 };
-use helix_view::graphics::{Color, CursorKind, Modifier, Rect, UnderlineStyle};
+use helix_view::{
+    editor::Config as EditorConfig,
+    graphics::{Color, CursorKind, Modifier, Rect, UnderlineStyle},
+};
+use once_cell::sync::OnceCell;
 use std::{
     fmt,
     io::{self, Write},
@@ -33,14 +42,15 @@ impl Capabilities {
     /// Detect capabilities from the terminfo database located based
     /// on the $TERM environment variable. If detection fails, returns
     /// a default value where no capability is supported.
-    pub fn from_env_or_default() -> Self {
+    pub fn from_env_or_default(config: &EditorConfig) -> Self {
         match termini::TermInfo::from_env() {
             Err(_) => Capabilities::default(),
             Ok(t) => Capabilities {
                 // Smulx, VTE: https://unix.stackexchange.com/a/696253/246284
                 // Su (used by kitty): https://sw.kovidgoyal.net/kitty/underlines
                 // WezTerm supports underlines but a lot of distros don't properly install it's terminfo
-                has_extended_underlines: t.extended_cap("Smulx").is_some()
+                has_extended_underlines: config.undercurl
+                    || t.extended_cap("Smulx").is_some()
                     || t.extended_cap("Su").is_some()
                     || vte_version() >= Some(5102)
                     || matches!(term_program().as_deref(), Some("WezTerm")),
@@ -52,18 +62,37 @@ pub fn from_env_or_default() -> Self {
 pub struct CrosstermBackend<W: Write> {
     buffer: W,
     capabilities: Capabilities,
+    supports_keyboard_enhancement_protocol: OnceCell<bool>,
 }
 
 impl<W> CrosstermBackend<W>
 where
     W: Write,
 {
-    pub fn new(buffer: W) -> CrosstermBackend<W> {
+    pub fn new(buffer: W, config: &EditorConfig) -> CrosstermBackend<W> {
         CrosstermBackend {
             buffer,
-            capabilities: Capabilities::from_env_or_default(),
+            capabilities: Capabilities::from_env_or_default(config),
+            supports_keyboard_enhancement_protocol: OnceCell::new(),
         }
     }
+
+    #[inline]
+    fn supports_keyboard_enhancement_protocol(&self) -> bool {
+        *self.supports_keyboard_enhancement_protocol
+            .get_or_init(|| {
+                use std::time::Instant;
+
+                let now = Instant::now();
+                let supported = matches!(terminal::supports_keyboard_enhancement(), Ok(true));
+                log::debug!(
+                    "The keyboard enhancement protocol is {}supported in this terminal (checked in {:?})",
+                    if supported { "" } else { "not " },
+                    Instant::now().duration_since(now)
+                );
+                supported
+            })
+    }
 }
 
 impl<W> Write for CrosstermBackend<W>
@@ -83,6 +112,66 @@ impl<W> Backend for CrosstermBackend<W>
 where
     W: Write,
 {
+    fn claim(&mut self, config: Config) -> io::Result<()> {
+        terminal::enable_raw_mode()?;
+        execute!(
+            self.buffer,
+            terminal::EnterAlternateScreen,
+            EnableBracketedPaste,
+            EnableFocusChange
+        )?;
+        execute!(self.buffer, terminal::Clear(terminal::ClearType::All))?;
+        if config.enable_mouse_capture {
+            execute!(self.buffer, EnableMouseCapture)?;
+        }
+        if self.supports_keyboard_enhancement_protocol() {
+            execute!(
+                self.buffer,
+                PushKeyboardEnhancementFlags(
+                    KeyboardEnhancementFlags::DISAMBIGUATE_ESCAPE_CODES
+                        | KeyboardEnhancementFlags::REPORT_ALTERNATE_KEYS
+                )
+            )?;
+        }
+        Ok(())
+    }
+
+    fn restore(&mut self, config: Config) -> io::Result<()> {
+        // reset cursor shape
+        write!(self.buffer, "\x1B[0 q")?;
+        if config.enable_mouse_capture {
+            execute!(self.buffer, DisableMouseCapture)?;
+        }
+        if self.supports_keyboard_enhancement_protocol() {
+            execute!(self.buffer, PopKeyboardEnhancementFlags)?;
+        }
+        execute!(
+            self.buffer,
+            DisableBracketedPaste,
+            DisableFocusChange,
+            terminal::LeaveAlternateScreen
+        )?;
+        terminal::disable_raw_mode()
+    }
+
+    fn force_restore() -> io::Result<()> {
+        let mut stdout = io::stdout();
+
+        // reset cursor shape
+        write!(stdout, "\x1B[0 q")?;
+        // Ignore errors on disabling, this might trigger on windows if we call
+        // disable without calling enable previously
+        let _ = execute!(stdout, DisableMouseCapture);
+        let _ = execute!(stdout, PopKeyboardEnhancementFlags);
+        execute!(
+            stdout,
+            DisableBracketedPaste,
+            DisableFocusChange,
+            terminal::LeaveAlternateScreen
+        )?;
+        terminal::disable_raw_mode()
+    }
+
     fn draw<'a, I>(&mut self, content: I) -> io::Result<()>
     where
         I: Iterator<Item = (u16, u16, &'a Cell)>,
@@ -156,12 +245,12 @@ fn hide_cursor(&mut self) -> io::Result<()> {
 
     fn show_cursor(&mut self, kind: CursorKind) -> io::Result<()> {
         let shape = match kind {
-            CursorKind::Block => CursorShape::Block,
-            CursorKind::Bar => CursorShape::Line,
-            CursorKind::Underline => CursorShape::UnderScore,
+            CursorKind::Block => SetCursorStyle::SteadyBlock,
+            CursorKind::Bar => SetCursorStyle::SteadyBar,
+            CursorKind::Underline => SetCursorStyle::SteadyUnderScore,
             CursorKind::Hidden => unreachable!(),
         };
-        map_error(execute!(self.buffer, Show, SetCursorShape(shape)))
+        map_error(execute!(self.buffer, Show, shape))
     }
 
     fn get_cursor(&mut self) -> io::Result<(u16, u16)> {
@@ -255,9 +344,9 @@ fn queue<W>(&self, mut w: W) -> io::Result<()>
     }
 }
 
-/// Crossterm uses semicolon as a seperator for colors
-/// this is actually not spec compliant (altough commonly supported)
-/// However the correct approach is to use colons as a seperator.
+/// Crossterm uses semicolon as a separator for colors
+/// this is actually not spec compliant (although commonly supported)
+/// However the correct approach is to use colons as a separator.
 /// This usually doesn't make a difference for emulators that do support colored underlines.
 /// However terminals that do not support colored underlines will ignore underlines colors with colons
 /// while escape sequences with semicolons are always processed which leads to weird visual artifacts.
diff --git a/helix-tui/src/backend/mod.rs b/helix-tui/src/backend/mod.rs
index c6c11019d..6d7c38942 100644
--- a/helix-tui/src/backend/mod.rs
+++ b/helix-tui/src/backend/mod.rs
@@ -1,6 +1,6 @@
 use std::io;
 
-use crate::buffer::Cell;
+use crate::{buffer::Cell, terminal::Config};
 
 use helix_view::graphics::{CursorKind, Rect};
 
@@ -13,6 +13,9 @@
 pub use self::test::TestBackend;
 
 pub trait Backend {
+    fn claim(&mut self, config: Config) -> Result<(), io::Error>;
+    fn restore(&mut self, config: Config) -> Result<(), io::Error>;
+    fn force_restore() -> Result<(), io::Error>;
     fn draw<'a, I>(&mut self, content: I) -> Result<(), io::Error>
     where
         I: Iterator<Item = (u16, u16, &'a Cell)>;
diff --git a/helix-tui/src/backend/test.rs b/helix-tui/src/backend/test.rs
index 52474148e..ff133ff3e 100644
--- a/helix-tui/src/backend/test.rs
+++ b/helix-tui/src/backend/test.rs
@@ -1,6 +1,7 @@
 use crate::{
     backend::Backend,
     buffer::{Buffer, Cell},
+    terminal::Config,
 };
 use helix_core::unicode::width::UnicodeWidthStr;
 use helix_view::graphics::{CursorKind, Rect};
@@ -106,6 +107,18 @@ pub fn assert_buffer(&self, expected: &Buffer) {
 }
 
 impl Backend for TestBackend {
+    fn claim(&mut self, _config: Config) -> Result<(), io::Error> {
+        Ok(())
+    }
+
+    fn restore(&mut self, _config: Config) -> Result<(), io::Error> {
+        Ok(())
+    }
+
+    fn force_restore() -> Result<(), io::Error> {
+        Ok(())
+    }
+
     fn draw<'a, I>(&mut self, content: I) -> Result<(), io::Error>
     where
         I: Iterator<Item = (u16, u16, &'a Cell)>,
diff --git a/helix-tui/src/buffer.rs b/helix-tui/src/buffer.rs
index 9b93c4050..8e0b0adf9 100644
--- a/helix-tui/src/buffer.rs
+++ b/helix-tui/src/buffer.rs
@@ -433,7 +433,48 @@ pub fn set_string_truncated_at_end(
         (x_offset as u16, y)
     }
 
-    pub fn set_spans<'a>(&mut self, x: u16, y: u16, spans: &Spans<'a>, width: u16) -> (u16, u16) {
+    pub fn set_spans_truncated(&mut self, x: u16, y: u16, spans: &Spans, width: u16) -> (u16, u16) {
+        // prevent panic if out of range
+        if !self.in_bounds(x, y) || width == 0 {
+            return (x, y);
+        }
+
+        let mut x_offset = x as usize;
+        let max_offset = min(self.area.right(), width.saturating_add(x));
+        let mut start_index = self.index_of(x, y);
+        let mut index = self.index_of(max_offset as u16, y);
+
+        let content_width = spans.width();
+        let truncated = content_width > width as usize;
+        if truncated {
+            self.content[start_index].set_symbol("");
+            start_index += 1;
+        } else {
+            index -= width as usize - content_width;
+        }
+        for span in spans.0.iter().rev() {
+            for s in span.content.graphemes(true).rev() {
+                let width = s.width();
+                if width == 0 {
+                    continue;
+                }
+                let start = index - width;
+                if start < start_index {
+                    break;
+                }
+                self.content[start].set_symbol(s);
+                self.content[start].set_style(span.style);
+                for i in start + 1..index {
+                    self.content[i].reset();
+                }
+                index -= width;
+                x_offset += width;
+            }
+        }
+        (x_offset as u16, y)
+    }
+
+    pub fn set_spans(&mut self, x: u16, y: u16, spans: &Spans, width: u16) -> (u16, u16) {
         let mut remaining_width = width;
         let mut x = x;
         for span in &spans.0 {
@@ -454,7 +495,7 @@ pub fn set_spans<'a>(&mut self, x: u16, y: u16, spans: &Spans<'a>, width: u16) -
         (x, y)
     }
 
-    pub fn set_span<'a>(&mut self, x: u16, y: u16, span: &Span<'a>, width: u16) -> (u16, u16) {
+    pub fn set_span(&mut self, x: u16, y: u16, span: &Span, width: u16) -> (u16, u16) {
         self.set_stringn(x, y, span.content.as_ref(), width as usize, span.style)
     }
 
@@ -521,10 +562,10 @@ pub fn clear_with(&mut self, area: Rect, style: Style) {
     pub fn merge(&mut self, other: &Buffer) {
         let area = self.area.union(other.area);
         let cell: Cell = Default::default();
-        self.content.resize(area.area() as usize, cell.clone());
+        self.content.resize(area.area(), cell.clone());
 
         // Move original content to the appropriate space
-        let size = self.area.area() as usize;
+        let size = self.area.area();
         for i in (0..size).rev() {
             let (x, y) = self.pos_of(i);
             // New index in content
@@ -537,7 +578,7 @@ pub fn merge(&mut self, other: &Buffer) {
 
         // Push content of the other buffer into this one (may erase previous
         // data)
-        let size = other.area.area() as usize;
+        let size = other.area.area();
         for i in 0..size {
             let (x, y) = other.pos_of(i);
             // New index in content
diff --git a/helix-tui/src/lib.rs b/helix-tui/src/lib.rs
index 2636b268f..59327d7c3 100644
--- a/helix-tui/src/lib.rs
+++ b/helix-tui/src/lib.rs
@@ -25,10 +25,12 @@
 //! use std::io;
 //! use helix_tui::Terminal;
 //! use helix_tui::backend::CrosstermBackend;
+//! use helix_view::editor::Config;
 //!
 //! fn main() -> Result<(), io::Error> {
 //!     let stdout = io::stdout();
-//!     let backend = CrosstermBackend::new(stdout);
+//!     let config = Config::default();
+//!     let backend = CrosstermBackend::new(stdout, &config);
 //!     let mut terminal = Terminal::new(backend)?;
 //!     Ok(())
 //! }
@@ -56,11 +58,13 @@
 //! use helix_tui::backend::CrosstermBackend;
 //! use helix_tui::widgets::{Widget, Block, Borders};
 //! use helix_tui::layout::{Layout, Constraint, Direction};
+//! use helix_view::editor::Config;
 //!
 //! fn main() -> Result<(), io::Error> {
 //!     terminal::enable_raw_mode().unwrap();
 //!     let stdout = io::stdout();
-//!     let backend = CrosstermBackend::new(stdout);
+//!     let config = Config::default();
+//!     let backend = CrosstermBackend::new(stdout, &config);
 //!     let mut terminal = Terminal::new(backend)?;
 //!     // terminal.draw(|f| {
 //!     //     let size = f.size();
@@ -86,11 +90,13 @@
 //! use helix_tui::backend::CrosstermBackend;
 //! use helix_tui::widgets::{Widget, Block, Borders};
 //! use helix_tui::layout::{Layout, Constraint, Direction};
+//! use helix_view::editor::Config;
 //!
 //! fn main() -> Result<(), io::Error> {
 //!     terminal::enable_raw_mode().unwrap();
 //!     let stdout = io::stdout();
-//!     let backend = CrosstermBackend::new(stdout);
+//!     let config = Config::default();
+//!     let backend = CrosstermBackend::new(stdout, &config);
 //!     let mut terminal = Terminal::new(backend)?;
 //!     // terminal.draw(|f| {
 //!     //     let chunks = Layout::default()
diff --git a/helix-tui/src/terminal.rs b/helix-tui/src/terminal.rs
index 22e9232f3..802a8c1d9 100644
--- a/helix-tui/src/terminal.rs
+++ b/helix-tui/src/terminal.rs
@@ -1,4 +1,5 @@
 use crate::{backend::Backend, buffer::Buffer};
+use helix_view::editor::Config as EditorConfig;
 use helix_view::graphics::{CursorKind, Rect};
 use std::io;
 
@@ -16,6 +17,19 @@ pub struct Viewport {
     resize_behavior: ResizeBehavior,
 }
 
+#[derive(Debug)]
+pub struct Config {
+    pub enable_mouse_capture: bool,
+}
+
+impl From<EditorConfig> for Config {
+    fn from(config: EditorConfig) -> Self {
+        Self {
+            enable_mouse_capture: config.mouse,
+        }
+    }
+}
+
 impl Viewport {
     /// UNSTABLE
     pub fn fixed(area: Rect) -> Viewport {
@@ -98,6 +112,14 @@ pub fn with_options(backend: B, options: TerminalOptions) -> io::Result<Terminal
         })
     }
 
+    pub fn claim(&mut self, config: Config) -> io::Result<()> {
+        self.backend.claim(config)
+    }
+
+    pub fn restore(&mut self, config: Config) -> io::Result<()> {
+        self.backend.restore(config)
+    }
+
     // /// Get a Frame object which provides a consistent view into the terminal state for rendering.
     // pub fn get_frame(&mut self) -> Frame<B> {
     //     Frame {
diff --git a/helix-tui/src/text.rs b/helix-tui/src/text.rs
index ccdafad5f..076766dd6 100644
--- a/helix-tui/src/text.rs
+++ b/helix-tui/src/text.rs
@@ -436,6 +436,34 @@ fn from(lines: Vec<Spans<'a>>) -> Text<'a> {
     }
 }
 
+impl<'a> From<Text<'a>> for String {
+    fn from(text: Text<'a>) -> String {
+        String::from(&text)
+    }
+}
+
+impl<'a> From<&Text<'a>> for String {
+    fn from(text: &Text<'a>) -> String {
+        let size = text
+            .lines
+            .iter()
+            .flat_map(|spans| spans.0.iter().map(|span| span.content.len()))
+            .sum::<usize>()
+            + text.lines.len().saturating_sub(1); // for newline after each line
+        let mut output = String::with_capacity(size);
+
+        for spans in &text.lines {
+            if !output.is_empty() {
+                output.push('\n');
+            }
+            for span in &spans.0 {
+                output.push_str(&span.content);
+            }
+        }
+        output
+    }
+}
+
 impl<'a> IntoIterator for Text<'a> {
     type Item = Spans<'a>;
     type IntoIter = std::vec::IntoIter<Self::Item>;
diff --git a/helix-tui/src/widgets/block.rs b/helix-tui/src/widgets/block.rs
index 98f84abe2..a6fdde4c0 100644
--- a/helix-tui/src/widgets/block.rs
+++ b/helix-tui/src/widgets/block.rs
@@ -7,8 +7,9 @@
 use helix_view::graphics::{Rect, Style};
 
 /// Border render type. Defaults to [`BorderType::Plain`].
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
 pub enum BorderType {
+    #[default]
     Plain,
     Rounded,
     Double,
@@ -26,12 +27,6 @@ pub fn line_symbols(border_type: Self) -> line::Set {
     }
 }
 
-impl Default for BorderType {
-    fn default() -> BorderType {
-        BorderType::Plain
-    }
-}
-
 /// Base widget to be used with all upper level ones. It may be used to display a box border around
 /// the widget and/or add a title.
 ///
diff --git a/helix-tui/src/widgets/mod.rs b/helix-tui/src/widgets/mod.rs
index 8946ef056..3a0dfc5d8 100644
--- a/helix-tui/src/widgets/mod.rs
+++ b/helix-tui/src/widgets/mod.rs
@@ -27,7 +27,7 @@
 
 bitflags! {
     /// Bitflags that can be composed to set the visible borders essentially on the block widget.
-    #[derive(Default)]
+    #[derive(Debug, PartialEq, Eq, Clone, Copy, Default)]
     pub struct Borders: u8 {
         /// Show the top border
         const TOP = 0b0000_0001;
@@ -38,7 +38,7 @@ pub struct Borders: u8 {
         /// Show the left border
         const LEFT = 0b0000_1000;
         /// Show all borders
-        const ALL = Self::TOP.bits | Self::RIGHT.bits | Self::BOTTOM.bits | Self::LEFT.bits;
+        const ALL = Self::TOP.bits() | Self::RIGHT.bits() | Self::BOTTOM.bits() | Self::LEFT.bits();
     }
 }
 
diff --git a/helix-tui/src/widgets/table.rs b/helix-tui/src/widgets/table.rs
index a8f428a7a..97762167e 100644
--- a/helix-tui/src/widgets/table.rs
+++ b/helix-tui/src/widgets/table.rs
@@ -4,14 +4,8 @@
     text::Text,
     widgets::{Block, Widget},
 };
-use cassowary::{
-    strength::{MEDIUM, REQUIRED, WEAK},
-    WeightedRelation::*,
-    {Expression, Solver},
-};
 use helix_core::unicode::width::UnicodeWidthStr;
 use helix_view::graphics::{Rect, Style};
-use std::collections::HashMap;
 
 /// A [`Cell`] contains the [`Text`] to be displayed in a [`Row`] of a [`Table`].
 ///
@@ -126,6 +120,17 @@ pub fn bottom_margin(mut self, margin: u16) -> Self {
     fn total_height(&self) -> u16 {
         self.height.saturating_add(self.bottom_margin)
     }
+
+    /// Returns the contents of cells as plain text, without styles and colors.
+    pub fn cell_text(&self) -> impl Iterator<Item = String> + '_ {
+        self.cells.iter().map(|cell| String::from(&cell.content))
+    }
+}
+
+impl<'a, T: Into<Cell<'a>>> From<T> for Row<'a> {
+    fn from(cell: T) -> Self {
+        Row::new(vec![cell.into()])
+    }
 }
 
 /// A widget to display data in formatted columns.
@@ -260,69 +265,32 @@ pub fn column_spacing(mut self, spacing: u16) -> Self {
     }
 
     fn get_columns_widths(&self, max_width: u16, has_selection: bool) -> Vec<u16> {
-        let mut solver = Solver::new();
-        let mut var_indices = HashMap::new();
-        let mut ccs = Vec::new();
-        let mut variables = Vec::new();
-        for i in 0..self.widths.len() {
-            let var = cassowary::Variable::new();
-            variables.push(var);
-            var_indices.insert(var, i);
-        }
-        let spacing_width = (variables.len() as u16).saturating_sub(1) * self.column_spacing;
-        let mut available_width = max_width.saturating_sub(spacing_width);
+        let mut constraints = Vec::with_capacity(self.widths.len() * 2 + 1);
         if has_selection {
             let highlight_symbol_width =
                 self.highlight_symbol.map(|s| s.width() as u16).unwrap_or(0);
-            available_width = available_width.saturating_sub(highlight_symbol_width);
+            constraints.push(Constraint::Length(highlight_symbol_width));
         }
-        for (i, constraint) in self.widths.iter().enumerate() {
-            ccs.push(variables[i] | GE(WEAK) | 0.);
-            ccs.push(match *constraint {
-                Constraint::Length(v) => variables[i] | EQ(MEDIUM) | f64::from(v),
-                Constraint::Percentage(v) => {
-                    variables[i] | EQ(WEAK) | (f64::from(v * available_width) / 100.0)
-                }
-                Constraint::Ratio(n, d) => {
-                    variables[i]
-                        | EQ(WEAK)
-                        | (f64::from(available_width) * f64::from(n) / f64::from(d))
-                }
-                Constraint::Min(v) => variables[i] | GE(WEAK) | f64::from(v),
-                Constraint::Max(v) => variables[i] | LE(WEAK) | f64::from(v),
-            })
+        for constraint in self.widths {
+            constraints.push(*constraint);
+            constraints.push(Constraint::Length(self.column_spacing));
         }
-        solver
-            .add_constraint(
-                variables
-                    .iter()
-                    .fold(Expression::from_constant(0.), |acc, v| acc + *v)
-                    | LE(REQUIRED)
-                    | f64::from(available_width),
-            )
-            .unwrap();
-        solver.add_constraints(&ccs).unwrap();
-        let mut widths = vec![0; variables.len()];
-        for &(var, value) in solver.fetch_changes() {
-            let index = var_indices[&var];
-            let value = if value.is_sign_negative() {
-                0
-            } else {
-                value.round() as u16
-            };
-            widths[index] = value;
+        if !self.widths.is_empty() {
+            constraints.pop();
         }
-        // Cassowary could still return columns widths greater than the max width when there are
-        // fixed length constraints that cannot be satisfied. Therefore, we clamp the widths from
-        // left to right.
-        let mut available_width = max_width;
-        for w in &mut widths {
-            *w = available_width.min(*w);
-            available_width = available_width
-                .saturating_sub(*w)
-                .saturating_sub(self.column_spacing);
+        let mut chunks = crate::layout::Layout::default()
+            .direction(crate::layout::Direction::Horizontal)
+            .constraints(constraints)
+            .split(Rect {
+                x: 0,
+                y: 0,
+                width: max_width,
+                height: 1,
+            });
+        if has_selection {
+            chunks.remove(0);
         }
-        widths
+        chunks.iter().step_by(2).map(|c| c.width).collect()
     }
 
     fn get_row_bounds(
@@ -386,7 +354,13 @@ pub fn select(&mut self, index: Option<usize>) {
 impl<'a> Table<'a> {
     // type State = TableState;
 
-    pub fn render_table(mut self, area: Rect, buf: &mut Buffer, state: &mut TableState) {
+    pub fn render_table(
+        mut self,
+        area: Rect,
+        buf: &mut Buffer,
+        state: &mut TableState,
+        truncate: bool,
+    ) {
         if area.area() == 0 {
             return;
         }
@@ -433,6 +407,7 @@ pub fn render_table(mut self, area: Rect, buf: &mut Buffer, state: &mut TableSta
                         width: *width,
                         height: max_header_height,
                     },
+                    truncate,
                 );
                 col += *width + self.column_spacing;
             }
@@ -477,6 +452,9 @@ pub fn render_table(mut self, area: Rect, buf: &mut Buffer, state: &mut TableSta
             };
             let mut col = table_row_start_col;
             for (width, cell) in columns_widths.iter().zip(table_row.cells.iter()) {
+                if is_selected {
+                    buf.set_style(table_row_area, self.highlight_style);
+                }
                 render_cell(
                     buf,
                     cell,
@@ -486,30 +464,32 @@ pub fn render_table(mut self, area: Rect, buf: &mut Buffer, state: &mut TableSta
                         width: *width,
                         height: table_row.height,
                     },
+                    truncate,
                 );
                 col += *width + self.column_spacing;
             }
-            if is_selected {
-                buf.set_style(table_row_area, self.highlight_style);
-            }
         }
     }
 }
 
-fn render_cell(buf: &mut Buffer, cell: &Cell, area: Rect) {
+fn render_cell(buf: &mut Buffer, cell: &Cell, area: Rect, truncate: bool) {
     buf.set_style(area, cell.style);
     for (i, spans) in cell.content.lines.iter().enumerate() {
         if i as u16 >= area.height {
             break;
         }
-        buf.set_spans(area.x, area.y + i as u16, spans, area.width);
+        if truncate {
+            buf.set_spans_truncated(area.x, area.y + i as u16, spans, area.width);
+        } else {
+            buf.set_spans(area.x, area.y + i as u16, spans, area.width);
+        }
     }
 }
 
 impl<'a> Widget for Table<'a> {
     fn render(self, area: Rect, buf: &mut Buffer) {
         let mut state = TableState::default();
-        Table::render_table(self, area, buf, &mut state);
+        Table::render_table(self, area, buf, &mut state, false);
     }
 }
 
diff --git a/helix-vcs/Cargo.toml b/helix-vcs/Cargo.toml
index e54cf828f..8a226a0bb 100644
--- a/helix-vcs/Cargo.toml
+++ b/helix-vcs/Cargo.toml
@@ -15,14 +15,16 @@ helix-core = { version = "0.6", path = "../helix-core" }
 
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "time", "sync", "parking_lot", "macros"] }
 parking_lot = "0.12"
+arc-swap = { version = "1.6.0" }
 
-git-repository = { version = "0.29", default-features = false , optional = true }
+gix = { version = "0.43.0", default-features = false , optional = true }
 imara-diff = "0.1.5"
+anyhow = "1"
 
 log = "0.4"
 
 [features]
-git = ["git-repository"]
+git = ["gix"]
 
 [dev-dependencies]
-tempfile = "3.3"
\ No newline at end of file
+tempfile = "3.4"
\ No newline at end of file
diff --git a/helix-vcs/src/diff.rs b/helix-vcs/src/diff.rs
index 9c6a362f7..ca33dda44 100644
--- a/helix-vcs/src/diff.rs
+++ b/helix-vcs/src/diff.rs
@@ -28,11 +28,18 @@ struct Event {
     render_lock: Option<RenderLock>,
 }
 
+#[derive(Clone, Debug, Default)]
+struct DiffInner {
+    diff_base: Rope,
+    doc: Rope,
+    hunks: Vec<Hunk>,
+}
+
 #[derive(Clone, Debug)]
 pub struct DiffHandle {
     channel: UnboundedSender<Event>,
     render_lock: Arc<RwLock<()>>,
-    hunks: Arc<Mutex<Vec<Hunk>>>,
+    diff: Arc<Mutex<DiffInner>>,
     inverted: bool,
 }
 
@@ -47,10 +54,10 @@ fn new_with_handle(
         redraw_handle: RedrawHandle,
     ) -> (DiffHandle, JoinHandle<()>) {
         let (sender, receiver) = unbounded_channel();
-        let hunks: Arc<Mutex<Vec<Hunk>>> = Arc::default();
+        let diff: Arc<Mutex<DiffInner>> = Arc::default();
         let worker = DiffWorker {
             channel: receiver,
-            hunks: hunks.clone(),
+            diff: diff.clone(),
             new_hunks: Vec::default(),
             redraw_notify: redraw_handle.0,
             diff_finished_notify: Arc::default(),
@@ -58,7 +65,7 @@ fn new_with_handle(
         let handle = tokio::spawn(worker.run(diff_base, doc));
         let differ = DiffHandle {
             channel: sender,
-            hunks,
+            diff,
             inverted: false,
             render_lock: redraw_handle.1,
         };
@@ -69,9 +76,9 @@ pub fn invert(&mut self) {
         self.inverted = !self.inverted;
     }
 
-    pub fn hunks(&self) -> FileHunks {
-        FileHunks {
-            hunks: self.hunks.lock(),
+    pub fn load(&self) -> Diff {
+        Diff {
+            diff: self.diff.lock(),
             inverted: self.inverted,
         }
     }
@@ -168,12 +175,28 @@ pub fn is_pure_removal(&self) -> bool {
 /// A list of changes in a file sorted in ascending
 /// non-overlapping order
 #[derive(Debug)]
-pub struct FileHunks<'a> {
-    hunks: MutexGuard<'a, Vec<Hunk>>,
+pub struct Diff<'a> {
+    diff: MutexGuard<'a, DiffInner>,
     inverted: bool,
 }
 
-impl FileHunks<'_> {
+impl Diff<'_> {
+    pub fn diff_base(&self) -> &Rope {
+        if self.inverted {
+            &self.diff.doc
+        } else {
+            &self.diff.diff_base
+        }
+    }
+
+    pub fn doc(&self) -> &Rope {
+        if self.inverted {
+            &self.diff.diff_base
+        } else {
+            &self.diff.doc
+        }
+    }
+
     pub fn is_inverted(&self) -> bool {
         self.inverted
     }
@@ -181,7 +204,7 @@ pub fn is_inverted(&self) -> bool {
     /// Returns the `Hunk` for the `n`th change in this file.
     /// if there is no `n`th change  `Hunk::NONE` is returned instead.
     pub fn nth_hunk(&self, n: u32) -> Hunk {
-        match self.hunks.get(n as usize) {
+        match self.diff.hunks.get(n as usize) {
             Some(hunk) if self.inverted => hunk.invert(),
             Some(hunk) => hunk.clone(),
             None => Hunk::NONE,
@@ -189,7 +212,7 @@ pub fn nth_hunk(&self, n: u32) -> Hunk {
     }
 
     pub fn len(&self) -> u32 {
-        self.hunks.len() as u32
+        self.diff.hunks.len() as u32
     }
 
     pub fn is_empty(&self) -> bool {
@@ -204,19 +227,20 @@ pub fn next_hunk(&self, line: u32) -> Option<u32> {
         };
 
         let res = self
+            .diff
             .hunks
             .binary_search_by_key(&line, |hunk| hunk_range(hunk).start);
 
         match res {
             // Search found a hunk that starts exactly at this line, return the next hunk if it exists.
-            Ok(pos) if pos + 1 == self.hunks.len() => None,
+            Ok(pos) if pos + 1 == self.diff.hunks.len() => None,
             Ok(pos) => Some(pos as u32 + 1),
 
             // No hunk starts exactly at this line, so the search returns
             // the position where a hunk starting at this line should be inserted.
             // That position is exactly the position of the next hunk or the end
             // of the list if no such hunk exists
-            Err(pos) if pos == self.hunks.len() => None,
+            Err(pos) if pos == self.diff.hunks.len() => None,
             Err(pos) => Some(pos as u32),
         }
     }
@@ -228,6 +252,7 @@ pub fn prev_hunk(&self, line: u32) -> Option<u32> {
             |hunk: &Hunk| hunk.after.clone()
         };
         let res = self
+            .diff
             .hunks
             .binary_search_by_key(&line, |hunk| hunk_range(hunk).end);
 
@@ -237,7 +262,7 @@ pub fn prev_hunk(&self, line: u32) -> Option<u32> {
             // which represents a pure removal.
             // Removals are technically empty but are still shown as single line hunks
             // and as such we must jump to the previous hunk (if it exists) if we are already inside the removal
-            Ok(pos) if !hunk_range(&self.hunks[pos]).is_empty() => Some(pos as u32),
+            Ok(pos) if !hunk_range(&self.diff.hunks[pos]).is_empty() => Some(pos as u32),
 
             // No hunk ends exactly at this line, so the search returns
             // the position where a hunk ending at this line should be inserted.
@@ -255,6 +280,7 @@ pub fn hunk_at(&self, line: u32, include_removal: bool) -> Option<u32> {
         };
 
         let res = self
+            .diff
             .hunks
             .binary_search_by_key(&line, |hunk| hunk_range(hunk).start);
 
@@ -267,7 +293,7 @@ pub fn hunk_at(&self, line: u32, include_removal: bool) -> Option<u32> {
             // The previous hunk contains this hunk if it exists and doesn't end before this line
             Err(0) => None,
             Err(pos) => {
-                let hunk = hunk_range(&self.hunks[pos - 1]);
+                let hunk = hunk_range(&self.diff.hunks[pos - 1]);
                 if hunk.end > line || include_removal && hunk.start == line && hunk.is_empty() {
                     Some(pos as u32 - 1)
                 } else {
diff --git a/helix-vcs/src/diff/line_cache.rs b/helix-vcs/src/diff/line_cache.rs
index c3ee5daa3..8e48250f1 100644
--- a/helix-vcs/src/diff/line_cache.rs
+++ b/helix-vcs/src/diff/line_cache.rs
@@ -43,6 +43,14 @@ pub fn new(diff_base: Rope, doc: Rope) -> InternedRopeLines {
         res
     }
 
+    pub fn doc(&self) -> Rope {
+        self.doc.clone()
+    }
+
+    pub fn diff_base(&self) -> Rope {
+        self.diff_base.clone()
+    }
+
     /// Updates the `diff_base` and optionally the document if `doc` is not None
     pub fn update_diff_base(&mut self, diff_base: Rope, doc: Option<Rope>) {
         self.interned.clear();
diff --git a/helix-vcs/src/diff/worker.rs b/helix-vcs/src/diff/worker.rs
index f4bb4dbfb..5406446fd 100644
--- a/helix-vcs/src/diff/worker.rs
+++ b/helix-vcs/src/diff/worker.rs
@@ -10,7 +10,7 @@
 use tokio::time::{timeout, timeout_at, Duration};
 
 use crate::diff::{
-    Event, RenderLock, ALGORITHM, DIFF_DEBOUNCE_TIME_ASYNC, DIFF_DEBOUNCE_TIME_SYNC,
+    DiffInner, Event, RenderLock, ALGORITHM, DIFF_DEBOUNCE_TIME_ASYNC, DIFF_DEBOUNCE_TIME_SYNC,
 };
 
 use super::line_cache::InternedRopeLines;
@@ -21,7 +21,7 @@
 
 pub(super) struct DiffWorker {
     pub channel: UnboundedReceiver<Event>,
-    pub hunks: Arc<Mutex<Vec<Hunk>>>,
+    pub diff: Arc<Mutex<DiffInner>>,
     pub new_hunks: Vec<Hunk>,
     pub redraw_notify: Arc<Notify>,
     pub diff_finished_notify: Arc<Notify>,
@@ -46,7 +46,7 @@ pub async fn run(mut self, diff_base: Rope, doc: Rope) {
         if let Some(lines) = interner.interned_lines() {
             self.perform_diff(lines);
         }
-        self.apply_hunks();
+        self.apply_hunks(interner.diff_base(), interner.doc());
         while let Some(event) = self.channel.recv().await {
             let (doc, diff_base) = self.accumulate_events(event).await;
 
@@ -70,15 +70,18 @@ pub async fn run(mut self, diff_base: Rope, doc: Rope) {
             #[cfg(not(test))]
             tokio::task::block_in_place(process_accumulated_events);
 
-            self.apply_hunks();
+            self.apply_hunks(interner.diff_base(), interner.doc());
         }
     }
 
     /// update the hunks (used by the gutter) by replacing it with `self.new_hunks`.
     /// `self.new_hunks` is always empty after this function runs.
     /// To improve performance this function tries to reuse the allocation of the old diff previously stored in `self.line_diffs`
-    fn apply_hunks(&mut self) {
-        swap(&mut *self.hunks.lock(), &mut self.new_hunks);
+    fn apply_hunks(&mut self, diff_base: Rope, doc: Rope) {
+        let mut diff = self.diff.lock();
+        diff.diff_base = diff_base;
+        diff.doc = doc;
+        swap(&mut diff.hunks, &mut self.new_hunks);
         self.diff_finished_notify.notify_waiters();
         self.new_hunks.clear();
     }
diff --git a/helix-vcs/src/diff/worker/test.rs b/helix-vcs/src/diff/worker/test.rs
index 144424265..6a68d987c 100644
--- a/helix-vcs/src/diff/worker/test.rs
+++ b/helix-vcs/src/diff/worker/test.rs
@@ -12,12 +12,12 @@ fn new_test(diff_base: &str, doc: &str) -> (DiffHandle, JoinHandle<()>) {
         )
     }
     async fn into_diff(self, handle: JoinHandle<()>) -> Vec<Hunk> {
-        let hunks = self.hunks;
+        let diff = self.diff;
         // dropping the channel terminates the task
         drop(self.channel);
         handle.await.unwrap();
-        let hunks = hunks.lock();
-        Vec::clone(&*hunks)
+        let diff = diff.lock();
+        Vec::clone(&diff.hunks)
     }
 }
 
diff --git a/helix-vcs/src/git.rs b/helix-vcs/src/git.rs
index 432159b6c..00a2c596d 100644
--- a/helix-vcs/src/git.rs
+++ b/helix-vcs/src/git.rs
@@ -1,9 +1,11 @@
+use anyhow::{bail, Context, Result};
+use arc_swap::ArcSwap;
 use std::path::Path;
+use std::sync::Arc;
 
-use git::objs::tree::EntryMode;
-use git::sec::trust::DefaultForLevel;
-use git::{Commit, ObjectId, Repository, ThreadSafeRepository};
-use git_repository as git;
+use gix::objs::tree::EntryMode;
+use gix::sec::trust::DefaultForLevel;
+use gix::{Commit, ObjectId, Repository, ThreadSafeRepository};
 
 use crate::DiffProvider;
 
@@ -13,15 +15,15 @@
 pub struct Git;
 
 impl Git {
-    fn open_repo(path: &Path, ceiling_dir: Option<&Path>) -> Option<ThreadSafeRepository> {
+    fn open_repo(path: &Path, ceiling_dir: Option<&Path>) -> Result<ThreadSafeRepository> {
         // custom open options
-        let mut git_open_opts_map = git::sec::trust::Mapping::<git::open::Options>::default();
+        let mut git_open_opts_map = gix::sec::trust::Mapping::<gix::open::Options>::default();
 
         // On windows various configuration options are bundled as part of the installations
         // This path depends on the install location of git and therefore requires some overhead to lookup
         // This is basically only used on windows and has some overhead hence it's disabled on other platforms.
         // `gitoxide` doesn't use this as default
-        let config = git::permissions::Config {
+        let config = gix::permissions::Config {
             system: true,
             git: true,
             user: true,
@@ -30,40 +32,45 @@ fn open_repo(path: &Path, ceiling_dir: Option<&Path>) -> Option<ThreadSafeReposi
             git_binary: cfg!(windows),
         };
         // change options for config permissions without touching anything else
-        git_open_opts_map.reduced = git_open_opts_map.reduced.permissions(git::Permissions {
+        git_open_opts_map.reduced = git_open_opts_map.reduced.permissions(gix::Permissions {
             config,
-            ..git::Permissions::default_for_level(git::sec::Trust::Reduced)
+            ..gix::Permissions::default_for_level(gix::sec::Trust::Reduced)
         });
-        git_open_opts_map.full = git_open_opts_map.full.permissions(git::Permissions {
+        git_open_opts_map.full = git_open_opts_map.full.permissions(gix::Permissions {
             config,
-            ..git::Permissions::default_for_level(git::sec::Trust::Full)
+            ..gix::Permissions::default_for_level(gix::sec::Trust::Full)
         });
 
-        let mut open_options = git::discover::upwards::Options::default();
+        let mut open_options = gix::discover::upwards::Options::default();
         if let Some(ceiling_dir) = ceiling_dir {
             open_options.ceiling_dirs = vec![ceiling_dir.to_owned()];
         }
 
-        ThreadSafeRepository::discover_with_environment_overrides_opts(
+        let res = ThreadSafeRepository::discover_with_environment_overrides_opts(
             path,
             open_options,
             git_open_opts_map,
-        )
-        .ok()
+        )?;
+
+        Ok(res)
     }
 }
 
 impl DiffProvider for Git {
-    fn get_diff_base(&self, file: &Path) -> Option<Vec<u8>> {
+    fn get_diff_base(&self, file: &Path) -> Result<Vec<u8>> {
         debug_assert!(!file.exists() || file.is_file());
         debug_assert!(file.is_absolute());
 
         // TODO cache repository lookup
-        let repo = Git::open_repo(file.parent()?, None)?.to_thread_local();
-        let head = repo.head_commit().ok()?;
+
+        let repo_dir = file.parent().context("file has no parent directory")?;
+        let repo = Git::open_repo(repo_dir, None)
+            .context("failed to open git repo")?
+            .to_thread_local();
+        let head = repo.head_commit()?;
         let file_oid = find_file_in_commit(&repo, &head, file)?;
 
-        let file_object = repo.find_object(file_oid).ok()?;
+        let file_object = repo.find_object(file_oid)?;
         let mut data = file_object.detach().data;
         // convert LF to CRLF if configured to avoid showing every line as changed
         if repo
@@ -86,20 +93,42 @@ fn get_diff_base(&self, file: &Path) -> Option<Vec<u8>> {
             }
             data = normalized_file
         }
-        Some(data)
+        Ok(data)
+    }
+
+    fn get_current_head_name(&self, file: &Path) -> Result<Arc<ArcSwap<Box<str>>>> {
+        debug_assert!(!file.exists() || file.is_file());
+        debug_assert!(file.is_absolute());
+        let repo_dir = file.parent().context("file has no parent directory")?;
+        let repo = Git::open_repo(repo_dir, None)
+            .context("failed to open git repo")?
+            .to_thread_local();
+        let head_ref = repo.head_ref()?;
+        let head_commit = repo.head_commit()?;
+
+        let name = match head_ref {
+            Some(reference) => reference.name().shorten().to_string(),
+            None => head_commit.id.to_hex_with_len(8).to_string(),
+        };
+
+        Ok(Arc::new(ArcSwap::from_pointee(name.into_boxed_str())))
     }
 }
 
 /// Finds the object that contains the contents of a file at a specific commit.
-fn find_file_in_commit(repo: &Repository, commit: &Commit, file: &Path) -> Option<ObjectId> {
-    let repo_dir = repo.work_dir()?;
-    let rel_path = file.strip_prefix(repo_dir).ok()?;
-    let tree = commit.tree().ok()?;
-    let tree_entry = tree.lookup_entry_by_path(rel_path).ok()??;
+fn find_file_in_commit(repo: &Repository, commit: &Commit, file: &Path) -> Result<ObjectId> {
+    let repo_dir = repo.work_dir().context("repo has no worktree")?;
+    let rel_path = file.strip_prefix(repo_dir)?;
+    let tree = commit.tree()?;
+    let tree_entry = tree
+        .lookup_entry_by_path(rel_path)?
+        .context("file is untracked")?;
     match tree_entry.mode() {
         // not a file, everything is new, do not show diff
-        EntryMode::Tree | EntryMode::Commit | EntryMode::Link => None,
+        mode @ (EntryMode::Tree | EntryMode::Commit | EntryMode::Link) => {
+            bail!("entry at {} is not a file but a {mode:?}", file.display())
+        }
         // found a file
-        EntryMode::Blob | EntryMode::BlobExecutable => Some(tree_entry.object_id()),
+        EntryMode::Blob | EntryMode::BlobExecutable => Ok(tree_entry.object_id()),
     }
 }
diff --git a/helix-vcs/src/git/test.rs b/helix-vcs/src/git/test.rs
index d6e9af088..9c67d2c33 100644
--- a/helix-vcs/src/git/test.rs
+++ b/helix-vcs/src/git/test.rs
@@ -54,7 +54,7 @@ fn missing_file() {
     let file = temp_git.path().join("file.txt");
     File::create(&file).unwrap().write_all(b"foo").unwrap();
 
-    assert_eq!(Git.get_diff_base(&file), None);
+    assert!(Git.get_diff_base(&file).is_err());
 }
 
 #[test]
@@ -64,7 +64,7 @@ fn unmodified_file() {
     let contents = b"foo".as_slice();
     File::create(&file).unwrap().write_all(contents).unwrap();
     create_commit(temp_git.path(), true);
-    assert_eq!(Git.get_diff_base(&file), Some(Vec::from(contents)));
+    assert_eq!(Git.get_diff_base(&file).unwrap(), Vec::from(contents));
 }
 
 #[test]
@@ -76,7 +76,7 @@ fn modified_file() {
     create_commit(temp_git.path(), true);
     File::create(&file).unwrap().write_all(b"bar").unwrap();
 
-    assert_eq!(Git.get_diff_base(&file), Some(Vec::from(contents)));
+    assert_eq!(Git.get_diff_base(&file).unwrap(), Vec::from(contents));
 }
 
 /// Test that `get_file_head` does not return content for a directory.
@@ -89,13 +89,13 @@ fn directory() {
     std::fs::create_dir(&dir).expect("");
     let file = dir.join("file.txt");
     let contents = b"foo".as_slice();
-    File::create(&file).unwrap().write_all(contents).unwrap();
+    File::create(file).unwrap().write_all(contents).unwrap();
 
     create_commit(temp_git.path(), true);
 
     std::fs::remove_dir_all(&dir).unwrap();
     File::create(&dir).unwrap().write_all(b"bar").unwrap();
-    assert_eq!(Git.get_diff_base(&dir), None);
+    assert!(Git.get_diff_base(&dir).is_err());
 }
 
 /// Test that `get_file_head` does not return content for a symlink.
@@ -116,6 +116,6 @@ fn symlink() {
     symlink("file.txt", &file_link).unwrap();
 
     create_commit(temp_git.path(), true);
-    assert_eq!(Git.get_diff_base(&file_link), None);
-    assert_eq!(Git.get_diff_base(&file), Some(Vec::from(contents)));
+    assert!(Git.get_diff_base(&file_link).is_err());
+    assert_eq!(Git.get_diff_base(&file).unwrap(), Vec::from(contents));
 }
diff --git a/helix-vcs/src/lib.rs b/helix-vcs/src/lib.rs
index 97320d325..4d3a3623b 100644
--- a/helix-vcs/src/lib.rs
+++ b/helix-vcs/src/lib.rs
@@ -1,4 +1,6 @@
-use std::path::Path;
+use anyhow::{bail, Result};
+use arc_swap::ArcSwap;
+use std::{path::Path, sync::Arc};
 
 #[cfg(feature = "git")]
 pub use git::Git;
@@ -17,14 +19,19 @@ pub trait DiffProvider {
     /// if this provider is used.
     /// The data is returned as raw byte without any decoding or encoding performed
     /// to ensure all file encodings are handled correctly.
-    fn get_diff_base(&self, file: &Path) -> Option<Vec<u8>>;
+    fn get_diff_base(&self, file: &Path) -> Result<Vec<u8>>;
+    fn get_current_head_name(&self, file: &Path) -> Result<Arc<ArcSwap<Box<str>>>>;
 }
 
 #[doc(hidden)]
 pub struct Dummy;
 impl DiffProvider for Dummy {
-    fn get_diff_base(&self, _file: &Path) -> Option<Vec<u8>> {
-        None
+    fn get_diff_base(&self, _file: &Path) -> Result<Vec<u8>> {
+        bail!("helix was compiled without git support")
+    }
+
+    fn get_current_head_name(&self, _file: &Path) -> Result<Arc<ArcSwap<Box<str>>>> {
+        bail!("helix was compiled without git support")
     }
 }
 
@@ -36,7 +43,27 @@ impl DiffProviderRegistry {
     pub fn get_diff_base(&self, file: &Path) -> Option<Vec<u8>> {
         self.providers
             .iter()
-            .find_map(|provider| provider.get_diff_base(file))
+            .find_map(|provider| match provider.get_diff_base(file) {
+                Ok(res) => Some(res),
+                Err(err) => {
+                    log::error!("{err:#?}");
+                    log::error!("failed to open diff base for {}", file.display());
+                    None
+                }
+            })
+    }
+
+    pub fn get_current_head_name(&self, file: &Path) -> Option<Arc<ArcSwap<Box<str>>>> {
+        self.providers
+            .iter()
+            .find_map(|provider| match provider.get_current_head_name(file) {
+                Ok(res) => Some(res),
+                Err(err) => {
+                    log::error!("{err:#?}");
+                    log::error!("failed to obtain current head name for {}", file.display());
+                    None
+                }
+            })
     }
 }
 
diff --git a/helix-view/Cargo.toml b/helix-view/Cargo.toml
index 13d5da0e5..4f7b08edd 100644
--- a/helix-view/Cargo.toml
+++ b/helix-view/Cargo.toml
@@ -14,20 +14,20 @@ default = []
 term = ["crossterm"]
 
 [dependencies]
-bitflags = "1.3"
+bitflags = "2.0"
 anyhow = "1"
 helix-core = { version = "0.6", path = "../helix-core" }
 helix-loader = { version = "0.6", path = "../helix-loader" }
 helix-lsp = { version = "0.6", path = "../helix-lsp" }
 helix-dap = { version = "0.6", path = "../helix-dap" }
-crossterm = { version = "0.25", optional = true }
+crossterm = { version = "0.26", optional = true }
 helix-vcs = { version = "0.6", path = "../helix-vcs" }
 
 # Conversion traits
-once_cell = "1.16"
+once_cell = "1.17"
 url = "2"
 
-arc-swap = { version = "1.5.1" }
+arc-swap = { version = "1.6.0" }
 
 tokio = { version = "1", features = ["rt", "rt-multi-thread", "io-util", "io-std", "time", "process", "macros", "fs", "parking_lot"] }
 tokio-stream = "0.1"
@@ -39,14 +39,18 @@ chardetng = "0.1"
 
 serde = { version = "1.0", features = ["derive"] }
 serde_json = "1.0"
-toml = "0.5"
+toml = "0.7"
 log = "~0.4"
 
-which = "4.2"
+which = "4.4"
+parking_lot = "0.12.1"
 
 
 [target.'cfg(windows)'.dependencies]
-clipboard-win = { version = "4.4", features = ["std"] }
+clipboard-win = { version = "4.5", features = ["std"] }
+
+[target.'cfg(unix)'.dependencies]
+libc = "0.2"
 
 [dev-dependencies]
 helix-tui = { path = "../helix-tui" }
diff --git a/helix-view/src/base64.rs b/helix-view/src/base64.rs
index a0dc167fe..13ee919d6 100644
--- a/helix-view/src/base64.rs
+++ b/helix-view/src/base64.rs
@@ -36,7 +36,7 @@
 pub fn encode(input: &[u8]) -> String {
     let rem = input.len() % 3;
     let complete_chunks = input.len() / 3;
-    let remainder_chunk = if rem == 0 { 0 } else { 1 };
+    let remainder_chunk = usize::from(rem != 0);
     let encoded_size = (complete_chunks + remainder_chunk) * 4;
 
     let mut output = vec![0; encoded_size];
diff --git a/helix-view/src/clipboard.rs b/helix-view/src/clipboard.rs
index 4f83fb4dc..d43d632a9 100644
--- a/helix-view/src/clipboard.rs
+++ b/helix-view/src/clipboard.rs
@@ -41,7 +41,7 @@ macro_rules! command_provider {
      primary_paste => $pr_get_prg:literal $( , $pr_get_arg:literal )* ;
      primary_copy => $pr_set_prg:literal $( , $pr_set_arg:literal )* ;
     ) => {{
-        log::info!(
+        log::debug!(
             "Using {} to interact with the system and selection (primary) clipboard",
             if $set_prg != $get_prg { format!("{}+{}", $set_prg, $get_prg)} else { $set_prg.to_string() }
         );
@@ -258,7 +258,7 @@ pub fn is_exit_success(program: &str, args: &[&str]) -> bool {
                 .args(args)
                 .output()
                 .ok()
-                .and_then(|out| out.status.success().then(|| ())) // TODO: use then_some when stabilized
+                .and_then(|out| out.status.success().then_some(()))
                 .is_some()
         }
 
@@ -276,12 +276,27 @@ fn execute(&self, input: Option<&str>, pipe_output: bool) -> Result<Option<Strin
                 let stdin = input.map(|_| Stdio::piped()).unwrap_or_else(Stdio::null);
                 let stdout = pipe_output.then(Stdio::piped).unwrap_or_else(Stdio::null);
 
-                let mut child = Command::new(self.prg)
+                let mut command: Command = Command::new(self.prg);
+
+                let mut command_mut: &mut Command = command
                     .args(self.args)
                     .stdin(stdin)
                     .stdout(stdout)
-                    .stderr(Stdio::null())
-                    .spawn()?;
+                    .stderr(Stdio::null());
+
+                // Fix for https://github.com/helix-editor/helix/issues/5424
+                if cfg!(unix) {
+                    use std::os::unix::process::CommandExt;
+
+                    unsafe {
+                        command_mut = command_mut.pre_exec(|| match libc::setsid() {
+                            -1 => Err(std::io::Error::last_os_error()),
+                            _ => Ok(()),
+                        });
+                    }
+                }
+
+                let mut child = command_mut.spawn()?;
 
                 if let Some(input) = input {
                     let mut stdin = child.stdin.take().context("stdin is missing")?;
@@ -366,7 +381,7 @@ mod provider {
 
     impl ClipboardProvider for WindowsProvider {
         fn name(&self) -> Cow<str> {
-            log::info!("Using clipboard-win to interact with the system clipboard");
+            log::debug!("Using clipboard-win to interact with the system clipboard");
             Cow::Borrowed("clipboard-win")
         }
 
diff --git a/helix-view/src/document.rs b/helix-view/src/document.rs
index 856e5628a..eca600265 100644
--- a/helix-view/src/document.rs
+++ b/helix-view/src/document.rs
@@ -1,10 +1,16 @@
 use anyhow::{anyhow, bail, Context, Error};
+use arc_swap::access::DynAccess;
+use arc_swap::ArcSwap;
 use futures_util::future::BoxFuture;
 use futures_util::FutureExt;
 use helix_core::auto_pairs::AutoPairs;
+use helix_core::doc_formatter::TextFormat;
+use helix_core::syntax::Highlight;
+use helix_core::text_annotations::{InlineAnnotation, TextAnnotations};
 use helix_core::Range;
 use helix_vcs::{DiffHandle, DiffProviderRegistry};
 
+use ::parking_lot::Mutex;
 use serde::de::{self, Deserialize, Deserializer};
 use serde::Serialize;
 use std::borrow::Cow;
@@ -13,8 +19,10 @@
 use std::fmt::Display;
 use std::future::Future;
 use std::path::{Path, PathBuf};
+use std::rc::Rc;
 use std::str::FromStr;
-use std::sync::Arc;
+use std::sync::{Arc, Weak};
+use std::time::SystemTime;
 
 use helix_core::{
     encoding,
@@ -26,14 +34,16 @@
     DEFAULT_LINE_ENDING,
 };
 
-use crate::editor::RedrawHandle;
-use crate::{apply_transaction, DocumentId, Editor, View, ViewId};
+use crate::editor::{Config, RedrawHandle};
+use crate::{DocumentId, Editor, Theme, View, ViewId};
 
 /// 8kB of buffer space for encoding and decoding `Rope`s.
 const BUF_SIZE: usize = 8192;
 
 const DEFAULT_INDENT: IndentStyle = IndentStyle::Tabs;
 
+pub const DEFAULT_LANGUAGE_NAME: &str = "text";
+
 pub const SCRATCH_BUFFER_NAME: &str = "[scratch]";
 
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
@@ -98,11 +108,26 @@ pub struct DocumentSavedEvent {
 pub type DocumentSavedEventResult = Result<DocumentSavedEvent, anyhow::Error>;
 pub type DocumentSavedEventFuture = BoxFuture<'static, DocumentSavedEventResult>;
 
+#[derive(Debug)]
+pub struct SavePoint {
+    /// The view this savepoint is associated with
+    pub view: ViewId,
+    revert: Mutex<Transaction>,
+}
+
 pub struct Document {
     pub(crate) id: DocumentId,
     text: Rope,
     selections: HashMap<ViewId, Selection>,
 
+    /// Inlay hints annotations for the document, by view.
+    ///
+    /// To know if they're up-to-date, check the `id` field in `DocumentInlayHints`.
+    pub(crate) inlay_hints: HashMap<ViewId, DocumentInlayHints>,
+    /// Set to `true` when the document is updated, reset to `false` on the next inlay hints
+    /// update from the LSP
+    pub inlay_hints_oudated: bool,
+
     path: Option<PathBuf>,
     encoding: &'static encoding::Encoding,
 
@@ -127,8 +152,13 @@ pub struct Document {
     // it back as it separated from the edits. We could split out the parts manually but that will
     // be more troublesome.
     pub history: Cell<History>,
+    pub config: Arc<dyn DynAccess<Config>>,
+
+    savepoints: Vec<Weak<SavePoint>>,
 
-    pub savepoint: Option<Transaction>,
+    // Last time we wrote to the file. This will carry the time the file was last opened if there
+    // were no saves.
+    last_saved_time: SystemTime,
 
     last_saved_revision: usize,
     version: i32, // should be usize?
@@ -138,6 +168,74 @@ pub struct Document {
     language_server: Option<Arc<helix_lsp::Client>>,
 
     diff_handle: Option<DiffHandle>,
+    version_control_head: Option<Arc<ArcSwap<Box<str>>>>,
+}
+
+/// Inlay hints for a single `(Document, View)` combo.
+///
+/// There are `*_inlay_hints` field for each kind of hints an LSP can send since we offer the
+/// option to style theme differently in the theme according to the (currently supported) kinds
+/// (`type`, `parameter` and the rest).
+///
+/// Inlay hints are always `InlineAnnotation`s, not overlays or line-ones: LSP may choose to place
+/// them anywhere in the text and will sometime offer config options to move them where the user
+/// wants them but it shouldn't be Helix who decides that so we use the most precise positioning.
+///
+/// The padding for inlay hints needs to be stored separately for before and after (the LSP spec
+/// uses 'left' and 'right' but not all text is left to right so let's be correct) padding because
+/// the 'before' padding must be added to a layer *before* the regular inlay hints and the 'after'
+/// padding comes ... after.
+#[derive(Debug, Clone)]
+pub struct DocumentInlayHints {
+    /// Identifier for the inlay hints stored in this structure. To be checked to know if they have
+    /// to be recomputed on idle or not.
+    pub id: DocumentInlayHintsId,
+
+    /// Inlay hints of `TYPE` kind, if any.
+    pub type_inlay_hints: Rc<[InlineAnnotation]>,
+
+    /// Inlay hints of `PARAMETER` kind, if any.
+    pub parameter_inlay_hints: Rc<[InlineAnnotation]>,
+
+    /// Inlay hints that are neither `TYPE` nor `PARAMETER`.
+    ///
+    /// LSPs are not required to associate a kind to their inlay hints, for example Rust-Analyzer
+    /// currently never does (February 2023) and the LSP spec may add new kinds in the future that
+    /// we want to display even if we don't have some special highlighting for them.
+    pub other_inlay_hints: Rc<[InlineAnnotation]>,
+
+    /// Inlay hint padding. When creating the final `TextAnnotations`, the `before` padding must be
+    /// added first, then the regular inlay hints, then the `after` padding.
+    pub padding_before_inlay_hints: Rc<[InlineAnnotation]>,
+    pub padding_after_inlay_hints: Rc<[InlineAnnotation]>,
+}
+
+impl DocumentInlayHints {
+    /// Generate an empty list of inlay hints with the given ID.
+    pub fn empty_with_id(id: DocumentInlayHintsId) -> Self {
+        Self {
+            id,
+            type_inlay_hints: Rc::new([]),
+            parameter_inlay_hints: Rc::new([]),
+            other_inlay_hints: Rc::new([]),
+            padding_before_inlay_hints: Rc::new([]),
+            padding_after_inlay_hints: Rc::new([]),
+        }
+    }
+}
+
+/// Associated with a [`Document`] and [`ViewId`], uniquely identifies the state of inlay hints for
+/// for that document and view: if this changed since the last save, the inlay hints for the view
+/// should be recomputed.
+///
+/// We can't store the `ViewOffset` instead of the first and last asked-for lines because if
+/// softwrapping changes, the `ViewOffset` may not change while the displayed lines will.
+#[derive(Copy, Clone, PartialEq, Eq)]
+pub struct DocumentInlayHintsId {
+    /// First line for which the inlay hints were requested.
+    pub first_line: usize,
+    /// Last line for which the inlay hints were requested.
+    pub last_line: usize,
 }
 
 use std::{fmt, mem};
@@ -147,6 +245,8 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
             .field("id", &self.id)
             .field("text", &self.text)
             .field("selections", &self.selections)
+            .field("inlay_hints_oudated", &self.inlay_hints_oudated)
+            .field("text_annotations", &self.inlay_hints)
             .field("path", &self.path)
             .field("encoding", &self.encoding)
             .field("restore_cursor", &self.restore_cursor)
@@ -155,6 +255,7 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
             .field("changes", &self.changes)
             .field("old_state", &self.old_state)
             // .field("history", &self.history)
+            .field("last_saved_time", &self.last_saved_time)
             .field("last_saved_revision", &self.last_saved_revision)
             .field("version", &self.version)
             .field("modified_since_accessed", &self.modified_since_accessed)
@@ -164,6 +265,15 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     }
 }
 
+impl fmt::Debug for DocumentInlayHintsId {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        // Much more agreable to read when debugging
+        f.debug_struct("DocumentInlayHintsId")
+            .field("lines", &(self.first_line..self.last_line))
+            .finish()
+    }
+}
+
 // The documentation and implementation of this function should be up-to-date with
 // its sibling function, `to_writer()`.
 //
@@ -351,7 +461,11 @@ fn take_with<T, F>(mut_ref: &mut T, f: F)
 use url::Url;
 
 impl Document {
-    pub fn from(text: Rope, encoding: Option<&'static encoding::Encoding>) -> Self {
+    pub fn from(
+        text: Rope,
+        encoding: Option<&'static encoding::Encoding>,
+        config: Arc<dyn DynAccess<Config>>,
+    ) -> Self {
         let encoding = encoding.unwrap_or(encoding::UTF_8);
         let changes = ChangeSet::new(&text);
         let old_state = None;
@@ -362,6 +476,8 @@ pub fn from(text: Rope, encoding: Option<&'static encoding::Encoding>) -> Self {
             encoding,
             text,
             selections: HashMap::default(),
+            inlay_hints: HashMap::default(),
+            inlay_hints_oudated: false,
             indent_style: DEFAULT_INDENT,
             line_ending: DEFAULT_LINE_ENDING,
             restore_cursor: false,
@@ -372,14 +488,20 @@ pub fn from(text: Rope, encoding: Option<&'static encoding::Encoding>) -> Self {
             diagnostics: Vec::new(),
             version: 0,
             history: Cell::new(History::default()),
-            savepoint: None,
+            savepoints: Vec::new(),
+            last_saved_time: SystemTime::now(),
             last_saved_revision: 0,
             modified_since_accessed: false,
             language_server: None,
             diff_handle: None,
+            config,
+            version_control_head: None,
         }
     }
-
+    pub fn default(config: Arc<dyn DynAccess<Config>>) -> Self {
+        let text = Rope::from(DEFAULT_LINE_ENDING.as_str());
+        Self::from(text, None, config)
+    }
     // TODO: async fn?
     /// Create a new document from `path`. Encoding is auto-detected, but it can be manually
     /// overwritten with the `encoding` parameter.
@@ -387,6 +509,7 @@ pub fn open(
         path: &Path,
         encoding: Option<&'static encoding::Encoding>,
         config_loader: Option<Arc<syntax::Loader>>,
+        config: Arc<dyn DynAccess<Config>>,
     ) -> Result<Self, Error> {
         // Open the file if it exists, otherwise assume it is a new file (and thus empty).
         let (rope, encoding) = if path.exists() {
@@ -398,7 +521,7 @@ pub fn open(
             (Rope::from(DEFAULT_LINE_ENDING.as_str()), encoding)
         };
 
-        let mut doc = Self::from(rope, Some(encoding));
+        let mut doc = Self::from(rope, Some(encoding), config);
 
         // set the path and try detecting the language
         doc.set_path(Some(path))?;
@@ -563,9 +686,11 @@ impl Future<Output = Result<DocumentSavedEvent, anyhow::Error>> + 'static + Send
 
         let encoding = self.encoding;
 
+        let last_saved_time = self.last_saved_time;
+
         // We encode the file according to the `Document`'s encoding.
         let future = async move {
-            use tokio::fs::File;
+            use tokio::{fs, fs::File};
             if let Some(parent) = path.parent() {
                 // TODO: display a prompt asking the user if the directories should be created
                 if !parent.exists() {
@@ -577,6 +702,17 @@ impl Future<Output = Result<DocumentSavedEvent, anyhow::Error>> + 'static + Send
                 }
             }
 
+            // Protect against overwriting changes made externally
+            if !force {
+                if let Ok(metadata) = fs::metadata(&path).await {
+                    if let Ok(mtime) = metadata.modified() {
+                        if last_saved_time < mtime {
+                            bail!("file modified by an external process, use :w! to overwrite");
+                        }
+                    }
+                }
+            }
+
             let mut file = File::create(&path).await?;
             to_writer(&mut file, encoding, &text).await?;
 
@@ -640,7 +776,7 @@ pub fn reload(
         let path = self
             .path()
             .filter(|path| path.exists())
-            .ok_or_else(|| anyhow!("can't find file to reload from"))?
+            .ok_or_else(|| anyhow!("can't find file to reload from {:?}", self.display_name()))?
             .to_owned();
 
         let mut file = std::fs::File::open(&path)?;
@@ -650,10 +786,12 @@ pub fn reload(
         // This is not considered a modification of the contents of the file regardless
         // of the encoding.
         let transaction = helix_core::diff::compare_ropes(self.text(), &rope);
-        apply_transaction(&transaction, self, view);
+        self.apply(&transaction, view.id);
         self.append_changes_to_history(view);
         self.reset_modified();
 
+        self.last_saved_time = SystemTime::now();
+
         self.detect_indent_and_line_ending();
 
         match provider_registry.get_diff_base(&path) {
@@ -661,6 +799,8 @@ pub fn reload(
             None => self.diff_handle = None,
         }
 
+        self.version_control_head = provider_registry.get_current_head_name(&path);
+
         Ok(())
     }
 
@@ -768,13 +908,16 @@ pub fn ensure_view_init(&mut self, view_id: ViewId) {
         }
     }
 
-    /// Remove a view's selection from this document.
+    /// Remove a view's selection and inlay hints from this document.
     pub fn remove_view(&mut self, view_id: ViewId) {
         self.selections.remove(&view_id);
+        self.inlay_hints.remove(&view_id);
     }
 
     /// Apply a [`Transaction`] to the [`Document`] to change its text.
     fn apply_impl(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
+        use helix_core::Assoc;
+
         let old_doc = self.text().clone();
 
         let success = transaction.changes().apply(&mut self.text);
@@ -808,11 +951,18 @@ fn apply_impl(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
             }
 
             // generate revert to savepoint
-            if self.savepoint.is_some() {
-                take_with(&mut self.savepoint, |prev_revert| {
-                    let revert = transaction.invert(&old_doc);
-                    Some(revert.compose(prev_revert.unwrap()))
-                });
+            if !self.savepoints.is_empty() {
+                let revert = transaction.invert(&old_doc);
+                self.savepoints
+                    .retain_mut(|save_point| match save_point.upgrade() {
+                        Some(savepoint) => {
+                            let mut revert_to_savepoint = savepoint.revert.lock();
+                            *revert_to_savepoint =
+                                revert.clone().compose(mem::take(&mut revert_to_savepoint));
+                            true
+                        }
+                        None => false,
+                    })
             }
 
             // update tree-sitter syntax tree
@@ -823,10 +973,10 @@ fn apply_impl(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
                     .unwrap();
             }
 
+            let changes = transaction.changes();
+
             // map state.diagnostics over changes::map_pos too
             for diagnostic in &mut self.diagnostics {
-                use helix_core::Assoc;
-                let changes = transaction.changes();
                 diagnostic.range.start = changes.map_pos(diagnostic.range.start, Assoc::After);
                 diagnostic.range.end = changes.map_pos(diagnostic.range.end, Assoc::After);
                 diagnostic.line = self.text.char_to_line(diagnostic.range.start);
@@ -834,13 +984,40 @@ fn apply_impl(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
             self.diagnostics
                 .sort_unstable_by_key(|diagnostic| diagnostic.range);
 
+            // Update the inlay hint annotations' positions, helping ensure they are displayed in the proper place
+            let apply_inlay_hint_changes = |annotations: &mut Rc<[InlineAnnotation]>| {
+                if let Some(data) = Rc::get_mut(annotations) {
+                    for inline in data.iter_mut() {
+                        inline.char_idx = changes.map_pos(inline.char_idx, Assoc::After);
+                    }
+                }
+            };
+
+            self.inlay_hints_oudated = true;
+            for text_annotation in self.inlay_hints.values_mut() {
+                let DocumentInlayHints {
+                    id: _,
+                    type_inlay_hints,
+                    parameter_inlay_hints,
+                    other_inlay_hints,
+                    padding_before_inlay_hints,
+                    padding_after_inlay_hints,
+                } = text_annotation;
+
+                apply_inlay_hint_changes(padding_before_inlay_hints);
+                apply_inlay_hint_changes(type_inlay_hints);
+                apply_inlay_hint_changes(parameter_inlay_hints);
+                apply_inlay_hint_changes(other_inlay_hints);
+                apply_inlay_hint_changes(padding_after_inlay_hints);
+            }
+
             // emit lsp notification
             if let Some(language_server) = self.language_server() {
                 let notify = language_server.text_document_did_change(
                     self.versioned_identifier(),
                     &old_doc,
                     self.text(),
-                    transaction.changes(),
+                    changes,
                 );
 
                 if let Some(notify) = notify {
@@ -852,9 +1029,6 @@ fn apply_impl(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
     }
 
     /// Apply a [`Transaction`] to the [`Document`] to change its text.
-    /// Instead of calling this function directly, use [crate::apply_transaction]
-    /// to ensure that the transaction is applied to the appropriate [`View`] as
-    /// well.
     pub fn apply(&mut self, transaction: &Transaction, view_id: ViewId) -> bool {
         // store the state just before any changes are made. This allows us to undo to the
         // state just before a transaction was applied.
@@ -905,14 +1079,39 @@ pub fn redo(&mut self, view: &mut View) -> bool {
         self.undo_redo_impl(view, false)
     }
 
-    pub fn savepoint(&mut self) {
-        self.savepoint = Some(Transaction::new(self.text()));
+    /// Creates a reference counted snapshot (called savpepoint) of the document.
+    ///
+    /// The snapshot will remain valid (and updated) idenfinitly as long as ereferences to it exist.
+    /// Restoring the snapshot will restore the selection and the contents of the document to
+    /// the state it had when this function was called.
+    pub fn savepoint(&mut self, view: &View) -> Arc<SavePoint> {
+        let revert = Transaction::new(self.text()).with_selection(self.selection(view.id).clone());
+        let savepoint = Arc::new(SavePoint {
+            view: view.id,
+            revert: Mutex::new(revert),
+        });
+        self.savepoints.push(Arc::downgrade(&savepoint));
+        savepoint
     }
 
-    pub fn restore(&mut self, view: &mut View) {
-        if let Some(revert) = self.savepoint.take() {
-            apply_transaction(&revert, self, view);
-        }
+    pub fn restore(&mut self, view: &mut View, savepoint: &SavePoint) {
+        assert_eq!(
+            savepoint.view, view.id,
+            "Savepoint must not be used with a different view!"
+        );
+        // search and remove savepoint using a ptr comparison
+        // this avoids a deadlock as we need to lock the mutex
+        let savepoint_idx = self
+            .savepoints
+            .iter()
+            .position(|savepoint_ref| savepoint_ref.as_ptr() == savepoint as *const _)
+            .expect("Savepoint must belong to this document");
+
+        let savepoint_ref = self.savepoints.remove(savepoint_idx);
+        let mut revert = savepoint.revert.lock();
+        self.apply(&revert, view.id);
+        *revert = Transaction::new(self.text()).with_selection(self.selection(view.id).clone());
+        self.savepoints.push(savepoint_ref)
     }
 
     fn earlier_later_impl(&mut self, view: &mut View, uk: UndoKind, earlier: bool) -> bool {
@@ -1005,6 +1204,7 @@ pub fn set_last_saved_revision(&mut self, rev: usize) {
             rev
         );
         self.last_saved_revision = rev;
+        self.last_saved_time = SystemTime::now();
     }
 
     /// Get the document's latest saved revision.
@@ -1062,7 +1262,7 @@ pub fn version(&self) -> i32 {
     /// Language server if it has been initialized.
     pub fn language_server(&self) -> Option<&helix_lsp::Client> {
         let server = self.language_server.as_deref()?;
-        server.is_initialized().then(|| server)
+        server.is_initialized().then_some(server)
     }
 
     pub fn diff_handle(&self) -> Option<&DiffHandle> {
@@ -1082,19 +1282,35 @@ pub fn set_diff_base(&mut self, diff_base: Vec<u8>, redraw_handle: RedrawHandle)
         }
     }
 
+    pub fn version_control_head(&self) -> Option<Arc<Box<str>>> {
+        self.version_control_head.as_ref().map(|a| a.load_full())
+    }
+
+    pub fn set_version_control_head(
+        &mut self,
+        version_control_head: Option<Arc<ArcSwap<Box<str>>>>,
+    ) {
+        self.version_control_head = version_control_head;
+    }
+
     #[inline]
     /// Tree-sitter AST tree
     pub fn syntax(&self) -> Option<&Syntax> {
         self.syntax.as_ref()
     }
 
-    /// Tab size in columns.
+    /// The width that the tab character is rendered at
     pub fn tab_width(&self) -> usize {
         self.language_config()
             .and_then(|config| config.indent.as_ref())
             .map_or(4, |config| config.tab_width) // fallback to 4 columns
     }
 
+    // The width (in spaces) of a level of indentation.
+    pub fn indent_width(&self) -> usize {
+        self.indent_style.indent_width(self.tab_width())
+    }
+
     pub fn changes(&self) -> &ChangeSet {
         &self.changes
     }
@@ -1120,6 +1336,7 @@ pub fn selection(&self, view_id: ViewId) -> &Selection {
         &self.selections[&view_id]
     }
 
+    #[inline]
     pub fn selections(&self) -> &HashMap<ViewId, Selection> {
         &self.selections
     }
@@ -1195,12 +1412,89 @@ pub fn auto_pairs<'a>(&'a self, editor: &'a Editor) -> Option<&'a AutoPairs> {
             None => global_config,
         }
     }
-}
 
-impl Default for Document {
-    fn default() -> Self {
-        let text = Rope::from(DEFAULT_LINE_ENDING.as_str());
-        Self::from(text, None)
+    pub fn text_format(&self, mut viewport_width: u16, theme: Option<&Theme>) -> TextFormat {
+        let config = self.config.load();
+        let text_width = self
+            .language_config()
+            .and_then(|config| config.text_width)
+            .unwrap_or(config.text_width);
+        let soft_wrap_at_text_width = self
+            .language_config()
+            .and_then(|config| {
+                config
+                    .soft_wrap
+                    .as_ref()
+                    .and_then(|soft_wrap| soft_wrap.wrap_at_text_width)
+            })
+            .or(config.soft_wrap.wrap_at_text_width)
+            .unwrap_or(false);
+        if soft_wrap_at_text_width {
+            // We increase max_line_len by 1 because softwrap considers the newline character
+            // as part of the line length while the "typical" expectation is that this is not the case.
+            // In particular other commands like :reflow do not count the line terminator.
+            // This is technically inconsistent for the last line as that line never has a line terminator
+            // but having the last visual line exceed the width by 1 seems like a rare edge case.
+            viewport_width = viewport_width.min(text_width as u16 + 1)
+        }
+        let config = self.config.load();
+        let editor_soft_wrap = &config.soft_wrap;
+        let language_soft_wrap = self
+            .language
+            .as_ref()
+            .and_then(|config| config.soft_wrap.as_ref());
+        let enable_soft_wrap = language_soft_wrap
+            .and_then(|soft_wrap| soft_wrap.enable)
+            .or(editor_soft_wrap.enable)
+            .unwrap_or(false);
+        let max_wrap = language_soft_wrap
+            .and_then(|soft_wrap| soft_wrap.max_wrap)
+            .or(config.soft_wrap.max_wrap)
+            .unwrap_or(20);
+        let max_indent_retain = language_soft_wrap
+            .and_then(|soft_wrap| soft_wrap.max_indent_retain)
+            .or(editor_soft_wrap.max_indent_retain)
+            .unwrap_or(40);
+        let wrap_indicator = language_soft_wrap
+            .and_then(|soft_wrap| soft_wrap.wrap_indicator.clone())
+            .or_else(|| config.soft_wrap.wrap_indicator.clone())
+            .unwrap_or_else(|| " ".into());
+        let tab_width = self.tab_width() as u16;
+        TextFormat {
+            soft_wrap: enable_soft_wrap && viewport_width > 10,
+            tab_width,
+            max_wrap: max_wrap.min(viewport_width / 4),
+            max_indent_retain: max_indent_retain.min(viewport_width * 2 / 5),
+            // avoid spinning forever when the window manager
+            // sets the size to something tiny
+            viewport_width,
+            wrap_indicator: wrap_indicator.into_boxed_str(),
+            wrap_indicator_highlight: theme
+                .and_then(|theme| theme.find_scope_index("ui.virtual.wrap"))
+                .map(Highlight),
+        }
+    }
+
+    /// Get the text annotations that apply to the whole document, those that do not apply to any
+    /// specific view.
+    pub fn text_annotations(&self, _theme: Option<&Theme>) -> TextAnnotations {
+        TextAnnotations::default()
+    }
+
+    /// Set the inlay hints for this document and `view_id`.
+    pub fn set_inlay_hints(&mut self, view_id: ViewId, inlay_hints: DocumentInlayHints) {
+        self.inlay_hints.insert(view_id, inlay_hints);
+    }
+
+    /// Get the inlay hints for this document and `view_id`.
+    pub fn inlay_hints(&self, view_id: ViewId) -> Option<&DocumentInlayHints> {
+        self.inlay_hints.get(&view_id)
+    }
+
+    /// Completely removes all the inlay hints saved for the document, dropping them to free memory
+    /// (since it often means inlay hints have been fully deactivated).
+    pub fn reset_all_inlay_hints(&mut self) {
+        self.inlay_hints = Default::default();
     }
 }
 
@@ -1239,13 +1533,19 @@ fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 
 #[cfg(test)]
 mod test {
+    use arc_swap::ArcSwap;
+
     use super::*;
 
     #[test]
     fn changeset_to_changes_ignore_line_endings() {
         use helix_lsp::{lsp, Client, OffsetEncoding};
         let text = Rope::from("hello\r\nworld");
-        let mut doc = Document::from(text, None);
+        let mut doc = Document::from(
+            text,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
         let view = ViewId::default();
         doc.set_selection(view, Selection::single(0, 0));
 
@@ -1279,7 +1579,11 @@ fn changeset_to_changes_ignore_line_endings() {
     fn changeset_to_changes() {
         use helix_lsp::{lsp, Client, OffsetEncoding};
         let text = Rope::from("hello");
-        let mut doc = Document::from(text, None);
+        let mut doc = Document::from(
+            text,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
         let view = ViewId::default();
         doc.set_selection(view, Selection::single(5, 5));
 
@@ -1392,7 +1696,9 @@ fn changeset_to_changes() {
     #[test]
     fn test_line_ending() {
         assert_eq!(
-            Document::default().text().to_string(),
+            Document::default(Arc::new(ArcSwap::new(Arc::new(Config::default()))))
+                .text()
+                .to_string(),
             DEFAULT_LINE_ENDING.as_str()
         );
     }
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index c13a66736..80c47ed08 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -7,8 +7,10 @@
     input::KeyEvent,
     theme::{self, Theme},
     tree::{self, Tree},
+    view::ViewPosition,
     Align, Document, DocumentId, View, ViewId,
 };
+use dap::StackFrame;
 use helix_vcs::DiffProviderRegistry;
 
 use futures_util::stream::select_all::SelectAll;
@@ -18,6 +20,7 @@
 
 use std::{
     borrow::Cow,
+    cell::Cell,
     collections::{BTreeMap, HashMap},
     io::stdin,
     num::NonZeroUsize,
@@ -29,7 +32,7 @@
 use tokio::{
     sync::{
         mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},
-        Notify, RwLock,
+        oneshot, Notify, RwLock,
     },
     time::{sleep, Duration, Instant, Sleep},
 };
@@ -38,12 +41,12 @@
 
 pub use helix_core::diagnostic::Severity;
 pub use helix_core::register::Registers;
-use helix_core::Position;
 use helix_core::{
     auto_pairs::AutoPairs,
-    syntax::{self, AutoPairConfig},
+    syntax::{self, AutoPairConfig, SoftWrap},
     Change,
 };
+use helix_core::{Position, Selection};
 use helix_dap as dap;
 use helix_lsp::lsp;
 
@@ -71,6 +74,96 @@ fn serialize_duration_millis<S>(duration: &Duration, serializer: S) -> Result<S:
     )
 }
 
+#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
+#[serde(rename_all = "kebab-case", default, deny_unknown_fields)]
+pub struct GutterConfig {
+    /// Gutter Layout
+    pub layout: Vec<GutterType>,
+    /// Options specific to the "line-numbers" gutter
+    pub line_numbers: GutterLineNumbersConfig,
+}
+
+impl Default for GutterConfig {
+    fn default() -> Self {
+        Self {
+            layout: vec![
+                GutterType::Diagnostics,
+                GutterType::Spacer,
+                GutterType::LineNumbers,
+                GutterType::Spacer,
+                GutterType::Diff,
+            ],
+            line_numbers: GutterLineNumbersConfig::default(),
+        }
+    }
+}
+
+impl From<Vec<GutterType>> for GutterConfig {
+    fn from(x: Vec<GutterType>) -> Self {
+        GutterConfig {
+            layout: x,
+            ..Default::default()
+        }
+    }
+}
+
+fn deserialize_gutter_seq_or_struct<'de, D>(deserializer: D) -> Result<GutterConfig, D::Error>
+where
+    D: Deserializer<'de>,
+{
+    struct GutterVisitor;
+
+    impl<'de> serde::de::Visitor<'de> for GutterVisitor {
+        type Value = GutterConfig;
+
+        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
+            write!(
+                formatter,
+                "an array of gutter names or a detailed gutter configuration"
+            )
+        }
+
+        fn visit_seq<S>(self, mut seq: S) -> Result<Self::Value, S::Error>
+        where
+            S: serde::de::SeqAccess<'de>,
+        {
+            let mut gutters = Vec::new();
+            while let Some(gutter) = seq.next_element::<String>()? {
+                gutters.push(
+                    gutter
+                        .parse::<GutterType>()
+                        .map_err(serde::de::Error::custom)?,
+                )
+            }
+
+            Ok(gutters.into())
+        }
+
+        fn visit_map<M>(self, map: M) -> Result<Self::Value, M::Error>
+        where
+            M: serde::de::MapAccess<'de>,
+        {
+            let deserializer = serde::de::value::MapAccessDeserializer::new(map);
+            Deserialize::deserialize(deserializer)
+        }
+    }
+
+    deserializer.deserialize_any(GutterVisitor)
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+#[serde(rename_all = "kebab-case", default, deny_unknown_fields)]
+pub struct GutterLineNumbersConfig {
+    /// Minimum number of characters to use for line number gutter. Defaults to 3.
+    pub min_width: usize,
+}
+
+impl Default for GutterLineNumbersConfig {
+    fn default() -> Self {
+        Self { min_width: 3 }
+    }
+}
+
 #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(rename_all = "kebab-case", default, deny_unknown_fields)]
 pub struct FilePickerConfig {
@@ -81,6 +174,8 @@ pub struct FilePickerConfig {
     /// Enables following symlinks.
     /// Whether to follow symbolic links in file picker and file or directory completions. Defaults to true.
     pub follow_symlinks: bool,
+    /// Hides symlinks that point into the current directory. Defaults to true.
+    pub deduplicate_links: bool,
     /// Enables reading ignore files from parent directories. Defaults to true.
     pub parents: bool,
     /// Enables reading `.ignore` files.
@@ -105,6 +200,7 @@ fn default() -> Self {
         Self {
             hidden: true,
             follow_symlinks: true,
+            deduplicate_links: true,
             parents: true,
             ignore: true,
             git_ignore: true,
@@ -132,8 +228,8 @@ pub struct Config {
     pub cursorline: bool,
     /// Highlight the columns cursors are currently on. Defaults to false.
     pub cursorcolumn: bool,
-    /// Gutters. Default ["diagnostics", "line-numbers"]
-    pub gutters: Vec<GutterType>,
+    #[serde(deserialize_with = "deserialize_gutter_seq_or_struct")]
+    pub gutters: GutterConfig,
     /// Middle click paste support. Defaults to true.
     pub middle_click_paste: bool,
     /// Automatic insertion of pairs to parentheses, brackets,
@@ -146,6 +242,8 @@ pub struct Config {
     pub auto_format: bool,
     /// Automatic save on focus lost. Defaults to false.
     pub auto_save: bool,
+    /// Set a global text_width
+    pub text_width: usize,
     /// Time in milliseconds since last keypress before idle timers trigger.
     /// Used for autocompletion, set to 0 for instant. Defaults to 400ms.
     #[serde(
@@ -154,6 +252,9 @@ pub struct Config {
     )]
     pub idle_timeout: Duration,
     pub completion_trigger_len: u8,
+    /// Whether to instruct the LSP to replace the entire word when applying a completion
+    /// or to only insert new text
+    pub completion_replace: bool,
     /// Whether to display infoboxes. Defaults to true.
     pub auto_info: bool,
     pub file_picker: FilePickerConfig,
@@ -163,6 +264,8 @@ pub struct Config {
     pub cursor_shape: CursorShapeConfig,
     /// Set to `true` to override automatic detection of terminal truecolor support in the event of a false negative. Defaults to `false`.
     pub true_color: bool,
+    /// Set to `true` to override automatic detection of terminal undercurl support in the event of a false negative. Defaults to `false`.
+    pub undercurl: bool,
     /// Search configuration.
     #[serde(default)]
     pub search: SearchConfig,
@@ -178,6 +281,9 @@ pub struct Config {
     pub indent_guides: IndentGuidesConfig,
     /// Whether to color modes with different colors. Defaults to `false`.
     pub color_modes: bool,
+    pub soft_wrap: SoftWrap,
+    /// Workspace specific lsp ceiling dirs
+    pub workspace_lsp_roots: Vec<PathBuf>,
 }
 
 #[derive(Debug, Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
@@ -206,10 +312,10 @@ pub fn get_terminal_provider() -> Option<TerminalConfig> {
         });
     }
 
-    return Some(TerminalConfig {
+    Some(TerminalConfig {
         command: "conhost".to_string(),
         args: vec!["cmd".to_string(), "/C".to_string()],
-    });
+    })
 }
 
 #[cfg(not(any(windows, target_os = "wasm32")))]
@@ -236,20 +342,29 @@ pub fn get_terminal_provider() -> Option<TerminalConfig> {
 #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(default, rename_all = "kebab-case", deny_unknown_fields)]
 pub struct LspConfig {
+    /// Enables LSP
+    pub enable: bool,
     /// Display LSP progress messages below statusline
     pub display_messages: bool,
     /// Enable automatic pop up of signature help (parameter hints)
     pub auto_signature_help: bool,
     /// Display docs under signature help popup
     pub display_signature_help_docs: bool,
+    /// Display inlay hints
+    pub display_inlay_hints: bool,
+    /// Whether to enable snippet support
+    pub snippets: bool,
 }
 
 impl Default for LspConfig {
     fn default() -> Self {
         Self {
+            enable: true,
             display_messages: false,
             auto_signature_help: true,
             display_signature_help_docs: true,
+            display_inlay_hints: false,
+            snippets: true,
         }
     }
 }
@@ -278,7 +393,12 @@ fn default() -> Self {
         use StatusLineElement as E;
 
         Self {
-            left: vec![E::Mode, E::Spinner, E::FileName],
+            left: vec![
+                E::Mode,
+                E::Spinner,
+                E::FileName,
+                E::FileModificationIndicator,
+            ],
             center: vec![],
             right: vec![E::Diagnostics, E::Selections, E::Position, E::FileEncoding],
             separator: String::from(""),
@@ -314,9 +434,15 @@ pub enum StatusLineElement {
     /// The LSP activity spinner
     Spinner,
 
-    /// The file nane/path, including a dirty flag if it's unsaved
+    /// The base file name, including a dirty flag if it's unsaved
+    FileBaseName,
+
+    /// The relative file path, including a dirty flag if it's unsaved
     FileName,
 
+    // The file modification indicator
+    FileModificationIndicator,
+
     /// The file encoding
     FileEncoding,
 
@@ -352,6 +478,9 @@ pub enum StatusLineElement {
 
     /// A single space
     Spacer,
+
+    /// Current version control information
+    VersionControl,
 }
 
 // Cursor shape is read and used on every rendered frame and so needs
@@ -409,10 +538,11 @@ fn default() -> Self {
 }
 
 /// bufferline render modes
-#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
+#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(rename_all = "kebab-case")]
 pub enum BufferLine {
     /// Don't render bufferline
+    #[default]
     Never,
     /// Always render
     Always,
@@ -420,12 +550,6 @@ pub enum BufferLine {
     Multiple,
 }
 
-impl Default for BufferLine {
-    fn default() -> Self {
-        BufferLine::Never
-    }
-}
-
 #[derive(Debug, Copy, Clone, PartialEq, Eq, Serialize, Deserialize)]
 #[serde(rename_all = "kebab-case")]
 pub enum LineNumber {
@@ -603,13 +727,7 @@ fn default() -> Self {
             line_number: LineNumber::Absolute,
             cursorline: false,
             cursorcolumn: false,
-            gutters: vec![
-                GutterType::Diagnostics,
-                GutterType::Spacer,
-                GutterType::LineNumbers,
-                GutterType::Spacer,
-                GutterType::Diff,
-            ],
+            gutters: GutterConfig::default(),
             middle_click_paste: true,
             auto_pairs: AutoPairConfig::default(),
             auto_completion: true,
@@ -622,6 +740,7 @@ fn default() -> Self {
             statusline: StatusLineConfig::default(),
             cursor_shape: CursorShapeConfig::default(),
             true_color: false,
+            undercurl: false,
             search: SearchConfig::default(),
             lsp: LspConfig::default(),
             terminal: get_terminal_provider(),
@@ -630,6 +749,10 @@ fn default() -> Self {
             bufferline: BufferLine::default(),
             indent_guides: IndentGuidesConfig::default(),
             color_modes: false,
+            soft_wrap: SoftWrap::default(),
+            text_width: 80,
+            completion_replace: false,
+            workspace_lsp_roots: Vec::new(),
         }
     }
 }
@@ -706,11 +829,16 @@ pub struct Editor {
     /// The currently applied editor theme. While previewing a theme, the previewed theme
     /// is set here.
     pub theme: Theme,
-    pub last_line_number: Option<usize>,
+
+    /// The primary Selection prior to starting a goto_line_number preview. This is
+    /// restored when the preview is aborted, or added to the jumplist when it is
+    /// confirmed.
+    pub last_selection: Option<Selection>,
+
     pub status_msg: Option<(Cow<'static, str>, Severity)>,
     pub autoinfo: Option<Info>,
 
-    pub config: Box<dyn DynAccess<Config>>,
+    pub config: Arc<dyn DynAccess<Config>>,
     pub auto_pairs: Option<AutoPairs>,
 
     pub idle_timer: Pin<Box<Sleep>>,
@@ -723,9 +851,30 @@ pub struct Editor {
     pub config_events: (UnboundedSender<ConfigEvent>, UnboundedReceiver<ConfigEvent>),
     /// Allows asynchronous tasks to control the rendering
     /// The `Notify` allows asynchronous tasks to request the editor to perform a redraw
-    /// The `RwLock` blocks the editor from performing the render until an exclusive lock can be aquired
+    /// The `RwLock` blocks the editor from performing the render until an exclusive lock can be acquired
     pub redraw_handle: RedrawHandle,
     pub needs_redraw: bool,
+    /// Cached position of the cursor calculated during rendering.
+    /// The content of `cursor_cache` is returned by `Editor::cursor` if
+    /// set to `Some(_)`. The value will be cleared after it's used.
+    /// If `cursor_cache` is `None` then the `Editor::cursor` function will
+    /// calculate the cursor position.
+    ///
+    /// `Some(None)` represents a cursor position outside of the visible area.
+    /// This will just cause `Editor::cursor` to return `None`.
+    ///
+    /// This cache is only a performance optimization to
+    /// avoid calculating the cursor position multiple
+    /// times during rendering and should not be set by other functions.
+    pub cursor_cache: Cell<Option<Option<Position>>>,
+    /// When a new completion request is sent to the server old
+    /// unifinished request must be dropped. Each completion
+    /// request is associated with a channel that cancels
+    /// when the channel is dropped. That channel is stored
+    /// here. When a new completion request is sent this
+    /// field is set and any old requests are automatically
+    /// canceled as a result
+    pub completion_request_handle: Option<oneshot::Sender<()>>,
 }
 
 pub type RedrawHandle = (Arc<Notify>, Arc<RwLock<()>>);
@@ -779,7 +928,7 @@ pub fn new(
         mut area: Rect,
         theme_loader: Arc<theme::Loader>,
         syn_loader: Arc<syntax::Loader>,
-        config: Box<dyn DynAccess<Config>>,
+        config: Arc<dyn DynAccess<Config>>,
     ) -> Self {
         let conf = config.load();
         let auto_pairs = (&conf.auto_pairs).into();
@@ -809,7 +958,7 @@ pub fn new(
             syn_loader,
             theme_loader,
             last_theme: None,
-            last_line_number: None,
+            last_selection: None,
             registers: Registers::default(),
             clipboard_provider: get_clipboard_provider(),
             status_msg: None,
@@ -823,6 +972,8 @@ pub fn new(
             config_events: unbounded_channel(),
             redraw_handle: Default::default(),
             needs_redraw: false,
+            cursor_cache: Cell::new(None),
+            completion_request_handle: None,
         }
     }
 
@@ -841,6 +992,7 @@ pub fn refresh_config(&mut self) {
         let config = self.config();
         self.auto_pairs = (&config.auto_pairs).into();
         self.reset_idle_timer();
+        self._refresh();
     }
 
     pub fn clear_idle_timer(&mut self) {
@@ -906,7 +1058,7 @@ pub fn set_theme(&mut self, theme: Theme) {
 
     fn set_theme_impl(&mut self, theme: Theme, preview: ThemeAction) {
         // `ui.selection` is the only scope required to be able to render a theme.
-        if theme.find_scope_index("ui.selection").is_none() {
+        if theme.find_scope_index_exact("ui.selection").is_none() {
             self.set_error("Invalid theme: `ui.selection` required");
             return;
         }
@@ -931,18 +1083,25 @@ fn set_theme_impl(&mut self, theme: Theme, preview: ThemeAction) {
 
     /// Refreshes the language server for a given document
     pub fn refresh_language_server(&mut self, doc_id: DocumentId) -> Option<()> {
-        let doc = self.documents.get_mut(&doc_id)?;
-        Self::launch_language_server(&mut self.language_servers, doc)
+        self.launch_language_server(doc_id)
     }
 
     /// Launch a language server for a given document
-    fn launch_language_server(ls: &mut helix_lsp::Registry, doc: &mut Document) -> Option<()> {
+    fn launch_language_server(&mut self, doc_id: DocumentId) -> Option<()> {
+        if !self.config().lsp.enable {
+            return None;
+        }
+
         // if doc doesn't have a URL it's a scratch buffer, ignore it
-        let doc_url = doc.url()?;
+        let doc = self.document(doc_id)?;
+        let (lang, path) = (doc.language.clone(), doc.path().cloned());
+        let config = doc.config.load();
+        let root_dirs = &config.workspace_lsp_roots;
 
         // try to find a language server based on the language name
-        let language_server = doc.language.as_ref().and_then(|language| {
-            ls.get(language, doc.path())
+        let language_server = lang.as_ref().and_then(|language| {
+            self.language_servers
+                .get(language, path.as_ref(), root_dirs, config.lsp.snippets)
                 .map_err(|e| {
                     log::error!(
                         "Failed to initialize the LSP for `{}` {{ {} }}",
@@ -953,6 +1112,10 @@ fn launch_language_server(ls: &mut helix_lsp::Registry, doc: &mut Document) -> O
                 .ok()
                 .flatten()
         });
+
+        let doc = self.document_mut(doc_id)?;
+        let doc_url = doc.url()?;
+
         if let Some(language_server) = language_server {
             // only spawn a new lang server if the servers aren't the same
             if Some(language_server.id()) != doc.language_server().map(|server| server.id()) {
@@ -978,9 +1141,23 @@ fn launch_language_server(ls: &mut helix_lsp::Registry, doc: &mut Document) -> O
 
     fn _refresh(&mut self) {
         let config = self.config();
+
+        // Reset the inlay hints annotations *before* updating the views, that way we ensure they
+        // will disappear during the `.sync_change(doc)` call below.
+        //
+        // We can't simply check this config when rendering because inlay hints are only parts of
+        // the possible annotations, and others could still be active, so we need to selectively
+        // drop the inlay hints.
+        if !config.lsp.display_inlay_hints {
+            for doc in self.documents_mut() {
+                doc.reset_all_inlay_hints();
+            }
+        }
+
         for (view, _) in self.tree.views_mut() {
             let doc = doc_mut!(self, &view.doc);
             view.sync_changes(doc);
+            view.gutters = config.gutters.clone();
             view.ensure_cursor_in_view(doc, config.scrolloff)
         }
     }
@@ -988,7 +1165,7 @@ fn _refresh(&mut self) {
     fn replace_document_in_view(&mut self, current_view: ViewId, doc_id: DocumentId) {
         let view = self.tree.get_mut(current_view);
         view.doc = doc_id;
-        view.offset = Position::default();
+        view.offset = ViewPosition::default();
 
         let doc = doc_mut!(self, &doc_id);
         doc.ensure_view_init(view.id);
@@ -1115,12 +1292,15 @@ fn new_file_from_document(&mut self, action: Action, doc: Document) -> DocumentI
     }
 
     pub fn new_file(&mut self, action: Action) -> DocumentId {
-        self.new_file_from_document(action, Document::default())
+        self.new_file_from_document(action, Document::default(self.config.clone()))
     }
 
     pub fn new_file_from_stdin(&mut self, action: Action) -> Result<DocumentId, Error> {
         let (rope, encoding) = crate::document::from_reader(&mut stdin(), None)?;
-        Ok(self.new_file_from_document(action, Document::from(rope, Some(encoding))))
+        Ok(self.new_file_from_document(
+            action,
+            Document::from(rope, Some(encoding), self.config.clone()),
+        ))
     }
 
     // ??? possible use for integration tests
@@ -1131,13 +1311,22 @@ pub fn open(&mut self, path: &Path, action: Action) -> Result<DocumentId, Error>
         let id = if let Some(id) = id {
             id
         } else {
-            let mut doc = Document::open(&path, None, Some(self.syn_loader.clone()))?;
+            let mut doc = Document::open(
+                &path,
+                None,
+                Some(self.syn_loader.clone()),
+                self.config.clone(),
+            )?;
 
-            let _ = Self::launch_language_server(&mut self.language_servers, &mut doc);
             if let Some(diff_base) = self.diff_providers.get_diff_base(&path) {
                 doc.set_diff_base(diff_base, self.redraw_handle.clone());
             }
-            self.new_document(doc)
+            doc.set_version_control_head(self.diff_providers.get_current_head_name(&path));
+
+            let id = self.new_document(doc);
+            let _ = self.launch_language_server(id);
+
+            id
         };
 
         self.switch(id, action);
@@ -1217,7 +1406,7 @@ enum Action {
                 .iter()
                 .map(|(&doc_id, _)| doc_id)
                 .next()
-                .unwrap_or_else(|| self.new_document(Document::default()));
+                .unwrap_or_else(|| self.new_document(Document::default(self.config.clone())));
             let view = View::new(doc_id, self.config().gutters.clone());
             let view_id = self.tree.insert(view);
             let doc = doc_mut!(self, &doc_id);
@@ -1282,6 +1471,10 @@ pub fn focus_next(&mut self) {
         self.focus(self.tree.next());
     }
 
+    pub fn focus_prev(&mut self) {
+        self.focus(self.tree.prev());
+    }
+
     pub fn focus_direction(&mut self, direction: tree::Direction) {
         let current_view = self.tree.focus;
         if let Some(id) = self.tree.find_split_in_direction(current_view, direction) {
@@ -1338,6 +1531,8 @@ pub fn document_by_path_mut<P: AsRef<Path>>(&mut self, path: P) -> Option<&mut D
             .find(|doc| doc.path().map(|p| p == path.as_ref()).unwrap_or(false))
     }
 
+    /// Gets the primary cursor position in screen coordinates,
+    /// or `None` if the primary cursor is not visible on screen.
     pub fn cursor(&self) -> (Option<Position>, CursorKind) {
         let config = self.config();
         let (view, doc) = current_ref!(self);
@@ -1345,7 +1540,11 @@ pub fn cursor(&self) -> (Option<Position>, CursorKind) {
             .selection(view.id)
             .primary()
             .cursor(doc.text().slice(..));
-        if let Some(mut pos) = view.screen_coords_at_pos(doc, doc.text().slice(..), cursor) {
+        let pos = self
+            .cursor_cache
+            .get()
+            .unwrap_or_else(|| view.screen_coords_at_pos(doc, doc.text().slice(..), cursor));
+        if let Some(mut pos) = pos {
             let inner = view.inner_area(doc);
             pos.col += inner.x as usize;
             pos.row += inner.y as usize;
@@ -1460,6 +1659,12 @@ pub fn enter_normal_mode(&mut self) {
             doc.restore_cursor = false;
         }
     }
+
+    pub fn current_stack_frame(&self) -> Option<&StackFrame> {
+        self.debugger
+            .as_ref()
+            .and_then(|debugger| debugger.current_stack_frame())
+    }
 }
 
 fn try_restore_indent(doc: &mut Document, view: &mut View) {
@@ -1493,6 +1698,6 @@ fn inserted_a_new_blank_line(changes: &[Operation], pos: usize, line_end_pos: us
                 let line_start_pos = text.line_to_char(range.cursor_line(text));
                 (line_start_pos, pos, None)
             });
-        crate::apply_transaction(&transaction, doc, view);
+        doc.apply(&transaction, view.id);
     }
 }
diff --git a/helix-view/src/graphics.rs b/helix-view/src/graphics.rs
index 9264c50f8..046db86a1 100644
--- a/helix-view/src/graphics.rs
+++ b/helix-view/src/graphics.rs
@@ -237,8 +237,8 @@ pub fn intersection(self, other: Rect) -> Rect {
         Rect {
             x: x1,
             y: y1,
-            width: x2 - x1,
-            height: y2 - y1,
+            width: x2.saturating_sub(x1),
+            height: y2.saturating_sub(y1),
         }
     }
 
@@ -251,7 +251,6 @@ pub fn intersects(self, other: Rect) -> bool {
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
-#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
 pub enum Color {
     Reset,
     Black,
@@ -353,7 +352,7 @@ fn from(style: UnderlineStyle) -> Self {
     ///
     /// let m = Modifier::BOLD | Modifier::ITALIC;
     /// ```
-    #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
+    #[derive(PartialEq, Eq, Debug, Clone, Copy)]
     pub struct Modifier: u16 {
         const BOLD              = 0b0000_0000_0001;
         const DIM               = 0b0000_0000_0010;
@@ -450,7 +449,6 @@ fn from_str(modifier: &str) -> Result<Self, Self::Err> {
 /// );
 /// ```
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
-#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
 pub struct Style {
     pub fg: Option<Color>,
     pub bg: Option<Color>,
diff --git a/helix-view/src/gutter.rs b/helix-view/src/gutter.rs
index 377518fb5..3ecae9195 100644
--- a/helix-view/src/gutter.rs
+++ b/helix-view/src/gutter.rs
@@ -2,17 +2,16 @@
 
 use crate::{
     editor::GutterType,
-    graphics::{Color, Style, UnderlineStyle},
+    graphics::{Style, UnderlineStyle},
     Document, Editor, Theme, View,
 };
 
 fn count_digits(n: usize) -> usize {
-    // NOTE: if int_log gets standardized in stdlib, can use checked_log10
-    // (https://github.com/rust-lang/rust/issues/70887#issue)
-    std::iter::successors(Some(n), |&n| (n >= 10).then(|| n / 10)).count()
+    // TODO: use checked_log10 when MSRV reaches 1.67
+    std::iter::successors(Some(n), |&n| (n >= 10).then_some(n / 10)).count()
 }
 
-pub type GutterFn<'doc> = Box<dyn FnMut(usize, bool, &mut String) -> Option<Style> + 'doc>;
+pub type GutterFn<'doc> = Box<dyn FnMut(usize, bool, bool, &mut String) -> Option<Style> + 'doc>;
 pub type Gutter =
     for<'doc> fn(&'doc Editor, &'doc Document, &View, &Theme, bool, usize) -> GutterFn<'doc>;
 
@@ -35,10 +34,10 @@ pub fn style<'doc>(
         }
     }
 
-    pub fn width(self, _view: &View, doc: &Document) -> usize {
+    pub fn width(self, view: &View, doc: &Document) -> usize {
         match self {
             GutterType::Diagnostics => 1,
-            GutterType::LineNumbers => line_numbers_width(_view, doc),
+            GutterType::LineNumbers => line_numbers_width(view, doc),
             GutterType::Spacer => 1,
             GutterType::Diff => 1,
         }
@@ -58,31 +57,36 @@ pub fn diagnostic<'doc>(
     let hint = theme.get("hint");
     let diagnostics = doc.diagnostics();
 
-    Box::new(move |line: usize, _selected: bool, out: &mut String| {
-        use helix_core::diagnostic::Severity;
-        if let Ok(index) = diagnostics.binary_search_by_key(&line, |d| d.line) {
-            let after = diagnostics[index..].iter().take_while(|d| d.line == line);
-
-            let before = diagnostics[..index]
-                .iter()
-                .rev()
-                .take_while(|d| d.line == line);
-
-            let diagnostics_on_line = after.chain(before);
-
-            // This unwrap is safe because the iterator cannot be empty as it contains at least the item found by the binary search.
-            let diagnostic = diagnostics_on_line.max_by_key(|d| d.severity).unwrap();
-
-            write!(out, "").unwrap();
-            return Some(match diagnostic.severity {
-                Some(Severity::Error) => error,
-                Some(Severity::Warning) | None => warning,
-                Some(Severity::Info) => info,
-                Some(Severity::Hint) => hint,
-            });
-        }
-        None
-    })
+    Box::new(
+        move |line: usize, _selected: bool, first_visual_line: bool, out: &mut String| {
+            if !first_visual_line {
+                return None;
+            }
+            use helix_core::diagnostic::Severity;
+            if let Ok(index) = diagnostics.binary_search_by_key(&line, |d| d.line) {
+                let after = diagnostics[index..].iter().take_while(|d| d.line == line);
+
+                let before = diagnostics[..index]
+                    .iter()
+                    .rev()
+                    .take_while(|d| d.line == line);
+
+                let diagnostics_on_line = after.chain(before);
+
+                // This unwrap is safe because the iterator cannot be empty as it contains at least the item found by the binary search.
+                let diagnostic = diagnostics_on_line.max_by_key(|d| d.severity).unwrap();
+
+                write!(out, "").unwrap();
+                return Some(match diagnostic.severity {
+                    Some(Severity::Error) => error,
+                    Some(Severity::Warning) | None => warning,
+                    Some(Severity::Info) => info,
+                    Some(Severity::Hint) => hint,
+                });
+            }
+            None
+        },
+    )
 }
 
 pub fn diff<'doc>(
@@ -96,39 +100,44 @@ pub fn diff<'doc>(
     let deleted = theme.get("diff.minus");
     let modified = theme.get("diff.delta");
     if let Some(diff_handle) = doc.diff_handle() {
-        let hunks = diff_handle.hunks();
+        let hunks = diff_handle.load();
         let mut hunk_i = 0;
         let mut hunk = hunks.nth_hunk(hunk_i);
-        Box::new(move |line: usize, _selected: bool, out: &mut String| {
-            // truncating the line is fine here because we don't compute diffs
-            // for files with more lines than i32::MAX anyways
-            // we need to special case removals here
-            // these technically do not have a range of lines to highlight (`hunk.after.start == hunk.after.end`).
-            // However we still want to display these hunks correctly we must not yet skip to the next hunk here
-            while hunk.after.end < line as u32
-                || !hunk.is_pure_removal() && line as u32 == hunk.after.end
-            {
-                hunk_i += 1;
-                hunk = hunks.nth_hunk(hunk_i);
-            }
-
-            if hunk.after.start > line as u32 {
-                return None;
-            }
-
-            let (icon, style) = if hunk.is_pure_insertion() {
-                ("", added)
-            } else if hunk.is_pure_removal() {
-                ("", deleted)
-            } else {
-                ("", modified)
-            };
-
-            write!(out, "{}", icon).unwrap();
-            Some(style)
-        })
+        Box::new(
+            move |line: usize, _selected: bool, first_visual_line: bool, out: &mut String| {
+                // truncating the line is fine here because we don't compute diffs
+                // for files with more lines than i32::MAX anyways
+                // we need to special case removals here
+                // these technically do not have a range of lines to highlight (`hunk.after.start == hunk.after.end`).
+                // However we still want to display these hunks correctly we must not yet skip to the next hunk here
+                while hunk.after.end < line as u32
+                    || !hunk.is_pure_removal() && line as u32 == hunk.after.end
+                {
+                    hunk_i += 1;
+                    hunk = hunks.nth_hunk(hunk_i);
+                }
+
+                if hunk.after.start > line as u32 {
+                    return None;
+                }
+
+                let (icon, style) = if hunk.is_pure_insertion() {
+                    ("", added)
+                } else if hunk.is_pure_removal() {
+                    if !first_visual_line {
+                        return None;
+                    }
+                    ("", deleted)
+                } else {
+                    ("", modified)
+                };
+
+                write!(out, "{}", icon).unwrap();
+                Some(style)
+            },
+        )
     } else {
-        Box::new(move |_, _, _| None)
+        Box::new(move |_, _, _, _| None)
     }
 }
 
@@ -140,12 +149,13 @@ pub fn line_numbers<'doc>(
     is_focused: bool,
 ) -> GutterFn<'doc> {
     let text = doc.text().slice(..);
-    let last_line = view.last_line(doc);
-    let width = GutterType::LineNumbers.width(view, doc);
+    let width = line_numbers_width(view, doc);
+
+    let last_line_in_view = view.estimate_last_doc_line(doc);
 
     // Whether to draw the line number for the last line of the
     // document or not.  We only draw it if it's not an empty line.
-    let draw_last = text.line_to_byte(last_line) < text.len_bytes();
+    let draw_last = text.line_to_byte(last_line_in_view) < text.len_bytes();
 
     let linenr = theme.get("ui.linenr");
     let linenr_select = theme.get("ui.linenr.selected");
@@ -157,44 +167,56 @@ pub fn line_numbers<'doc>(
     let line_number = editor.config().line_number;
     let mode = editor.mode;
 
-    Box::new(move |line: usize, selected: bool, out: &mut String| {
-        if line == last_line && !draw_last {
-            write!(out, "{:>1$}", '~', width).unwrap();
-            Some(linenr)
-        } else {
-            use crate::{document::Mode, editor::LineNumber};
-
-            let relative = line_number == LineNumber::Relative
-                && mode != Mode::Insert
-                && is_focused
-                && current_line != line;
-
-            let display_num = if relative {
-                abs_diff(current_line, line)
+    Box::new(
+        move |line: usize, selected: bool, first_visual_line: bool, out: &mut String| {
+            if line == last_line_in_view && !draw_last {
+                write!(out, "{:>1$}", '~', width).unwrap();
+                Some(linenr)
             } else {
-                line + 1
-            };
-
-            let style = if selected && is_focused {
-                linenr_select
-            } else {
-                linenr
-            };
-
-            write!(out, "{:>1$}", display_num, width).unwrap();
-            Some(style)
-        }
-    })
+                use crate::{document::Mode, editor::LineNumber};
+
+                let relative = line_number == LineNumber::Relative
+                    && mode != Mode::Insert
+                    && is_focused
+                    && current_line != line;
+
+                let display_num = if relative {
+                    abs_diff(current_line, line)
+                } else {
+                    line + 1
+                };
+
+                let style = if selected && is_focused {
+                    linenr_select
+                } else {
+                    linenr
+                };
+
+                if first_visual_line {
+                    write!(out, "{:>1$}", display_num, width).unwrap();
+                } else {
+                    write!(out, "{:>1$}", " ", width).unwrap();
+                }
+
+                first_visual_line.then_some(style)
+            }
+        },
+    )
 }
 
-pub fn line_numbers_width(_view: &View, doc: &Document) -> usize {
+/// The width of a "line-numbers" gutter
+///
+/// The width of the gutter depends on the number of lines in the document,
+/// whether there is content on the last line (the `~` line), and the
+/// `editor.gutters.line-numbers.min-width` settings.
+fn line_numbers_width(view: &View, doc: &Document) -> usize {
     let text = doc.text();
     let last_line = text.len_lines().saturating_sub(1);
     let draw_last = text.line_to_byte(last_line) < text.len_bytes();
     let last_drawn = if draw_last { last_line + 1 } else { last_line };
-
-    // set a lower bound to 2-chars to minimize ambiguous relative line numbers
-    std::cmp::max(count_digits(last_drawn), 2)
+    let digits = count_digits(last_drawn);
+    let n_min = view.gutters.line_numbers.min_width;
+    digits.max(n_min)
 }
 
 pub fn padding<'doc>(
@@ -204,7 +226,7 @@ pub fn padding<'doc>(
     _theme: &Theme,
     _is_focused: bool,
 ) -> GutterFn<'doc> {
-    Box::new(|_line: usize, _selected: bool, _out: &mut String| None)
+    Box::new(|_line: usize, _selected: bool, _first_visual_line: bool, _out: &mut String| None)
 }
 
 #[inline(always)]
@@ -223,49 +245,76 @@ pub fn breakpoints<'doc>(
     theme: &Theme,
     _is_focused: bool,
 ) -> GutterFn<'doc> {
-    let warning = theme.get("warning");
     let error = theme.get("error");
     let info = theme.get("info");
+    let breakpoint_style = theme.get("ui.debug.breakpoint");
 
     let breakpoints = doc.path().and_then(|path| editor.breakpoints.get(path));
 
     let breakpoints = match breakpoints {
         Some(breakpoints) => breakpoints,
-        None => return Box::new(move |_, _, _| None),
+        None => return Box::new(move |_, _, _, _| None),
     };
 
-    Box::new(move |line: usize, _selected: bool, out: &mut String| {
-        let breakpoint = breakpoints
-            .iter()
-            .find(|breakpoint| breakpoint.line == line)?;
-
-        let mut style = if breakpoint.condition.is_some() && breakpoint.log_message.is_some() {
-            error.underline_style(UnderlineStyle::Line)
-        } else if breakpoint.condition.is_some() {
-            error
-        } else if breakpoint.log_message.is_some() {
-            info
-        } else {
-            warning
-        };
-
-        if !breakpoint.verified {
-            // Faded colors
-            style = if let Some(Color::Rgb(r, g, b)) = style.fg {
-                style.fg(Color::Rgb(
-                    ((r as f32) * 0.4).floor() as u8,
-                    ((g as f32) * 0.4).floor() as u8,
-                    ((b as f32) * 0.4).floor() as u8,
-                ))
+    Box::new(
+        move |line: usize, _selected: bool, first_visual_line: bool, out: &mut String| {
+            if !first_visual_line {
+                return None;
+            }
+            let breakpoint = breakpoints
+                .iter()
+                .find(|breakpoint| breakpoint.line == line)?;
+
+            let style = if breakpoint.condition.is_some() && breakpoint.log_message.is_some() {
+                error.underline_style(UnderlineStyle::Line)
+            } else if breakpoint.condition.is_some() {
+                error
+            } else if breakpoint.log_message.is_some() {
+                info
             } else {
-                style.fg(Color::Gray)
+                breakpoint_style
+            };
+
+            let sym = if breakpoint.verified { "" } else { "" };
+            write!(out, "{}", sym).unwrap();
+            Some(style)
+        },
+    )
+}
+
+fn execution_pause_indicator<'doc>(
+    editor: &'doc Editor,
+    doc: &'doc Document,
+    theme: &Theme,
+    is_focused: bool,
+) -> GutterFn<'doc> {
+    let style = theme.get("ui.debug.active");
+    let current_stack_frame = editor.current_stack_frame();
+    let frame_line = current_stack_frame.map(|frame| frame.line - 1);
+    let frame_source_path = current_stack_frame.map(|frame| {
+        frame
+            .source
+            .as_ref()
+            .and_then(|source| source.path.as_ref())
+    });
+    let should_display_for_current_doc =
+        doc.path().is_some() && frame_source_path.unwrap_or(None) == doc.path();
+
+    Box::new(
+        move |line: usize, _selected: bool, first_visual_line: bool, out: &mut String| {
+            if !first_visual_line
+                || !is_focused
+                || line != frame_line?
+                || !should_display_for_current_doc
+            {
+                return None;
             }
-        };
 
-        let sym = if breakpoint.verified { "" } else { "" };
-        write!(out, "{}", sym).unwrap();
-        Some(style)
-    })
+            let sym = "";
+            write!(out, "{}", sym).unwrap();
+            Some(style)
+        },
+    )
 }
 
 pub fn diagnostics_or_breakpoints<'doc>(
@@ -277,8 +326,113 @@ pub fn diagnostics_or_breakpoints<'doc>(
 ) -> GutterFn<'doc> {
     let mut diagnostics = diagnostic(editor, doc, view, theme, is_focused);
     let mut breakpoints = breakpoints(editor, doc, view, theme, is_focused);
+    let mut execution_pause_indicator = execution_pause_indicator(editor, doc, theme, is_focused);
 
-    Box::new(move |line, selected, out| {
-        breakpoints(line, selected, out).or_else(|| diagnostics(line, selected, out))
+    Box::new(move |line, selected, first_visual_line: bool, out| {
+        execution_pause_indicator(line, selected, first_visual_line, out)
+            .or_else(|| breakpoints(line, selected, first_visual_line, out))
+            .or_else(|| diagnostics(line, selected, first_visual_line, out))
     })
 }
+
+#[cfg(test)]
+mod tests {
+    use std::sync::Arc;
+
+    use super::*;
+    use crate::document::Document;
+    use crate::editor::{Config, GutterConfig, GutterLineNumbersConfig};
+    use crate::graphics::Rect;
+    use crate::DocumentId;
+    use arc_swap::ArcSwap;
+    use helix_core::Rope;
+
+    #[test]
+    fn test_default_gutter_widths() {
+        let mut view = View::new(DocumentId::default(), GutterConfig::default());
+        view.area = Rect::new(40, 40, 40, 40);
+
+        let rope = Rope::from_str("abc\n\tdef");
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+
+        assert_eq!(view.gutters.layout.len(), 5);
+        assert_eq!(view.gutters.layout[0].width(&view, &doc), 1);
+        assert_eq!(view.gutters.layout[1].width(&view, &doc), 1);
+        assert_eq!(view.gutters.layout[2].width(&view, &doc), 3);
+        assert_eq!(view.gutters.layout[3].width(&view, &doc), 1);
+        assert_eq!(view.gutters.layout[4].width(&view, &doc), 1);
+    }
+
+    #[test]
+    fn test_configured_gutter_widths() {
+        let gutters = GutterConfig {
+            layout: vec![GutterType::Diagnostics],
+            ..Default::default()
+        };
+
+        let mut view = View::new(DocumentId::default(), gutters);
+        view.area = Rect::new(40, 40, 40, 40);
+
+        let rope = Rope::from_str("abc\n\tdef");
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+
+        assert_eq!(view.gutters.layout.len(), 1);
+        assert_eq!(view.gutters.layout[0].width(&view, &doc), 1);
+
+        let gutters = GutterConfig {
+            layout: vec![GutterType::Diagnostics, GutterType::LineNumbers],
+            line_numbers: GutterLineNumbersConfig { min_width: 10 },
+        };
+
+        let mut view = View::new(DocumentId::default(), gutters);
+        view.area = Rect::new(40, 40, 40, 40);
+
+        let rope = Rope::from_str("abc\n\tdef");
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+
+        assert_eq!(view.gutters.layout.len(), 2);
+        assert_eq!(view.gutters.layout[0].width(&view, &doc), 1);
+        assert_eq!(view.gutters.layout[1].width(&view, &doc), 10);
+    }
+
+    #[test]
+    fn test_line_numbers_gutter_width_resizes() {
+        let gutters = GutterConfig {
+            layout: vec![GutterType::Diagnostics, GutterType::LineNumbers],
+            line_numbers: GutterLineNumbersConfig { min_width: 1 },
+        };
+
+        let mut view = View::new(DocumentId::default(), gutters);
+        view.area = Rect::new(40, 40, 40, 40);
+
+        let rope = Rope::from_str("a\nb");
+        let doc_short = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+
+        let rope = Rope::from_str("a\nb\nc\nd\ne\nf\ng\nh\ni\nj\nk\nl\nm\nn\no\np");
+        let doc_long = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+
+        assert_eq!(view.gutters.layout.len(), 2);
+        assert_eq!(view.gutters.layout[1].width(&view, &doc_short), 1);
+        assert_eq!(view.gutters.layout[1].width(&view, &doc_long), 2);
+    }
+}
diff --git a/helix-view/src/handlers/dap.rs b/helix-view/src/handlers/dap.rs
index 2e86871b5..107c29be5 100644
--- a/helix-view/src/handlers/dap.rs
+++ b/helix-view/src/handlers/dap.rs
@@ -1,7 +1,8 @@
 use crate::editor::{Action, Breakpoint};
 use crate::{align_view, Align, Editor};
+use dap::requests::DisconnectArguments;
 use helix_core::Selection;
-use helix_dap::{self as dap, Client, Payload, Request, ThreadId};
+use helix_dap::{self as dap, Client, ConnectionType, Payload, Request, ThreadId};
 use helix_lsp::block_on;
 use log::warn;
 use std::fmt::Write;
@@ -274,6 +275,66 @@ pub async fn handle_debugger_message(&mut self, payload: helix_dap::Payload) ->
                         self.set_status("Debugged application started");
                     }; // TODO: do we need to handle error?
                 }
+                Event::Terminated(terminated) => {
+                    let restart_args = if let Some(terminated) = terminated {
+                        terminated.restart
+                    } else {
+                        None
+                    };
+
+                    let disconnect_args = Some(DisconnectArguments {
+                        restart: Some(restart_args.is_some()),
+                        terminate_debuggee: None,
+                        suspend_debuggee: None,
+                    });
+
+                    if let Err(err) = debugger.disconnect(disconnect_args).await {
+                        self.set_error(format!(
+                            "Cannot disconnect debugger upon terminated event receival {:?}",
+                            err
+                        ));
+                        return false;
+                    }
+
+                    match restart_args {
+                        Some(restart_args) => {
+                            log::info!("Attempting to restart debug session.");
+                            let connection_type = match debugger.connection_type() {
+                                Some(connection_type) => connection_type,
+                                None => {
+                                    self.set_error("No starting request found, to be used in restarting the debugging session.");
+                                    return false;
+                                }
+                            };
+
+                            let relaunch_resp = if let ConnectionType::Launch = connection_type {
+                                debugger.launch(restart_args).await
+                            } else {
+                                debugger.attach(restart_args).await
+                            };
+
+                            if let Err(err) = relaunch_resp {
+                                self.set_error(format!(
+                                    "Failed to restart debugging session: {:?}",
+                                    err
+                                ));
+                            }
+                        }
+                        None => {
+                            self.set_status(
+                                "Terminated debugging session and disconnected debugger.",
+                            );
+                        }
+                    }
+                }
+                Event::Exited(resp) => {
+                    let exit_code = resp.exit_code;
+                    if exit_code != 0 {
+                        self.set_error(format!(
+                            "Debuggee failed to exit successfully (exit code: {exit_code})."
+                        ));
+                    }
+                }
                 ev => {
                     log::warn!("Unhandled event {:?}", ev);
                     return false; // return early to skip render
diff --git a/helix-view/src/input.rs b/helix-view/src/input.rs
index bda0520e0..d8832adce 100644
--- a/helix-view/src/input.rs
+++ b/helix-view/src/input.rs
@@ -380,7 +380,7 @@ fn from_str(s: &str) -> Result<Self, Self::Err> {
                 let function: String = function.chars().skip(1).collect();
                 let function = str::parse::<u8>(&function)?;
                 (function > 0 && function < 13)
-                    .then(|| KeyCode::F(function))
+                    .then_some(KeyCode::F(function))
                     .ok_or_else(|| anyhow!("Invalid function key '{}'", function))?
             }
             invalid => return Err(anyhow!("Invalid key code '{}'", invalid)),
diff --git a/helix-view/src/keyboard.rs b/helix-view/src/keyboard.rs
index cf673e113..080bce8dd 100644
--- a/helix-view/src/keyboard.rs
+++ b/helix-view/src/keyboard.rs
@@ -2,7 +2,7 @@
 
 bitflags! {
     /// Represents key modifiers (shift, control, alt).
-    #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
+    #[derive(Debug, PartialOrd, Ord, PartialEq, Eq, Clone, Copy, Hash)]
     pub struct KeyModifiers: u8 {
         const SHIFT = 0b0000_0001;
         const CONTROL = 0b0000_0010;
diff --git a/helix-view/src/lib.rs b/helix-view/src/lib.rs
index 9cf36ae05..c3f67345b 100644
--- a/helix-view/src/lib.rs
+++ b/helix-view/src/lib.rs
@@ -49,13 +49,10 @@ pub enum Align {
 }
 
 pub fn align_view(doc: &Document, view: &mut View, align: Align) {
-    let pos = doc
-        .selection(view.id)
-        .primary()
-        .cursor(doc.text().slice(..));
-    let line = doc.text().char_to_line(pos);
-
-    let last_line_height = view.inner_height().saturating_sub(1);
+    let doc_text = doc.text().slice(..);
+    let cursor = doc.selection(view.id).primary().cursor(doc_text);
+    let viewport = view.inner_area(doc);
+    let last_line_height = viewport.height.saturating_sub(1);
 
     let relative = match align {
         Align::Center => last_line_height / 2,
@@ -63,21 +60,20 @@ pub fn align_view(doc: &Document, view: &mut View, align: Align) {
         Align::Bottom => last_line_height,
     };
 
-    view.offset.row = line.saturating_sub(relative);
-}
-
-/// Applies a [`helix_core::Transaction`] to the given [`Document`]
-/// and [`View`].
-pub fn apply_transaction(
-    transaction: &helix_core::Transaction,
-    doc: &mut Document,
-    view: &View,
-) -> bool {
-    // TODO remove this helper function. Just call Document::apply everywhere directly.
-    doc.apply(transaction, view.id)
+    let text_fmt = doc.text_format(viewport.width, None);
+    let annotations = view.text_annotations(doc, None);
+    (view.offset.anchor, view.offset.vertical_offset) = char_idx_at_visual_offset(
+        doc_text,
+        cursor,
+        -(relative as isize),
+        0,
+        &text_fmt,
+        &annotations,
+    );
 }
 
 pub use document::Document;
 pub use editor::Editor;
+use helix_core::char_idx_at_visual_offset;
 pub use theme::Theme;
 pub use view::View;
diff --git a/helix-view/src/theme.rs b/helix-view/src/theme.rs
index f1219ec5d..a8cc59260 100644
--- a/helix-view/src/theme.rs
+++ b/helix-view/src/theme.rs
@@ -1,9 +1,10 @@
 use std::{
-    collections::HashMap,
+    collections::{HashMap, HashSet},
     path::{Path, PathBuf},
+    str,
 };
 
-use anyhow::{anyhow, Context, Result};
+use anyhow::{anyhow, Result};
 use helix_core::hashmap;
 use helix_loader::merge_toml_values;
 use log::warn;
@@ -14,32 +15,43 @@
 use crate::graphics::UnderlineStyle;
 pub use crate::graphics::{Color, Modifier, Style};
 
+pub static DEFAULT_THEME_DATA: Lazy<Value> = Lazy::new(|| {
+    let bytes = include_bytes!("../../theme.toml");
+    toml::from_str(str::from_utf8(bytes).unwrap()).expect("Failed to parse base default theme")
+});
+
+pub static BASE16_DEFAULT_THEME_DATA: Lazy<Value> = Lazy::new(|| {
+    let bytes = include_bytes!("../../base16_theme.toml");
+    toml::from_str(str::from_utf8(bytes).unwrap()).expect("Failed to parse base 16 default theme")
+});
+
 pub static DEFAULT_THEME: Lazy<Theme> = Lazy::new(|| Theme {
     name: "default".into(),
-    ..toml::from_slice(include_bytes!("../../theme.toml")).expect("Failed to parse default theme")
+    ..Theme::from(DEFAULT_THEME_DATA.clone())
 });
 
 pub static BASE16_DEFAULT_THEME: Lazy<Theme> = Lazy::new(|| Theme {
-    name: "base16_theme".into(),
-    ..toml::from_slice(include_bytes!("../../base16_theme.toml"))
-        .expect("Failed to parse base 16 default theme")
+    name: "base16_default".into(),
+    ..Theme::from(BASE16_DEFAULT_THEME_DATA.clone())
 });
 
 #[derive(Clone, Debug)]
 pub struct Loader {
-    user_dir: PathBuf,
-    default_dir: PathBuf,
+    /// Theme directories to search from highest to lowest priority
+    theme_dirs: Vec<PathBuf>,
 }
 impl Loader {
-    /// Creates a new loader that can load themes from two directories.
-    pub fn new<P: AsRef<Path>>(user_dir: P, default_dir: P) -> Self {
+    /// Creates a new loader that can load themes from multiple directories.
+    ///
+    /// The provided directories should be ordered from highest to lowest priority.
+    /// The directories will have their "themes" subdirectory searched.
+    pub fn new(dirs: &[PathBuf]) -> Self {
         Self {
-            user_dir: user_dir.as_ref().join("themes"),
-            default_dir: default_dir.as_ref().join("themes"),
+            theme_dirs: dirs.iter().map(|p| p.join("themes")).collect(),
         }
     }
 
-    /// Loads a theme first looking in the `user_dir` then in `default_dir`
+    /// Loads a theme searching directories in priority order.
     pub fn load(&self, name: &str) -> Result<Theme> {
         if name == "default" {
             return Ok(self.default());
@@ -48,7 +60,8 @@ pub fn load(&self, name: &str) -> Result<Theme> {
             return Ok(self.base16_default());
         }
 
-        let theme = self.load_theme(name, name, false).map(Theme::from)?;
+        let mut visited_paths = HashSet::new();
+        let theme = self.load_theme(name, &mut visited_paths).map(Theme::from)?;
 
         Ok(Theme {
             name: name.into(),
@@ -56,16 +69,18 @@ pub fn load(&self, name: &str) -> Result<Theme> {
         })
     }
 
-    // load the theme and its parent recursively and merge them
-    // `base_theme_name` is the theme from the config.toml,
-    // used to prevent some circular loading scenarios
-    fn load_theme(
-        &self,
-        name: &str,
-        base_them_name: &str,
-        only_default_dir: bool,
-    ) -> Result<Value> {
-        let path = self.path(name, only_default_dir);
+    /// Recursively load a theme, merging with any inherited parent themes.
+    ///
+    /// The paths that have been visited in the inheritance hierarchy are tracked
+    /// to detect and avoid cycling.
+    ///
+    /// It is possible for one file to inherit from another file with the same name
+    /// so long as the second file is in a themes directory with lower priority.
+    /// However, it is not recommended that users do this as it will make tracing
+    /// errors more difficult.
+    fn load_theme(&self, name: &str, visited_paths: &mut HashSet<PathBuf>) -> Result<Value> {
+        let path = self.path(name, visited_paths)?;
+
         let theme_toml = self.load_toml(path)?;
 
         let inherits = theme_toml.get("inherits");
@@ -78,11 +93,12 @@ fn load_theme(
                 )
             })?;
 
-            let parent_theme_toml = self.load_theme(
-                parent_theme_name,
-                base_them_name,
-                base_them_name == parent_theme_name,
-            )?;
+            let parent_theme_toml = match parent_theme_name {
+                // load default themes's toml from const.
+                "default" => DEFAULT_THEME_DATA.clone(),
+                "base16_default" => BASE16_DEFAULT_THEME_DATA.clone(),
+                _ => self.load_theme(parent_theme_name, visited_paths)?,
+            };
 
             self.merge_themes(parent_theme_toml, theme_toml)
         } else {
@@ -112,7 +128,7 @@ fn merge_themes(&self, parent_theme_toml: Value, theme_toml: Value) -> Value {
         let parent_palette = parent_theme_toml.get("palette");
         let palette = theme_toml.get("palette");
 
-        // handle the table seperately since it needs a `merge_depth` of 2
+        // handle the table separately since it needs a `merge_depth` of 2
         // this would conflict with the rest of the theme merge strategy
         let palette_values = match (parent_palette, palette) {
             (Some(parent_palette), Some(palette)) => {
@@ -133,32 +149,43 @@ fn merge_themes(&self, parent_theme_toml: Value, theme_toml: Value) -> Value {
         merge_toml_values(theme, palette.into(), 1)
     }
 
-    // Loads the theme data as `toml::Value` first from the user_dir then in default_dir
+    // Loads the theme data as `toml::Value`
     fn load_toml(&self, path: PathBuf) -> Result<Value> {
-        let data = std::fs::read(&path)?;
+        let data = std::fs::read_to_string(path)?;
+        let value = toml::from_str(&data)?;
 
-        toml::from_slice(data.as_slice()).context("Failed to deserialize theme")
+        Ok(value)
     }
 
-    // Returns the path to the theme with the name
-    // With `only_default_dir` as false the path will first search for the user path
-    // disabled it ignores the user path and returns only the default path
-    fn path(&self, name: &str, only_default_dir: bool) -> PathBuf {
+    /// Returns the path to the theme with the given name
+    ///
+    /// Ignores paths already visited and follows directory priority order.
+    fn path(&self, name: &str, visited_paths: &mut HashSet<PathBuf>) -> Result<PathBuf> {
         let filename = format!("{}.toml", name);
 
-        let user_path = self.user_dir.join(&filename);
-        if !only_default_dir && user_path.exists() {
-            user_path
-        } else {
-            self.default_dir.join(filename)
-        }
-    }
-
-    /// Lists all theme names available in default and user directory
-    pub fn names(&self) -> Vec<String> {
-        let mut names = Self::read_names(&self.user_dir);
-        names.extend(Self::read_names(&self.default_dir));
-        names
+        let mut cycle_found = false; // track if there was a path, but it was in a cycle
+        self.theme_dirs
+            .iter()
+            .find_map(|dir| {
+                let path = dir.join(&filename);
+                if !path.exists() {
+                    None
+                } else if visited_paths.contains(&path) {
+                    // Avoiding cycle, continuing to look in lower priority directories
+                    cycle_found = true;
+                    None
+                } else {
+                    visited_paths.insert(path.clone());
+                    Some(path)
+                }
+            })
+            .ok_or_else(|| {
+                if cycle_found {
+                    anyhow!("Theme: cycle found in inheriting: {}", name)
+                } else {
+                    anyhow!("Theme: file not found for: {}", name)
+                }
+            })
     }
 
     pub fn default_theme(&self, true_color: bool) -> Theme {
@@ -193,16 +220,18 @@ pub struct Theme {
 
 impl From<Value> for Theme {
     fn from(value: Value) -> Self {
-        let values: Result<HashMap<String, Value>> =
-            toml::from_str(&value.to_string()).context("Failed to load theme");
-
-        let (styles, scopes, highlights) = build_theme_values(values);
-
-        Self {
-            styles,
-            scopes,
-            highlights,
-            ..Default::default()
+        if let Value::Table(table) = value {
+            let (styles, scopes, highlights) = build_theme_values(table);
+
+            Self {
+                styles,
+                scopes,
+                highlights,
+                ..Default::default()
+            }
+        } else {
+            warn!("Expected theme TOML value to be a table, found {:?}", value);
+            Default::default()
         }
     }
 }
@@ -212,9 +241,9 @@ fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
     {
-        let values = HashMap::<String, Value>::deserialize(deserializer)?;
+        let values = Map::<String, Value>::deserialize(deserializer)?;
 
-        let (styles, scopes, highlights) = build_theme_values(Ok(values));
+        let (styles, scopes, highlights) = build_theme_values(values);
 
         Ok(Self {
             styles,
@@ -226,39 +255,37 @@ fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 }
 
 fn build_theme_values(
-    values: Result<HashMap<String, Value>>,
+    mut values: Map<String, Value>,
 ) -> (HashMap<String, Style>, Vec<String>, Vec<Style>) {
     let mut styles = HashMap::new();
     let mut scopes = Vec::new();
     let mut highlights = Vec::new();
 
-    if let Ok(mut colors) = values {
-        // TODO: alert user of parsing failures in editor
-        let palette = colors
-            .remove("palette")
-            .map(|value| {
-                ThemePalette::try_from(value).unwrap_or_else(|err| {
-                    warn!("{}", err);
-                    ThemePalette::default()
-                })
-            })
-            .unwrap_or_default();
-        // remove inherits from value to prevent errors
-        let _ = colors.remove("inherits");
-        styles.reserve(colors.len());
-        scopes.reserve(colors.len());
-        highlights.reserve(colors.len());
-        for (name, style_value) in colors {
-            let mut style = Style::default();
-            if let Err(err) = palette.parse_style(&mut style, style_value) {
+    // TODO: alert user of parsing failures in editor
+    let palette = values
+        .remove("palette")
+        .map(|value| {
+            ThemePalette::try_from(value).unwrap_or_else(|err| {
                 warn!("{}", err);
-            }
-
-            // these are used both as UI and as highlights
-            styles.insert(name.clone(), style);
-            scopes.push(name);
-            highlights.push(style);
+                ThemePalette::default()
+            })
+        })
+        .unwrap_or_default();
+    // remove inherits from value to prevent errors
+    let _ = values.remove("inherits");
+    styles.reserve(values.len());
+    scopes.reserve(values.len());
+    highlights.reserve(values.len());
+    for (name, style_value) in values {
+        let mut style = Style::default();
+        if let Err(err) = palette.parse_style(&mut style, style_value) {
+            warn!("{}", err);
         }
+
+        // these are used both as UI and as highlights
+        styles.insert(name.clone(), style);
+        scopes.push(name);
+        highlights.push(style);
     }
 
     (styles, scopes, highlights)
@@ -298,10 +325,23 @@ pub fn scopes(&self) -> &[String] {
         &self.scopes
     }
 
-    pub fn find_scope_index(&self, scope: &str) -> Option<usize> {
+    pub fn find_scope_index_exact(&self, scope: &str) -> Option<usize> {
         self.scopes().iter().position(|s| s == scope)
     }
 
+    pub fn find_scope_index(&self, mut scope: &str) -> Option<usize> {
+        loop {
+            if let Some(highlight) = self.find_scope_index_exact(scope) {
+                return Some(highlight);
+            }
+            if let Some(new_end) = scope.rfind('.') {
+                scope = &scope[..new_end];
+            } else {
+                return None;
+            }
+        }
+    }
+
     pub fn is_16_color(&self) -> bool {
         self.styles.iter().all(|(_, style)| {
             [style.fg, style.bg]
@@ -501,10 +541,8 @@ fn test_parse_style_table() {
 
         let mut style = Style::default();
         let palette = ThemePalette::default();
-        if let Value::Table(entries) = table {
-            for (_name, value) in entries {
-                palette.parse_style(&mut style, value).unwrap();
-            }
+        for (_name, value) in table {
+            palette.parse_style(&mut style, value).unwrap();
         }
 
         assert_eq!(
diff --git a/helix-view/src/tree.rs b/helix-view/src/tree.rs
index 469e913de..e8afd2045 100644
--- a/helix-view/src/tree.rs
+++ b/helix-view/src/tree.rs
@@ -278,16 +278,15 @@ pub fn get(&self, index: ViewId) -> &View {
         self.try_get(index).unwrap()
     }
 
-    /// Try to get reference to a [View] by index. Returns `None` if node content is not a [Content::View]
-    /// # Panics
+    /// Try to get reference to a [View] by index. Returns `None` if node content is not a [`Content::View`].
     ///
-    /// Panics if `index` is not in self.nodes. This can be checked with [Self::contains]
+    /// Does not panic if the view does not exists anymore.
     pub fn try_get(&self, index: ViewId) -> Option<&View> {
-        match &self.nodes[index] {
-            Node {
+        match self.nodes.get(index) {
+            Some(Node {
                 content: Content::View(view),
                 ..
-            } => Some(view),
+            }) => Some(view),
             _ => None,
         }
     }
@@ -701,7 +700,7 @@ fn next_back(&mut self) -> Option<Self::Item> {
 #[cfg(test)]
 mod test {
     use super::*;
-    use crate::editor::GutterType;
+    use crate::editor::GutterConfig;
     use crate::DocumentId;
 
     #[test]
@@ -712,34 +711,22 @@ fn find_split_in_direction() {
             width: 180,
             height: 80,
         });
-        let mut view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let mut view = View::new(DocumentId::default(), GutterConfig::default());
         view.area = Rect::new(0, 0, 180, 80);
         tree.insert(view);
 
         let l0 = tree.focus;
-        let view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(DocumentId::default(), GutterConfig::default());
         tree.split(view, Layout::Vertical);
         let r0 = tree.focus;
 
         tree.focus = l0;
-        let view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(DocumentId::default(), GutterConfig::default());
         tree.split(view, Layout::Horizontal);
         let l1 = tree.focus;
 
         tree.focus = l0;
-        let view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(DocumentId::default(), GutterConfig::default());
         tree.split(view, Layout::Vertical);
         let l2 = tree.focus;
 
@@ -781,40 +768,28 @@ fn swap_split_in_direction() {
         });
 
         let doc_l0 = DocumentId::default();
-        let mut view = View::new(
-            doc_l0,
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let mut view = View::new(doc_l0, GutterConfig::default());
         view.area = Rect::new(0, 0, 180, 80);
         tree.insert(view);
 
         let l0 = tree.focus;
 
         let doc_r0 = DocumentId::default();
-        let view = View::new(
-            doc_r0,
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(doc_r0, GutterConfig::default());
         tree.split(view, Layout::Vertical);
         let r0 = tree.focus;
 
         tree.focus = l0;
 
         let doc_l1 = DocumentId::default();
-        let view = View::new(
-            doc_l1,
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(doc_l1, GutterConfig::default());
         tree.split(view, Layout::Horizontal);
         let l1 = tree.focus;
 
         tree.focus = l0;
 
         let doc_l2 = DocumentId::default();
-        let view = View::new(
-            doc_l2,
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let view = View::new(doc_l2, GutterConfig::default());
         tree.split(view, Layout::Vertical);
         let l2 = tree.focus;
 
diff --git a/helix-view/src/view.rs b/helix-view/src/view.rs
index c09d502dc..ee6fc1275 100644
--- a/helix-view/src/view.rs
+++ b/helix-view/src/view.rs
@@ -1,11 +1,25 @@
-use crate::{align_view, editor::GutterType, graphics::Rect, Align, Document, DocumentId, ViewId};
+use crate::{
+    align_view,
+    document::DocumentInlayHints,
+    editor::{GutterConfig, GutterType},
+    graphics::Rect,
+    Align, Document, DocumentId, Theme, ViewId,
+};
+
 use helix_core::{
-    pos_at_visual_coords, visual_coords_at_pos, Position, RopeSlice, Selection, Transaction,
+    char_idx_at_visual_offset,
+    doc_formatter::TextFormat,
+    syntax::Highlight,
+    text_annotations::TextAnnotations,
+    visual_offset_from_anchor, visual_offset_from_block, Position, RopeSlice, Selection,
+    Transaction,
+    VisualOffsetError::{PosAfterMaxRow, PosBeforeAnchorRow},
 };
 
 use std::{
     collections::{HashMap, VecDeque},
     fmt,
+    rc::Rc,
 };
 
 const JUMP_LIST_CAPACITY: usize = 30;
@@ -87,10 +101,17 @@ fn apply(&mut self, transaction: &Transaction, doc: &Document) {
     }
 }
 
+#[derive(Clone, Debug, PartialEq, Eq, Copy, Default)]
+pub struct ViewPosition {
+    pub anchor: usize,
+    pub horizontal_offset: usize,
+    pub vertical_offset: usize,
+}
+
 #[derive(Clone)]
 pub struct View {
     pub id: ViewId,
-    pub offset: Position,
+    pub offset: ViewPosition,
     pub area: Rect,
     pub doc: DocumentId,
     pub jumps: JumpList,
@@ -103,8 +124,8 @@ pub struct View {
     pub last_modified_docs: [Option<DocumentId>; 2],
     /// used to store previous selections of tree-sitter objects
     pub object_selections: Vec<Selection>,
-    /// GutterTypes used to fetch Gutter (constructor) and width for rendering
-    gutters: Vec<GutterType>,
+    /// all gutter-related configuration settings, used primarily for gutter rendering
+    pub gutters: GutterConfig,
     /// A mapping between documents and the last history revision the view was updated at.
     /// Changes between documents and views are synced lazily when switching windows. This
     /// mapping keeps track of the last applied history revision so that only new changes
@@ -123,17 +144,21 @@ fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 }
 
 impl View {
-    pub fn new(doc: DocumentId, gutter_types: Vec<crate::editor::GutterType>) -> Self {
+    pub fn new(doc: DocumentId, gutters: GutterConfig) -> Self {
         Self {
             id: ViewId::default(),
             doc,
-            offset: Position::new(0, 0),
+            offset: ViewPosition {
+                anchor: 0,
+                horizontal_offset: 0,
+                vertical_offset: 0,
+            },
             area: Rect::default(), // will get calculated upon inserting into tree
             jumps: JumpList::new((doc, Selection::point(0))), // TODO: use actual sel
             docs_access_history: Vec::new(),
             last_modified_docs: [None, None],
             object_selections: Vec::new(),
-            gutters: gutter_types,
+            gutters,
             doc_revisions: HashMap::new(),
         }
     }
@@ -153,12 +178,17 @@ pub fn inner_height(&self) -> usize {
         self.area.clip_bottom(1).height.into() // -1 for statusline
     }
 
+    pub fn inner_width(&self, doc: &Document) -> u16 {
+        self.area.clip_left(self.gutter_offset(doc)).width
+    }
+
     pub fn gutters(&self) -> &[GutterType] {
-        &self.gutters
+        &self.gutters.layout
     }
 
     pub fn gutter_offset(&self, doc: &Document) -> u16 {
         self.gutters
+            .layout
             .iter()
             .map(|gutter| gutter.width(self, doc) as u16)
             .sum()
@@ -169,84 +199,112 @@ pub fn offset_coords_to_in_view(
         &self,
         doc: &Document,
         scrolloff: usize,
-    ) -> Option<(usize, usize)> {
-        self.offset_coords_to_in_view_center(doc, scrolloff, false)
+    ) -> Option<ViewPosition> {
+        self.offset_coords_to_in_view_center::<false>(doc, scrolloff)
     }
 
-    pub fn offset_coords_to_in_view_center(
+    pub fn offset_coords_to_in_view_center<const CENTERING: bool>(
         &self,
         doc: &Document,
         scrolloff: usize,
-        centering: bool,
-    ) -> Option<(usize, usize)> {
-        let cursor = doc
-            .selection(self.id)
-            .primary()
-            .cursor(doc.text().slice(..));
-
-        let Position { col, row: line } =
-            visual_coords_at_pos(doc.text().slice(..), cursor, doc.tab_width());
-
-        let inner_area = self.inner_area(doc);
-        let last_line = (self.offset.row + inner_area.height as usize).saturating_sub(1);
-        let last_col = self.offset.col + inner_area.width.saturating_sub(1) as usize;
-
-        let new_offset = |scrolloff: usize| {
-            // - 1 so we have at least one gap in the middle.
-            // a height of 6 with padding of 3 on each side will keep shifting the view back and forth
-            // as we type
-            let scrolloff = scrolloff.min(inner_area.height.saturating_sub(1) as usize / 2);
-
-            let row = if line > last_line.saturating_sub(scrolloff) {
-                // scroll down
-                self.offset.row + line - (last_line.saturating_sub(scrolloff))
-            } else if line < self.offset.row + scrolloff {
-                // scroll up
-                line.saturating_sub(scrolloff)
+    ) -> Option<ViewPosition> {
+        let doc_text = doc.text().slice(..);
+        let viewport = self.inner_area(doc);
+        let vertical_viewport_end = self.offset.vertical_offset + viewport.height as usize;
+        let text_fmt = doc.text_format(viewport.width, None);
+        let annotations = self.text_annotations(doc, None);
+
+        // - 1 so we have at least one gap in the middle.
+        // a height of 6 with padding of 3 on each side will keep shifting the view back and forth
+        // as we type
+        let scrolloff = if CENTERING {
+            0
+        } else {
+            scrolloff.min(viewport.height.saturating_sub(1) as usize / 2)
+        };
+
+        let cursor = doc.selection(self.id).primary().cursor(doc_text);
+        let mut offset = self.offset;
+        let off = visual_offset_from_anchor(
+            doc_text,
+            offset.anchor,
+            cursor,
+            &text_fmt,
+            &annotations,
+            vertical_viewport_end,
+        );
+
+        let (new_anchor, at_top) = match off {
+            Ok((visual_pos, _)) if visual_pos.row < scrolloff + offset.vertical_offset => {
+                if CENTERING {
+                    // cursor out of view
+                    return None;
+                }
+                (true, true)
+            }
+            Ok((visual_pos, _)) if visual_pos.row + scrolloff >= vertical_viewport_end => {
+                (true, false)
+            }
+            Ok((_, _)) => (false, false),
+            Err(_) if CENTERING => return None,
+            Err(PosBeforeAnchorRow) => (true, true),
+            Err(PosAfterMaxRow) => (true, false),
+        };
+
+        if new_anchor {
+            let v_off = if at_top {
+                scrolloff as isize
             } else {
-                self.offset.row
+                viewport.height as isize - scrolloff as isize - 1
             };
+            (offset.anchor, offset.vertical_offset) =
+                char_idx_at_visual_offset(doc_text, cursor, -v_off, 0, &text_fmt, &annotations);
+        }
 
-            let col = if col > last_col.saturating_sub(scrolloff) {
+        if text_fmt.soft_wrap {
+            offset.horizontal_offset = 0;
+        } else {
+            // determine the current visual column of the text
+            let col = off
+                .unwrap_or_else(|_| {
+                    visual_offset_from_block(
+                        doc_text,
+                        offset.anchor,
+                        cursor,
+                        &text_fmt,
+                        &annotations,
+                    )
+                })
+                .0
+                .col;
+
+            let last_col = offset.horizontal_offset + viewport.width.saturating_sub(1) as usize;
+            if col > last_col.saturating_sub(scrolloff) {
                 // scroll right
-                self.offset.col + col - (last_col.saturating_sub(scrolloff))
-            } else if col < self.offset.col + scrolloff {
+                offset.horizontal_offset += col - (last_col.saturating_sub(scrolloff))
+            } else if col < offset.horizontal_offset + scrolloff {
                 // scroll left
-                col.saturating_sub(scrolloff)
-            } else {
-                self.offset.col
+                offset.horizontal_offset = col.saturating_sub(scrolloff)
             };
-            (row, col)
-        };
-        let current_offset = (self.offset.row, self.offset.col);
-        if centering {
-            // return None if cursor is out of view
-            let offset = new_offset(0);
-            (offset == current_offset).then(|| {
-                if scrolloff == 0 {
-                    offset
-                } else {
-                    new_offset(scrolloff)
-                }
-            })
-        } else {
-            // return None if cursor is in (view - scrolloff)
-            let offset = new_offset(scrolloff);
-            (offset != current_offset).then(|| offset) // TODO: use 'then_some' when 1.62 <= MSRV
         }
+
+        // if we are not centering return None if view position is unchanged
+        if !CENTERING && offset == self.offset {
+            return None;
+        }
+
+        Some(offset)
     }
 
     pub fn ensure_cursor_in_view(&mut self, doc: &Document, scrolloff: usize) {
-        if let Some((row, col)) = self.offset_coords_to_in_view_center(doc, scrolloff, false) {
-            self.offset.row = row;
-            self.offset.col = col;
+        if let Some(offset) = self.offset_coords_to_in_view_center::<false>(doc, scrolloff) {
+            self.offset = offset;
         }
     }
 
     pub fn ensure_cursor_in_view_center(&mut self, doc: &Document, scrolloff: usize) {
-        if let Some((row, col)) = self.offset_coords_to_in_view_center(doc, scrolloff, true) {
-            self.offset.row = row;
-            self.offset.col = col;
+        if let Some(offset) = self.offset_coords_to_in_view_center::<true>(doc, scrolloff) {
+            self.offset = offset;
         } else {
             align_view(doc, self, Align::Center);
         }
@@ -256,14 +314,52 @@ pub fn is_cursor_in_view(&mut self, doc: &Document, scrolloff: usize) -> bool {
         self.offset_coords_to_in_view(doc, scrolloff).is_none()
     }
 
-    /// Calculates the last visible line on screen
+    /// Estimates the last visible document line on screen.
+    /// This estimate is an upper bound obtained by calculating the first
+    /// visible line and adding the viewport height.
+    /// The actual last visible line may be smaller if softwrapping occurs
+    /// or virtual text lines are visible
     #[inline]
-    pub fn last_line(&self, doc: &Document) -> usize {
-        std::cmp::min(
-            // Saturating subs to make it inclusive zero indexing.
-            (self.offset.row + self.inner_height()).saturating_sub(1),
-            doc.text().len_lines().saturating_sub(1),
-        )
+    pub fn estimate_last_doc_line(&self, doc: &Document) -> usize {
+        let doc_text = doc.text().slice(..);
+        let line = doc_text.char_to_line(self.offset.anchor.min(doc_text.len_chars()));
+        // Saturating subs to make it inclusive zero indexing.
+        (line + self.inner_height())
+            .min(doc_text.len_lines())
+            .saturating_sub(1)
+    }
+
+    /// Calculates the last non-empty visual line on screen
+    #[inline]
+    pub fn last_visual_line(&self, doc: &Document) -> usize {
+        let doc_text = doc.text().slice(..);
+        let viewport = self.inner_area(doc);
+        let text_fmt = doc.text_format(viewport.width, None);
+        let annotations = self.text_annotations(doc, None);
+
+        // last visual line in view is trivial to compute
+        let visual_height = self.offset.vertical_offset + viewport.height as usize;
+
+        // fast path when the EOF is not visible on the screen,
+        if self.estimate_last_doc_line(doc) < doc_text.len_lines() - 1 {
+            return visual_height.saturating_sub(1);
+        }
+
+        // translate to document line
+        let pos = visual_offset_from_anchor(
+            doc_text,
+            self.offset.anchor,
+            usize::MAX,
+            &text_fmt,
+            &annotations,
+            visual_height,
+        );
+
+        match pos {
+            Ok((Position { row, .. }, _)) => row.saturating_sub(self.offset.vertical_offset),
+            Err(PosAfterMaxRow) => visual_height.saturating_sub(1),
+            Err(PosBeforeAnchorRow) => 0,
+        }
     }
 
     /// Translates a document position to an absolute position in the terminal.
@@ -275,22 +371,81 @@ pub fn screen_coords_at_pos(
         text: RopeSlice,
         pos: usize,
     ) -> Option<Position> {
-        let line = text.char_to_line(pos);
-
-        if line < self.offset.row || line > self.last_line(doc) {
+        if pos < self.offset.anchor {
             // Line is not visible on screen
             return None;
         }
 
-        let tab_width = doc.tab_width();
-        // TODO: visual_coords_at_pos also does char_to_line which we ignore, can we reuse the call?
-        let Position { col, .. } = visual_coords_at_pos(text, pos, tab_width);
+        let viewport = self.inner_area(doc);
+        let text_fmt = doc.text_format(viewport.width, None);
+        let annotations = self.text_annotations(doc, None);
+
+        let mut pos = visual_offset_from_anchor(
+            text,
+            self.offset.anchor,
+            pos,
+            &text_fmt,
+            &annotations,
+            viewport.height as usize,
+        )
+        .ok()?
+        .0;
+        if pos.row < self.offset.vertical_offset {
+            return None;
+        }
+        pos.row -= self.offset.vertical_offset;
+        if pos.row >= viewport.height as usize {
+            return None;
+        }
+        pos.col = pos.col.saturating_sub(self.offset.horizontal_offset);
+
+        Some(pos)
+    }
+
+    /// Get the text annotations to display in the current view for the given document and theme.
+    pub fn text_annotations(&self, doc: &Document, theme: Option<&Theme>) -> TextAnnotations {
+        // TODO custom annotations for custom views like side by side diffs
 
-        // It is possible for underflow to occur if the buffer length is larger than the terminal width.
-        let row = line.saturating_sub(self.offset.row);
-        let col = col.saturating_sub(self.offset.col);
+        let mut text_annotations = doc.text_annotations(theme);
 
-        Some(Position::new(row, col))
+        let DocumentInlayHints {
+            id: _,
+            type_inlay_hints,
+            parameter_inlay_hints,
+            other_inlay_hints,
+            padding_before_inlay_hints,
+            padding_after_inlay_hints,
+        } = match doc.inlay_hints.get(&self.id) {
+            Some(doc_inlay_hints) => doc_inlay_hints,
+            None => return text_annotations,
+        };
+
+        let type_style = theme
+            .and_then(|t| t.find_scope_index("ui.virtual.inlay-hint.type"))
+            .map(Highlight);
+        let parameter_style = theme
+            .and_then(|t| t.find_scope_index("ui.virtual.inlay-hint.parameter"))
+            .map(Highlight);
+        let other_style = theme
+            .and_then(|t| t.find_scope_index("ui.virtual.inlay-hint"))
+            .map(Highlight);
+
+        let mut add_annotations = |annotations: &Rc<[_]>, style| {
+            if !annotations.is_empty() {
+                text_annotations.add_inline_annotations(Rc::clone(annotations), style);
+            }
+        };
+
+        // Overlapping annotations are ignored apart from the first so the order here is not random:
+        // types -> parameters -> others should hopefully be the "correct" order for most use cases,
+        // with the padding coming before and after as expected.
+        add_annotations(padding_before_inlay_hints, None);
+        add_annotations(type_inlay_hints, type_style);
+        add_annotations(parameter_inlay_hints, parameter_style);
+        add_annotations(other_inlay_hints, other_style);
+        add_annotations(padding_after_inlay_hints, None);
+
+        text_annotations
     }
 
     pub fn text_pos_at_screen_coords(
@@ -298,9 +453,10 @@ pub fn text_pos_at_screen_coords(
         doc: &Document,
         row: u16,
         column: u16,
-        tab_width: usize,
+        fmt: TextFormat,
+        annotations: &TextAnnotations,
+        ignore_virtual_text: bool,
     ) -> Option<usize> {
-        let text = doc.text().slice(..);
         let inner = self.inner_area(doc);
         // 1 for status
         if row < inner.top() || row >= inner.bottom() {
@@ -311,27 +467,80 @@ pub fn text_pos_at_screen_coords(
             return None;
         }
 
-        let text_row = (row - inner.y) as usize + self.offset.row;
-        if text_row > text.len_lines() - 1 {
-            return Some(text.len_chars());
-        }
+        self.text_pos_at_visual_coords(
+            doc,
+            row - inner.y,
+            column - inner.x,
+            fmt,
+            annotations,
+            ignore_virtual_text,
+        )
+    }
+
+    pub fn text_pos_at_visual_coords(
+        &self,
+        doc: &Document,
+        row: u16,
+        column: u16,
+        text_fmt: TextFormat,
+        annotations: &TextAnnotations,
+        ignore_virtual_text: bool,
+    ) -> Option<usize> {
+        let text = doc.text().slice(..);
 
-        let text_col = (column - inner.x) as usize + self.offset.col;
+        let text_row = row as usize + self.offset.vertical_offset;
+        let text_col = column as usize + self.offset.horizontal_offset;
 
-        Some(pos_at_visual_coords(
+        let (char_idx, virt_lines) = char_idx_at_visual_offset(
             text,
-            Position {
-                row: text_row,
-                col: text_col,
-            },
-            tab_width,
-        ))
+            self.offset.anchor,
+            text_row as isize,
+            text_col,
+            &text_fmt,
+            annotations,
+        );
+
+        // if the cursor is on a line with only virtual text return None
+        if virt_lines != 0 && ignore_virtual_text {
+            return None;
+        }
+        Some(char_idx)
     }
 
     /// Translates a screen position to position in the text document.
     /// Returns a usize typed position in bounds of the text if found in this view, None if out of view.
-    pub fn pos_at_screen_coords(&self, doc: &Document, row: u16, column: u16) -> Option<usize> {
-        self.text_pos_at_screen_coords(doc, row, column, doc.tab_width())
+    pub fn pos_at_screen_coords(
+        &self,
+        doc: &Document,
+        row: u16,
+        column: u16,
+        ignore_virtual_text: bool,
+    ) -> Option<usize> {
+        self.text_pos_at_screen_coords(
+            doc,
+            row,
+            column,
+            doc.text_format(self.inner_width(doc), None),
+            &self.text_annotations(doc, None),
+            ignore_virtual_text,
+        )
+    }
+
+    pub fn pos_at_visual_coords(
+        &self,
+        doc: &Document,
+        row: u16,
+        column: u16,
+        ignore_virtual_text: bool,
+    ) -> Option<usize> {
+        self.text_pos_at_visual_coords(
+            doc,
+            row,
+            column,
+            doc.text_format(self.inner_width(doc), None),
+            &self.text_annotations(doc, None),
+            ignore_virtual_text,
+        )
     }
 
     /// Translates screen coordinates into coordinates on the gutter of the view.
@@ -380,8 +589,6 @@ pub fn remove_document(&mut self, doc_id: &DocumentId) {
     // }
 
     /// Applies a [`Transaction`] to the view.
-    /// Instead of calling this function directly, use [crate::apply_transaction]
-    /// which applies a transaction to the [`Document`] and view together.
     pub fn apply(&mut self, transaction: &Transaction, doc: &mut Document) {
         self.jumps.apply(transaction, doc);
         self.doc_revisions
@@ -414,156 +621,398 @@ pub fn sync_changes(&mut self, doc: &mut Document) {
 
 #[cfg(test)]
 mod tests {
+    use std::sync::Arc;
+
     use super::*;
+    use arc_swap::ArcSwap;
     use helix_core::Rope;
-    const OFFSET: u16 = 3; // 1 diagnostic + 2 linenr (< 100 lines)
-    const OFFSET_WITHOUT_LINE_NUMBERS: u16 = 1; // 1 diagnostic
-                                                // const OFFSET: u16 = GUTTERS.iter().map(|(_, width)| *width as u16).sum();
+
+    // 1 diagnostic + 1 spacer + 3 linenr (< 1000 lines) + 1 spacer + 1 diff
+    const DEFAULT_GUTTER_OFFSET: u16 = 7;
+
+    // 1 diagnostics + 1 spacer + 1 gutter
+    const DEFAULT_GUTTER_OFFSET_ONLY_DIAGNOSTICS: u16 = 3;
+
     use crate::document::Document;
-    use crate::editor::GutterType;
+    use crate::editor::{Config, GutterConfig, GutterLineNumbersConfig, GutterType};
 
     #[test]
     fn test_text_pos_at_screen_coords() {
-        let mut view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let mut view = View::new(DocumentId::default(), GutterConfig::default());
         view.area = Rect::new(40, 40, 40, 40);
         let rope = Rope::from_str("abc\n\tdef");
-        let doc = Document::from(rope, None);
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 40, 2, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                2,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 40, 41, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                41,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 0, 2, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                0,
+                2,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 0, 49, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                0,
+                49,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 0, 41, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                0,
+                41,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 40, 81, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                81,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 78, 41, 4), None);
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                78,
+                41,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            None
+        );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 3, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 3,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(3)
         );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 40, 80, 4), Some(3));
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                80,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            Some(3)
+        );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 41, 40 + OFFSET + 1, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                40 + DEFAULT_GUTTER_OFFSET + 1,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(4)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 41, 40 + OFFSET + 4, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                40 + DEFAULT_GUTTER_OFFSET + 4,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(5)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 41, 40 + OFFSET + 7, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                40 + DEFAULT_GUTTER_OFFSET + 7,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(8)
         );
 
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 41, 80, 4), Some(8));
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                80,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            Some(8)
+        );
     }
 
     #[test]
     fn test_text_pos_at_screen_coords_without_line_numbers_gutter() {
-        let mut view = View::new(DocumentId::default(), vec![GutterType::Diagnostics]);
+        let mut view = View::new(
+            DocumentId::default(),
+            GutterConfig {
+                layout: vec![GutterType::Diagnostics],
+                line_numbers: GutterLineNumbersConfig::default(),
+            },
+        );
         view.area = Rect::new(40, 40, 40, 40);
         let rope = Rope::from_str("abc\n\tdef");
-        let doc = Document::from(rope, None);
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 41, 40 + OFFSET_WITHOUT_LINE_NUMBERS + 1, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                40 + DEFAULT_GUTTER_OFFSET_ONLY_DIAGNOSTICS + 1,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(4)
         );
     }
 
     #[test]
     fn test_text_pos_at_screen_coords_without_any_gutters() {
-        let mut view = View::new(DocumentId::default(), vec![]);
+        let mut view = View::new(
+            DocumentId::default(),
+            GutterConfig {
+                layout: vec![],
+                line_numbers: GutterLineNumbersConfig::default(),
+            },
+        );
         view.area = Rect::new(40, 40, 40, 40);
         let rope = Rope::from_str("abc\n\tdef");
-        let doc = Document::from(rope, None);
-        assert_eq!(view.text_pos_at_screen_coords(&doc, 41, 40 + 1, 4), Some(4));
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
+        assert_eq!(
+            view.text_pos_at_screen_coords(
+                &doc,
+                41,
+                40 + 1,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
+            Some(4)
+        );
     }
 
     #[test]
     fn test_text_pos_at_screen_coords_cjk() {
-        let mut view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let mut view = View::new(DocumentId::default(), GutterConfig::default());
         view.area = Rect::new(40, 40, 40, 40);
         let rope = Rope::from_str("Hi! ");
-        let doc = Document::from(rope, None);
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(0)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 4, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 4,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(4)
         );
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 5, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 5,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(4)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 6, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 6,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(5)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 7, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 7,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(5)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 8, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 8,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(6)
         );
     }
 
     #[test]
     fn test_text_pos_at_screen_coords_graphemes() {
-        let mut view = View::new(
-            DocumentId::default(),
-            vec![GutterType::Diagnostics, GutterType::LineNumbers],
-        );
+        let mut view = View::new(DocumentId::default(), GutterConfig::default());
         view.area = Rect::new(40, 40, 40, 40);
         let rope = Rope::from_str("Hello world!");
-        let doc = Document::from(rope, None);
+        let doc = Document::from(
+            rope,
+            None,
+            Arc::new(ArcSwap::new(Arc::new(Config::default()))),
+        );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(0)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 1, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 1,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(1)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 2, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 2,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(3)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 3, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 3,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(5)
         );
 
         assert_eq!(
-            view.text_pos_at_screen_coords(&doc, 40, 40 + OFFSET + 4, 4),
+            view.text_pos_at_screen_coords(
+                &doc,
+                40,
+                40 + DEFAULT_GUTTER_OFFSET + 4,
+                TextFormat::default(),
+                &TextAnnotations::default(),
+                true
+            ),
             Some(7)
         );
     }
diff --git a/languages.toml b/languages.toml
index e6bc344cc..c643beab1 100644
--- a/languages.toml
+++ b/languages.toml
@@ -19,6 +19,14 @@ indent = { tab-width = 4, unit = "    " }
 '"' = '"'
 '`' = '`'
 
+[language.config]
+inlayHints.bindingModeHints.enable = false
+inlayHints.closingBraceHints.minLines = 10
+inlayHints.closureReturnTypeHints.enable = "with_block"
+inlayHints.discriminantHints.enable = "fieldless"
+inlayHints.lifetimeElisionHints.enable = "skip_trivial"
+inlayHints.typeHints.hideClosureInitialization = false
+
 [language.debugger]
 name = "lldb-vscode"
 transport = "stdio"
@@ -52,6 +60,20 @@ args = { attachCommands = [ "platform select remote-gdb-server", "platform conne
 name = "rust"
 source = { git = "https://github.com/tree-sitter/tree-sitter-rust", rev = "0431a2c60828731f27491ee9fdefe25e250ce9c9" }
 
+[[language]]
+name = "sway"
+scope = "source.sway"
+injection-regex = "sway"
+file-types = ["sw"]
+language-server = { command = "forc", args = ["lsp"] }
+roots = ["Forc.toml", "Forc.lock"]
+indent = { tab-width = 4, unit = "    " }
+comment-token = "//"
+
+[[grammar]]
+name = "sway"
+source = { git = "https://github.com/FuelLabs/tree-sitter-sway", rev = "e491a005ee1d310f4c138bf215afd44cfebf959c" }
+
 [[language]]
 name = "toml"
 scope = "source.toml"
@@ -138,7 +160,7 @@ indent = { tab-width = 2, unit = "  " }
 name = "json"
 scope = "source.json"
 injection-regex = "json"
-file-types = ["json"]
+file-types = ["json", "jsonc", "arb"]
 roots = []
 language-server = { command = "vscode-json-language-server", args = ["--stdio"] }
 auto-format = true
@@ -147,7 +169,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "json"
-source = { git = "https://github.com/tree-sitter/tree-sitter-json", rev = "65bceef69c3b0f24c0b19ce67d79f57c96e90fcb" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-json", rev = "73076754005a460947cafe8e03a8cf5fa4fa2938" }
 
 [[language]]
 name = "c"
@@ -190,7 +212,7 @@ source = { git = "https://github.com/tree-sitter/tree-sitter-c", rev = "7175a6dd
 name = "cpp"
 scope = "source.cpp"
 injection-regex = "cpp"
-file-types = ["cc", "hh", "cpp", "hpp", "h", "ipp", "tpp", "cxx", "hxx", "ixx", "txx", "ino"]
+file-types = ["cc", "hh", "c++", "cpp", "hpp", "h", "ipp", "tpp", "cxx", "hxx", "ixx", "txx", "ino", "C", "H", "cu", "cuh"]
 roots = []
 comment-token = "//"
 language-server = { command = "clangd" }
@@ -221,7 +243,16 @@ args = { console = "internalConsole", attachCommands = [ "platform select remote
 
 [[grammar]]
 name = "cpp"
-source = { git = "https://github.com/tree-sitter/tree-sitter-cpp", rev = "d5e90fba898f320db48d81ddedd78d52c67c1fed" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-cpp", rev = "2d2c4aee8672af4c7c8edff68e7dd4c07e88d2b1" }
+
+[[language]]
+name = "crystal"
+scope = "source.cr"
+file-types = ["cr"]
+roots = ["shard.yml", "shard.lock"]
+comment-token = "#"
+indent = { tab-width = 2, unit = "  " }
+grammar = "ruby"
 
 [[language]]
 name = "c-sharp"
@@ -268,6 +299,14 @@ language-server = { command = "gopls" }
 # TODO: gopls needs utf-8 offsets?
 indent = { tab-width = 4, unit = "\t" }
 
+[language.config.hints]
+assignVariableTypes = true
+compositeLiteralFields = true
+constantValues = true
+functionTypeParameters = true
+parameterNames = true
+rangeVariableTypes = true
+
 [language.debugger]
 name = "go"
 transport = "tcp"
@@ -301,7 +340,7 @@ args = { mode = "local", processId = "{0}" }
 
 [[grammar]]
 name = "go"
-source = { git = "https://github.com/tree-sitter/tree-sitter-go", rev = "05900faa3cdb5d2d8c8bd5e77ee698487e0a8611" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-go", rev = "64457ea6b73ef5422ed1687178d4545c3e91334a" }
 
 [[language]]
 name = "gomod"
@@ -359,6 +398,18 @@ comment-token = "//"
 language-server = { command = "typescript-language-server", args = ["--stdio"], language-id = "javascript" }
 indent = { tab-width = 2, unit = "  " }
 
+[language.config]
+hostInfo = "helix"
+
+[language.config.javascript.inlayHints]
+includeInlayEnumMemberValueHints = true
+includeInlayFunctionLikeReturnTypeHints = true
+includeInlayFunctionParameterTypeHints = true
+includeInlayParameterNameHints = "all"
+includeInlayParameterNameHintsWhenArgumentMatchesName = true
+includeInlayPropertyDeclarationTypeHints = true
+includeInlayVariableTypeHints = true
+
 [language.debugger]
 name = "node-debug2"
 transport = "stdio"
@@ -386,17 +437,41 @@ language-server = { command = "typescript-language-server", args = ["--stdio"],
 indent = { tab-width = 2, unit = "  " }
 grammar = "javascript"
 
+[language.config]
+hostInfo = "helix"
+
+[language.config.javascript.inlayHints]
+includeInlayEnumMemberValueHints = true
+includeInlayFunctionLikeReturnTypeHints = true
+includeInlayFunctionParameterTypeHints = true
+includeInlayParameterNameHints = "all"
+includeInlayParameterNameHintsWhenArgumentMatchesName = true
+includeInlayPropertyDeclarationTypeHints = true
+includeInlayVariableTypeHints = true
+
 [[language]]
 name = "typescript"
 scope = "source.ts"
 injection-regex = "(ts|typescript)"
-file-types = ["ts"]
+file-types = ["ts", "mts", "cts"]
 shebangs = []
 roots = []
 # TODO: highlights-params
 language-server = { command = "typescript-language-server", args = ["--stdio"], language-id = "typescript"}
 indent = { tab-width = 2, unit = "  " }
 
+[language.config]
+hostInfo = "helix"
+
+[language.config.typescript.inlayHints]
+includeInlayEnumMemberValueHints = true
+includeInlayFunctionLikeReturnTypeHints = true
+includeInlayFunctionParameterTypeHints = true
+includeInlayParameterNameHints = "all"
+includeInlayParameterNameHintsWhenArgumentMatchesName = true
+includeInlayPropertyDeclarationTypeHints = true
+includeInlayVariableTypeHints = true
+
 [[grammar]]
 name = "typescript"
 source = { git = "https://github.com/tree-sitter/tree-sitter-typescript", rev = "6aac031ad88dd6317f02ac0bb27d099a553a7d8c", subpath = "typescript" }
@@ -411,6 +486,18 @@ roots = []
 language-server = { command = "typescript-language-server", args = ["--stdio"], language-id = "typescriptreact" }
 indent = { tab-width = 2, unit = "  " }
 
+[language.config]
+hostInfo = "helix"
+
+[language.config.typescript.inlayHints]
+includeInlayEnumMemberValueHints = true
+includeInlayFunctionLikeReturnTypeHints = true
+includeInlayFunctionParameterTypeHints = true
+includeInlayParameterNameHints = "all"
+includeInlayParameterNameHintsWhenArgumentMatchesName = true
+includeInlayPropertyDeclarationTypeHints = true
+includeInlayVariableTypeHints = true
+
 [[grammar]]
 name = "tsx"
 source = { git = "https://github.com/tree-sitter/tree-sitter-typescript", rev = "6aac031ad88dd6317f02ac0bb27d099a553a7d8c", subpath = "tsx" }
@@ -464,7 +551,7 @@ source = { git = "https://github.com/tree-sitter/tree-sitter-html", rev = "29f53
 name = "python"
 scope = "source.python"
 injection-regex = "python"
-file-types = ["py"]
+file-types = ["py","pyi","py3","pyw","ptl",".pythonstartup",".pythonrc","SConstruct"]
 shebangs = ["python"]
 roots = []
 comment-token = "#"
@@ -504,13 +591,13 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "nix"
-source = { git = "https://github.com/cstrahan/tree-sitter-nix", rev = "6b71a810c0acd49b980c50fc79092561f7cee307" }
+source = { git = "https://github.com/nix-community/tree-sitter-nix", rev = "6b71a810c0acd49b980c50fc79092561f7cee307" }
 
 [[language]]
 name = "ruby"
 scope = "source.ruby"
 injection-regex = "ruby"
-file-types = ["rb", "rake", "rakefile", "irb", "gemfile", "gemspec", "Rakefile", "Gemfile", "rabl", "jbuilder", "jb"]
+file-types = ["rb", "rake", "rakefile", "irb", "gemfile", "gemspec", "Rakefile", "Gemfile", "rabl", "jbuilder", "jb", "Podfile", "podspec"]
 shebangs = ["ruby"]
 roots = []
 comment-token = "#"
@@ -519,13 +606,13 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "ruby"
-source = { git = "https://github.com/tree-sitter/tree-sitter-ruby", rev = "4c600a463d97e36a0ca5ac57e11f3ac8c297a0fa" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-ruby", rev = "206c7077164372c596ffa8eaadb9435c28941364" }
 
 [[language]]
 name = "bash"
 scope = "source.bash"
 injection-regex = "(shell|bash|zsh|sh)"
-file-types = ["sh", "bash", "zsh", ".bash_login", ".bash_logout", ".bash_profile", ".bashrc", ".profile", ".zshenv", ".zlogin", ".zlogout", ".zprofile", ".zshrc", "APKBUILD", "PKGBUILD", "eclass", "ebuild", "bazelrc"]
+file-types = ["sh", "bash", "zsh", ".bash_login", ".bash_logout", ".bash_profile", ".bashrc", ".profile", ".zshenv", ".zlogin", ".zlogout", ".zprofile", ".zshrc", "APKBUILD", "PKGBUILD", "eclass", "ebuild", "bazelrc", ".bash_aliases"]
 shebangs = ["sh", "bash", "dash", "zsh"]
 roots = []
 comment-token = "#"
@@ -548,7 +635,7 @@ indent = { tab-width = 4, unit = "    " }
 
 [[grammar]]
 name = "php"
-source = { git = "https://github.com/tree-sitter/tree-sitter-php", rev = "57f855461aeeca73bd4218754fb26b5ac143f98f" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-php", rev = "f860e598194f4a71747f91789bf536b393ad4a56" }
 
 [[language]]
 name = "twig"
@@ -643,7 +730,7 @@ name = "java"
 scope = "source.java"
 injection-regex = "java"
 file-types = ["java"]
-roots = ["pom.xml"]
+roots = ["pom.xml", "build.gradle"]
 language-server = { command = "jdtls" }
 indent = { tab-width = 4, unit = "    " }
 
@@ -688,6 +775,13 @@ comment-token = "(**)"
 language-server = { command = "ocamllsp" }
 indent = { tab-width = 2, unit = "  " }
 
+[language.auto-pairs]
+'(' = ')'
+'{' = '}'
+'[' = ']'
+'"' = '"'
+'`' = '`'
+
 [[grammar]]
 name = "ocaml"
 source = { git = "https://github.com/tree-sitter/tree-sitter-ocaml", rev = "23d419ba45789c5a47d31448061557716b02750a", subpath = "ocaml" }
@@ -702,12 +796,20 @@ comment-token = "(**)"
 language-server = { command = "ocamllsp" }
 indent = { tab-width = 2, unit = "  " }
 
+[language.auto-pairs]
+'(' = ')'
+'{' = '}'
+'[' = ']'
+'"' = '"'
+'`' = '`'
+
 [[grammar]]
 name = "ocaml-interface"
 source = { git = "https://github.com/tree-sitter/tree-sitter-ocaml", rev = "23d419ba45789c5a47d31448061557716b02750a", subpath = "interface" }
 
 [[language]]
 name = "lua"
+injection-regex = "lua"
 scope = "source.lua"
 file-types = ["lua"]
 shebangs = ["lua"]
@@ -716,6 +818,14 @@ comment-token = "--"
 indent = { tab-width = 2, unit = "  " }
 language-server = { command = "lua-language-server", args = [] }
 
+[language.config.Lua.hint]
+enable = true
+arrayIndex = "Enable"
+setType = true
+paramName = "All"
+paramType = true
+await = true
+
 [[grammar]]
 name = "lua"
 source = { git = "https://github.com/MunifTanjim/tree-sitter-lua", rev = "887dfd4e83c469300c279314ff1619b1d0b85b91" }
@@ -868,7 +978,7 @@ source = { git = "https://github.com/uyha/tree-sitter-cmake", rev = "6e51463ef30
 [[language]]
 name = "make"
 scope = "source.make"
-file-types = ["Makefile", "makefile", "mk", "justfile", ".justfile"]
+file-types = ["Makefile", "makefile", "mk", "Justfile", "justfile", ".justfile"]
 injection-regex = "(make|makefile|Makefile|mk|just)"
 roots = []
 comment-token = "#"
@@ -1009,14 +1119,14 @@ source = { git = "https://github.com/Flakebi/tree-sitter-tablegen", rev = "568dd
 name = "markdown"
 scope = "source.md"
 injection-regex = "md|markdown"
-file-types = ["md", "markdown"]
+file-types = ["md", "markdown", "PULLREQ_EDITMSG"]
 roots = [".marksman.toml"]
 language-server = { command = "marksman", args=["server"] }
 indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "markdown"
-source = { git = "https://github.com/MDeiml/tree-sitter-markdown", rev = "a7de4be29783a6e25f3240c90afea52f2417faa3", subpath = "tree-sitter-markdown" }
+source = { git = "https://github.com/MDeiml/tree-sitter-markdown", rev = "7e7aa9a25ca9729db9fe22912f8f47bdb403a979", subpath = "tree-sitter-markdown" }
 
 [[language]]
 name = "markdown.inline"
@@ -1028,7 +1138,7 @@ grammar = "markdown_inline"
 
 [[grammar]]
 name = "markdown_inline"
-source = { git = "https://github.com/MDeiml/tree-sitter-markdown", rev = "a7de4be29783a6e25f3240c90afea52f2417faa3", subpath = "tree-sitter-markdown-inline" }
+source = { git = "https://github.com/MDeiml/tree-sitter-markdown", rev = "7e7aa9a25ca9729db9fe22912f8f47bdb403a979", subpath = "tree-sitter-markdown-inline" }
 
 [[language]]
 name = "dart"
@@ -1052,17 +1162,18 @@ file-types = ["scala", "sbt", "sc"]
 comment-token = "//"
 indent = { tab-width = 2, unit = "  " }
 language-server = { command = "metals" }
+config = { "isHttpEnabled" = true }
 
 [[grammar]]
 name = "scala"
-source = { git = "https://github.com/tree-sitter/tree-sitter-scala", rev = "140c96cf398693189d4e50f76d19ddfcd8a018f8" }
+source = { git = "https://github.com/tree-sitter/tree-sitter-scala", rev = "f6bbf35de41653b409ca9a3537a154f2b095ef64" }
 
 [[language]]
 name = "dockerfile"
 scope = "source.dockerfile"
 injection-regex = "docker|dockerfile"
-roots = ["Dockerfile"]
-file-types = ["Dockerfile", "dockerfile"]
+roots = ["Dockerfile", "Containerfile"]
+file-types = ["Dockerfile", "dockerfile", "Containerfile", "containerfile"]
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
 language-server = { command = "docker-langserver", args = ["--stdio"] }
@@ -1079,11 +1190,11 @@ file-types = ["COMMIT_EDITMSG"]
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
 rulers = [50, 72]
-max-line-length = 72
+text-width = 72
 
 [[grammar]]
 name = "git-commit"
-source = { git = "https://github.com/the-mikedavis/tree-sitter-git-commit", rev = "318dd72abfaa7b8044c1d1fbeabcd06deaaf038f" }
+source = { git = "https://github.com/the-mikedavis/tree-sitter-git-commit", rev = "bd0ca5a6065f2cada3ac6a82a66db3ceff55fa6b" }
 
 [[language]]
 name = "diff"
@@ -1109,7 +1220,7 @@ indent = { tab-width = 2, unit = " " }
 
 [[grammar]]
 name = "git-rebase"
-source = { git = "https://github.com/the-mikedavis/tree-sitter-git-rebase", rev = "332dc528f27044bc4427024dbb33e6941fc131f2" }
+source = { git = "https://github.com/the-mikedavis/tree-sitter-git-rebase", rev = "d8a4207ebbc47bd78bacdf48f883db58283f9fd8" }
 
 [[language]]
 name = "regex"
@@ -1165,7 +1276,7 @@ source = { git = "https://github.com/shunsambongi/tree-sitter-gitignore", rev =
 name = "graphql"
 scope = "source.graphql"
 injection-regex = "graphql"
-file-types = ["gql", "graphql"]
+file-types = ["gql", "graphql", "graphqls"]
 roots = []
 indent = { tab-width = 2, unit = "  " }
 
@@ -1220,6 +1331,7 @@ scope = "source.erlang"
 injection-regex = "erl(ang)?"
 file-types = ["erl", "hrl", "app", "rebar.config", "rebar.lock"]
 roots = ["rebar.config"]
+shebangs = ["escript"]
 comment-token = "%%"
 indent = { tab-width = 4, unit = "    " }
 language-server = { command = "erlang_ls" }
@@ -1325,6 +1437,20 @@ comment-token = "//"
 indent = { tab-width = 4, unit = "    " }
 grammar = "rust"
 
+[[language]]
+name = "robot"
+scope = "source.robot"
+injection-regex = "robot"
+file-types = ["robot", "resource"]
+comment-token = "#"
+roots = []
+indent = { tab-width = 4, unit = " " }
+language-server = { command = "robotframework_ls" }
+
+[[grammar]]
+name = "robot"
+source = { git = "https://github.com/Hubro/tree-sitter-robot", rev = "f1142bfaa6acfce95e25d2c6d18d218f4f533927" }
+
 [[language]]
 name = "r"
 scope = "source.r"
@@ -1334,7 +1460,7 @@ shebangs = ["r", "R"]
 roots = []
 comment-token = "#"
 indent = { tab-width = 2, unit = "  " }
-language-server = { command = "R", args = ["--slave", "-e", "languageserver::run()"] }
+language-server = { command = "R", args = ["--no-echo", "-e", "languageserver::run()"] }
 
 [[grammar]]
 name = "r"
@@ -1423,7 +1549,7 @@ injection-regex = "sql"
 
 [[grammar]]
 name = "sql"
-source = { git = "https://github.com/DerekStride/tree-sitter-sql", rev = "2743c7b5e710e6854d4e8c14c302548b436e2a1f" }
+source = { git = "https://github.com/DerekStride/tree-sitter-sql", rev = "3a3f92b29c880488a08bc2baaf1aca6432ec3380" }
 
 [[language]]
 name = "gdscript"
@@ -1433,22 +1559,23 @@ file-types = ["gd"]
 shebangs = []
 roots = ["project.godot"]
 auto-format = true
+formatter = { command = "gdformat", args = ["-"] }
 comment-token = "#"
 indent = { tab-width = 4, unit = "\t" }
 
 [[grammar]]
 name = "gdscript"
-source = { git = "https://github.com/PrestonKnopp/tree-sitter-gdscript", rev = "2a6abdaa47fcb91397e09a97c7433fd995ea46c6" }
+source = { git = "https://github.com/PrestonKnopp/tree-sitter-gdscript", rev = "a4b57cc3bcbfc24550e858159647e9238e7ad1ac" }
 
 [[language]]
 name = "godot-resource"
 scope = "source.tscn"
 injection-regex = "godot"
-file-types = ["tscn","tres"]
+file-types = ["tscn", "tres", "godot", "gdextension"]
 shebangs = []
 roots = ["project.godot"]
 auto-format = false
-comment-token = "#"
+comment-token = ";"
 indent = { tab-width = 4, unit = "\t" }
 
 [[grammar]]
@@ -1567,6 +1694,7 @@ name = "sshclientconfig"
 scope = "source.sshclientconfig"
 file-types = [{ suffix = ".ssh/config" }, { suffix = "/etc/ssh/ssh_config" }]
 roots = []
+comment-token = "#"
 
 [[grammar]]
 name = "sshclientconfig"
@@ -1588,17 +1716,17 @@ source = { git = "https://github.com/6cdh/tree-sitter-scheme", rev = "c0741320bf
 [[language]]
 name = "v"
 scope = "source.v"
-file-types = ["v", "vv"]
+file-types = ["v", "vv", "vsh"]
 shebangs = ["v run"]
 roots = ["v.mod"]
-language-server = { command = "vls", args = [] }
+language-server = { command = "v", args = ["ls"] }
 auto-format = true
 comment-token = "//"
 indent = { tab-width = 4, unit = "\t" }
 
 [[grammar]]
 name = "v"
-source = { git = "https://github.com/vlang/vls", subpath = "tree_sitter_v", rev = "3e8124ea4ab80aa08ec77f03df53f577902a0cdd" }
+source = { git = "https://github.com/vlang/vls", subpath = "tree_sitter_v", rev = "66cf9d3086fb5ecc827cb32c64c5d812ab17d2c6" }
 
 [[language]]
 name = "verilog"
@@ -1664,7 +1792,7 @@ indent = { tab-width = 2, unit = "  " }
 
 [[grammar]]
 name = "prisma"
-source = { git = "https://github.com/victorhqc/tree-sitter-prisma", rev = "17a59236ac25413b81b1613ea6ba5d8d52d7cd6c" }
+source = { git = "https://github.com/victorhqc/tree-sitter-prisma", rev = "eca2596a355b1a9952b4f80f8f9caed300a272b5" }
 
 [[language]]
 name = "clojure"
@@ -1766,6 +1894,7 @@ auto-format = true
 comment-token = "//"
 language-server = { command = "cuelsp" }
 indent = { tab-width = 4, unit = "\t" }
+formatter = { command = "cue", args = ["fmt", "-"] }
 
 [[grammar]]
 name = "cue"
@@ -1954,7 +2083,7 @@ source = { git = "https://github.com/Unoqwy/tree-sitter-kdl", rev = "e1cd292c6d1
 name = "xml"
 scope = "source.xml"
 injection-regex = "xml"
-file-types = ["xml"]
+file-types = ["xml", "mobileconfig", "plist", "xib", "storyboard", "svg", "xsd"]
 indent = { tab-width = 2, unit = "  " }
 roots = []
 
@@ -1968,7 +2097,7 @@ roots = []
 
 [[grammar]]
 name = "xml"
-source = { git = "https://github.com/RenjiSann/tree-sitter-xml", rev = "422528a43630db6dcc1e222d1c5ee3babd559473" }
+source = { git = "https://github.com/RenjiSann/tree-sitter-xml", rev = "48a7c2b6fb9d515577e115e6788937e837815651" }
 
 [[language]]
 name = "wit"
@@ -1994,15 +2123,12 @@ source = { git = "https://github.com/hh9527/tree-sitter-wit", rev = "c917790ab9a
 [[language]]
 name = "env"
 scope = "source.env"
-file-types = [".env", ".env.local", ".env.development", ".env.production"]
+file-types = [".env", ".env.local", ".env.development", ".env.production", ".env.dist", ".envrc"]
 injection-regex = "env"
 comment-token = "#"
 indent = { tab-width = 4, unit = "\t" }
 roots = []
-
-[[grammar]]
-name = "env"
-source = { git = "https://github.com/seshotake/tree-sitter-env", rev = "e6c6bb1e7b51d481cba463fe949f083cf22d81f7" }
+grammar = "bash"
 
 [[language]]
 name = "ini"
@@ -2043,3 +2169,284 @@ grammar = "qmljs"
 [[grammar]]
 name = "qmljs"
 source = { git = "https://github.com/yuja/tree-sitter-qmljs", rev = "0b2b25bcaa7d4925d5f0dda16f6a99c588a437f1" }
+
+[[language]]
+name = "mermaid"
+scope = "source.mermaid"
+injection-regex = "mermaid"
+file-types = ["mermaid"]
+roots = []
+comment-token = "%%"
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "mermaid"
+source = { git = "https://github.com/monaqa/tree-sitter-mermaid", rev = "d787c66276e7e95899230539f556e8b83ee16f6d" }
+
+[[language]]
+name = "matlab"
+scope = "source.m"
+file-types = ["m"]
+comment-token = "%"
+shebangs = ["octave-cli", "matlab"]
+roots = []
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "matlab"
+source = { git = "https://github.com/mstanciu552/tree-sitter-matlab", rev = "2d5d3d5193718a86477d4335aba5b34e79147326" }
+
+[[language]]
+name = "ponylang"
+scope = "source.pony"
+file-types = ["pony"]
+injection-regex = "pony"
+roots = ["corral.json", "lock.json"]
+indent = { tab-width = 2, unit = "  " }
+comment-token = "//"
+
+[[grammar]]
+name = "ponylang"
+source = { git = "https://github.com/mfelsche/tree-sitter-ponylang", rev = "ef66b151bc2604f431b5668fcec4747db4290e11" }
+
+[[language]]
+name = "dhall"
+scope = "source.dhall"
+injection-regex = "dhall"
+file-types = ["dhall"]
+roots = []
+comment-token = "--"
+indent = { tab-width = 2, unit = "  " }
+language-server = { command = "dhall-lsp-server" }
+formatter = { command = "dhall" , args = ["format"] }
+
+[[grammar]]
+name = "dhall"
+source = { git = "https://github.com/jbellerb/tree-sitter-dhall", rev = "affb6ee38d629c9296749767ab832d69bb0d9ea8" }
+
+[[language]]
+name = "sage"
+scope = "source.sage"
+file-types = ["sage"]
+injection-regex = "sage"
+roots = []
+comment-token = "#"
+indent = { tab-width = 4, unit = "    " }
+grammar = "python"
+
+[[language]]
+name = "msbuild"
+scope = "source.msbuild"
+injection-regex = "msbuild"
+file-types = ["proj", "vbproj", "csproj", "fsproj", "targets", "props"]
+indent = { tab-width = 2, unit = "  " }
+roots = []
+grammar = "xml"
+
+[language.auto-pairs]
+'(' = ')'
+'{' = '}'
+'[' = ']'
+'"' = '"'
+"'" = "'"
+"<" = ">"
+
+[[language]]
+name = "pem"
+scope = "source.pem"
+file-types = ["pem", "cert", "crt"]
+injection-regex = "pem"
+roots = []
+grammar = "pem"
+
+[[grammar]]
+name = "pem"
+source = { git = "https://github.com/mtoohey31/tree-sitter-pem", rev = "be67a4330a1aa507c7297bc322204f936ec1132c" }
+
+[[language]]
+name = "passwd"
+scope = "source.passwd"
+file-types = ["passwd"]
+roots = []
+
+[[grammar]]
+name = "passwd"
+source = { git = "https://github.com/ath3/tree-sitter-passwd", rev = "20239395eacdc2e0923a7e5683ad3605aee7b716" }
+
+[[language]]
+name = "hosts"
+scope = "source.hosts"
+file-types = ["hosts"]
+roots = []
+comment-token = "#"
+
+[[grammar]]
+name = "hosts"
+source = { git = "https://github.com/ath3/tree-sitter-hosts", rev = "301b9379ce7dfc8bdbe2c2699a6887dcb73953f9" }
+
+[[language]]
+name = "uxntal"
+scope = "source.tal"
+injection-regex = "tal"
+file-types = ["tal"]
+roots = []
+auto-format = false
+comment-token = "("
+
+[[grammar]]
+name = "uxntal"
+source = { git = "https://github.com/Jummit/tree-sitter-uxntal", rev = "9297e95ef74380b0ad84c4fd98f91e9f6e4319e6" }
+
+[[language]]
+name = "yuck"
+scope = "source.yuck"
+injection-regex = "yuck"
+file-types = ["yuck"]
+roots = []
+comment-token = ";"
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "yuck"
+source = { git = "https://github.com/Philipp-M/tree-sitter-yuck", rev = "e3d91a3c65decdea467adebe4127b8366fa47919" }
+
+[[language]]
+name = "prql"
+scope = "source.prql"
+injection-regex = "prql"
+file-types = ["prql"]
+roots = []
+comment-token = "#"
+indent = { tab-width = 4, unit = "    " }
+
+[[grammar]]
+name = "prql"
+source = { git = "https://github.com/PRQL/tree-sitter-prql", rev = "3f27cac466f030ee7d985d91eba5470e01dd21ea" }
+
+[[language]]
+name = "po"
+scope = "source.po"
+file-types = ["po", "pot"]
+roots = []
+comment-token = "#"
+
+[[grammar]]
+name = "po"
+source = { git = "https://github.com/erasin/tree-sitter-po", rev = "417cee9abb2053ed26b19e7de972398f2da9b29e" }
+
+[[language]]
+name = "nasm"
+scope = "source.nasm"
+file-types = ["asm", "s", "S", "nasm"]
+injection-regex = "n?asm"
+roots = []
+comment-token = ";"
+indent = { tab-width = 8, unit = "        " }
+
+[[grammar]]
+name = "nasm"
+source = { git = "https://github.com/naclsn/tree-sitter-nasm", rev = "a0db15db6fcfb1bf2cc8702500e55e558825c48b" }
+
+[[language]]
+name = "rst"
+scope = "source.rst"
+comment-token = ".."
+file-types = ["rst"]
+roots = []
+
+[[grammar]]
+name = "rst"
+source = { git = "https://github.com/stsewd/tree-sitter-rst", rev = "25e6328872ac3a764ba8b926aea12719741103f1" }
+
+[[language]]
+name = "capnp"
+scope = "source.capnp"
+injection-regex = "capnp"
+file-types = ["capnp"]
+roots = []
+comment-token = "#"
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "capnp"
+source = { git = "https://github.com/amaanq/tree-sitter-capnp", rev = "fc6e2addf103861b9b3dffb82c543eb6b71061aa" }
+
+[[language]]
+name = "smithy"
+scope = "source.smithy"
+injection-regex = "smithy"
+file-types = ["smithy"]
+roots = ["smithy-build.json"]
+comment-token = "//"
+indent = { tab-width = 4, unit = "    " }
+language-server = { command = "cs", args = ["launch", "com.disneystreaming.smithy:smithy-language-server:latest.release", "--", "0"] }
+
+[[grammar]]
+name = "smithy"
+source = { git = "https://github.com/indoorvivants/tree-sitter-smithy", rev = "cf8c7eb9faf7c7049839585eac19c94af231e6a0" }
+
+[[language]]
+name = "vhdl"
+scope = "source.vhdl"
+file-types = ["vhd", "vhdl"]
+roots = []
+comment-token = "--"
+language-server = { command = "vhdl_ls", args = [] }
+indent = { tab-width = 2, unit = "  " }
+injection-regex = "vhdl"
+
+[[grammar]]
+name = "vhdl"
+source = { git = "https://github.com/teburd/tree-sitter-vhdl", rev = "c57313adee2231100db0a7880033f6865deeadb2" }
+
+[[language]]
+name = "rego"
+roots = []
+scope = "source.rego"
+injection-regex = "rego"
+file-types = ["rego"]
+auto-format = true
+comment-token = "#"
+language-server = { command = "regols" }
+grammar = "rego"
+
+[[grammar]]
+name = "rego"
+source = { git = "https://github.com/FallenAngel97/tree-sitter-rego", rev = "b2667c975f07b33be3ceb83bea5cfbad88095866" }
+
+[[language]]
+name = "nim"
+scope = "source.nim"
+injection-regex = "nim"
+file-types = ["nim", "nims", "nimble"]
+shebangs = []
+roots = []
+comment-token = "#"
+indent = { tab-width = 2, unit = "  " }
+language-server = { command = "nimlangserver" }
+
+[language.auto-pairs]
+'(' = ')'
+'[' = ']'
+'"' = '"'
+"'" = "'"
+'{' = '}'
+
+# Nim's tree-sitter grammar is in heavy development.
+[[grammar]]
+name = "nim"
+source = { git = "https://github.com/aMOPel/tree-sitter-nim", rev = "240239b232550e431d67de250d1b5856209e7f06" }
+
+[[language]]
+name = "hurl"
+scope = "source.hurl"
+injection-regex = "hurl"
+file-types = ["hurl"]
+roots = []
+comment-token = "#"
+indent = { tab-width = 2, unit = "  " }
+
+[[grammar]]
+name = "hurl"
+source = { git = "https://github.com/pfeiferj/tree-sitter-hurl", rev = "264c42064b61ee21abe88d0061f29a0523352e22" }
+
diff --git a/runtime/queries/bash/indents.scm b/runtime/queries/bash/indents.scm
new file mode 100644
index 000000000..f2077037d
--- /dev/null
+++ b/runtime/queries/bash/indents.scm
@@ -0,0 +1,11 @@
+[
+  (function_definition)
+  (if_statement)
+  (for_statement)
+  (case_statement)
+  (pipeline)
+] @indent
+
+[
+  "}"
+] @outdent
diff --git a/runtime/queries/c/indents.scm b/runtime/queries/c/indents.scm
index 353ea81b9..812867854 100644
--- a/runtime/queries/c/indents.scm
+++ b/runtime/queries/c/indents.scm
@@ -1,5 +1,6 @@
 [
   (compound_statement)
+  (declaration_list)
   (field_declaration_list)
   (enumerator_list)
   (parameter_list)
diff --git a/runtime/queries/capnp/folds.scm b/runtime/queries/capnp/folds.scm
new file mode 100644
index 000000000..6e3f9c187
--- /dev/null
+++ b/runtime/queries/capnp/folds.scm
@@ -0,0 +1,14 @@
+[
+  (annotation_targets)
+  (const_list)
+  (enum)
+  (interface)
+  (implicit_generics)
+  (generics)
+  (group)
+  (method_parameters)
+  (named_return_types)
+  (struct)
+  (struct_shorthand)
+  (union)
+] @fold
diff --git a/runtime/queries/capnp/highlights.scm b/runtime/queries/capnp/highlights.scm
new file mode 100644
index 000000000..27ddf8e2d
--- /dev/null
+++ b/runtime/queries/capnp/highlights.scm
@@ -0,0 +1,141 @@
+; Preproc
+
+(unique_id) @keyword.directive
+(top_level_annotation_body) @keyword.directive
+
+; Includes
+
+[
+  "import"
+  "$import"
+  "embed"
+] @keyword.control.import
+
+(import_path) @string
+
+; Builtins
+
+[
+  (primitive_type)
+  "List"
+] @type.builtin
+
+; Typedefs
+
+(type_definition) @type
+
+; Labels (@number, @number!)
+
+(field_version) @label
+
+; Methods
+
+(annotation_definition_identifier) @function.method
+(method_identifier) @function.method
+
+; Fields
+
+(field_identifier) @variable.other.member
+
+; Properties
+
+(property) @label
+
+; Parameters
+
+(param_identifier) @variable.parameter
+(return_identifier) @variable.parameter
+
+; Constants
+
+(const_identifier) @variable
+(local_const) @constant
+(enum_member) @type.enum.variant
+
+(void) @constant.builtin
+
+; Types
+
+(enum_identifier) @type.enum
+(extend_type) @type
+(type_identifier) @type
+
+; Attributes
+
+(annotation_identifier) @attribute
+(attribute) @attribute
+
+; Operators
+
+[
+ ; @ ! -
+  "="
+] @operator
+
+; Keywords
+
+
+[
+  "annotation"
+  "enum"
+  "group"
+  "interface"
+  "struct"
+  "union"
+] @keyword.storage.type
+
+[
+  "extends"
+  "namespace"
+  "using"
+  (annotation_target)
+] @special
+
+; Literals
+
+[
+  (string)
+  (concatenated_string)
+  (block_text)
+  (namespace)
+] @string
+
+(escape_sequence) @constant.character.escape
+
+(data_string) @string.special
+
+(number) @constant.numeric.integer
+
+(float) @constant.numeric.float
+
+(boolean) @constant.builtin.boolean
+
+; Misc
+
+[
+  "const"
+] @keyword.storage.modifier
+
+[
+  "*"
+  "$"
+  ":"
+] @string.special.symbol
+
+["{" "}"] @punctuation.bracket
+
+["(" ")"] @punctuation.bracket
+
+["[" "]"] @punctuation.bracket
+
+[
+  ","
+  ";"
+  "->"
+] @punctuation.delimiter
+
+(data_hex) @constant
+
+; Comments
+
+(comment) @comment.line
diff --git a/runtime/queries/capnp/indents.scm b/runtime/queries/capnp/indents.scm
new file mode 100644
index 000000000..9adaf34fd
--- /dev/null
+++ b/runtime/queries/capnp/indents.scm
@@ -0,0 +1,19 @@
+[
+  (annotation_targets)
+  (const_list)
+  (enum)
+  (interface)
+  (implicit_generics)
+  (generics)
+  (group)
+  (method_parameters)
+  (named_return_types)
+  (struct)
+  (struct_shorthand)
+  (union)
+] @indent
+
+[
+  "}"
+  ")"
+] @outdent
diff --git a/runtime/queries/capnp/injections.scm b/runtime/queries/capnp/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/capnp/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/capnp/locals.scm b/runtime/queries/capnp/locals.scm
new file mode 100644
index 000000000..e98ce2605
--- /dev/null
+++ b/runtime/queries/capnp/locals.scm
@@ -0,0 +1,96 @@
+; Scopes
+
+[
+  (message)
+  (annotation_targets)
+  (const_list)
+  (enum)
+  (interface)
+  (implicit_generics)
+  (generics)
+  (group)
+  (method_parameters)
+  (named_return_types)
+  (struct)
+  (struct_shorthand)
+  (union)
+] @local.scope
+
+; References
+
+[
+  (extend_type)
+  (field_type)
+] @local.reference
+(custom_type (type_identifier) @local.reference)
+(custom_type
+  (generics
+    (generic_parameters 
+      (generic_identifier) @local.reference)))
+
+; Definitions
+
+(annotation_definition_identifier) @local.definition
+
+(const_identifier) @local.definition
+
+(enum (enum_identifier) @local.definition)
+
+[
+  (enum_member)
+  (field_identifier)
+] @local.definition
+
+(method_identifier) @local.definition
+
+(namespace) @local.definition
+
+[
+  (param_identifier)
+  (return_identifier)
+] @local.definition
+
+(group (type_identifier) @local.definition)
+
+(struct (type_identifier) @local.definition)
+
+(union (type_identifier) @local.definition)
+
+(interface (type_identifier) @local.definition)
+
+; Generics Related (don't know how to combine these)
+
+(struct
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
+
+(interface
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
+
+(method
+  (implicit_generics
+    (implicit_generic_parameters
+      (generic_identifier) @local.definition)))
+
+(method
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
+
+(annotation
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
+
+(replace_using
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
+
+(return_type
+  (generics
+    (generic_parameters
+      (generic_identifier) @local.definition)))
diff --git a/runtime/queries/comment/highlights.scm b/runtime/queries/comment/highlights.scm
index 88685d59a..3b25531a8 100644
--- a/runtime/queries/comment/highlights.scm
+++ b/runtime/queries/comment/highlights.scm
@@ -5,17 +5,33 @@
 
 ":" @punctuation.delimiter
 
+; Hint level tags
+((tag (name) @hint)
+ (#match? @hint "^(HINT|MARK)$"))
+
+("text" @hint
+ (#match? @hint "^(HINT|MARK)$"))
+
+; Info level tags
+((tag (name) @info)
+ (#match? @info "^(INFO|NOTE|TODO)$"))
+
+("text" @info
+ (#match? @info "^(INFO|NOTE|TODO)$"))
+
+; Warning level tags
 ((tag (name) @warning)
- (#match? @warning "^(TODO|HACK|WARNING)$"))
+ (#match? @warning "^(HACK|WARN|WARNING)$"))
 
 ("text" @warning
- (#match? @warning "^(TODO|HACK|WARNING)$"))
+ (#match? @warning "^(HACK|WARN|WARNING)$"))
 
+; Error level tags
 ((tag (name) @error)
- (match? @error "^(FIXME|XXX|BUG)$"))
+ (match? @error "^(BUG|FIXME|ISSUE|XXX)$"))
 
 ("text" @error
- (match? @error "^(FIXME|XXX|BUG)$"))
+ (match? @error "^(BUG|FIXME|ISSUE|XXX)$"))
 
 (tag
  (name) @ui.text
diff --git a/runtime/queries/cpp/injections.scm b/runtime/queries/cpp/injections.scm
index a5a5208ca..fb783bb6f 100644
--- a/runtime/queries/cpp/injections.scm
+++ b/runtime/queries/cpp/injections.scm
@@ -1 +1,4 @@
 ; inherits: c
+(raw_string_literal
+  delimiter: (raw_string_delimiter) @injection.language
+  (raw_string_content) @injection.content)
diff --git a/runtime/queries/crystal/highlights.scm b/runtime/queries/crystal/highlights.scm
new file mode 100644
index 000000000..571542863
--- /dev/null
+++ b/runtime/queries/crystal/highlights.scm
@@ -0,0 +1 @@
+; inherits: ruby
diff --git a/runtime/queries/crystal/injections.scm b/runtime/queries/crystal/injections.scm
new file mode 100644
index 000000000..571542863
--- /dev/null
+++ b/runtime/queries/crystal/injections.scm
@@ -0,0 +1 @@
+; inherits: ruby
diff --git a/runtime/queries/crystal/locals.scm b/runtime/queries/crystal/locals.scm
new file mode 100644
index 000000000..571542863
--- /dev/null
+++ b/runtime/queries/crystal/locals.scm
@@ -0,0 +1 @@
+; inherits: ruby
diff --git a/runtime/queries/crystal/textobjects.scm b/runtime/queries/crystal/textobjects.scm
new file mode 100644
index 000000000..571542863
--- /dev/null
+++ b/runtime/queries/crystal/textobjects.scm
@@ -0,0 +1 @@
+; inherits: ruby
diff --git a/runtime/queries/dhall/highlights.scm b/runtime/queries/dhall/highlights.scm
new file mode 100644
index 000000000..0663bbd9d
--- /dev/null
+++ b/runtime/queries/dhall/highlights.scm
@@ -0,0 +1,110 @@
+;; Literals
+(integer_literal) @constant.numeric.integer
+(natural_literal) @constant.numeric.integer
+(double_literal) @constant.numeric.float
+(boolean_literal) @constant.builtin.boolean
+(builtin "None") @constant.builtin
+
+;; Text
+(text_literal) @string
+(interpolation "}" @string)
+(double_quote_escaped) @constant.character.escape
+(single_quote_escaped) @constant.character.escape
+
+;; Imports
+(local_import) @string.special.path
+(http_import) @string.special.url
+(env_import) @keyword
+(env_variable) @string.special
+(import_hash) @string.special
+(missing_import) @keyword.control.import
+[ (import_as_location) (import_as_text) ] @type
+
+;; Comments
+(block_comment) @comment.block
+(line_comment) @comment.line
+
+;; Types
+([
+  (let_binding (label) @type)
+  (union_type_entry (label) @type)
+] (#match? @type "^[A-Z]"))
+((primitive_expression
+  (identifier (label) @type)
+  (selector (label) @type)?) @whole_identifier
+  (#match? @whole_identifier "(?:^|\\.)[A-Z][^.]*$"))
+
+;; Variables
+(identifier [
+  (label) @variable
+  (de_bruijn_index) @operator
+])
+(let_binding label: (label) @variable)
+(lambda_expression label: (label) @variable.parameter)
+(record_literal_entry (label) @variable.other.member)
+(record_type_entry (label) @variable.other.member)
+(selector) @variable.other.member
+
+;; Keywords
+[
+  "let"
+  "in"
+  "assert"
+] @keyword
+[
+  "using"
+  "as"
+  "with"
+] @keyword.operator
+
+;; Operators
+[
+  (type_operator)
+  (assign_operator)
+  (lambda_operator)
+  (arrow_operator)
+  (infix_operator)
+  (completion_operator)
+  (assert_operator)
+  (forall_operator)
+  (empty_record_literal)
+] @operator
+
+;; Builtins
+(builtin_function) @function.builtin
+(builtin [
+  "Bool"
+  "Optional"
+  "Natural"
+  "Integer"
+  "Double"
+  "Text"
+  "Date"
+  "Time"
+  "TimeZone"
+  "List"
+  "Type"
+  "Kind"
+  "Sort"
+] @type.builtin)
+
+;; Punctuation
+[ "," "|" ] @punctuation.delimiter
+(selector_dot) @punctuation.delimiter
+[
+  "("
+  ")"
+  "{"
+  "}"
+  "["
+  "]"
+  "<"
+  ">"
+] @punctuation.bracket
+
+;; Conditionals
+[
+  "if"
+  "then"
+  "else"
+] @keyword.control.conditional
diff --git a/runtime/queries/dhall/injections.scm b/runtime/queries/dhall/injections.scm
new file mode 100644
index 000000000..0164f6840
--- /dev/null
+++ b/runtime/queries/dhall/injections.scm
@@ -0,0 +1,2 @@
+([(block_comment) (line_comment)] @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/dhall/textobjects.scm b/runtime/queries/dhall/textobjects.scm
new file mode 100644
index 000000000..c840c7584
--- /dev/null
+++ b/runtime/queries/dhall/textobjects.scm
@@ -0,0 +1,23 @@
+(lambda_expression
+  (label) @parameter.inside
+  (expression) @function.inside
+) @function.around
+
+(forall_expression
+  (label) @parameter.inside
+  (expression) @function.inside
+) @function.around
+
+(assert_expression
+  (expression) @test.inside
+) @test.around
+
+[
+  (block_comment_content)
+  (line_comment_content)
+] @comment.inside
+
+[
+  (block_comment)
+  (line_comment)
+] @comment.around
diff --git a/runtime/queries/ecma/highlights.scm b/runtime/queries/ecma/highlights.scm
index 212bb8754..7285ab960 100644
--- a/runtime/queries/ecma/highlights.scm
+++ b/runtime/queries/ecma/highlights.scm
@@ -167,55 +167,76 @@
 ]  @punctuation.bracket
 
 [
-  "as"
   "async"
   "debugger"
   "delete"
   "extends"
   "from"
-  "function"
   "get"
-  "in"
-  "instanceof"
   "new"
-  "of"
   "set"
-  "static"
   "target"
-  "try"
   "typeof"
+  "instanceof"
   "void"
   "with"
 ] @keyword
 
+[
+  "of"
+  "as"
+  "in"
+] @keyword.operator
+
+[
+  "function"
+] @keyword.function
+
 [
   "class"
   "let"
-  "const"
   "var"
 ] @keyword.storage.type
 
 [
-  "switch"
-  "case"
+  "const"
+  "static"
+] @keyword.storage.modifier
+
+[
   "default"
-  "if"
-  "else"
   "yield"
-  "throw"
   "finally"
-  "return"
-  "catch"
-  "continue"
-  "while"
-  "break"
-  "for"
   "do"
   "await"
 ] @keyword.control
 
+[
+  "if"
+  "else"
+  "switch"
+  "case"
+  "while"
+] @keyword.control.conditional
+
+[
+  "for"
+] @keyword.control.repeat
+
 [
   "import"
   "export"
 ] @keyword.control.import 
 
+[
+  "return"
+  "break"
+  "continue"
+] @keyword.control.return
+
+[
+  "throw"
+  "try"
+  "catch"
+] @keyword.control.exception
+
diff --git a/runtime/queries/ecma/indents.scm b/runtime/queries/ecma/indents.scm
index a4237e599..12c8fc98e 100644
--- a/runtime/queries/ecma/indents.scm
+++ b/runtime/queries/ecma/indents.scm
@@ -5,6 +5,7 @@
   (formal_parameters)
 
   (statement_block)
+  (switch_statement)
   (object_pattern)
   (class_body)
   (named_imports)
@@ -15,6 +16,11 @@
   (export_clause)
 ] @indent
 
+[
+  (switch_case)
+  (switch_default)
+] @indent @extend
+
 [
   "}"
   "]"
diff --git a/runtime/queries/elm/textobjects.scm b/runtime/queries/elm/textobjects.scm
new file mode 100644
index 000000000..d212e9c3b
--- /dev/null
+++ b/runtime/queries/elm/textobjects.scm
@@ -0,0 +1,63 @@
+(line_comment) @comment.inside
+(line_comment)+ @comment.around
+(block_comment) @comment.inside
+(block_comment)+ @comment.around
+
+((type_annotation)?
+  (value_declaration
+    (function_declaration_left (lower_case_identifier))
+    (eq)
+    (_) @function.inside
+  )
+) @function.around
+
+(parenthesized_expr
+  (anonymous_function_expr
+    (
+      (arrow)
+      (_) @function.inside
+    )
+  )
+) @function.around
+
+(value_declaration
+  (function_declaration_left
+    (lower_pattern
+      (lower_case_identifier) @parameter.inside @parameter.around
+    )
+  )
+)
+
+(value_declaration
+  (function_declaration_left
+    (pattern) @parameter.inside @parameter.around
+  )
+)
+
+(value_declaration
+  (function_declaration_left
+    (tuple_pattern
+      (pattern) @parameter.inside
+    ) @parameter.around
+  )
+)
+
+(value_declaration
+  (function_declaration_left
+    (record_pattern
+      (lower_pattern
+        (lower_case_identifier) @parameter.inside
+      )
+    ) @parameter.around
+  )
+)
+
+(parenthesized_expr
+  (anonymous_function_expr
+    (
+      (backslash)
+      (pattern) @parameter.inside
+      (arrow)
+    )
+  )
+)
diff --git a/runtime/queries/env/highlights.scm b/runtime/queries/env/highlights.scm
index 6a27e8e5a..8a70c41c1 100644
--- a/runtime/queries/env/highlights.scm
+++ b/runtime/queries/env/highlights.scm
@@ -1,19 +1 @@
-(env_variable (quoted_string)) @string
-(env_variable (unquoted_string)) @string
-
-(env_key) @keyword
-
-((variable) @keyword
-  (#match? @keyword "^([A-Z][A-Z_0-9]*)$"))
-  
-[
-  "{"
-  "}"
-] @punctuation.bracket
-
-[
-  "$"
-  "=" 
-] @operator
-
-(comment) @comment
\ No newline at end of file
+; inherits: bash
\ No newline at end of file
diff --git a/runtime/queries/erlang/highlights.scm b/runtime/queries/erlang/highlights.scm
index 3f4ef4cb0..741f5e544 100644
--- a/runtime/queries/erlang/highlights.scm
+++ b/runtime/queries/erlang/highlights.scm
@@ -65,6 +65,16 @@
 (function_capture module: (atom) @namespace)
 (function_capture function: (atom) @function)
 
+; Macros
+(macro
+  "?"+ @constant
+  name: (_) @constant
+  !arguments)
+
+(macro
+  "?"+ @keyword.directive
+  name: (_) @keyword.directive)
+
 ; Ignored variables
 ((variable) @comment.discard
  (#match? @comment.discard "^_"))
@@ -125,16 +135,6 @@
 (unary_operator operator: _ @operator)
 ["/" ":" "->"] @operator
 
-; Macros
-(macro
-  "?"+ @constant
-  name: (_) @constant
-  !arguments)
-
-(macro
-  "?"+ @keyword.directive
-  name: (_) @keyword.directive)
-
 ; Comments
 (tripledot) @comment.discard
 
diff --git a/runtime/queries/gdscript/highlights.scm b/runtime/queries/gdscript/highlights.scm
index f36f4e35c..37aa3d62f 100644
--- a/runtime/queries/gdscript/highlights.scm
+++ b/runtime/queries/gdscript/highlights.scm
@@ -1,7 +1,8 @@
 ; Identifier naming conventions
 
-((identifier) @constant
- (#match? @constant "^[A-Z][A-Z_]*$"))
+(
+  (identifier) @constant 
+  (#match? @constant "^[A-Z][A-Z\\d_]+$"))
 
 ; class
 (class_name_statement (name) @type)
@@ -11,32 +12,56 @@
 ; Function calls
 
 (attribute_call (identifier) @function)
-
 (base_call (identifier) @function)
-
 (call (identifier) @function)
 
 ; Function definitions
 
-(function_definition (name) @function)
-
+(function_definition 
+  name: (name) @function
+  parameters: (parameters) @variable.parameter )
 (constructor_definition "_init" @function)
+(lambda (parameters) @variable.parameter)
+
 
 ;; Literals
-(integer) @constant.numeric.integer
-(float) @constant.numeric.float
 (comment) @comment
 (string) @string
-(escape_sequence) @constant.character.escape
-(identifier) @variable
+
 (type) @type
+(expression_statement (array (identifier) @type))
+(binary_operator (identifier) @type)
+(enum_definition (name) @type.enum)
+(enumerator (identifier) @type.enum.variant)
+[
+  (null)
+  (underscore)
+] @type.builtin
 
-;; Literals
+
+(variable_statement (identifier) @variable)
+(attribute 
+  (identifier) 
+  (identifier) @variable.other.member)
+(attribute 
+  (identifier) @type.builtin
+  (#match? @type.builtin "^(AABB|Array|Basis|bool|Callable|Color|Dictionary|float|int|NodePath|Object|Packed(Byte|Color|String)Array|PackedFloat(32|64)Array|PackedInt(32|64)Array|PackedVector(2|3)Array|Plane|Projection|Quaternion|Rect2([i]{0,1})|RID|Signal|String|StringName|Transform(2|3)D|Variant|Vector(2|3|4)([i]{0,1}))$"))
+
+[
+  (string_name)
+  (node_path)
+  (get_node)
+] @label
+(signal_statement (name) @label)
+
+(const_statement (name) @constant)
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(escape_sequence) @constant.character.escape
 [
   (true)
   (false)
-  (null)
-] @constant.builtin
+] @constant.builtin.boolean
 
 [
   "+"
@@ -62,37 +87,69 @@
   "~"
   "<<"
   ">>"
-  "and"
-  "or"
-  "not"
+  ":="
 ] @operator
 
+(annotation (identifier) @keyword.storage.modifier)
+
 [
-  (static_keyword)
-  (remote_keyword)
-  (tool_statement)
-  "var"
-  "func"
-  "setget"
-  "in"
-  "is"
-  "as"
   "if"
   "else"
   "elif"
+  "match"
+] @keyword.control.conditional
+
+[
   "while"
   "for"
+] @keyword.control.repeat
+
+[
   "return"
+  "pass"
   "break"
   "continue"
-  "pass"
-  "match"
+] @keyword.control.return
+
+[
+  "func"
+] @keyword.control.function
+
+[
+  "export"
+] @keyword.control.import
+
+[
+  "in"
+  "is"
+  "as"
+  "and"
+  "or"
+  "not"
+] @keyword.operator
+
+[
+  "var"
   "class"
   "class_name"
   "enum"
+] @keyword.storage.type
+
+
+[
+  (remote_keyword)
+  (static_keyword)
+  "const"
   "signal"
+  "@"
+] @keyword.storage.modifier
+
+[
+  "setget"
   "onready"
-  "export"
   "extends"
-  "const"
+  "set"
+  "get"
+  "await"
 ] @keyword
+
diff --git a/runtime/queries/gdscript/indents.scm b/runtime/queries/gdscript/indents.scm
new file mode 100644
index 000000000..c969eb7cf
--- /dev/null
+++ b/runtime/queries/gdscript/indents.scm
@@ -0,0 +1,35 @@
+[
+  (if_statement)
+  (for_statement)
+  (while_statement)
+  (match_statement)
+  (pattern_section)
+
+  (function_definition)
+  (constructor_definition)
+  (class_definition)
+  (enum_definition)
+
+  (dictionary (_))
+  (array (_))
+  (setget)
+] @indent
+
+[
+  (if_statement)
+  (for_statement)
+  (while_statement)
+  (match_statement)
+  (pattern_section)
+
+  (function_definition)
+  (class_definition)
+] @extend
+
+[
+  (return_statement)
+  (break_statement)
+  (continue_statement)
+  (pass_statement)
+] @extend.prevent-once
+
diff --git a/runtime/queries/gdscript/injections.scm b/runtime/queries/gdscript/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/gdscript/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/git-commit/textobjects.scm b/runtime/queries/git-commit/textobjects.scm
new file mode 100644
index 000000000..4465c8768
--- /dev/null
+++ b/runtime/queries/git-commit/textobjects.scm
@@ -0,0 +1,2 @@
+(comment) @comment.inside
+(comment)+ @comment.around
diff --git a/runtime/queries/git-rebase/highlights.scm b/runtime/queries/git-rebase/highlights.scm
index 4f007037d..5a03dadf8 100644
--- a/runtime/queries/git-rebase/highlights.scm
+++ b/runtime/queries/git-rebase/highlights.scm
@@ -1,11 +1,36 @@
-(operation operator: ["p" "pick" "r" "reword" "e" "edit" "s" "squash" "m" "merge" "d" "drop" "b" "break" "x" "exec"] @keyword)
-(operation operator: ["l" "label" "t" "reset"] @function)
-(operation operator: ["f" "fixup"] @function.special)
+; a rough translation:
+; * constant.builtin - git hash
+; * constant - a git label
+; * keyword - command that acts on commits commits
+; * function - command that acts only on labels
+; * comment - discarded commentary on a command, has no effect on the rebase
+; * string - text used in the rebase operation
+; * operator - a 'switch' (used in fixup and merge), either -c or -C at time of writing
+
+(((command) @keyword
+  (label) @constant.builtin
+  (message)? @comment)
+ (#match? @keyword "^(p|pick|r|reword|e|edit|s|squash|d|drop)$"))
+
+(((command) @function
+  (label) @constant
+  (message)? @comment)
+ (#match? @function "^(l|label|t|reset|u|update-ref)$"))
+
+((command) @keyword
+ (#match? @keyword "^(x|exec|b|break)$"))
+
+(((command) @attribute
+  (label) @constant.builtin
+  (message)? @comment)
+ (#match? @attribute "^(f|fixup)$"))
+
+(((command) @keyword
+  (label) @constant.builtin
+  (label) @constant
+  (message) @string)
+ (#match? @keyword "^(m|merge)$"))
 
 (option) @operator
-(label) @string.special.symbol
-(commit) @constant
-"#" @punctuation.delimiter
-(comment) @comment
 
-(ERROR) @error
+(comment) @comment
diff --git a/runtime/queries/git-rebase/injections.scm b/runtime/queries/git-rebase/injections.scm
index 070129b63..90f1f9416 100644
--- a/runtime/queries/git-rebase/injections.scm
+++ b/runtime/queries/git-rebase/injections.scm
@@ -1,4 +1,5 @@
-((operation
-   operator: ["x" "exec"]
-   (command) @injection.content)
- (#set! injection.language "bash"))
+(((command) @attribute
+  (message)? @injection.content)
+ (#match? @attribute "^(x|exec)$")
+ (#set! injection.language "bash")
+)
diff --git a/runtime/queries/go/highlights.scm b/runtime/queries/go/highlights.scm
index 927bd95b0..b2d81e45d 100644
--- a/runtime/queries/go/highlights.scm
+++ b/runtime/queries/go/highlights.scm
@@ -19,6 +19,9 @@
 (method_declaration
   name: (field_identifier) @function.method)
 
+(method_spec 
+  name: (field_identifier) @function.method) 
+
 ; Identifiers
 
 ((identifier) @constant (match? @constant "^[A-Z][A-Z\\d_]+$"))
@@ -32,10 +35,19 @@
   (match? @type.builtin "^(any|bool|byte|comparable|complex128|complex64|error|float32|float64|int|int16|int32|int64|int8|rune|string|uint|uint16|uint32|uint64|uint8|uintptr)$"))
 
 (type_identifier) @type
+(type_spec 
+  name: (type_identifier) @constructor)
 (field_identifier) @variable.other.member
 (identifier) @variable
-(package_identifier) @variable
+(package_identifier) @namespace
+
+(parameter_declaration (identifier) @variable.parameter)
+(variadic_parameter_declaration (identifier) @variable.parameter)
 
+(label_name) @label
+
+(const_spec
+  name: (identifier) @constant)
 
 ; Operators
 
@@ -82,36 +94,57 @@
 ; Keywords
 
 [
-  "break"
-  "case"
-  "chan"
-  "const"
-  "continue"
   "default"
-  "defer"
+  "type"
+] @keyword
+
+[
+  "if"  
   "else"
-  "fallthrough"
+  "switch"
+  "select"
+  "case"
+] @keyword.control.conditional
+
+[
   "for"
-  "func"
-  "go"
-  "goto"
-  "if"
-  "interface"
-  "map"
   "range"
-  "return"
-  "select"
-  "struct"
-  "switch"
-  "type"
-  "var"
-] @keyword
+] @keyword.control.repeat
 
 [
   "import"
   "package"
 ] @keyword.control.import
 
+[
+  "return"
+  "continue"
+  "break"
+  "fallthrough"
+] @keyword.control.return
+
+[
+  "func"
+] @keyword.function
+
+[
+  "var"
+  "chan"
+  "interface"
+  "map"
+  "struct"
+] @keyword.storage.type
+
+[
+  "const"
+] @keyword.storage.modifier
+
+[
+  "defer"
+  "goto"
+  "go"
+] @function.macro
+
 ; Delimiters
 
 [
diff --git a/runtime/queries/go/indents.scm b/runtime/queries/go/indents.scm
index f72ec9e82..e439a9055 100644
--- a/runtime/queries/go/indents.scm
+++ b/runtime/queries/go/indents.scm
@@ -20,8 +20,9 @@
 ] @indent
 
 [
-  "case"
-  "}"
   "]"
   ")"
 ] @outdent
+
+((_ "}" @outdent) @outer (#not-kind-eq? @outer "select_statement"))
+(communication_case) @extend
diff --git a/runtime/queries/godot-resource/highlights.scm b/runtime/queries/godot-resource/highlights.scm
index 18dae41fb..d8a69f655 100644
--- a/runtime/queries/godot-resource/highlights.scm
+++ b/runtime/queries/godot-resource/highlights.scm
@@ -25,4 +25,5 @@
 
 "=" @operator
 
-(ERROR) @error
\ No newline at end of file
+(ERROR) @error
+(comment) @comment
diff --git a/runtime/queries/godot-resource/injections.scm b/runtime/queries/godot-resource/injections.scm
new file mode 100644
index 000000000..7929d63cd
--- /dev/null
+++ b/runtime/queries/godot-resource/injections.scm
@@ -0,0 +1,18 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
+
+; ((section) @injection.content
+;  (#set! injection.language "comment"))
+
+((section 
+  (attribute 
+    (identifier) @_type
+    (string) @_is_shader)
+  (property 
+    (path) @_is_code
+    (string) @injection.content))
+  (#match? @_type "type")
+  (#match? @_is_shader "Shader")
+  (#eq? @_is_code "code")
+  (#set! injection.language "glsl")
+)
diff --git a/runtime/queries/hosts/highlights.scm b/runtime/queries/hosts/highlights.scm
new file mode 100644
index 000000000..9d069031c
--- /dev/null
+++ b/runtime/queries/hosts/highlights.scm
@@ -0,0 +1,3 @@
+(comment) @comment
+(ip) @namespace
+(host) @string
diff --git a/runtime/queries/hurl/highlights.scm b/runtime/queries/hurl/highlights.scm
new file mode 100644
index 000000000..c066b2844
--- /dev/null
+++ b/runtime/queries/hurl/highlights.scm
@@ -0,0 +1,127 @@
+[
+  "[QueryStringParams]"
+  "[FormParams]"
+  "[MultipartFormData]"
+  "[Cookies]"
+  "[Captures]"
+  "[Asserts]"
+  "[Options]"
+  "[BasicAuth]"
+] @attribute
+
+(comment) @comment
+
+[
+  (key_string)
+  (json_key_string)
+] @variable.other.member
+ 
+(value_string) @string
+(quoted_string) @string
+(json_string) @string
+(file_value) @string.special.path
+(regex) @string.regex
+
+[
+  "\\"
+  (regex_escaped_char)
+  (quoted_string_escaped_char)
+  (key_string_escaped_char)
+  (value_string_escaped_char)
+  (oneline_string_escaped_char)
+  (multiline_string_escaped_char)
+  (filename_escaped_char)
+  (json_string_escaped_char)
+] @constant.character.escape
+
+(method) @type.builtin
+(multiline_string_type) @type
+
+[
+  "status"
+  "url"
+  "header"
+  "cookie"
+  "body"
+  "xpath"
+  "jsonpath"
+  "regex"
+  "variable"
+  "duration"
+  "sha256"
+  "md5"
+  "bytes"
+] @function.builtin
+
+(filter) @attribute
+
+(version) @string.special
+[
+  "null"
+  "cacert"
+  "location"
+  "insecure"
+  "max-redirs"
+  "retry"
+  "retry-interval"
+  "retry-max-count"
+  (variable_option "variable")
+  "verbose"
+  "very-verbose"
+] @constant.builtin
+
+(boolean) @constant.builtin.boolean
+
+(variable_name) @variable
+
+[
+  "not"
+  "equals"
+  "=="
+  "notEquals"
+  "!="
+  "greaterThan"
+  ">"
+  "greaterThanOrEquals"
+  ">="
+  "lessThan"
+  "<"
+  "lessThanOrEquals"
+  "<="
+  "startsWith"
+  "endsWith"
+  "contains"
+  "matches"
+  "exists"
+  "includes"
+  "isInteger"
+  "isFloat"
+  "isBoolean"
+  "isString"
+  "isCollection"
+] @keyword.operator
+
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(status) @constant.numeric
+(json_number) @constant.numeric.float
+
+[
+  ":"
+  ","
+] @punctuation.delimiter
+
+[
+  "["
+  "]"
+  "{"
+  "}"
+  "{{"
+  "}}"
+] @punctuation.special
+
+[
+  "base64,"
+  "file,"
+  "hex,"
+] @string.special
\ No newline at end of file
diff --git a/runtime/queries/hurl/indents.scm b/runtime/queries/hurl/indents.scm
new file mode 100644
index 000000000..d436f76fd
--- /dev/null
+++ b/runtime/queries/hurl/indents.scm
@@ -0,0 +1,11 @@
+[
+  (json_object)
+  (json_array)
+  (xml_tag)
+] @indent
+
+[
+  "}"
+  "]"
+  (xml_close_tag)
+] @outdent
diff --git a/runtime/queries/hurl/injections.scm b/runtime/queries/hurl/injections.scm
new file mode 100644
index 000000000..a0d238173
--- /dev/null
+++ b/runtime/queries/hurl/injections.scm
@@ -0,0 +1,14 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
+
+((json_value) @injection.content
+  (#set! injection.language "json"))
+
+((xml) @injection.content
+  (#set! injection.language "xml"))
+
+((multiline_string
+  (multiline_string_type) @injection.language
+  (multiline_string_content) @injection.content)
+  (#set! injection.include-children)
+  (#set! injection.combined))
diff --git a/runtime/queries/julia/indents.scm b/runtime/queries/julia/indents.scm
new file mode 100644
index 000000000..08f55aa7f
--- /dev/null
+++ b/runtime/queries/julia/indents.scm
@@ -0,0 +1,16 @@
+[
+  (struct_definition)
+  (macro_definition)
+  (function_definition)
+  (compound_expression)
+  (let_statement)
+  (if_statement)
+  (for_statement)
+  (while_statement)
+  (do_clause)
+  (parameter_list)
+] @indent
+
+[
+  "end"
+] @outdent
diff --git a/runtime/queries/julia/injections.scm b/runtime/queries/julia/injections.scm
index ce4011f20..fd174a4a0 100644
--- a/runtime/queries/julia/injections.scm
+++ b/runtime/queries/julia/injections.scm
@@ -26,3 +26,9 @@
     prefix: (identifier) @function.macro) @injection.content
   (#eq? @function.macro "re")
   (#set! injection.language "regex"))
+
+(
+  (prefixed_string_literal
+    prefix: (identifier) @function.macro) @injection.content
+  (#eq? @function.macro "md")
+  (#set! injection.language "markdown"))
diff --git a/runtime/queries/julia/textobjects.scm b/runtime/queries/julia/textobjects.scm
new file mode 100644
index 000000000..1927c2b18
--- /dev/null
+++ b/runtime/queries/julia/textobjects.scm
@@ -0,0 +1,46 @@
+(function_definition (_)? @function.inside) @function.around
+
+(short_function_definition (_)? @function.inside) @function.around
+
+(macro_definition (_)? @function.inside) @function.around
+
+(struct_definition (_)? @class.inside) @class.around
+
+(abstract_definition (_)? @class.inside) @class.around
+
+(primitive_definition (_)? @class.inside) @class.around
+
+(parameter_list
+  ; Match all children of parameter_list *except* keyword_parameters
+  ([(identifier)
+    (slurp_parameter)
+    (optional_parameter)
+    (typed_parameter)
+    (tuple_expression)
+    (interpolation_expression)
+    (call_expression)]
+  @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(keyword_parameters
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(argument_list
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(type_parameter_list
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(line_comment) @comment.inside
+
+(line_comment)+ @comment.around
+
+(block_comment) @comment.inside
+
+(block_comment)+ @comment.around
+
+(_expression (macro_identifier
+    (identifier) @_name
+    (#match? @_name "^(test|test_throws|test_logs|inferred|test_deprecated|test_warn|test_nowarn|test_broken|test_skip)$")
+  )
+  .
+  (macro_argument_list) @test.inside) @test.around
diff --git a/runtime/queries/make/highlights.scm b/runtime/queries/make/highlights.scm
index 5aef8e0f6..68a61cf4c 100644
--- a/runtime/queries/make/highlights.scm
+++ b/runtime/queries/make/highlights.scm
@@ -45,7 +45,9 @@
  (raw_text)
 ] @string
 
-(variable_assignment (word) @string)
+(variable_assignment (word) @variable)
+(shell_text
+  [(variable_reference (word) @variable.parameter)])
 
 [
  "ifeq"
@@ -139,6 +141,7 @@
   function: "info"
   (arguments (text) @info))
 
+
 ;; Install Command Categories
 ;; Others special variables
 ;; Variables Used by Implicit Rules
@@ -168,3 +171,5 @@
 (targets
   (word) @constant.macro
   (#match? @constant.macro "^\.(PHONY|SUFFIXES|DEFAULT|PRECIOUS|INTERMEDIATE|SECONDARY|SECONDEXPANSION|DELETE_ON_ERROR|IGNORE|LOW_RESOLUTION_TIME|SILENT|EXPORT_ALL_VARIABLES|NOTPARALLEL|ONESHELL|POSIX)$"))
+
+(targets (word) @constant)
diff --git a/runtime/queries/make/injections.scm b/runtime/queries/make/injections.scm
index 321c90add..cfcba286e 100644
--- a/runtime/queries/make/injections.scm
+++ b/runtime/queries/make/injections.scm
@@ -1,2 +1,5 @@
 ((comment) @injection.content
  (#set! injection.language "comment"))
+
+((shell_text) @injection.content
+ (#set! injection.language "bash"))
diff --git a/runtime/queries/markdown.inline/injections.scm b/runtime/queries/markdown.inline/injections.scm
index 2dd149d90..c2e7012ca 100644
--- a/runtime/queries/markdown.inline/injections.scm
+++ b/runtime/queries/markdown.inline/injections.scm
@@ -1,2 +1,4 @@
 
 ((html_tag) @injection.content (#set! injection.language "html") (#set! injection.include-unnamed-children))
+
+((latex_block) @injection.content (#set! injection.language "latex") (#set! injection.include-unnamed-children))
diff --git a/runtime/queries/markdown/highlights.scm b/runtime/queries/markdown/highlights.scm
index 25f22ba73..72bb68dc2 100644
--- a/runtime/queries/markdown/highlights.scm
+++ b/runtime/queries/markdown/highlights.scm
@@ -39,7 +39,10 @@
   (list_marker_parenthesis)
 ] @markup.list.numbered
 
-(thematic_break) @punctuation.delimiter
+(task_list_marker_checked) @markup.list.checked
+(task_list_marker_unchecked) @markup.list.unchecked
+
+(thematic_break) @punctuation.special
 
 [
   (block_continuation)
@@ -51,3 +54,9 @@
 ] @string.escape
 
 (block_quote) @markup.quote
+
+(pipe_table_row
+  "|" @punctuation.special)
+(pipe_table_header
+  "|" @punctuation.special)
+(pipe_table_delimiter_row) @punctuation.special
diff --git a/runtime/queries/markdown/injections.scm b/runtime/queries/markdown/injections.scm
index e184db157..e88393512 100644
--- a/runtime/queries/markdown/injections.scm
+++ b/runtime/queries/markdown/injections.scm
@@ -5,7 +5,10 @@
     (language) @injection.language)
   (code_fence_content) @injection.content (#set! injection.include-unnamed-children))
 
-((html_block) @injection.content (#set! injection.language "html") (#set! injection.include-unnamed-children))
+((html_block) @injection.content
+ (#set! injection.language "html")
+ (#set! injection.include-unnamed-children)
+ (#set! injection.combined))
 
 ((pipe_table_cell) @injection.content (#set! injection.language "markdown.inline") (#set! injection.include-unnamed-children))
 
diff --git a/runtime/queries/matlab/highlights.scm b/runtime/queries/matlab/highlights.scm
new file mode 100644
index 000000000..c0e23e917
--- /dev/null
+++ b/runtime/queries/matlab/highlights.scm
@@ -0,0 +1,97 @@
+  ; highlights.scm
+
+function_keyword: (function_keyword) @keyword.function
+
+(function_definition
+function_name: (identifier) @function
+(end) @function)
+
+(parameter_list (identifier) @variable.parameter)
+
+[
+    "if"
+    "elseif"
+    "else"
+    "switch"
+    "case"
+    "otherwise"
+] @keyword.control.conditional
+
+(if_statement (end) @keyword.control.conditional)
+(switch_statement (end) @keyword.control.conditional)
+
+["for" "while"] @keyword.control.repeat
+(for_statement (end) @keyword.control.repeat)
+(while_statement (end) @keyword.control.repeat)
+
+["try" "catch"] @keyword.control.exception
+(try_statement (end) @keyword.control.exception)
+
+(function_definition end: (end) @keyword)
+
+["return" "break" "continue"] @keyword.return
+
+(
+(identifier) @constant.builtin
+(#any-of? @constant.builtin "true" "false")
+)
+
+(
+    (identifier) @constant.builtin
+    (#eq? @constant.builtin "end")
+)
+
+;; Punctuations
+
+[";" ","] @punctuation.special
+(argument_list "," @punctuation.delimiter)
+(vector_definition ["," ";"] @punctuation.delimiter)
+(cell_definition ["," ";"] @punctuation.delimiter)
+":" @punctuation.delimiter
+(parameter_list "," @punctuation.delimiter)
+(return_value "," @punctuation.delimiter)
+
+; ;; Brackets
+
+[
+ "("
+ ")"
+ "["
+ "]"
+ "{"
+ "}"
+] @punctuation.bracket
+
+;; Operators
+"=" @operator
+(operation [ ">"
+            "<"
+            "=="
+            "<="
+            ">="
+            "=<"
+            "=>"
+            "~="
+            "*"
+            ".*"
+            "/"
+            "\\"
+            "./"
+            "^"
+            ".^"
+            "+"] @operator)
+
+;; boolean operator
+[
+    "&&"
+    "||"
+] @operator
+
+;; Number
+(number) @constant.numeric
+
+;; String
+(string) @string
+
+;; Comment
+(comment) @comment
diff --git a/runtime/queries/mermaid/highlights.scm b/runtime/queries/mermaid/highlights.scm
new file mode 100644
index 000000000..b546d39f2
--- /dev/null
+++ b/runtime/queries/mermaid/highlights.scm
@@ -0,0 +1,187 @@
+[
+ "sequenceDiagram"
+ "classDiagram"
+ "classDiagram-v2"
+ "stateDiagram"
+ "stateDiagram-v2"
+ "gantt"
+ "pie"
+ "flowchart"
+ "erdiagram"
+
+ "participant"
+ "as"
+ "activate"
+ "deactivate"
+ "note "
+ "over"
+ "link"
+ "links"
+ ; "left of"
+ ; "right of"
+ "properties"
+ "details"
+ "title"
+ "loop"
+ "rect"
+ "opt"
+ "alt"
+ "else"
+ "par"
+ "and"
+ "end"
+ (sequence_stmt_autonumber)
+ (note_placement_left)
+ (note_placement_right)
+
+ "class"
+
+ "state "
+
+ "dateformat"
+ "inclusiveenddates"
+ "topaxis"
+ "axisformat"
+ "includes"
+ "excludes"
+ "todaymarker"
+ "title"
+ "section"
+
+ "direction"
+ "subgraph"
+
+ ] @keyword
+
+[
+ (comment)
+ ] @comment
+
+(flow_vertex_id) @type
+(flow_arrow_text) @label
+(flow_text_literal) @string
+ 
+[
+ ":"
+ (sequence_signal_plus_sign)
+ (sequence_signal_minus_sign)
+
+ (class_visibility_public)
+ (class_visibility_private)
+ (class_visibility_protected)
+ (class_visibility_internal)
+
+ (state_division)
+ ] @punctuation.delimiter
+
+[
+ "("
+ ")"
+ "{"
+ "}"
+ ] @punctuation.bracket
+
+[
+ "-->"
+ (solid_arrow)
+ (dotted_arrow)
+ (solid_open_arrow)
+ (dotted_open_arrow)
+ (solid_cross)
+ (dotted_cross)
+ (solid_point)
+ (dotted_point)
+ ] @operator
+
+[
+ (class_reltype_aggregation)
+ (class_reltype_extension)
+ (class_reltype_composition)
+ (class_reltype_dependency)
+ (class_linetype_solid)
+ (class_linetype_dotted)
+ "&"
+ ] @operator
+
+(sequence_actor) @variable
+(sequence_text) @string
+
+(class_name) @type
+(class_label) @string
+(class_method_line) @function.method
+
+(state_name) @variable
+
+(gantt_section) @markup.heading
+(gantt_task_text) @variable.builtin
+(gantt_task_data) @string
+
+[
+ (class_annotation_line)
+ (class_stmt_annotation)
+ (class_generics)
+
+ (state_annotation_fork)
+ (state_annotation_join)
+ (state_annotation_choice)
+ ] @type
+
+(directive) @keyword.directive
+
+(pie_label) @string
+(pie_value) @constant.numeric
+
+[
+(flowchart_direction_lr)
+(flowchart_direction_rl)
+(flowchart_direction_tb)
+(flowchart_direction_bt)
+ ] @constant
+
+(flow_vertex_id) @variable
+
+[
+ (flow_link_arrow)
+ (flow_link_arrow_start)
+ ] @operator
+
+(flow_link_arrowtext "|" @punctuation.bracket)
+
+(flow_vertex_square        [ "[" "]" ]   @punctuation.bracket )
+(flow_vertex_circle        ["((" "))"]   @punctuation.bracket )
+(flow_vertex_ellipse       ["(-" "-)"]   @punctuation.bracket )
+(flow_vertex_stadium       ["([" "])"]   @punctuation.bracket )
+(flow_vertex_subroutine    ["[[" "]]"]   @punctuation.bracket )
+(flow_vertex_rect          ["[|" "|]"]   @punctuation.bracket )
+(flow_vertex_cylinder      ["[(" ")]"]   @punctuation.bracket )
+(flow_vertex_round         ["(" ")"]     @punctuation.bracket )
+(flow_vertex_diamond       ["{" "}"]     @punctuation.bracket )
+(flow_vertex_hexagon       ["{{" "}}"]   @punctuation.bracket )
+(flow_vertex_odd           [">" "]"]     @punctuation.bracket )
+(flow_vertex_trapezoid     ["[/" "\\]"]  @punctuation.bracket )
+(flow_vertex_inv_trapezoid ["[\\" "/]"]  @punctuation.bracket )
+(flow_vertex_leanright     ["[/" "/]"]   @punctuation.bracket )
+(flow_vertex_leanleft      ["[\\" "\\]"] @punctuation.bracket )
+
+(flow_stmt_subgraph ["[" "]"] @punctuation.bracket )
+
+[
+ (er_cardinarity_zero_or_one)
+ (er_cardinarity_zero_or_more)
+ (er_cardinarity_one_or_more)
+ (er_cardinarity_only_one)
+ (er_reltype_non_identifying)
+ (er_reltype_identifying)
+ ] @operator
+
+(er_entity_name) @variable
+
+(er_attribute_type) @type
+(er_attribute_name) @variable
+
+[
+ (er_attribute_key_type_pk)
+ (er_attribute_key_type_fk)
+ ] @keyword
+
+(er_attribute_comment) @string
diff --git a/runtime/queries/msbuild/highlights.scm b/runtime/queries/msbuild/highlights.scm
new file mode 100644
index 000000000..27b10d95d
--- /dev/null
+++ b/runtime/queries/msbuild/highlights.scm
@@ -0,0 +1 @@
+; inherits: xml
diff --git a/runtime/queries/msbuild/indents.scm b/runtime/queries/msbuild/indents.scm
new file mode 100644
index 000000000..27b10d95d
--- /dev/null
+++ b/runtime/queries/msbuild/indents.scm
@@ -0,0 +1 @@
+; inherits: xml
diff --git a/runtime/queries/msbuild/injections.scm b/runtime/queries/msbuild/injections.scm
new file mode 100644
index 000000000..27b10d95d
--- /dev/null
+++ b/runtime/queries/msbuild/injections.scm
@@ -0,0 +1 @@
+; inherits: xml
diff --git a/runtime/queries/nasm/highlights.scm b/runtime/queries/nasm/highlights.scm
new file mode 100644
index 000000000..5e3cfebe6
--- /dev/null
+++ b/runtime/queries/nasm/highlights.scm
@@ -0,0 +1,126 @@
+(comment) @comment
+
+(label) @label
+
+(preproc_expression) @keyword.directive
+
+[
+  (line_here_token)
+  (section_here_token)
+] @variable.builtin
+
+(unary_expression
+  operator: _ @operator)
+(binary_expression
+  operator: _ @operator)
+(conditional_expression
+  "?" @operator
+  ":" @operator)
+
+[
+  ":"
+  ","
+] @punctuation.delimiter
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+] @punctuation.bracket
+
+(instruction_prefix) @keyword
+(actual_instruction
+  instruction: (word) @function)
+
+(call_syntax_expression
+  base: (word) @function)
+
+(size_hint) @type
+(struc_declaration
+  name: (word) @type)
+(struc_instance
+  name: (word) @type)
+
+(effective_address
+ hint: _ @type)
+(effective_address
+ segment: _ @constant.builtin)
+
+(register) @constant.builtin
+
+(number_literal) @constant.numeric.integer
+(string_literal) @string
+(float_literal) @constant.numeric.float
+(packed_bcd_literal) @constant.numeric.integer
+
+((word) @constant
+  (#match? @constant "^[A-Z_][?A-Z_0-9]+$"))
+((word) @constant.builtin
+  (#match? @constant.builtin "^__\\?[A-Z_a-z0-9]+\\?__$"))
+(word) @variable
+
+(preproc_arg) @keyword.directive
+
+[
+  (preproc_def)
+  (preproc_function_def)
+  (preproc_undef)
+  (preproc_alias)
+  (preproc_multiline_macro)
+  (preproc_multiline_unmacro)
+  (preproc_if)
+  (preproc_rotate)
+  (preproc_rep_loop)
+  (preproc_include)
+  (preproc_pathsearch)
+  (preproc_depend)
+  (preproc_use)
+  (preproc_push)
+  (preproc_pop)
+  (preproc_repl)
+  (preproc_arg)
+  (preproc_stacksize)
+  (preproc_local)
+  (preproc_reporting)
+  (preproc_pragma)
+  (preproc_line)
+  (preproc_clear)
+] @keyword.directive
+[
+  (pseudo_instruction_dx)
+  (pseudo_instruction_resx)
+  (pseudo_instruction_incbin_command)
+  (pseudo_instruction_equ_command)
+  (pseudo_instruction_times_prefix)
+  (pseudo_instruction_alignx_macro)
+] @function.special
+[
+  (assembl_directive_target)
+  (assembl_directive_defaults)
+  (assembl_directive_sections)
+  (assembl_directive_absolute)
+  (assembl_directive_symbols)
+  (assembl_directive_common)
+  (assembl_directive_symbolfixes)
+  (assembl_directive_cpu)
+  (assembl_directive_floathandling)
+  (assembl_directive_org)
+  (assembl_directive_sectalign)
+
+  (assembl_directive_primitive_target)
+  (assembl_directive_primitive_defaults)
+  (assembl_directive_primitive_sections)
+  (assembl_directive_primitive_absolute)
+  (assembl_directive_primitive_symbols)
+  (assembl_directive_primitive_common)
+  (assembl_directive_primitive_symbolfixes)
+  (assembl_directive_primitive_cpu)
+  (assembl_directive_primitive_floathandling)
+  (assembl_directive_primitive_org)
+  (assembl_directive_primitive_sectalign)
+  (assembl_directive_primitive_warning)
+  (assembl_directive_primitive_map)
+] @keyword
diff --git a/runtime/queries/nasm/injections.scm b/runtime/queries/nasm/injections.scm
new file mode 100644
index 000000000..2f0e58eb6
--- /dev/null
+++ b/runtime/queries/nasm/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+  (#set! injection.language "comment"))
diff --git a/runtime/queries/nasm/textobjects.scm b/runtime/queries/nasm/textobjects.scm
new file mode 100644
index 000000000..ddfbad78c
--- /dev/null
+++ b/runtime/queries/nasm/textobjects.scm
@@ -0,0 +1,15 @@
+(preproc_multiline_macro
+  body: (body) @function.inside) @function.around
+(struc_declaration
+  body: (struc_declaration_body) @class.inside) @class.around
+(struc_instance
+  body: (struc_instance_body) @class.inside) @class.around
+
+(preproc_function_def_parameters
+  (word) @parameter.inside)
+(call_syntax_arguments
+  (_) @parameter.inside)
+(operand) @parameter.inside
+
+(comment) @comment.inside
+(comment)+ @comment.around
diff --git a/runtime/queries/nim/highlights.scm b/runtime/queries/nim/highlights.scm
new file mode 100644
index 000000000..1d3256853
--- /dev/null
+++ b/runtime/queries/nim/highlights.scm
@@ -0,0 +1,315 @@
+;; Constants, Comments, and Literals
+
+(comment) @comment.line
+(multilineComment) @comment.block
+(docComment) @comment.block.documentation
+(multilineDocComment) @comment.block.documentation
+; comments
+
+[(literal) (generalizedLit)] @constant
+[(nil_lit)] @constant.builtin
+[(bool_lit)] @constant.builtin.boolean
+[(char_lit)] @constant.character
+[(char_esc_seq) (str_esc_seq)] @constant.character.escape
+[(custom_numeric_lit)] @constant.numeric
+[(int_lit) (int_suffix)] @constant.numeric.integer
+[(float_lit) (float_suffix)] @constant.numeric.float
+; literals
+; note: somewhat irritatingly for testing, lits have the same syntax highlighting as types
+
+[
+  (str_lit)
+  (triplestr_lit)
+  (rstr_lit)
+  (generalized_str_lit)
+  (generalized_triplestr_lit)
+  (interpolated_str_lit)
+  (interpolated_triplestr_lit)
+] @string
+; [] @string.regexp
+; string literals
+
+[
+  "."
+  ","
+  ";"
+  ":"
+] @punctuation.delimiter
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "{."
+  ".}"
+  "#["
+  "]#"
+] @punctuation.bracket
+(interpolated_str_lit "&" @punctuation.special)
+(interpolated_str_lit "{" @punctuation.special)
+(interpolated_str_lit "}" @punctuation.special)
+; punctuation
+
+[
+  "and"
+  "or"
+  "xor"
+  "not"
+  "in"
+  "notin"
+  "is"
+  "isnot"
+  "div"
+  "mod"
+  "shl"
+  "shr"
+] @keyword.operator
+; operators: we list them explicitly to deliminate them from symbolic operators
+
+[(operator) (opr) "="] @operator
+; all operators (must come after @keyword.operator)
+
+(pragma) @attribute
+; pragmas
+
+
+;; Imports and Exports
+
+(importStmt
+  (keyw) @keyword.control.import
+  (expr (primary (symbol) @namespace))?
+  (expr (primary (arrayConstr (exprColonExprList (exprColonExpr (expr (primary (symbol) @namespace)))))))?)
+(exportStmt
+  (keyw) @keyword.control.import
+  (expr (primary (symbol) @namespace))?
+  (expr (primary (arrayConstr (exprColonExprList (exprColonExpr (expr (primary (symbol) @namespace)))))))?)
+(fromStmt
+  (keyw) @keyword.control.import
+  (expr (primary (symbol) @namespace))?
+  (expr (primary (arrayConstr (exprColonExprList (exprColonExpr (expr (primary (symbol) @namespace)))))))?)
+(includeStmt
+  (keyw) @keyword.control.import
+  (expr (primary (symbol) @namespace))?
+  (expr (primary (arrayConstr (exprColonExprList (exprColonExpr (expr (primary (symbol) @namespace)))))))?)
+(importExceptStmt
+  (keyw) @keyword.control.import
+  (expr (primary (symbol) @namespace))?
+  (expr (primary (arrayConstr (exprColonExprList (exprColonExpr (expr (primary (symbol) @namespace)))))))?)
+; import statements
+; yeah, this is a bit gross.
+
+
+;; Control Flow
+
+(ifStmt (keyw) @keyword.control.conditional)
+(whenStmt (keyw) @keyword.control.conditional)
+(elifStmt (keyw) @keyword.control.conditional)
+(elseStmt (keyw) @keyword.control.conditional)
+(caseStmt (keyw) @keyword.control.conditional)
+(ofBranch (keyw) @keyword.control.conditional)
+(inlineIfStmt (keyw) @keyword.control.conditional)
+(inlineWhenStmt (keyw) @keyword.control.conditional)
+; conditional statements
+; todo: do block
+
+(forStmt
+  . (keyw) @keyword.control.repeat
+  . (symbol) @variable
+  . (keyw) @keyword.control.repeat)
+(whileStmt (keyw) @keyword.control.repeat)
+; loop statements
+
+(returnStmt (keyw) @keyword.control.repeat)
+(yieldStmt (keyw) @keyword.control.repeat)
+(discardStmt (keyw) @keyword.control.repeat)
+(breakStmt (keyw) @keyword.control.repeat)
+(continueStmt (keyw) @keyword.control.repeat)
+; control flow statements
+
+(raiseStmt (keyw) @keyword.control.exception)
+(tryStmt (keyw) @keyword.control.exception)
+(tryExceptStmt (keyw) @keyword.control.exception)
+(tryFinallyStmt (keyw) @keyword.control.exception)
+(inlineTryStmt (keyw) @keyword.control.exception)
+; (inlineTryExceptStmt (keyw) @keyword.control.exception)
+; (inlineTryFinallyStmt (keyw) @keyword.control.exception)
+; exception handling statements
+
+(staticStmt (keyw) @keyword)
+(deferStmt (keyw) @keyword)
+(asmStmt (keyw) @keyword)
+(bindStmt (keyw) @keyword)
+(mixinStmt (keyw) @keyword)
+; miscellaneous blocks
+
+(blockStmt
+  (keyw) @keyword.control
+  (symbol) @label)
+; block statements
+
+
+;; Types and Type Declarations
+
+(typeDef
+  (keyw) @keyword.storage.type
+  (symbol) @type)
+; names of new types type declarations
+
+(exprColonEqExpr
+  . (expr (primary (symbol) @variable))
+  . (expr (primary (symbol) @type)))
+; variables in inline tuple declarations
+
+(primarySuffix
+  (indexSuffix
+    (exprColonEqExprList
+      (exprColonEqExpr
+        (expr
+          (primary
+            (symbol) @type))))))
+; nested types in brackets, i.e. seq[string]
+
+(primaryTypeDef (symbol) @type)
+; primary types of type declarations (NOT nested types)
+
+(primaryTypeDef (primaryPrefix (keyw) @type))
+; for consistency
+
+(primaryTypeDesc (symbol) @type)
+; type annotations, on declarations or in objects
+
+(primaryTypeDesc (primaryPrefix (keyw) @type))
+; var types etc
+
+(genericParamList (genericParam (symbol) @type))
+; types in generic blocks
+
+(enumDecl (keyw) @keyword.storage.type)
+(enumElement (symbol) @type.enum.variant)
+; enum declarations and elements
+
+(tupleDecl (keyw) @keyword.storage.type)
+; tuple declarations
+
+(objectDecl (keyw) @keyword.storage.type)
+(objectPart (symbol) @variable.other.member)
+; object declarations and fields
+
+(objectCase
+  (keyw) @keyword.control.conditional
+  (symbol) @variable.other.member)
+(objectBranch (keyw) @keyword.control.conditional)
+(objectElif (keyw) @keyword.control.conditional)
+(objectElse (keyw) @keyword.control.conditional)
+(objectWhen (keyw) @keyword.control.conditional)
+; variant objects
+
+(conceptDecl (keyw) @keyword.storage.type)
+(conceptParam (keyw) @type)
+(conceptParam (symbol) @variable)
+; concept declarations, parameters, and qualifiers on those parameters
+
+((expr
+  (primary (symbol))
+  (operator) @operator
+  (primary (symbol) @type))
+ (#match? @operator "is"))
+((exprStmt
+  (primary (symbol))
+  (operator) @operator
+  (primary (symbol) @type))
+ (#match? @operator "is"))
+; symbols likely to be types: "x is t" means t is either a type or a type variable
+
+; distinct?
+
+
+;; Functions
+
+(routine
+  . (keyw) @keyword.function
+  . (symbol) @function)
+; function declarations
+
+(routineExpr (keyw) @keyword.function)
+; discarded function
+
+(routineExprTypeDesc (keyw) @keyword.function)
+; function declarations as types
+
+(primary
+  . (symbol) @function.call
+  . (primarySuffix (functionCall)))
+; regular function calls
+
+(primary
+  . (symbol) @function.call
+  . (primarySuffix (cmdCall)))
+; function calls without parenthesis
+
+(primary
+  (primarySuffix (qualifiedSuffix (symbol) @function.call))
+  . (primarySuffix (functionCall)))
+; uniform function call syntax calls
+
+(primary
+  (primarySuffix (qualifiedSuffix (symbol) @function.call))
+  . (primarySuffix (cmdCall)))
+; just in case
+
+(primary
+  (symbol) @constructor
+  (primarySuffix (objectConstr)))
+; object constructor
+
+; does not appear to be a way to distinguish these without verbatium matching
+; [] @function.builtin
+; [] @function.method
+; [] @function.macro
+; [] @function.special
+
+
+;; Variables
+
+(paramList (paramColonEquals (symbol) @variable.parameter))
+; parameter identifiers
+
+(identColon (ident) @variable.other.member)
+; named parts of tuples
+
+(symbolColonExpr (symbol) @variable)
+; object constructor parameters
+
+(symbolEqExpr (symbol) @variable)
+; named parameters
+
+(variable
+  (keyw) @keyword.storage.type
+  (declColonEquals (symbol) @variable))
+; let, var, const expressions
+
+((primary (symbol) @variable.builtin)
+ (#match? @variable.builtin "result"))
+; `result` is an implicit builtin variable inside function scopes
+
+((primary (symbol) @type)
+ (#match? @type "^[A-Z]"))
+; assume PascalCase identifiers to be types
+
+((primary
+  (primarySuffix
+    (qualifiedSuffix
+      (symbol) @type)))
+ (#match? @type "^[A-Z]"))
+; assume PascalCase member variables to be enum entries
+
+(primary (symbol) @variable)
+; overzealous, matches variables
+
+(primary (primarySuffix (qualifiedSuffix (symbol) @variable.other.member)))
+; overzealous, matches member variables: i.e. x in foo.x
+
+(keyw) @keyword
+; more specific matches are done above whenever possible
diff --git a/runtime/queries/nim/indents.scm b/runtime/queries/nim/indents.scm
new file mode 100644
index 000000000..677435407
--- /dev/null
+++ b/runtime/queries/nim/indents.scm
@@ -0,0 +1,54 @@
+[
+  (typeDef)
+  (ifStmt)
+  (whenStmt)
+  (elifStmt)
+  (elseStmt)
+  (ofBranch) ; note: not caseStmt
+  (whileStmt)
+  (tryStmt)
+  (tryExceptStmt)
+  (tryFinallyStmt)
+  (forStmt)
+  (blockStmt)
+  (staticStmt)
+  (deferStmt)
+  (asmStmt)
+  ; exprStmt?
+] @indent
+;; increase the indentation level
+
+[
+  (ifStmt)
+  (whenStmt)
+  (elifStmt)
+  (elseStmt)
+  (ofBranch) ; note: not caseStmt
+  (whileStmt)
+  (tryStmt)
+  (tryExceptStmt)
+  (tryFinallyStmt)
+  (forStmt)
+  (blockStmt)
+  (staticStmt)
+  (deferStmt)
+  (asmStmt)
+  ; exprStmt?
+] @extend
+;; ???
+
+[
+  (returnStmt)
+  (raiseStmt)
+  (yieldStmt)
+  (breakStmt)
+  (continueStmt)
+] @extend.prevent-once
+;; end a level of indentation while staying indented
+
+[
+  ")" ; tuples
+  "]" ; arrays, seqs
+  "}" ; sets
+] @outdent
+;; end a level of indentation and unindent the line
diff --git a/runtime/queries/nim/textobjects.scm b/runtime/queries/nim/textobjects.scm
new file mode 100644
index 000000000..943aa7f08
--- /dev/null
+++ b/runtime/queries/nim/textobjects.scm
@@ -0,0 +1,19 @@
+(routine
+  (block) @function.inside) @function.around
+
+; @class.inside (types?)
+; @class.around
+
+; paramListSuffix is strange and i do not understand it
+(paramList
+  (paramColonEquals) @parameter.inside) @parameter.around
+
+(comment) @comment.inside
+(multilineComment) @comment.inside
+(docComment) @comment.inside
+(multilineDocComment) @comment.inside
+
+(comment)+ @comment.around
+(multilineComment) @comment.around
+(docComment)+ @comment.around
+(multilineDocComment) @comment.around
diff --git a/runtime/queries/nix/highlights.scm b/runtime/queries/nix/highlights.scm
index ce8e3c1a2..a998aa644 100644
--- a/runtime/queries/nix/highlights.scm
+++ b/runtime/queries/nix/highlights.scm
@@ -95,6 +95,8 @@
   "."
   ","
   "="
+  ":"
+  (ellipses)
 ] @punctuation.delimiter
 
 [
diff --git a/runtime/queries/nix/injections.scm b/runtime/queries/nix/injections.scm
index 82d79cc76..62b48233a 100644
--- a/runtime/queries/nix/injections.scm
+++ b/runtime/queries/nix/injections.scm
@@ -1,8 +1,13 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
+
 ; mark arbitary languages with a comment
 ((((comment) @injection.language) .
   (indented_string_expression (string_fragment) @injection.content))
   (#set! injection.combined))
 
+; Common attribute keys corresponding to scripts,
+; such as those of stdenv.mkDerivation.
 ((binding
    attrpath: (attrpath (identifier) @_path)
    expression: (indented_string_expression
@@ -11,6 +16,25 @@
  (#set! injection.language "bash")
  (#set! injection.combined))
 
+; builtins.{match,split} regex str
+; Example: nix/tests/lang/eval-okay-regex-{match,split}.nix
+((apply_expression
+   function: (_) @_func
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)match|split$")
+ (#set! injection.language "regex")
+ (#set! injection.combined))
+
+; builtins.fromJSON json
+; Example: nix/tests/lang/eval-okay-fromjson.nix
+((apply_expression
+   function: (_) @_func
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)fromJSON$")
+ (#set! injection.language "json")
+ (#set! injection.combined))
+
+; trivial-builders.nix pkgs.writeShellScript[Bin] name content
 ((apply_expression
    function: (apply_expression function: (_) @_func)
    argument: (indented_string_expression (string_fragment) @injection.content))
@@ -18,6 +42,8 @@
  (#set! injection.language "bash")
  (#set! injection.combined))
 
+; trivial-builders.nix, aliases.nix
+; pkgs.runCommand[[No]CC][Local] name attrs content
 (apply_expression
   (apply_expression
     function: (apply_expression
@@ -27,6 +53,7 @@
   (#set! injection.language "bash")
   (#set! injection.combined))
 
+; trivial-builders.nix pkgs.writeShellApplication { text = content; }
 (apply_expression
   function: ((_) @_func)
   argument: (_ (_)* (_ (_)* (binding
@@ -37,3 +64,89 @@
   (#match? @_path "^text$")
   (#set! injection.language "bash")
   (#set! injection.combined))
+
+; trivial-builders.nix pkgs.writeCBin name content
+((apply_expression
+   function: (apply_expression function: (_) @_func)
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)writeC(Bin)?$")
+ (#set! injection.language "c")
+ (#set! injection.combined))
+
+; pkgs.writers.* usage examples: nixpkgs/pkgs/build-support/writers/test.nix
+
+; pkgs.writers.write{Bash,Dash}[Bin] name content
+((apply_expression
+   function: (apply_expression function: (_) @_func)
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)write[BD]ash(Bin)?$")
+ (#set! injection.language "bash")
+ (#set! injection.combined))
+
+; pkgs.writers.writeFish[Bin] name content
+((apply_expression
+   function: (apply_expression function: (_) @_func)
+   argument: (indented_string_expression (string_fragment) @injection.content))
+ (#match? @_func "(^|\\.)writeFish(Bin)?$")
+ (#set! injection.language "fish")
+ (#set! injection.combined))
+
+; pkgs.writers.writeRust[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeRust(Bin)?$")
+  (#set! injection.language "rust")
+  (#set! injection.combined))
+
+; pkgs.writers.writeHaskell[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeHaskell(Bin)?$")
+  (#set! injection.language "haskell")
+  (#set! injection.combined))
+
+; pkgs.writers.writeJS[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writeJS(Bin)?$")
+  (#set! injection.language "javascript")
+  (#set! injection.combined))
+
+; pkgs.writers.writePerl[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)writePerl(Bin)?$")
+  (#set! injection.language "perl")
+  (#set! injection.combined))
+
+; pkgs.writers.write{Python,PyPy}{2,3}[Bin] name attrs content
+(apply_expression
+  (apply_expression
+    function: (apply_expression
+      function: ((_) @_func)))
+    argument: (indented_string_expression (string_fragment) @injection.content)
+  (#match? @_func "(^|\\.)write(Python|PyPy)[23](Bin)?$")
+  (#set! injection.language "python")
+  (#set! injection.combined))
+
+; pkgs.writers.writeFSharp[Bin] name content
+; No query available for f-sharp as of the time of writing
+; See: https://github.com/helix-editor/helix/issues/4943
+; ((apply_expression
+;    function: (apply_expression function: (_) @_func)
+;    argument: (indented_string_expression (string_fragment) @injection.content))
+;  (#match? @_func "(^|\\.)writeFSharp(Bin)?$")
+;  (#set! injection.language "f-sharp")
+;  (#set! injection.combined))
diff --git a/runtime/queries/passwd/highlights.scm b/runtime/queries/passwd/highlights.scm
new file mode 100644
index 000000000..00751750d
--- /dev/null
+++ b/runtime/queries/passwd/highlights.scm
@@ -0,0 +1,7 @@
+(user) @namespace
+(auth) @keyword
+(uid) @constant
+(gid) @constant
+(gecos) @string
+(home) @variable
+(shell) @attribute
diff --git a/runtime/queries/pem/highlights.scm b/runtime/queries/pem/highlights.scm
new file mode 100644
index 000000000..ee7a40433
--- /dev/null
+++ b/runtime/queries/pem/highlights.scm
@@ -0,0 +1,7 @@
+(label) @constant
+
+(preeb) @keyword
+(posteb) @keyword
+
+(base64pad) @string.special.symbol
+(laxbase64text) @string
diff --git a/runtime/queries/php/highlights.scm b/runtime/queries/php/highlights.scm
index 77c9424fe..b9429ae8a 100644
--- a/runtime/queries/php/highlights.scm
+++ b/runtime/queries/php/highlights.scm
@@ -2,15 +2,63 @@
 "?>" @tag
 
 ; Types
+[
+  (primitive_type)
+  (cast_type)
+] @type.builtin
+
+(named_type
+  [ (name) @type
+    (qualified_name (name) @type)])
+
+(base_clause
+  [ (name) @type
+    (qualified_name (name) @type)])
+
+(enum_declaration
+  name: (name) @type.enum)
 
-(primitive_type) @type.builtin
-(cast_type) @type.builtin
-(named_type (name) @type) @type
-(named_type (qualified_name) @type) @type
+(interface_declaration
+  name: (name) @constructor)
+
+(class_declaration
+  name: (name) @constructor)
+
+(trait_declaration
+  name:(name) @constructor)
 
 (namespace_definition
   name: (namespace_name (name) @namespace))
 
+(namespace_name_as_prefix 
+  (namespace_name (name) @namespace))
+
+(namespace_use_clause
+  [ (name) @namespace
+    (qualified_name (name) @type) ])
+
+(namespace_aliasing_clause (name) @namespace)
+
+(class_interface_clause
+  [(name) @type
+   (qualified_name (name) @type)])
+
+(scoped_call_expression
+  scope: [(name) @type
+          (qualified_name (name) @type)])
+
+(class_constant_access_expression
+  . [(name) @constructor
+     (qualified_name (name) @constructor)]
+  (name) @constant)
+
+(use_declaration (name) @type)
+
+(binary_expression
+  operator: "instanceof"
+  right: [(name) @type
+          (qualified_name (name) @type)])
+
 ; Superglobals
 (subscript_expression
   (variable_name(name) @constant.builtin
@@ -36,6 +84,21 @@
 (function_definition
   name: (name) @function)
 
+(nullsafe_member_call_expression
+    name: (name) @function.method)
+
+(object_creation_expression
+  [(name) @constructor
+   (qualified_name (name) @constructor)])
+
+; Parameters
+[
+  (simple_parameter)
+  (variadic_parameter)
+] @variable.parameter
+
+(argument
+    (name) @variable.parameter)
 
 ; Member
 
@@ -62,68 +125,194 @@
 
 (variable_name) @variable
 
+; Attributes
+(attribute_list) @attribute
+
 ; Basic tokens
 
-(string) @string
-(heredoc) @string
+[
+  (string)
+  (encapsed_string)
+  (heredoc_body)
+  (nowdoc_body)
+  (shell_command_expression) 
+] @string
+(escape_sequence) @constant.character.escape
+
 (boolean) @constant.builtin.boolean
 (null) @constant.builtin
 (integer) @constant.numeric.integer
 (float) @constant.numeric.float
 (comment) @comment
 
-"$" @operator
+(goto_statement (name) @label)
+(named_label_statement (name) @label)
 
 ; Keywords
 
 [
-  "abstract" 
-  "as" 
-  "break" 
-  "case" 
-  "catch" 
-  "class" 
-  "const" 
-  "continue" 
-  "declare" 
   "default" 
-  "do" 
   "echo" 
-  "else" 
-  "elseif" 
-  "enddeclare" 
-  "endforeach" 
-  "endif" 
-  "endswitch" 
-  "endwhile" 
   "enum" 
   "extends" 
   "final" 
-  "finally" 
-  "foreach" 
-  "fn" 
-  "function" 
+  "goto"
   "global" 
-  "if" 
   "implements" 
-  "include_once" 
-  "include" 
   "insteadof" 
-  "interface" 
-  "match" 
-  "namespace" 
   "new" 
   "private" 
   "protected" 
   "public" 
+  "clone"
+  "unset"
+] @keyword
+
+[
+  "if" 
+  "else" 
+  "elseif" 
+  "endif" 
+  "switch" 
+  "endswitch" 
+  "case" 
+  "match" 
+  "declare" 
+  "enddeclare" 
+  "??"
+] @keyword.control.conditional
+
+[
+  "for"
+  "endfor"
+  "foreach" 
+  "endforeach" 
+  "while" 
+  "endwhile" 
+  "do"
+] @keyword.control.repeat
+
+[
+  
+  "include_once" 
+  "include" 
   "require_once" 
   "require" 
+  "use"
+] @keyword.control.import
+
+[
   "return" 
-  "static" 
-  "switch" 
+  "break" 
+  "continue" 
+  "yield"
+] @keyword.control.return
+
+[
   "throw" 
-  "trait" 
   "try" 
-  "use" 
-  "while" 
-] @keyword
+  "catch" 
+  "finally"
+] @keyword.control.exception
+
+[
+  "as" 
+  "or"
+  "xor"
+  "and"
+  "instanceof"
+] @keyword.operator
+
+[
+  "fn" 
+  "function" 
+] @keyword.function
+
+[
+  "namespace" 
+  "class" 
+  "interface" 
+  "trait" 
+  "abstract" 
+] @keyword.storage.type
+
+[
+  "static"
+  "const"
+] @keyword.storage.modifier
+
+[
+  ","
+  ";"
+  ":"
+  "\\"
+ ] @punctuation.delimiter
+
+[
+  (php_tag)
+  "?>"
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "#["
+] @punctuation.bracket
+
+[
+  "="
+
+  "."
+  "-"
+  "*"
+  "/"
+  "+"
+  "%"
+  "**"
+
+  "~"
+  "|"
+  "^"
+  "&"
+  "<<"
+  ">>"
+
+  "->"
+  "?->"
+
+  "=>"
+
+  "<"
+  "<="
+  ">="
+  ">"
+  "<>"
+  "=="
+  "!="
+  "==="
+  "!=="
+
+  "!"
+  "&&"
+  "||"
+
+  ".="
+  "-="
+  "+="
+  "*="
+  "/="
+  "%="
+  "**="
+  "&="
+  "|="
+  "^="
+  "<<="
+  ">>="
+  "??="
+  "--"
+  "++"
+
+  "@"
+  "::"
+] @operator
diff --git a/runtime/queries/php/injections.scm b/runtime/queries/php/injections.scm
index 614a38509..8d1b97402 100644
--- a/runtime/queries/php/injections.scm
+++ b/runtime/queries/php/injections.scm
@@ -4,3 +4,22 @@
 
 ((comment) @injection.content
  (#set! injection.language "comment"))
+
+((function_call_expression
+ function: (name) @_function
+ arguments: (arguments . (argument (_ (string_value) @injection.content))))
+ (#match? @_function "^preg_")
+ (#set! injection.language "regex"))
+
+((function_call_expression
+ function: (name) @_function
+ arguments: (arguments (_) (argument (_ (string_value) @injection.content))))
+ (#match? @_function "^mysqli_")
+ (#set! injection.language "sql"))
+
+((member_call_expression
+ object: (_)
+ name: (name) @_function
+ arguments: (arguments . (argument (_ (string_value) @injection.content))))
+ (#match? @_function "^(prepare|query)$")
+ (#set! injection.language "sql"))
diff --git a/runtime/queries/po/highlights.scm b/runtime/queries/po/highlights.scm
new file mode 100644
index 000000000..b090f129d
--- /dev/null
+++ b/runtime/queries/po/highlights.scm
@@ -0,0 +1,15 @@
+[
+  (msgctxt)
+  (msgid)
+  (msgid_plural)
+  (msgstr)
+]@keyword
+
+(comment) @comment
+(comment (comment_reference (text) @string.special.path))
+(comment (comment_flag (text) @label))
+
+(number) @constant.numeric
+(string) @string
+
+(ERROR) @error
diff --git a/runtime/queries/po/textobjects.scm b/runtime/queries/po/textobjects.scm
new file mode 100644
index 000000000..70abcb149
--- /dev/null
+++ b/runtime/queries/po/textobjects.scm
@@ -0,0 +1,6 @@
+(msgid) @parameter.inside
+
+(comment) @comment.inside
+(comment)+ @comment.around
+
+
diff --git a/runtime/queries/ponylang/highlights.scm b/runtime/queries/ponylang/highlights.scm
new file mode 100644
index 000000000..2d0594a7c
--- /dev/null
+++ b/runtime/queries/ponylang/highlights.scm
@@ -0,0 +1,176 @@
+[
+  (line_comment)
+  (block_comment)
+] @comment
+
+(bool) @constant.builtin.boolean
+(integer) @constant.numeric.integer
+(float) @constant.numeric.float
+(character) @constant.character
+
+;; strings and docstring
+(source_file docstring: (string) @string.special)
+(entity docstring: (string) @string.special)
+(method docstring: (string) @string.special) ; docstring for methods without body
+(behavior docstring: (string) @string.special) ; docstring for methods without body
+(constructor docstring: (string) @string.special) ; docstring for methods without body
+(method body: (block . (string) @string.special)) ; docstring for methods with body
+(behavior body: (block . (string) @string.special))
+(constructor body: (block . (string) @string.special))
+(field docstring: (string) @string.special)
+(string) @string
+
+;; Punctuation
+[
+  "("
+  ")"
+  "{"
+  "}"
+  "["
+  "]"
+] @punctuation.bracket
+[
+  ";"
+  "."
+  ","
+] @punctuation.delimiter
+
+(this) @variable.builtin
+
+(field name: (identifier) @variable.other.member)
+
+"use" @keyword.control.import
+[
+  "for"
+  "in"
+  "while"
+  "do"
+  "repeat"
+  "until"
+] @keyword.control.repeat
+[
+ "if"
+ "ifdef"
+ "iftype"
+ "then"
+ "elseif"
+ "else"
+ "match"
+] @keyword.control.conditional
+[
+  "break"
+  "continue"
+  "return"
+  "error"
+  "compile_error"
+  "compile_intrinsic"
+] @keyword.control.return
+[
+  "recover"
+  "consume"
+  "end"
+  "try"
+  "with"
+] @keyword.control
+
+[
+  "as"
+  "is"
+  "isnt"
+  "not"
+  "and"
+  "or"
+  "xor"
+  "digestof"
+  "addressof"
+  (location)
+] @keyword.operator
+
+(entity_type) @keyword.storage.type
+
+[
+  "var"
+  "let"
+  "embed"
+] @keyword.storage
+
+[
+  "fun"
+  "be"
+  "new"
+] @keyword.function
+
+[
+  (cap)
+  (gencap)
+  "where"
+] @keyword
+
+[
+  (partial)
+  "=>"
+  "~"
+  ".>"
+  "+"
+  "-"
+  "*"
+  "/"
+  "%"
+  "%%"
+  "+~"
+  "-~"
+  "/~"
+  "*~"
+  "%~"
+  "%%~"
+
+  ">>"
+  "<<"
+  ">>~"
+  "<<~"
+
+  "=="
+  "!="
+  ">"
+  "<"
+  ">="
+  "<="
+] @operator
+
+;; Types
+(entity name: (identifier) @type)
+(nominal_type name: (identifier) @type)
+(typeparams (typeparam name: (identifier) @type))
+
+;; constructors / methods / behaviors
+(constructor name: (identifier) @constructor)
+(method name: (identifier) @function.method)
+(behavior name: (identifier) @function.method)
+
+;; method calls
+; TODO: be more specific about what is the actual function reference
+(call callee: (field_access field: (identifier) @function.method))
+(call callee: (_) @function.method)
+(ffi_call name: (_) @function)
+(partial_application function: (identifier) @function.method)
+(chain function: (identifier) @function.method)
+
+;; fields and params
+(field name: (identifier) @variable.other.member)
+(param (identifier) @variable.parameter)
+(lambdaparam (identifier) @variable.parameter)
+
+;; this.field is considered a member access
+(field_access base: (this) field: (identifier) @variable.other.member)
+
+;; annotations
+(annotations (identifier) @attribute)
+
+;; variables
+;; references to upper case things are considered constructors
+(
+  (identifier) @constructor
+  (#match @constructor "^[A-Z]")
+)
+(identifier) @variable
+
diff --git a/runtime/queries/ponylang/indents.scm b/runtime/queries/ponylang/indents.scm
new file mode 100644
index 000000000..ef9c82036
--- /dev/null
+++ b/runtime/queries/ponylang/indents.scm
@@ -0,0 +1,32 @@
+; queries for helix to do automatic indentation upon hitting enter
+; TODO: needs more work, cover more cases
+[
+  (entity)
+  (method)
+  (behavior)
+  (constructor)
+  (block)
+  (tuple)
+  (grouped)
+] @indent
+(match_case body: (block) @indent)
+; ffi_call and call
+(_ arguments: (_) @indent)
+(assignment right: (_) @indent
+ (#set! "scope" "all")
+)
+
+[
+  (params)
+  (object)
+  ("if")
+] @extend
+(lambda params: (_) @extend)
+
+[
+  "end"
+  "}"
+  "]"
+  ")"
+  "|"
+] @outdent
diff --git a/runtime/queries/ponylang/locals.scm b/runtime/queries/ponylang/locals.scm
new file mode 100644
index 000000000..e9efd69e7
--- /dev/null
+++ b/runtime/queries/ponylang/locals.scm
@@ -0,0 +1,37 @@
+[
+  (entity)
+  (method)
+  (behavior)
+  (constructor)
+  ("if")
+  (elseif)
+  (ifdef)
+  (elseifdef)
+  (iftype)
+  (elseiftype)
+  (match)
+  (match_case)
+  ("while")
+  ("repeat")
+  ("for")
+  (lambda)
+  (try_block)
+  (with)
+] @local.scope
+(match else_block: (block) @local.scope)
+(try_block else_block: (block) @local.scope)
+(try_block then_block: (block) @local.scope)
+(with else_block: (block) @local.scope)
+
+(field name: (identifier) @local.definition)
+(local name: (identifier) @local.definition)
+(param name: (identifier) @local.definition)
+(lambdaparam name: (identifier) @local.definition)
+("for" element: (idseq (identifier) @local.definition))
+(withelem name: (idseq (identifier) @local.definition))
+
+; only lower case identifiers are references
+(
+  (identifier) @local.reference
+  (#match? @local.reference "^[a-z_][a-zA-Z_]*")
+)
diff --git a/runtime/queries/ponylang/textobjects.scm b/runtime/queries/ponylang/textobjects.scm
new file mode 100644
index 000000000..0f24583d2
--- /dev/null
+++ b/runtime/queries/ponylang/textobjects.scm
@@ -0,0 +1,64 @@
+;; Queries for helix to select textobjects: https://docs.helix-editor.com/usage.html#textobjects
+;;  function.inside
+;; function.around
+;; class.inside
+;; class.around
+;; test.inside
+;; test.around
+;; parameter.inside
+;; comment.inside
+;; comment.around
+
+;; Queries for navigating using textobjects
+
+[
+  (line_comment)
+  (block_comment)
+] @comment.inside
+
+(line_comment)+ @comment.around
+(block_comment) @comment.around
+
+(entity members: (members)? @class.inside) @class.around
+(object members: (members)? @class.inside) @class.around
+
+(method
+  body: (block)? @function.inside
+) @function.around
+(behavior
+  body: (block)? @function.inside
+) @function.around
+(constructor
+  body: (block)? @function.inside
+) @function.around
+(lambda
+  body: (block)? @function.inside
+) @function.outside
+
+(params
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around
+)
+(lambda
+  params: ((_) @parameter.inside . ","? @parameter.around) @parameter.around
+)
+(typeargs
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around
+)
+(typeparams
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around
+)
+(arguments
+  positional: (positional_args
+                ((_) @parameter.inside . ","? @parameter.around)? @parameter.around)
+  ; TODO: get named args right
+  named: (named_args ((_) @parameter.inside . ","? @parameter.around)? @parameter.around)
+)
+
+(
+  (entity
+    provides: (type (nominal_type name: (identifier) @_provides))
+    members: (members) @test.inside
+  ) @test.outside
+  (#eq? @_provides "UnitTest")
+)
+
diff --git a/runtime/queries/prisma/highlights.scm b/runtime/queries/prisma/highlights.scm
index b5c0c4ae3..dfd5292d0 100644
--- a/runtime/queries/prisma/highlights.scm
+++ b/runtime/queries/prisma/highlights.scm
@@ -8,6 +8,7 @@
 
 (arguments) @variable.other.member
 (model_declaration (identifier) @type)
+(view_declaration (identifier) @type)
 
 [
  "datasource"
@@ -15,6 +16,7 @@
  "generator"
  "model"
  "type"
+ "view"
 ] @keyword
 
 [
diff --git a/runtime/queries/prql/highlights.scm b/runtime/queries/prql/highlights.scm
new file mode 100644
index 000000000..5cfedee48
--- /dev/null
+++ b/runtime/queries/prql/highlights.scm
@@ -0,0 +1,136 @@
+[
+  (keyword_from)
+  (keyword_filter)
+  (keyword_derive)
+  (keyword_group)
+  (keyword_aggregate)
+  (keyword_sort)
+  (keyword_take)
+  (keyword_window)
+  (keyword_join)
+  (keyword_select)
+  (keyword_switch)
+  (keyword_append)
+  (keyword_remove)
+  (keyword_intersect)
+  (keyword_rolling)
+  (keyword_rows)
+  (keyword_expanding)
+  (keyword_let)
+  (keyword_prql)
+  (keyword_from_text)
+] @keyword
+
+(literal) @string
+
+(assignment
+  alias: (field) @variable.other.member)
+
+alias: (identifier) @variable.other.member
+
+(f_string) @string.special
+(s_string) @string.special
+
+(comment) @comment
+
+(keyword_func) @keyword.function
+
+(function_call
+  (identifier) @function)
+
+[
+  "+"
+  "-"
+  "*"
+  "/"
+  "="
+  "=="
+  "<"
+  "<="
+  "!="
+  ">="
+  ">"
+  "->"
+  (bang)
+] @operator
+
+[
+  "("
+  ")"
+  "["
+  "]"
+] @punctuation.bracket
+
+[
+  ","
+  "."
+  (pipe)
+] @punctuation.delimiter
+
+(literal
+  (integer) @constant.numeric.integer)
+
+(integer) @constant.numeric.integer
+
+(literal
+  (decimal_number) @constant.numeric.float)
+
+(decimal_number) @constant.numeric.float
+
+[
+  (keyword_min)
+  (keyword_max)
+  (keyword_count)
+  (keyword_count_distinct)
+  (keyword_average)
+  (keyword_avg)
+  (keyword_sum)
+  (keyword_stddev)
+  (keyword_count)
+] @function
+
+[
+ (keyword_side)
+ (keyword_version)
+ (keyword_target)
+ (keyword_null)
+ (keyword_format)
+] @attribute
+
+(target) @function.builtin
+
+ [
+  (date)
+  (time)
+  (timestamp)
+] @string.special
+
+[
+  (keyword_left)
+  (keyword_inner)
+  (keyword_right)
+  (keyword_full)
+  (keyword_csv)
+  (keyword_json)
+] @function.method
+
+[
+  (keyword_true)
+  (keyword_false)
+] @constant.builtin.boolean
+
+[
+ (keyword_and)
+ (keyword_or)
+] @keyword.operator
+
+(function_definition
+  (keyword_func)
+  name: (identifier) @function)
+
+(parameter
+  (identifier) @variable.parameter)
+
+(variable
+  (keyword_let)
+  name: (identifier) @constant)
diff --git a/runtime/queries/prql/injections.scm b/runtime/queries/prql/injections.scm
new file mode 100644
index 000000000..02a8919f8
--- /dev/null
+++ b/runtime/queries/prql/injections.scm
@@ -0,0 +1,8 @@
+((s_string) @injection.content
+ (#set! injection.language "sql"))
+
+(from_text
+  (keyword_from_text)
+  (keyword_json)
+  (literal) @injection.content
+  (#set! injection.language "json"))
diff --git a/runtime/queries/python/indents.scm b/runtime/queries/python/indents.scm
index 743971adb..835b40d39 100644
--- a/runtime/queries/python/indents.scm
+++ b/runtime/queries/python/indents.scm
@@ -29,6 +29,19 @@
   (class_definition)
 ] @indent
 
+; Workaround for the tree-sitter grammar creating large errors when a
+; try_statement is missing the except/finally clause
+(ERROR
+  "try"
+  .
+  ":" @indent @extend)
+(ERROR
+  .
+  "def") @indent @extend
+(ERROR
+  (block) @indent @extend
+  (#set! "scope" "all"))
+
 [
   (if_statement)
   (for_statement)
diff --git a/runtime/queries/rego/highlights.scm b/runtime/queries/rego/highlights.scm
new file mode 100644
index 000000000..0ff6de552
--- /dev/null
+++ b/runtime/queries/rego/highlights.scm
@@ -0,0 +1,68 @@
+[
+  (import)
+] @keyword.control.import
+
+[
+  (package)
+] @namespace
+
+[
+  (with)
+  (as)
+  (every)
+  (some)
+  (in)
+  (default)
+  "null"
+] @keyword.control
+
+[
+  (not)
+  (if)
+  (contains)
+  (else)
+] @keyword.control.conditional
+
+[
+  (boolean)
+] @constant.builtin.boolean
+
+[
+  (assignment_operator)
+  (bool_operator)
+  (arith_operator)
+  (bin_operator)
+] @operator
+
+[
+  (string)
+  (raw_string)
+] @string
+
+(term (ref (var))) @variable
+
+(comment) @comment.line
+
+(number) @constant.numeric.integer
+
+(expr_call func_name: (fn_name (var) @function .))
+
+(expr_call func_arguments: (fn_args (expr) @variable.parameter))
+
+(rule_args (term) @variable.parameter)
+
+[
+  (open_paren)
+  (close_paren)
+  (open_bracket)
+  (close_bracket)
+  (open_curly)
+  (close_curly)
+] @punctuation.bracket
+
+(rule (rule_head (var) @function.method))
+
+(rule
+  (rule_head (term (ref (var) @namespace)))
+  (rule_body (query (literal (expr (expr_infix (expr (term (ref (var)) @_output)))))) (#eq? @_output @namespace))
+)
diff --git a/runtime/queries/rego/injections.scm b/runtime/queries/rego/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/rego/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/robot/highlights.scm b/runtime/queries/robot/highlights.scm
new file mode 100644
index 000000000..60f416b7b
--- /dev/null
+++ b/runtime/queries/robot/highlights.scm
@@ -0,0 +1,21 @@
+(comment) @comment
+(ellipses) @punctuation.delimiter
+
+(section_header) @keyword
+(extra_text) @comment
+
+(setting_statement) @keyword
+
+(variable_definition (variable_name) @variable)
+
+(keyword_definition (name) @function)
+(keyword_definition (body (keyword_setting) @keyword))
+
+(test_case_definition (name) @property)
+
+(keyword_invocation (keyword) @function)
+
+(argument (text_chunk) @string)
+(argument (scalar_variable) @string.special)
+(argument (list_variable) @string.special)
+(argument (dictionary_variable) @string.special)
diff --git a/runtime/queries/rst/highlights.scm b/runtime/queries/rst/highlights.scm
new file mode 100644
index 000000000..73c0def43
--- /dev/null
+++ b/runtime/queries/rst/highlights.scm
@@ -0,0 +1,38 @@
+(comment) @comment
+
+[
+  (title)
+] @markup.heading.1
+
+[
+  "adornment"
+] @markup.heading.marker
+
+[
+  (target)
+  (reference)
+] @markup.link.url
+
+[
+  "bullet"
+] @markup.list.unnumbered
+
+(strong) @markup.bold
+(emphasis) @markup.italic
+(literal) @markup.raw.inline
+
+(list_item
+  (term) @markup.bold
+  (classifier)? @markup.italic)
+
+(directive
+  [".." (type) "::"] @function
+)
+
+(field
+  [":" (field_name) ":"] @variable.other.member
+)
+
+(interpreted_text) @markup.raw.inline
+
+(interpreted_text (role)) @keyword
diff --git a/runtime/queries/ruby/highlights.scm b/runtime/queries/ruby/highlights.scm
index 898f8f794..7c69276ba 100644
--- a/runtime/queries/ruby/highlights.scm
+++ b/runtime/queries/ruby/highlights.scm
@@ -1,44 +1,67 @@
 ; Keywords
 
 [
+  "BEGIN"
+  "END"
   "alias"
-  "and"
   "begin"
-  "break"
-  "case"
   "class"
-  "def"
   "do"
-  "else"
-  "elsif"
   "end"
-  "ensure"
-  "for"
-  "if"
-  "in"
   "module"
-  "next"
-  "or"
+  "in"
   "rescue"
-  "retry"
-  "return"
-  "then"
-  "unless"
-  "until"
+  "ensure"
+] @keyword
+
+[
+  "if"
+  "else"
+  "elsif"
   "when"
+  "case"
+  "unless"
+  "then"
+] @keyword.control.conditional
+
+[
+  "for"
   "while"
+  "retry"
+  "until"
+  "redo"
+] @keyword.control.repeat
+
+[
   "yield"
-] @keyword
+  "return"
+  "next"
+  "break"
+] @keyword.control.return
+
+[
+  "def"
+  "undef"
+] @keyword.function
+
+((identifier) @keyword.control.import
+ (#match? @keyword.control.import "^(require|require_relative|load|autoload)$"))
+
+[
+  "or"
+  "and"
+  "not"
+] @keyword.operator
 
-((identifier) @keyword
- (#match? @keyword "^(private|protected|public)$"))
+((identifier) @keyword.control.exception
+ (#match? @keyword.control.exception "^(raise|fail)$"))
 
 ; Function calls
 
-((identifier) @function.method.builtin
- (#eq? @function.method.builtin "require"))
+((identifier) @function.builtin
+ (#match? @function.builtin "^(attr|attr_accessor|attr_reader|attr_writer|include|prepend|refine|private|protected|public)$"))
 
-"defined?" @function.method.builtin
+"defined?" @function.builtin
 
 (call
   method: [(identifier) (constant)] @function.method)
@@ -58,7 +81,10 @@
 ] @variable.other.member
 
 ((identifier) @constant.builtin
- (#match? @constant.builtin "^__(FILE|LINE|ENCODING)__$"))
+ (#match? @constant.builtin "^(__FILE__|__LINE__|__ENCODING__)$"))
+
+((constant) @constant.builtin
+ (#match? @constant.builtin "^(ENV|ARGV|ARGF|RUBY_PLATFORM|RUBY_RELEASE_DATE|RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING)$"))
 
 ((constant) @constant
  (#match? @constant "^[A-Z\\d_]+$"))
@@ -66,22 +92,23 @@
 (constant) @constructor
 
 (self) @variable.builtin
-(super) @variable.builtin
+(super) @function.builtin
 
+[(forward_parameter)(forward_argument)] @variable.parameter
+(keyword_parameter name:((_)":" @variable.parameter) @variable.parameter)
+(optional_parameter name:((_)"=" @operator) @variable.parameter)
+(optional_parameter name: (identifier) @variable.parameter)
+(splat_parameter name: (identifier) @variable.parameter) @variable.parameter
+(hash_splat_parameter name: (identifier) @variable.parameter) @variable.parameter
+(method_parameters (identifier) @variable.parameter)
 (block_parameter (identifier) @variable.parameter)
 (block_parameters (identifier) @variable.parameter)
-(destructured_parameter (identifier) @variable.parameter)
-(hash_splat_parameter (identifier) @variable.parameter)
-(lambda_parameters (identifier) @variable.parameter)
-(method_parameters (identifier) @variable.parameter)
-(splat_parameter (identifier) @variable.parameter)
-
-(keyword_parameter name: (identifier) @variable.parameter)
-(optional_parameter name: (identifier) @variable.parameter)
 
 ((identifier) @function.method
  (#is-not? local))
-(identifier) @variable
+[
+  (identifier)
+] @variable
 
 ; Literals
 
@@ -96,10 +123,11 @@
 [
   (simple_symbol)
   (delimited_symbol)
-  (hash_key_symbol)
   (bare_symbol)
 ] @string.special.symbol
 
+(pair key: ((_)":" @string.special.symbol) @string.special.symbol)
+
 (regex) @string.regexp
 (escape_sequence) @constant.character.escape
 
@@ -112,7 +140,7 @@
   (nil)
   (true)
   (false)
-]@constant.builtin
+] @constant.builtin
 
 (interpolation
   "#{" @punctuation.special
@@ -121,20 +149,36 @@
 (comment) @comment
 
 ; Operators
-
 [
-"="
+":"
+"?"
+"~"
 "=>"
 "->"
+"!"
 ] @operator
 
+(assignment
+  "=" @operator)
+
+(operator_assignment
+  operator: ["+=" "-=" "*=" "**=" "/=" "||=" "|=" "&&=" "&=" "%=" ">>=" "<<=" "^="] @operator)
+
+(binary
+  operator: ["/" "|" "==" "===" "||" "&&" ">>" "<<" "<" ">" "<=" ">=" "&" "^" "!~" "=~" "<=>" "**" "*" "!=" "%" "-" "+"] @operator)
+
+(range
+  operator: [".." "..."] @operator)
+
 [
   ","
   ";"
   "."
+  "&."
 ] @punctuation.delimiter
 
 [
+  "|"
   "("
   ")"
   "["
diff --git a/runtime/queries/ruby/injections.scm b/runtime/queries/ruby/injections.scm
index 321c90add..1a865df19 100644
--- a/runtime/queries/ruby/injections.scm
+++ b/runtime/queries/ruby/injections.scm
@@ -1,2 +1,8 @@
 ((comment) @injection.content
  (#set! injection.language "comment"))
+
+((heredoc_body 
+  (heredoc_content) @injection.content
+  (heredoc_end) @name
+  (#set! injection.language "sql")) 
+ (#eq? @name "SQL"))
diff --git a/runtime/queries/rust/highlights.scm b/runtime/queries/rust/highlights.scm
index d3c292708..bf2fde499 100644
--- a/runtime/queries/rust/highlights.scm
+++ b/runtime/queries/rust/highlights.scm
@@ -45,7 +45,8 @@
   "'" @label
   (identifier) @label)
 (loop_label
-  (identifier) @type)
+  "'" @label
+  (identifier) @label)
 
 ; ---
 ; Punctuation
@@ -102,8 +103,6 @@
 (closure_parameters
 	(identifier) @variable.parameter)
 
-
-
 ; -------
 ; Keywords
 ; -------
@@ -129,9 +128,7 @@
 [
   "break"
   "continue"
-
   "return"
-
   "await"
 ] @keyword.control.return
 
@@ -154,10 +151,7 @@
   "trait"
   "for"
 
-  "unsafe"
   "default"
-  "macro_rules!"
-
   "async"
 ] @keyword
 
@@ -165,13 +159,13 @@
   "struct"
   "enum"
   "union"
-
   "type"
 ] @keyword.storage.type
 
 "let" @keyword.storage
-
 "fn" @keyword.function
+"unsafe" @keyword.special
+"macro_rules!" @function.macro
 
 (mutable_specifier) @keyword.storage.modifier.mut
 
@@ -202,11 +196,11 @@
 
 (call_expression
   function: [
-    ((identifier) @type.variant
-      (#match? @type.variant "^[A-Z]"))
+    ((identifier) @type.enum.variant
+      (#match? @type.enum.variant "^[A-Z]"))
     (scoped_identifier
-      name: ((identifier) @type.variant
-        (#match? @type.variant "^[A-Z]")))
+      name: ((identifier) @type.enum.variant
+        (#match? @type.enum.variant "^[A-Z]")))
   ])
 
 ; ---
@@ -237,16 +231,6 @@
 ((identifier) @type
   (#match? @type "^[A-Z]"))
 
-
-
-(attribute
-  (identifier) @_macro
-  arguments: (token_tree (identifier) @constant.numeric.integer)
-  (#eq? @_macro "derive")
-)
-@special
-
-
 ; -------
 ; Functions
 ; -------
@@ -278,6 +262,12 @@
 ; Macros
 ; ---
 
+(attribute
+  (identifier) @special
+  arguments: (token_tree (identifier) @type)
+  (#eq? @special "derive")
+)
+
 (attribute
   (identifier) @function.macro)
 (attribute
@@ -303,8 +293,6 @@
 (metavariable) @variable.parameter
 (fragment_specifier) @type
 
-
-
 ; -------
 ; Operators
 ; -------
@@ -350,8 +338,6 @@
   "'"
 ] @operator
 
-
-
 ; -------
 ; Paths
 ; -------
@@ -382,8 +368,6 @@
 (scoped_type_identifier
   path: (identifier) @namespace)
 
-
-
 ; -------
 ; Remaining Identifiers
 ; -------
diff --git a/runtime/queries/rust/injections.scm b/runtime/queries/rust/injections.scm
index 704d84947..d191a53ad 100644
--- a/runtime/queries/rust/injections.scm
+++ b/runtime/queries/rust/injections.scm
@@ -51,3 +51,30 @@
     [(string_literal) (raw_string_literal)] @injection.content
   )
   (#set! injection.language "sql"))
+
+; Highlight SQL in `sqlx::query_unchecked!()`
+(macro_invocation
+  macro: (scoped_identifier
+    path: (identifier) @_sqlx (#eq? @_sqlx "sqlx")
+    name: (identifier) @_query_as (#eq? @_query_as "query_unchecked"))
+  (token_tree
+    ; Only the first argument is SQL
+    .
+    [(string_literal) (raw_string_literal)] @injection.content
+  )
+  (#set! injection.language "sql"))
+
+; Highlight SQL in `sqlx::query_as_unchecked!()`
+(macro_invocation
+  macro: (scoped_identifier
+    path: (identifier) @_sqlx (#eq? @_sqlx "sqlx")
+    name: (identifier) @_query_as (#eq? @_query_as "query_as_unchecked"))
+  (token_tree
+    ; Only the second argument is SQL
+    .
+    ; Allow anything as the first argument in case the user has lower case type
+    ; names for some reason
+    (_)
+    [(string_literal) (raw_string_literal)] @injection.content
+  )
+  (#set! injection.language "sql"))
diff --git a/runtime/queries/sage/highlights.scm b/runtime/queries/sage/highlights.scm
new file mode 100644
index 000000000..0b920cbf9
--- /dev/null
+++ b/runtime/queries/sage/highlights.scm
@@ -0,0 +1 @@
+; inherits: python
diff --git a/runtime/queries/sage/injections.scm b/runtime/queries/sage/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/sage/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/sage/textobjects.scm b/runtime/queries/sage/textobjects.scm
new file mode 100644
index 000000000..0b920cbf9
--- /dev/null
+++ b/runtime/queries/sage/textobjects.scm
@@ -0,0 +1 @@
+; inherits: python
diff --git a/runtime/queries/scala/highlights.scm b/runtime/queries/scala/highlights.scm
index 50a6e18a6..67603fdda 100644
--- a/runtime/queries/scala/highlights.scm
+++ b/runtime/queries/scala/highlights.scm
@@ -33,6 +33,26 @@
 (type_definition
   name: (type_identifier) @type)
 
+(full_enum_case
+  name: (identifier) @type)
+
+(simple_enum_case
+  name: (identifier) @type)
+
+;; val/var definitions/declarations
+
+(val_definition
+  pattern: (identifier) @variable)
+
+(var_definition
+  pattern: (identifier) @variable)
+
+(val_declaration
+  name: (identifier) @variable)
+
+(var_declaration
+  name: (identifier) @variable)
+
 ; method definition
 
 (class_definition
@@ -48,7 +68,7 @@
     (function_definition
       name: (identifier) @function.method)))
 
-; imports
+; imports/exports
 
 (import_declaration
   path: (identifier) @namespace)
@@ -58,7 +78,15 @@
   path: (identifier) @type) (#match? @type "^[A-Z]"))
 ((stable_identifier (identifier) @type) (#match? @type "^[A-Z]"))
 
-((import_selectors (identifier) @type) (#match? @type "^[A-Z]"))
+(export_declaration
+  path: (identifier) @namespace)
+((stable_identifier (identifier) @namespace))
+
+((export_declaration
+  path: (identifier) @type) (#match? @type "^[A-Z]"))
+((stable_identifier (identifier) @type) (#match? @type "^[A-Z]"))
+
+((namespace_selectors (identifier) @type) (#match? @type "^[A-Z]"))
 
 ; method invocation
 
@@ -66,10 +94,17 @@
 (call_expression
   function: (identifier) @function)
 
+(call_expression
+  function: (operator_identifier) @function)
+
 (call_expression
   function: (field_expression
     field: (identifier) @function.method))
 
+(call_expression
+  function: (field_expression
+    field: (operator_identifier) @function.method))
+
 ((call_expression
    function: (identifier) @variable.other.member)
  (#match? @variable.other.member "^[A-Z]"))
@@ -77,6 +112,9 @@
 (generic_function
   function: (identifier) @function)
 
+(interpolated_string_expression
+  interpolator: (identifier) @function)
+
 (
   (identifier) @function.builtin
   (#match? @function.builtin "^super$")
@@ -87,9 +125,15 @@
 (function_definition
   name: (identifier) @function)
 
+(function_definition
+  name: (operator_identifier) @function)
+
 (parameter
   name: (identifier) @variable.parameter)
 
+(binding
+  name: (identifier) @variable.parameter)
+
 ; expressions
 
 
@@ -109,7 +153,7 @@
 
 
 (symbol_literal) @string.special.symbol
- 
+
 [
 (string)
 (character_literal)
@@ -118,29 +162,50 @@
 
 (interpolation "$" @punctuation.special)
 
+; annotations
+
+(annotation) @attribute
+
 ;; keywords
 
+;; storage in TextMate scope lingo means field or type
 [
+  (opaque_modifier)
+  (infix_modifier)
+  (transparent_modifier)
+  (open_modifier)
   "abstract"
-  "case"
-  "class"
-  "extends"
   "final"
-  "finally"
-;; `forSome` existential types not implemented yet
   "implicit"
   "lazy"
-;; `macro` not implemented yet
-  "object"
   "override"
-  "package"
   "private"
   "protected"
   "sealed"
+] @keyword.storage.modifier
+
+[
+  "class"
+  "enum"
+  "extension"
+  "given"
+  "object"
+  "package"
   "trait"
   "type"
   "val"
   "var"
+] @keyword.storage.type
+
+[
+  "as"
+  "derives"
+  "end"
+  "extends"
+;; `forSome` existential types not implemented yet
+;; `macro` not implemented yet
+;; `throws`
+  "using"
   "with"
 ] @keyword
 
@@ -152,33 +217,36 @@
 "new" @keyword.operator
 
 [
- "else"
- "if"
- "match"
- "try"
- "catch"
- "throw"
+  "case"
+  "catch"
+  "else"
+  "finally"
+  "if"
+  "match"
+  "then"
+  "throw"
+  "try"
 ] @keyword.control.conditional
 
 [
- "("
- ")"
- "["
- "]"
- "{"
- "}"
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
 ] @punctuation.bracket
 
 [
- "."
- ","
+  "."
+  ","
 ] @punctuation.delimiter
 
 [
- "do"
- "for"
- "while"
- "yield"
+  "do"
+  "for"
+  "while"
+  "yield"
 ] @keyword.control.repeat
 
 "def" @keyword.function
@@ -191,6 +259,8 @@
 
 "import" @keyword.control.import
 
+"export" @keyword.control.import
+
 "return" @keyword.control.return
 
 (comment) @comment
@@ -200,4 +270,6 @@
 (case_block
   (case_clause ("case") @keyword.control.conditional))
 
-(identifier) @variable
\ No newline at end of file
+(identifier) @variable
+
+(operator_identifier) @operator
diff --git a/runtime/queries/smithy/highlights.scm b/runtime/queries/smithy/highlights.scm
new file mode 100644
index 000000000..269e96094
--- /dev/null
+++ b/runtime/queries/smithy/highlights.scm
@@ -0,0 +1,102 @@
+; Queries are taken from: https://github.com/indoorvivants/tree-sitter-smithy/blob/main/queries/highlights.scm
+; Preproc
+(control_key) @keyword.directive
+
+; Namespace
+(namespace) @namespace
+
+; Includes
+[
+  "use"
+] @keyword.control.import
+
+; Builtins
+(primitive) @type.builtin
+[
+  "enum"
+  "intEnum"
+  "list"
+  "map"
+  "set"
+] @type.builtin
+
+; Fields (Members)
+; (field) @variable.other.member
+
+(key_identifier) @variable.other.member
+(shape_member
+  (field) @variable.other.member)
+(operation_field) @variable.other.member
+(operation_error_field) @variable.other.member
+
+; Constants
+(enum_member
+  (enum_field) @type.enum)
+
+; Types
+(identifier) @type
+(structure_resource
+  (shape_id) @type)
+
+; Attributes
+(mixins
+  (shape_id) @attribute)
+(trait_statement
+  (shape_id) @attribute)
+
+; Operators
+[
+  "@"
+  "-"
+  "="
+  ":="
+] @operator
+
+; Keywords
+[
+  "namespace"
+  "service"
+  "structure"
+  "operation"
+  "union"
+  "resource"
+  "metadata"
+  "apply"
+  "for"
+  "with"
+] @keyword
+
+; Literals
+(string) @string
+(escape_sequence) @constant.character.escape
+
+(number) @constant.numeric
+
+(float) @constant.numeric.float
+
+(boolean) @constant.builtin.boolean
+
+(null) @constant.builtin
+
+; Misc
+[
+  "$"
+  "#"
+] @punctuation.special
+
+["{" "}"] @punctuation.bracket
+
+["(" ")"] @punctuation.bracket
+
+["[" "]"] @punctuation.bracket
+
+[
+  ":"
+  "."
+] @punctuation.delimiter
+
+; Comments
+[
+  (comment)
+  (documentation_comment)
+] @comment
diff --git a/runtime/queries/sql/highlights.scm b/runtime/queries/sql/highlights.scm
index ece8be333..f15a92e7e 100644
--- a/runtime/queries/sql/highlights.scm
+++ b/runtime/queries/sql/highlights.scm
@@ -1,19 +1,17 @@
-(keyword_gist) @function.builtin
-(keyword_btree) @function.builtin
-(keyword_btree) @function.builtin
-(keyword_hash) @function.builtin
-(keyword_spgist) @function.builtin
-(keyword_gin) @function.builtin
-(keyword_brin) @function.builtin
-(keyword_float) @function.builtin
-
-(invocation
-  name: (identifier) @function.builtin
-  parameter: [(field)]? @variable.other.member)
-  
-(count
-  name: (identifier) @function.builtin
-  parameter: [(field)]? @variable.other.member)
+
+[
+  (keyword_btree)
+  (keyword_hash)
+  (keyword_gist)
+  (keyword_spgist)
+  (keyword_gin)
+  (keyword_brin)
+
+  (cast)
+  (count)
+  (group_concat)
+  (invocation)
+] @function.builtin
   
 (table_reference
   name: (identifier) @namespace)
@@ -28,7 +26,6 @@
   table_alias: (identifier) @variable.parameter
   name: (identifier) @variable.other.member)
 
-
 (comment) @comment
 
 [
@@ -42,21 +39,13 @@
   "."
 ] @punctuation.delimiter
 
-[
-  "*"
-  "+"
-  "-"
-  "/"
-  "%"
-  "^"
-  "||"  
-  "="
-  "<"
-  "<="
-  "!="
-  ">="
-  ">"
-] @operator
+(binary_expression
+  operator: _ @operator)
+
+(unary_expression
+  operator: _ @operator)
+
+(all_fields) @special
 
 [
   (keyword_null)
@@ -64,10 +53,10 @@
   (keyword_false)
 ] @constant.builtin
 
-(literal) @string
-
 ((literal) @constant.numeric
-  (#match? @constant.numeric "^(-?\d*\.?\d*)$"))
+  (#match? @constant.numeric "^-?\\d*\\.?\\d*$"))
+
+(literal) @string
 
 [
   (keyword_select)
@@ -100,6 +89,8 @@
   (keyword_primary)
   (keyword_create)
   (keyword_alter)
+  (keyword_change)
+  (keyword_modify)
   (keyword_drop)
   (keyword_add)
   (keyword_table)
@@ -110,12 +101,16 @@
   (keyword_as)
   (keyword_distinct)
   (keyword_constraint)
+  ; (keyword_cast)
   ; (keyword_count)
+  ; (keyword_group_concat)
+  (keyword_separator)
   (keyword_max)
   (keyword_min)
   (keyword_avg)
   (keyword_end)
   (keyword_force)
+  (keyword_ignore)
   (keyword_using)
   (keyword_use)
   (keyword_index)
@@ -123,10 +118,12 @@
   (keyword_if)
   (keyword_exists)
   (keyword_auto_increment)
+  (keyword_collate)
+  (keyword_character)
+  (keyword_engine)
   (keyword_default)
   (keyword_cascade)
-  (keyword_between)
-  (keyword_window)
+  (keyword_restrict)
   (keyword_with)
   (keyword_no)
   (keyword_data)
@@ -137,6 +134,7 @@
   (keyword_owner)
   (keyword_temp)
   (keyword_temporary)
+  (keyword_unlogged)
   (keyword_union)
   (keyword_all)
   (keyword_except)
@@ -146,6 +144,67 @@
   (keyword_commit)
   (keyword_rollback)
   (keyword_transaction)
+  (keyword_over)
+  (keyword_nulls)
+  (keyword_first)
+  (keyword_after)
+  (keyword_last)
+  (keyword_window)
+  (keyword_range)
+  (keyword_rows)
+  (keyword_groups)
+  (keyword_between)
+  (keyword_unbounded)
+  (keyword_preceding)
+  (keyword_following)
+  (keyword_exclude)
+  (keyword_current)
+  (keyword_row)
+  (keyword_ties)
+  (keyword_others)
+  (keyword_only)
+  (keyword_unique)
+  (keyword_concurrently)
+  ; (keyword_btree)
+  ; (keyword_hash)
+  ; (keyword_gist)
+  ; (keyword_spgist)
+  ; (keyword_gin)
+  ; (keyword_brin)
+  (keyword_like)
+  (keyword_similar)
+  (keyword_preserve)
+  (keyword_unsigned)
+  (keyword_zerofill)
+
+  (keyword_external)
+  (keyword_stored)
+  (keyword_cached)
+  (keyword_uncached)
+  (keyword_replication)
+  (keyword_tblproperties)
+  (keyword_compute)
+  (keyword_stats)
+  (keyword_location)
+  (keyword_partitioned)
+  (keyword_comment)
+  (keyword_sort)
+  (keyword_format)
+  (keyword_delimited)
+  (keyword_fields)
+  (keyword_terminated)
+  (keyword_escaped)
+  (keyword_lines)
+
+  (keyword_parquet)
+  (keyword_rcfile)
+  (keyword_csv)
+  (keyword_textfile)
+  (keyword_avro)
+  (keyword_sequencefile)
+  (keyword_orc)
+  (keyword_avro)
+  (keyword_jsonfile)
 ] @keyword
 
 [
@@ -165,17 +224,21 @@
 
 [
   (keyword_boolean)
+
   (keyword_smallserial)
   (keyword_serial)
   (keyword_bigserial)
-  (keyword_smallint)
-  (keyword_int)
 
+  (tinyint)
+  (smallint)
+  (mediumint)
+  (int)
   (bigint)
   (decimal)
   (numeric)
   (keyword_real)
   (double)
+  (float)
 
   (keyword_money)
 
@@ -196,8 +259,21 @@
   (keyword_timestamp)
   (keyword_timestamptz)
 
+  (keyword_interval)
+
   (keyword_geometry)
   (keyword_geography)
   (keyword_box2d)
   (keyword_box3d)
+
+  (char)
+  (varchar)
+  (numeric)
+
+  (keyword_oid)
+  (keyword_name)
+  (keyword_regclass)
+  (keyword_regnamespace)
+  (keyword_regproc)
+  (keyword_regtype)
 ] @type.builtin
diff --git a/runtime/queries/sway/highlights.scm b/runtime/queries/sway/highlights.scm
new file mode 100644
index 000000000..98f4d4493
--- /dev/null
+++ b/runtime/queries/sway/highlights.scm
@@ -0,0 +1,336 @@
+; -------
+; Tree-Sitter doesn't allow overrides in regards to captures,
+; though it is possible to affect the child node of a captured
+; node. Thus, the approach here is to flip the order so that
+; overrides are unnecessary.
+; -------
+
+; -------
+; Types
+; -------
+
+; ---
+; Primitives
+; ---
+
+(escape_sequence) @constant.character.escape
+(primitive_type) @type.builtin
+(boolean_literal) @constant.builtin.boolean
+(integer_literal) @constant.numeric.integer
+(float_literal) @constant.numeric.float
+(char_literal) @constant.character
+[
+  (string_literal)
+  (raw_string_literal)
+] @string
+[
+  (line_comment)
+  (block_comment)
+] @comment
+
+; ---
+; Extraneous
+; ---
+
+(self) @variable.builtin
+(enum_variant (identifier) @type.enum.variant)
+
+(field_initializer
+  (field_identifier) @variable.other.member)
+(shorthand_field_initializer
+  (identifier) @variable.other.member)
+(shorthand_field_identifier) @variable.other.member
+
+(loop_label
+  "'" @label
+  (identifier) @label)
+
+; ---
+; Punctuation
+; ---
+
+[
+  "::"
+  "."
+  ";"
+  ","
+] @punctuation.delimiter
+
+[
+  "("
+  ")"
+  "["
+  "]"
+  "{"
+  "}"
+  "#"
+] @punctuation.bracket
+(type_arguments
+  [
+    "<"
+    ">"
+  ] @punctuation.bracket)
+(type_parameters
+  [
+    "<"
+    ">"
+  ] @punctuation.bracket)
+(closure_parameters
+  "|" @punctuation.bracket)
+
+; ---
+; Variables
+; ---
+
+(let_declaration
+  pattern: [
+    ((identifier) @variable)
+    ((tuple_pattern
+      (identifier) @variable))
+  ])
+  
+; It needs to be anonymous to not conflict with `call_expression` further below. 
+(_
+ value: (field_expression
+  value: (identifier)? @variable
+  field: (field_identifier) @variable.other.member))
+
+(parameter
+	pattern: (identifier) @variable.parameter)
+(closure_parameters
+	(identifier) @variable.parameter)
+
+; -------
+; Keywords
+; -------
+
+(for_expression
+  "for" @keyword.control.repeat)
+((identifier) @keyword.control
+  (#match? @keyword.control "^yield$"))
+
+"in" @keyword.control
+
+[
+  "match"
+  "if"
+  "else"
+] @keyword.control.conditional
+
+[
+  "while"
+] @keyword.control.repeat
+
+[
+  "break"
+  "continue"
+  "return"
+] @keyword.control.return
+
+[
+  "contract"
+  "script"
+  "predicate"
+] @keyword.other
+
+"use" @keyword.control.import
+(dep_item "dep" @keyword.control.import !body)
+(use_as_clause "as" @keyword.control.import)
+
+(type_cast_expression "as" @keyword.operator)
+
+[
+  "as"
+  "pub"
+  "dep"
+
+  "abi"
+  "impl"
+  "where"
+  "trait"
+  "for"
+] @keyword
+
+[
+  "struct"
+  "enum"
+  "storage"
+  "configurable"
+] @keyword.storage.type
+
+"let" @keyword.storage
+"fn" @keyword.function
+"abi" @keyword.function
+
+(mutable_specifier) @keyword.storage.modifier.mut
+
+(reference_type "&" @keyword.storage.modifier.ref)
+(self_parameter "&" @keyword.storage.modifier.ref)
+
+[
+  "const"
+  "ref"
+  "deref"
+  "move"
+] @keyword.storage.modifier
+
+; TODO: variable.mut to highlight mutable identifiers via locals.scm
+
+; -------
+; Guess Other Types
+; -------
+
+((identifier) @constant
+ (#match? @constant "^[A-Z][A-Z\\d_]*$"))
+
+; ---
+; PascalCase identifiers in call_expressions (e.g. `Ok()`)
+; are assumed to be enum constructors.
+; ---
+
+(call_expression
+  function: [
+    ((identifier) @type.enum.variant
+      (#match? @type.enum.variant "^[A-Z]"))
+    (scoped_identifier
+      name: ((identifier) @type.enum.variant
+        (#match? @type.enum.variant "^[A-Z]")))
+  ])
+
+; ---
+; Assume that types in match arms are enums and not
+; tuple structs. Same for `if let` expressions.
+; ---
+
+(match_pattern
+    (scoped_identifier
+      name: (identifier) @constructor))
+(tuple_struct_pattern
+    type: [
+      ((identifier) @constructor)
+      (scoped_identifier  
+        name: (identifier) @constructor)
+      ])
+(struct_pattern
+  type: [
+    ((type_identifier) @constructor)
+    (scoped_type_identifier
+      name: (type_identifier) @constructor)
+    ])
+
+; ---
+; Other PascalCase identifiers are assumed to be structs.
+; ---
+
+((identifier) @type
+  (#match? @type "^[A-Z]"))
+
+; -------
+; Functions
+; -------
+
+(call_expression
+  function: [
+    ((identifier) @function)
+    (scoped_identifier
+      name: (identifier) @function)
+    (field_expression
+      field: (field_identifier) @function)
+  ])
+(generic_function
+  function: [
+    ((identifier) @function)
+    (scoped_identifier
+      name: (identifier) @function)
+    (field_expression
+      field: (field_identifier) @function.method)
+  ])
+
+(function_item
+  name: (identifier) @function)
+
+(function_signature_item
+  name: (identifier) @function)
+
+; -------
+; Operators
+; -------
+
+[
+  "*"
+  "'"
+  "->"
+  "=>"
+  "<="
+  "="
+  "=="
+  "!"
+  "!="
+  "%"
+  "%="
+  "&"
+  "&="
+  "&&"
+  "|"
+  "|="
+  "||"
+  "^"
+  "^="
+  "*"
+  "*="
+  "-"
+  "-="
+  "+"
+  "+="
+  "/"
+  "/="
+  ">"
+  "<"
+  ">="
+  ">>"
+  "<<"
+  ">>="
+  "<<="
+  "@"
+  ".."
+  "..="
+  "'"
+] @operator
+
+; -------
+; Paths
+; -------
+
+(use_declaration
+  argument: (identifier) @namespace)
+(use_wildcard
+  (identifier) @namespace)
+(dep_item
+  name: (identifier) @namespace)
+(scoped_use_list
+  path: (identifier)? @namespace)
+(use_list
+  (identifier) @namespace)
+(use_as_clause
+  path: (identifier)? @namespace
+  alias: (identifier) @namespace)
+
+; ---
+; Remaining Paths
+; ---
+
+(scoped_identifier
+  path: (identifier)? @namespace
+  name: (identifier) @namespace)
+(scoped_type_identifier
+  path: (identifier) @namespace)
+
+; -------
+; Remaining Identifiers
+; -------
+
+"?" @special
+
+(type_identifier) @type
+(identifier) @variable
+(field_identifier) @variable.other.member
diff --git a/runtime/queries/sway/indents.scm b/runtime/queries/sway/indents.scm
new file mode 100644
index 000000000..e6902b62c
--- /dev/null
+++ b/runtime/queries/sway/indents.scm
@@ -0,0 +1,71 @@
+[
+  (use_list)
+  (block)
+  (match_block)
+  (arguments)
+  (parameters)
+  (declaration_list)
+  (field_declaration_list)
+  (field_initializer_list)
+  (struct_pattern)
+  (tuple_pattern)
+  (unit_expression)
+  (enum_variant_list)
+  (call_expression)
+  (binary_expression)
+  (field_expression)
+  (tuple_expression)
+  (array_expression)
+  (where_clause)
+
+  (token_tree)
+] @indent
+
+[
+  "}"
+  "]"
+  ")"
+] @outdent
+
+; Indent the right side of assignments.
+; The #not-same-line? predicate is required to prevent an extra indent for e.g.
+; an else-clause where the previous if-clause starts on the same line as the assignment.
+(assignment_expression
+  .
+  (_) @expr-start
+  right: (_) @indent
+  (#not-same-line? @indent @expr-start)
+  (#set! "scope" "all")
+)
+(compound_assignment_expr
+  .
+  (_) @expr-start
+  right: (_) @indent
+  (#not-same-line? @indent @expr-start)
+  (#set! "scope" "all")
+)
+(let_declaration
+  .
+  (_) @expr-start
+  value: (_) @indent
+  alternative: (_)? @indent
+  (#not-same-line? @indent @expr-start)
+  (#set! "scope" "all")
+)
+(if_expression
+  .
+  (_) @expr-start
+  condition: (_) @indent
+  (#not-same-line? @indent @expr-start)
+  (#set! "scope" "all")
+)
+
+; Some field expressions where the left part is a multiline expression are not
+; indented by cargo fmt.
+; Because this multiline expression might be nested in an arbitrary number of
+; field expressions, this can only be matched using a Regex.
+(field_expression
+  value: (_) @val
+  "." @outdent
+  (#match? @val "(\\A[^\\n\\r]+\\([\\t ]*(\\n|\\r).*)|(\\A[^\\n\\r]*\\{[\\t ]*(\\n|\\r))")
+)
diff --git a/runtime/queries/sway/injections.scm b/runtime/queries/sway/injections.scm
new file mode 100644
index 000000000..e4509a5fd
--- /dev/null
+++ b/runtime/queries/sway/injections.scm
@@ -0,0 +1,2 @@
+([(line_comment) (block_comment)] @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/queries/sway/locals.scm b/runtime/queries/sway/locals.scm
new file mode 100644
index 000000000..262d609e9
--- /dev/null
+++ b/runtime/queries/sway/locals.scm
@@ -0,0 +1,17 @@
+; Scopes
+
+[
+  (function_item)
+  (closure_expression)
+  (block)
+] @local.scope
+
+; Definitions
+
+(parameter
+  (identifier) @local.definition)
+
+(closure_parameters (identifier) @local.definition)
+
+; References
+(identifier) @local.reference
diff --git a/runtime/queries/sway/textobjects.scm b/runtime/queries/sway/textobjects.scm
new file mode 100644
index 000000000..15740bc85
--- /dev/null
+++ b/runtime/queries/sway/textobjects.scm
@@ -0,0 +1,52 @@
+(function_item
+  body: (_) @function.inside) @function.around(closure_expression body: (_) @function.inside) @function.around
+
+(struct_item
+  body: (_) @class.inside) @class.around
+
+(enum_item
+  body: (_) @class.inside) @class.around
+
+(trait_item
+  body: (_) @class.inside) @class.around
+
+(impl_item
+  body: (_) @class.inside) @class.around
+
+(parameters 
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(type_parameters
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(type_arguments
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(closure_parameters
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(arguments
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+[
+  (line_comment)
+  (block_comment)
+] @comment.inside
+
+(line_comment)+ @comment.around
+
+(block_comment) @comment.around
+
+(; #[test]
+ (attribute_item
+   (attribute
+     (identifier) @_test_attribute))
+ ; allow other attributes like #[should_panic] and comments
+ [
+   (attribute_item)
+   (line_comment)
+ ]*
+ ; the test function
+ (function_item
+   body: (_) @test.inside) @test.around
+ (#eq? @_test_attribute "test"))
diff --git a/runtime/queries/tfvars/folds.scm b/runtime/queries/tfvars/folds.scm
new file mode 100644
index 000000000..0e5ffc2db
--- /dev/null
+++ b/runtime/queries/tfvars/folds.scm
@@ -0,0 +1 @@
+; inherits: hcl
diff --git a/runtime/queries/tfvars/highlights.scm b/runtime/queries/tfvars/highlights.scm
new file mode 100644
index 000000000..0e5ffc2db
--- /dev/null
+++ b/runtime/queries/tfvars/highlights.scm
@@ -0,0 +1 @@
+; inherits: hcl
diff --git a/runtime/queries/tfvars/indents.scm b/runtime/queries/tfvars/indents.scm
new file mode 100644
index 000000000..0e5ffc2db
--- /dev/null
+++ b/runtime/queries/tfvars/indents.scm
@@ -0,0 +1 @@
+; inherits: hcl
diff --git a/runtime/queries/tfvars/injections.scm b/runtime/queries/tfvars/injections.scm
new file mode 100644
index 000000000..0e5ffc2db
--- /dev/null
+++ b/runtime/queries/tfvars/injections.scm
@@ -0,0 +1 @@
+; inherits: hcl
diff --git a/runtime/queries/uxntal/highlights.scm b/runtime/queries/uxntal/highlights.scm
new file mode 100644
index 000000000..a6ff18528
--- /dev/null
+++ b/runtime/queries/uxntal/highlights.scm
@@ -0,0 +1,15 @@
+; highlights.scm
+
+(identifier) @keyword
+(number) @constant.numeric
+(comment) @comment
+(raw_character) @constant.character
+(literal_hex) @constant.numeric.integer
+(macro_definition) @function
+(label_definition) @label
+(sub_label_definition) @label
+(relative_pad) @constant
+(label) @label
+(sub_label) @label
+(ERROR) @error
+["[" "]" "{" "}"] @punctuation.bracket
diff --git a/runtime/queries/v/highlights.scm b/runtime/queries/v/highlights.scm
index c71245dca..e014b77d9 100644
--- a/runtime/queries/v/highlights.scm
+++ b/runtime/queries/v/highlights.scm
@@ -14,71 +14,130 @@
 
 (field_identifier) @variable.other.member
 (selector_expression
+  operand: (identifier) @variable
   field: (identifier) @variable.other.member)
 
 (int_literal) @constant.numeric.integer
-(interpreted_string_literal) @string
-(rune_literal) @string
+
+(attribute_declaration) @attribute
+(comment) @comment
+[
+  (c_string_literal)
+  (raw_string_literal)
+  (interpreted_string_literal)
+  (string_interpolation)
+  (rune_literal)
+] @string
+
 (escape_sequence) @constant.character.escape
 
 [
-  (type_identifier)
-  (builtin_type)
   (pointer_type)
   (array_type)
 ] @type
 
+(const_spec name: (identifier) @constant)
+(global_var_type_initializer name: (identifier) @constant)
+(global_var_spec name: (identifier) @constant)
+((identifier) @constant (#match? @constant "^[A-Z][A-Z\\d_]*$"))
+
+
+[
+  (generic_type)
+  (type_identifier)
+] @constructor 
+
+(builtin_type) @type.builtin
+
+[
+ (true)
+ (false)
+] @constant.builtin.boolean
+
+
 [
-  (identifier)
   (module_identifier)
   (import_path)
+] @namespace
+
+[
+  (pseudo_comptime_identifier)
+  (label_name)
+] @label
+
+[
+  (identifier)
 ] @variable
 
+
 [
- "as"
- "asm"
- "assert"
- ;"atomic"
- ;"break"
- "const"
- ;"continue"
- "defer"
- "else"
- "enum"
- "fn"
- "for"
- "$for"
- "go"
- "goto"
- "if"
- "$if"
- "import"
- "in"
- "!in"
- "interface"
- "is"
- "!is"
- "lock"
- "match"
- "module"
- "mut"
- "or"
- "pub"
- "return"
- "rlock"
- "select"
- ;"shared"
- ;"static"
- "struct"
- "type"
- ;"union"
- "unsafe"
+  "pub"
+  "assert"
+  "go"
+  "asm"
+  "defer"
+  "unsafe"
+  "sql"
+  (none)
 ] @keyword
 
 [
- (true)
- (false)
-] @boolean
+  "interface"
+  "enum"
+  "type"
+  "union"
+  "struct"
+  "module"
+] @keyword.storage.type
+
+[
+  "static"
+  "const"
+  "__global"
+] @keyword.storage.modifier
+
+[
+  "mut"
+] @keyword.storage.modifier.mut
+
+[
+  "shared"
+  "lock"
+  "rlock"
+  "spawn"
+] @keyword.control
+
+[
+  "if"
+  "select"
+  "else"
+  "match"
+] @keyword.control.conditional
+
+[
+  "for"
+] @keyword.control.repeat
+
+[
+  "goto"
+  "return"
+] @keyword.control.return
+
+[
+  "fn"
+] @keyword.control.function
+
+
+[
+  "import"
+] @keyword.control.import
+
+[
+  "as"
+  "in"
+  "is"
+  "or"
+] @keyword.operator
 
 [
  "."
@@ -146,5 +205,3 @@
  ".."
  "..."
 ] @operator
-
-(comment) @comment
\ No newline at end of file
diff --git a/runtime/queries/v/indents.scm b/runtime/queries/v/indents.scm
new file mode 100644
index 000000000..5573d4897
--- /dev/null
+++ b/runtime/queries/v/indents.scm
@@ -0,0 +1,17 @@
+[
+  (struct_declaration)
+  (function_declaration)
+  (if_expression)
+  (match_expression)
+  (expression_case)
+  (default_case)
+  (for_statement)
+  (unsafe_expression)
+  (short_var_declaration)
+] @indent
+
+[
+  "]"
+  ")"
+  "}"
+] @outdent
diff --git a/runtime/queries/v/injections.scm b/runtime/queries/v/injections.scm
new file mode 100644
index 000000000..f698de836
--- /dev/null
+++ b/runtime/queries/v/injections.scm
@@ -0,0 +1,6 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
+
+((sql_expression) @injection.content
+ (#set! injection.language "sql"))
+
diff --git a/runtime/queries/v/textobjects.scm b/runtime/queries/v/textobjects.scm
new file mode 100644
index 000000000..40eb101fe
--- /dev/null
+++ b/runtime/queries/v/textobjects.scm
@@ -0,0 +1,27 @@
+(function_declaration
+  body: (block)? @function.inside) @function.around
+
+((function_declaration
+   name: (identifier) @_name
+   body: (block)? @test.inside) @test.around
+ (#match? @_name "^test"))
+
+(fn_literal
+  body: (block)? @function.inside) @function.around
+
+(parameter_list
+  ((_) @parameter.inside . ","? @parameter.around) @parameter.around)
+
+(call_expression
+  (argument_list
+    ((_) @parameter.inside) @parameter.around))
+
+(struct_declaration
+  (struct_field_declaration_list) @class.inside) @class.around
+
+(struct_field_declaration_list
+  ((_) @parameter.inside) @parameter.around)
+
+(comment) @comment.inside
+(comment)+ @comment.around
+
diff --git a/runtime/queries/vhdl/highlights.scm b/runtime/queries/vhdl/highlights.scm
new file mode 100644
index 000000000..59cef41cd
--- /dev/null
+++ b/runtime/queries/vhdl/highlights.scm
@@ -0,0 +1,338 @@
+(comment) @comment
+
+; Keywords
+[
+  ; vhdl 08
+  "abs"
+  "access"
+  "after"
+  "alias"
+  "all"
+  "and"
+  "architecture"
+  "array"
+  "assert"
+  "attribute"
+  "begin"
+  "block"
+  "body"
+  "buffer"
+  "bus"
+  "case"
+  "component"
+  "configuration"
+  "constant"
+  "disconnect"
+  "downto"
+  "else"
+  "elsif"
+  "end"
+  "entity"
+  "exit"
+  "file"
+  "for"
+  "function"
+  "generic"
+  "group"
+  "guarded"
+  "if"
+  "impure"
+  "in"
+  "inertial"
+  "inout"
+  "is"
+  "label"
+  "library"
+  "linkage"
+  "literal"
+  "loop"
+  "map"
+  "mod"
+  "nand"
+  "new"
+  "next"
+  "nor"
+  "not"
+  "null"
+  "of"
+  "on"
+  "open"
+  "or"
+  "others"
+  "out"
+  "package"
+  "port"
+  "postponed"
+  "procedure"
+  "process"
+  "protected"
+  "pure"
+  "range"
+  "record"
+  "register"
+  "reject"
+  "rem"
+  "report"
+  "return"
+  "rol"
+  "ror"
+  "select"
+  "severity"
+  "shared"
+  "signal"
+  "sla"
+  "sll"
+  "sra"
+  "srl"
+  "subtype"
+  "then"
+  "to"
+  "transport"
+  "type"
+  "unaffected"
+  "units"
+  "until"
+  "use"
+  "variable"
+  "wait"
+  "when"
+  "while"
+  "with"
+  "xnor"
+  "xor"
+  ; vhdl 08
+  "context"
+  "force"
+  "property"
+  "release"
+  "sequence"
+] @keyword
+
+[
+  ; vhdl 02
+  "boolean"
+  "bit"
+  "bit_vector"
+  ;"character"
+  ;"severity_level"
+  ;"integer"
+  ;"real"
+  ;"time"
+  ;"natural"
+  ;"positive"
+  "string"
+  ;"line"
+  ;"text"
+  ;"side"
+  ;"unsigned"
+  ;"signed"
+  ;"delay_length"
+  ;"file_open_kind"
+  ;"file_open_status"
+  ;"std_logic"
+  ;"std_logic_vector"
+  ;"std_ulogic"
+  ;"std_ulogic_vector"
+  ; vhdl 08
+  ;"boolean_vector"
+  ;"integer_vector"
+  ;"real_vector"
+  ;"time_vector"
+  ; math types
+  ;"complex"
+  ;"complex_polar"
+  ;"positive_real"
+  ;"principal_value"
+] @type.builtin
+
+[
+  ; vhdl 02
+  "base"
+  "left"
+  "right"
+  "high"
+  "low"
+  "pos"
+  "val"
+  "succ"
+  "pred"
+  "leftof"
+  "rightof"
+  "range"
+  "reverse_range"
+  "length"
+  "delayed"
+  "stable"
+  "quiet"
+  "transaction"
+  "event"
+  "active"
+  "last_event"
+  "last_active"
+  "last_value"
+  "driving"
+  "driving_value"
+  "ascending"
+  "value"
+  "image"
+  "simple_name"
+  "instance_name"
+  "path_name"
+  ;"foreign"
+  ; vhdl 08
+  "instance_name"
+  "path_name"
+] @attribute
+
+;[
+  ; vhdl 02
+  ;"now"
+  ;"resolved"
+  ;"rising_edge"
+  ;"falling_edge"
+  ;"read"
+  ;"readline"
+  ;"hread"
+  ;"oread"
+  ;"write"
+  ;"writeline"
+  ;"hwrite"
+  ;"owrite"
+  ;"endfile"
+  ;"resize"
+  ;"is_X"
+  ;"std_match"
+  ;"shift_left"
+  ;"shift_right"
+  ;"rotate_left"
+  ;"rotate_right"
+  ;"to_unsigned"
+  ;"to_signed"
+  ;"to_integer"
+  ;"to_stdLogicVector"
+  ;"to_stdULogic"
+  ;"to_stdULogicVector"
+  ;"to_bit"
+  ;"to_bitVector"
+  ;"to_X01"
+  ;"to_X01Z"
+  ;"to_UX01"
+  ;"to_01"
+  ;"conv_unsigned"
+  ;"conv_signed"
+  ;"conv_integer"
+  ;"conv_std_logic_vector"
+  ;"shl"
+  ;"shr"
+  ;"ext"
+  ;"sxt"
+  ;"deallocate"
+  ; vhdl 08
+  ;"finish"
+  ;"flush"
+  ;"justify"
+  ;"maximum"
+  ;"minimum"
+  ;"resolution_limit"
+  ;"stop"
+  ;"swrite"
+  ;"tee"
+  ;"to_binarystring"
+  ;"to_bstring"
+  ;"to_hexstring"
+  ;"to_hstring"
+  ;"to_octalstring"
+  ;"to_ostring"
+  ;"to_string"
+  ; vhdl math
+  ;"arccos"
+  ;"arccosh"
+  ;"arcsin"
+  ;"arcsinh"
+  ;"arctan"
+  ;"arctanh"
+  ;"arg"
+  ;"cbrt"
+  ;"ceil"
+  ;"cmplx"
+  ;"complex_to_polar"
+  ;"conj"
+  ;"cos"
+  ;"cosh"
+  ;"exp"
+  ;"floor"
+  ;"get_principal_value"
+  ;"log"
+  ;"log10"
+  ;"log2"
+  ;"polar_to_complex"
+  ;"realmax"
+  ;"realmin"
+  ;"round"
+  ;"sign"
+  ;"sin"
+  ;"sinh"
+  ;"sqrt"
+  ;"tan"
+  ;"tanh"
+  ;"trunc"
+  ;"uniform"
+;] @function.builtin
+
+; Operators
+[
+  "+"
+  "-"
+  "*"
+  "/"
+  "**"
+  "abs"
+  "not"
+  "mod"
+  "rem"
+  "&"
+  "sll"
+  "srl"
+  "sla"
+  "sra"
+  "rol"
+  "ror"
+  "="
+  "/="
+  "?="
+  "?/="
+  "?<"
+  "?<="
+  "?>"
+  "?>="
+  "<"
+  "<="
+  ">"
+  ">="
+  "and"
+  "or"
+  "nand"
+  "nor"
+  "xor"
+  "xnor"
+  ":="
+  "<="
+  "??"
+] @operator
+
+[
+  ";"
+  ","
+] @punctuation.delimiter
+
+[
+  "("
+  ")"
+  "'"
+] @punctuation.bracket
+
+(full_type_declaration "type" name: (identifier) @type)
+(signal_declaration "signal" (identifier_list) @variable)
+(variable_declaration "variable" (identifier_list) @variable)
+(constant_declaration "constant" (identifier_list) @variable)
+
diff --git a/runtime/queries/vue/injections.scm b/runtime/queries/vue/injections.scm
index 73df868b6..1b053e748 100644
--- a/runtime/queries/vue/injections.scm
+++ b/runtime/queries/vue/injections.scm
@@ -8,13 +8,37 @@
   (raw_text) @injection.content)
  (#set! injection.language "javascript"))
 
+; <script>
 ((script_element
+    (start_tag) @_no_lang
+    (raw_text) @injection.content)
+  (#not-match? @_no_lang "lang=")
+  (#set! injection.language "javascript"))
+
+; <script lang="...">
+((script_element
+  (start_tag
+    (attribute
+    (attribute_name) @_attr_name
+    (quoted_attribute_value (attribute_value) @injection.language)))
   (raw_text) @injection.content)
- (#set! injection.language "javascript"))
+  (#eq? @_attr_name "lang"))
 
+; <style>
 ((style_element
-  (raw_text) @injection.content)
- (#set! injection.language "css"))
+    (start_tag) @_no_lang
+    (raw_text) @injection.content)
+  (#not-match? @_no_lang "lang=")
+  (#set! injection.language "css"))
+
+; <style lang="...">
+((style_element
+  (start_tag
+    (attribute
+      (attribute_name) @_attr_name
+      (quoted_attribute_value (attribute_value) @injection.language)))
+   (raw_text) @injection.content)
+ (#eq? @_attr_name "lang"))
 
 ((comment) @injection.content
  (#set! injection.language "comment"))
diff --git a/runtime/queries/yuck/highlights.scm b/runtime/queries/yuck/highlights.scm
new file mode 100644
index 000000000..9f116f153
--- /dev/null
+++ b/runtime/queries/yuck/highlights.scm
@@ -0,0 +1,107 @@
+; Errors
+
+(ERROR) @error
+
+; Comments
+
+(comment) @comment
+
+; Operators
+
+[
+  "+"
+  "-"
+  "*"
+  "/"
+  "%"
+  "||"
+  "&&"
+  "=="
+  "!="
+  "=~"
+  ">"
+  "<"
+  ">="
+  "<="
+  "!"
+  "?."
+  "?:"
+] @operator
+
+(ternary_expression
+  ["?" ":"] @operator)
+
+; Punctuation
+
+[ ":" "." "," ] @punctuation.delimiter
+
+[ "{" "}" "[" "]" "(" ")" ] @punctuation.bracket
+
+; Literals
+
+(number (float)) @constant.numeric.float
+
+(number (integer)) @constant.numeric.integer
+
+(boolean) @constant.builtin.boolean
+
+; Strings
+
+(escape_sequence) @constant.character.escape
+
+(string_interpolation
+  "${" @punctuation.special
+  "}" @punctuation.special)
+
+[ (string_fragment) "\"" "'" "`" ] @string
+
+; Attributes & Fields
+
+(keyword) @attribute
+
+; Functions
+
+(function_call
+  name: (ident) @function)
+
+; Variables
+
+(ident) @variable
+
+(array
+  (symbol) @variable)
+
+; Builtin widgets
+
+(list .
+  ((symbol) @tag.builtin
+    (#match? @tag.builtin "^(box|button|calendar|centerbox|checkbox|circular-progress|color-button|color-chooser|combo-box-text|eventbox|expander|graph|image|input|label|literal|overlay|progress|revealer|scale|scroll|transform)$")))
+
+; Keywords
+
+; I think there's a bug in tree-sitter the anchor doesn't seem to be working, see
+; https://github.com/tree-sitter/tree-sitter/pull/2107
+(list .
+  ((symbol) @keyword
+    (#match? @keyword "^(defwindow|defwidget|defvar|defpoll|deflisten|geometry|children|struts)$")))
+
+(list .
+  ((symbol) @keyword.control.import
+    (#eq? @keyword.control.import "include")))
+
+; Loop
+
+(loop_widget . "for" @keyword.control.repeat . (symbol) @variable . "in" @keyword.operator . (symbol) @variable)
+
+(loop_widget . "for" @keyword.control.repeat . (symbol) @variable . "in" @keyword.operator)
+
+; Tags
+
+; TODO apply to every symbol in list? I think it should probably only be applied to the first child of the list
+(list
+  (symbol) @tag)
+
+; Other stuff that has not been catched by the previous queries yet
+
+(ident) @variable
+(index) @variable
diff --git a/runtime/queries/yuck/injections.scm b/runtime/queries/yuck/injections.scm
new file mode 100644
index 000000000..321c90add
--- /dev/null
+++ b/runtime/queries/yuck/injections.scm
@@ -0,0 +1,2 @@
+((comment) @injection.content
+ (#set! injection.language "comment"))
diff --git a/runtime/themes/acme.toml b/runtime/themes/acme.toml
index e1785f4a5..650924741 100644
--- a/runtime/themes/acme.toml
+++ b/runtime/themes/acme.toml
@@ -2,6 +2,8 @@
 
 "ui.background" = {bg="acme_bg"}
 "ui.text" = "black"
+"ui.linenr" = {bg="acme_bg", fg="black"}
+"ui.linenr.selected" = {bg="acme_bg", fg="black"}
 "ui.selection" = {bg="selected"}
 "ui.cursorline" = {bg="acme_bar_bg"}
 "ui.statusline" = {fg="black", bg="acme_bar_bg"}
@@ -10,6 +12,8 @@
 "ui.virtual.ruler" = { bg = "acme_bar_bg" }
 "ui.cursor.match" = {bg="acme_bar_bg"}
 "ui.cursor" = {bg="cursor", fg="white"}
+"ui.debug" = {fg="orange"}
+"ui.highlight.frameline" = {bg="#da8581"}
 "string" = "red"
 "comment" = "green"
 "ui.help" = {fg="black", bg="acme_bg"}
@@ -20,7 +24,7 @@
 "diagnostic.error" = {bg="red", fg="white", modifiers=["bold"]}
 "diagnostic.warning" = {bg="orange", fg="black", modifiers=["bold"]}
 "diagnostic.hint" = {fg="gray", modifiers=["bold"]}
-"ui.bufferline" = { fg = "indent", bg = "acme_bar_bg" }
+"ui.bufferline" = { fg = "black", bg = "acme_bar_bg" }
 "ui.bufferline.active" = { fg = "black", bg = "acme_bg" }
 "diff.plus" = {fg = "green"}
 "diff.delta" = {fg = "acme_bar_bg"}
diff --git a/runtime/themes/adwaita-dark.toml b/runtime/themes/adwaita-dark.toml
new file mode 100644
index 000000000..2ecfe08e0
--- /dev/null
+++ b/runtime/themes/adwaita-dark.toml
@@ -0,0 +1,172 @@
+# Author: Mofiqul Islam <mofi0islam@gmail.com>
+
+"attribute" = "orange_4"
+
+"type" = "teal_2"
+"type.builtin" = "teal_2"
+
+"constructor" = "blue_2"
+
+"constant" = "violet_2"
+"constant.builtin" = { fg = "violet_2", modifiers = ["bold"] }
+"constant.character" = "teal_3"
+"constant.numeric" = { fg = "teal_3", modifiers = ["bold"] }
+"constant.character.escape" = "violet_2"
+
+"string" = "teal_2"
+"string.regexp" = "purple_2"
+"string.special" = "blue_2"
+
+"comment" = "dark_2"
+
+"variable" = "light_4"
+"variable.parameter" = "orange_2"
+"variable.builtin" = "orange_2"
+"variable.other" = "teal_2"
+"variable.other.member" = "teal_2"
+
+"label" = "purple_2"
+
+"punctuation" = "light_4"
+"punctuation.delimiter" = "light_4"
+"punctuation.bracket" = "light_4"
+"punctuation.special" = "red_3"
+
+"keyword" = { fg = "orange_2", modifiers = ["bold"] }
+"keyword.control" = { fg = "orange_2", modifiers = ["bold"] }
+"keyword.operator" = "purple_2"
+"keyword.directive" = { fg = "orange_2", modifiers = ["bold"] }
+"keyword.function" = "orange_2"
+"keyword.storage" = { fg = "orange_2", modifiers = ["bold"] }
+
+"operator" = "purple_2"
+
+"function" = "blue_2"
+"function.builtin" = "blue_2"
+"function.macro" = { fg = "blue_2", modifiers = ["bold"] }
+"function.special" = { fg = "blue_2", modifiers = ["bold"] }
+
+"tag" = "teal_2"
+
+"namespace" = "orange_2"
+
+"markup" = "light_4"
+"markup.heading" = { fg = "teal_2", modifiers = ["bold"] }
+"markup.list" = { fg = "orange_2", modifiers = ["bold"] }
+"markup.bold" = { fg = "light_4", modifiers = ["bold"] }
+"markup.italic" = { fg = "light_4", modifiers = ["italic"] }
+"markup.link" = { fg = "blue_3", modifiers = ["underlined"] }
+"markup.quote" = { fg = "light_3", modifiers = ["italic"] }
+"diff.plus" = "teal_3"
+"diff.minus" = "red_1"
+"diff.delta" = "orange_3"
+"diff.delta.moved" = "orange_2"
+
+"ui.background" = { fg = "light_4", bg = "libadwaita_dark" }
+"ui.background.separator" = { fg = "split_and_borders", bg = "libadwaita_dark" }
+"ui.cursor" = { fg = "libadwaita_dark", bg = "light_5" }
+"ui.cursor.insert" = { fg = "libadwaita_dark", bg = "light_5" }
+"ui.cursor.select" = { fg = "libadwaita_dark", bg = "light_5" }
+"ui.cursor.match" = { fg = "libadwaita_dark", bg = "blue_2" }
+"ui.cursor.primary" = { fg = "libadwaita_dark", bg = "light_7" }
+"ui.linenr" = "dark_2"
+"ui.linenr.selected" = { fg = "light_7", bg = "libadwaita_dark_alt", modifiers = [
+  "bold",
+] }
+"ui.statusline" = { fg = "light_4", bg = "libadwaita_dark_alt" }
+"ui.statusline.inactive" = { fg = "light_4", bg = "libadwaita_dark_alt" }
+"ui.statusline.insert" = { fg = "light_4", bg = "teal_4" }
+"ui.statusline.select" = { fg = "light_4", bg = "blue_4" }
+"ui.popup" = { bg = "libadwaita_popup" }
+"ui.window" = "split_and_borders"
+"ui.help" = { bg = "libadwaita_dark_alt" }
+"ui.text" = "light_4"
+"ui.virtual" = "dark_1"
+"ui.menu" = { fg = "light_4", bg = "libadwaita_popup" }
+"ui.menu.selected" = { fg = "light_4", bg = "blue_5" }
+"ui.menu.scroll" = { fg = "light_7", bg = "dark_3" }
+"ui.selection" = { bg = "blue_7" }
+"ui.selection.primary" = { bg = "blue_7" }
+"ui.cursorline.primary" = { bg = "libadwaita_dark_alt" }
+
+"warning" = "yellow_2"
+"error" = "red_4"
+"info" = "purple_2"
+"hint" = "blue_2"
+
+"diagnostic.hint" = { fg = "blue_2", modifiers = ["dim"] }
+"diagnostic.info" = { fg = "purple_2", modifiers = ["dim"] }
+"diagnostic.error" = { fg = "red_4", modifiers = ["underlined"] }
+"diagnostic.warning" = { fg = "yellow_2", modifiers = ["underlined"] }
+
+"ui.bufferline" = { fg = "dark_2", bg = "libadwaita_dark" }
+"ui.bufferline.active" = { fg = "light_4", bg = "libadwaita_dark_alt" }
+
+[palette]
+blue_1 = "#99C1F1"
+blue_2 = "#62A0EA"
+blue_3 = "#3584E4"
+blue_4 = "#1C71D8"
+blue_5 = "#1A5FB4"
+blue_6 = "#1B497E"
+blue_7 = "#193D66"
+brown_1 = "#CDAB8F"
+brown_2 = "#B5835A"
+brown_3 = "#986A44"
+brown_4 = "#865E3C"
+brown_5 = "#63452C"
+chameleon_3 = "#4E9A06"
+dark_1 = "#77767B"
+dark_2 = "#5E5C64"
+dark_3 = "#504E55"
+dark_4 = "#3D3846"
+dark_5 = "#241F31"
+dark_6 = "#000000"
+dark_7 = "#1c1c1c"
+green_1 = "#8FF0A4"
+green_2 = "#57E389"
+green_3 = "#33D17A"
+green_4 = "#2EC27E"
+green_5 = "#26A269"
+green_6 = "#1F7F56"
+green_7 = "#1C6849"
+libadwaita_dark = "#1D1D1D"
+libadwaita_dark_alt = "#303030"
+libadwaita_popup = "#282828"
+light_1 = "#FFFFFF"
+light_2 = "#FCFCFC"
+light_3 = "#F6F5F4"
+light_4 = "#DEDDDA"
+light_5 = "#C0BFBC"
+light_6 = "#B0AFAC"
+light_7 = "#9A9996"
+orange_1 = "#FFBE6F"
+orange_2 = "#FFA348"
+orange_3 = "#FF7800"
+orange_4 = "#E66100"
+orange_5 = "#C64600"
+purple_1 = "#DC8ADD"
+purple_2 = "#C061CB"
+purple_3 = "#9141AC"
+purple_4 = "#813D9C"
+purple_5 = "#613583"
+red_1 = "#F66151"
+red_2 = "#ED333B"
+red_3 = "#E01B24"
+red_4 = "#C01C28"
+red_5 = "#A51D2D"
+teal_1 = "#93DDC2"
+teal_2 = "#5BC8AF"
+teal_3 = "#33B2A4"
+teal_4 = "#26A1A2"
+teal_5 = "#218787"
+violet_2 = "#7D8AC7"
+violet_3 = "#6362C8"
+violet_4 = "#4E57BA"
+yellow_1 = "#F9F06B"
+yellow_2 = "#F8E45C"
+yellow_3 = "#F6D32D"
+yellow_4 = "#F5C211"
+yellow_5 = "#E5A50A"
+yellow_6 = "#D38B09"
+split_and_borders = "#4F4F4F"
diff --git a/runtime/themes/autumn.toml b/runtime/themes/autumn.toml
index 501675da1..4474b0d41 100644
--- a/runtime/themes/autumn.toml
+++ b/runtime/themes/autumn.toml
@@ -9,23 +9,25 @@
 
 "ui.background" = { bg = "my_gray0" }
 "ui.menu" = { fg = "my_white", bg = "my_gray2" }
-"ui.menu.selected" = { fg = "my_gray2", bg = "my_gray5" }
+"ui.menu.selected" = { fg = "my_gray2", bg = "my_gray6" }
 "ui.linenr" = { fg = "my_gray3", bg = "my_gray0" }
 "ui.popup" = { bg = "my_gray2" }
 "ui.window" = { fg = "my_gray3", bg = "my_gray2" }
-"ui.linenr.selected" = { fg = "my_gray6", bg = "my_gray0"}
+"ui.linenr.selected" = { fg = "my_gray7", bg = "my_gray0"}
 "ui.selection" = { bg = "my_gray3" }
-"comment" = { fg = "my_gray4", modifiers = ["italic"] }
+"comment" = { fg = "my_gray5", modifiers = ["italic"] }
 "ui.cursorline" = { bg = "my_gray3" }
-"ui.statusline" = { fg = "my_gray6", bg = "my_gray2" }
-"ui.statusline.inactive" = { fg = 'my_gray4', bg = 'my_gray2' }
-"ui.statusline.insert" = {fg = "my_black", bg = "my_gray5", modifiers = ["bold"]}
-"ui.statusline.normal" = {fg = "my_gray6", bg = "my_gray2"}
-"ui.statusline.select" = {fg = "my_gray6", bg = "my_black", modifiers = ["bold"]}
-"ui.cursor" = { fg = "my_gray5", modifiers = ["reversed"] }
+"ui.statusline" = { fg = "my_gray7", bg = "my_gray2" }
+"ui.statusline.inactive" = { fg = 'my_gray5', bg = 'my_gray2' }
+"ui.statusline.insert" = {fg = "my_black", bg = "my_gray6", modifiers = ["bold"]}
+"ui.statusline.normal" = {fg = "my_gray7", bg = "my_gray2"}
+"ui.statusline.select" = {fg = "my_gray7", bg = "my_black", modifiers = ["bold"]}
+"ui.cursor" = { fg = "my_gray6", modifiers = ["reversed"] }
 "ui.cursor.primary" = { fg = "my_white", modifiers = ["reversed"] }
 "ui.cursorline.primary" = { bg = "my_black" }
 "ui.cursorline.secondary" = { bg = "my_black" }
+"ui.highlight.frameline" = { bg = "#8b6904" }
+"ui.debug" = { fg = "my_yellow1", bg = "my_gray0" }
 "ui.text" = "my_white"
 "operator" = "my_white"
 "ui.text.focus" = "my_white"
@@ -44,27 +46,31 @@
 "keyword" = "my_red"
 "label" = "my_red"
 "namespace" = "my_white3"
-"ui.help" = { fg = "my_gray6", bg = "my_gray2" }
-"ui.virtual.whitespace" = { fg = "my_gray5" }
+"ui.help" = { fg = "my_gray7", bg = "my_gray2" }
+"ui.virtual.whitespace" = { fg = "my_gray6" }
 "ui.virtual.ruler" = { bg = "my_gray1" }
+"ui.virtual.inlay-hint" = { fg = "my_gray4", modifiers = ["normal"] }
+"ui.virtual.inlay-hint.parameter" = { fg = "my_gray4", modifiers = ["normal"] }
+"ui.virtual.inlay-hint.type" = { fg = "my_gray4", modifiers = ["italic"] }
 
 "markup.heading" = "my_yellow1"
 "markup.list" = "my_white2"
 "markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = {  modifiers = ["italic"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "my_turquoise2"
 "markup.link.text" = "my_white2"
 "markup.quote" = "my_brown"
 "markup.raw" = "my_green"
 
 "diff.plus" = "my_green"
-"diff.delta" = "my_gray4"
+"diff.delta" = "my_gray5"
 "diff.minus" = "my_red"
 
 "diagnostic" = { modifiers = ["underlined"] }
 "diagnostic.error" = { underline = { style = "curl", color = "my_red" } }
 "ui.gutter" = { bg = "my_gray0" }
-"hint" = "my_gray5"
+"hint" = "my_gray6"
 "debug" = "my_yellow2"
 "info" = "my_yellow2"
 "warning" = "my_yellow2"
@@ -75,11 +81,12 @@ my_black      = "#212121" # Cursorline
 my_gray0      = "#262626" # Default Background
 my_gray1      = "#2b2b2b" # Ruler
 my_gray2      = "#323232" # Lighter Background (Used for status bars, line number and folding marks)
-my_gray3      = "#505050" # Selection Background
-my_gray4      = "#7c7c7c" # Comments, Invisibles, Line Highlighting
-my_gray5      = "#a8a8a8" # Dark Foreground (Used for status bars)
-my_gray6      = "#c8c8c8" # Light Foreground (Not often used)
-my_gray7      = "#e8e8e8" # Light Background (Not often used)
+my_gray3      = "#404040" # Selection Background
+my_gray4      = "#6a6a6a" # Inlay-hint
+my_gray5      = "#848484" # Comments, Invisibles, Line Highlighting
+my_gray6      = "#a8a8a8" # Dark Foreground (Used for status bars)
+my_gray7      = "#c8c8c8" # Light Foreground
+my_gray8      = "#e8e8e8" # Light Background
 my_white      = "#F3F2CC" # Default Foreground, Caret, Delimiters, Operators
 my_white2     = "#F3F2CC" # Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deleted
 my_white3     = "#F3F2CC" # Classes, Markup Bold, Search Text Background
diff --git a/runtime/themes/autumn_night.toml b/runtime/themes/autumn_night.toml
index c26cc777e..70045f42d 100644
--- a/runtime/themes/autumn_night.toml
+++ b/runtime/themes/autumn_night.toml
@@ -14,11 +14,12 @@ my_black      = "#111111" # Cursorline
 my_gray0      = "#090909" # Default Background
 my_gray1      = "#0e0e0e" # Ruler
 my_gray2      = "#1a1a1a" # Lighter Background (Used for status bars, line number and folding marks)
-my_gray3      = "#323232" # Selection Background
-my_gray4      = "#7c7c7c" # Comments, Invisibles, Line Highlighting
-my_gray5      = "#aaaaaa" # Dark Foreground (Used for status bars)
-my_gray6      = "#c4c4c4" # Light Foreground (Not often used)
-my_gray7      = "#e8e8e8" # Light Background (Not often used)
+my_gray3      = "#404040" # Selection Background
+my_gray4      = "#626262" # Inlay-hint
+my_gray5      = "#808080" # Comments, Invisibles, Line Highlighting
+my_gray6      = "#aaaaaa" # Dark Foreground (Used for status bars)
+my_gray7      = "#c4c4c4" # Light Foreground
+my_gray8      = "#e8e8e8" # Light Background
 my_white      = "#F3F2CC" # Default Foreground, Caret, Delimiters, Operators
 my_white2     = "#F3F2CC" # Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deleted
 my_white3     = "#F3F2CC" # Classes, Markup Bold, Search Text Background
diff --git a/runtime/themes/ayu_dark.toml b/runtime/themes/ayu_dark.toml
index b297a3abd..211d423f4 100644
--- a/runtime/themes/ayu_dark.toml
+++ b/runtime/themes/ayu_dark.toml
@@ -47,6 +47,7 @@
 "ui.text.info" = "foreground"
 "ui.virtual.whitespace" = "dark_gray"
 "ui.virtual.ruler" = { bg = "black" }
+"ui.virtual.inlay-hint" = { fg = "#e6b450", bg = "#302a20" }  # original bg #e6b45033
 "ui.menu" = { fg = "foreground", bg = "black" }
 "ui.menu.selected" = { bg = "gray", fg = "background" }
 "ui.selection" = { bg = "dark_gray" }
@@ -54,12 +55,14 @@
 "error" = { fg = "red", modifiers = ["bold"] }
 "info" = { fg = "blue", modifiers = ["bold"] }
 "hint" = { fg = "blue", modifiers = ["bold"] }
-"diagnostic"= { fg = "red", modifiers = ["underlined"] }
-"diagnostic.info"= { fg = "blue", modifiers = ["underlined"] }
-"diagnostic.warning"= { fg = "yellow", modifiers = ["underlined"] }
-"diagnostic.error"= { fg = "red", modifiers = ["underlined"] }
+"diagnostic.hint" = { underline = { color = "blue", style="curl"} }
+"diagnostic.info"= { underline = { color = "blue", style="curl"} }
+"diagnostic.warning"= { underline = { color = "yellow", style="curl"} }
+"diagnostic.error"= { underline = { color = "red", style="curl"} }
 "ui.bufferline" = { fg = "gray", bg = "background" }
 "ui.bufferline.active" = { fg = "foreground", bg = "dark_gray" }
+"ui.debug" = { fg = "orange", bg = "background" }
+"ui.highlight.frameline" = { bg = "#0067a3" }
 
 "special" = "orange"
 
diff --git a/runtime/themes/ayu_evolve.toml b/runtime/themes/ayu_evolve.toml
new file mode 100644
index 000000000..b57235a6a
--- /dev/null
+++ b/runtime/themes/ayu_evolve.toml
@@ -0,0 +1,37 @@
+inherits = 'ayu_dark'
+
+"keyword.control" = "orange"
+"keyword.storage" = "yellow"
+"keyword.storage.modifier" = "magenta"
+"variable" = "light_gray"
+"constructor" = "magenta"
+"type.builtin" = { fg = "blue", modifiers = ["italic"] }
+
+# Gutters and editing area
+"error" = "red"
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"warning" = "vibrant_orange"
+"diagnostic.warning" = { underline = { color = "vibrant_orange", style = "curl" } }
+"hint" = "vibrant_yellow"
+"diagnostic.hint" = { underline = { color = "vibrant_yellow", style = "curl" } }
+"info" = "white"
+"diagnostic.info" = { underline = { color = "white", style = "curl" } }
+
+"markup.raw.block" = { bg = "black" }
+"markup.raw.inline" = { bg = "black" }
+
+"ui.cursor" = { fg = "dark_gray", bg = "light_gray" }
+"ui.cursor.primary" = { fg = "dark_gray", bg = "orange" }
+"ui.cursor.primary.select" = { fg = "dark_gray", bg = "magenta" }
+"ui.cursor.primary.insert" = { fg = "dark_gray", bg = "green" }
+"ui.text.inactive" = "gray"
+"ui.bufferline" = { fg = "light_gray", bg = "background" }
+"ui.bufferline.active" = { fg = "light_gray", bg = "dark_gray" }
+
+[palette]
+background = '#020202'
+black = "#0D0D0D"
+light_gray = "#dedede"
+red = "#DD3E25"
+vibrant_yellow = "#CFCA0D"
+vibrant_orange = "#FF8732"
diff --git a/runtime/themes/ayu_light.toml b/runtime/themes/ayu_light.toml
index ab0283fb6..4b0ba1db7 100644
--- a/runtime/themes/ayu_light.toml
+++ b/runtime/themes/ayu_light.toml
@@ -47,6 +47,7 @@
 "ui.text.info" = "foreground"
 "ui.virtual.whitespace" = "dark_gray"
 "ui.virtual.ruler" = { bg = "black" }
+"ui.virtual.inlay-hint" = { fg = "#f4a028", bg = "#fcf2e3" }  # bg original #ffaa3333
 "ui.menu" = { fg = "foreground", bg = "black" }
 "ui.menu.selected" = { bg = "gray", fg = "background" }
 "ui.selection" = { bg = "dark_gray" }
@@ -54,12 +55,14 @@
 "error" = { fg = "red", modifiers = ["bold"] }
 "info" = { fg = "blue", modifiers = ["bold"] }
 "hint" = { fg = "blue", modifiers = ["bold"] }
-"diagnostic"= { fg = "red", modifiers = ["underlined"] }
-"diagnostic.info"= { fg = "blue", modifiers = ["underlined"] }
-"diagnostic.warning"= { fg = "yellow", modifiers = ["underlined"] }
-"diagnostic.error"= { fg = "red", modifiers = ["underlined"] }
+"diagnostic.hint"= { underline = { color = "blue", style = "curl" } }
+"diagnostic.info"= { underline = { color = "blue", style = "curl" } }
+"diagnostic.warning"= { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error"= { underline = { color = "red", style = "curl" } }
 "ui.bufferline" = { fg = "gray", bg = "background" }
 "ui.bufferline.active" = { fg = "foreground", bg = "dark_gray" }
+"ui.debug" = { fg = "orange", bg = "background" }
+"ui.highlight.frameline" = { bg = "#cfe0f2" }
 
 "special" = "orange"
 
diff --git a/runtime/themes/ayu_mirage.toml b/runtime/themes/ayu_mirage.toml
index d6af12fa7..5afe0acd9 100644
--- a/runtime/themes/ayu_mirage.toml
+++ b/runtime/themes/ayu_mirage.toml
@@ -47,6 +47,7 @@
 "ui.text.info" = "foreground"
 "ui.virtual.whitespace" = "dark_gray"
 "ui.virtual.ruler" = { bg = "black" }
+"ui.virtual.inlay-hint" = { fg = "#ffcc66", bg = "#47433d" }  # original bg #ffcc6633
 "ui.menu" = { fg = "foreground", bg = "black" }
 "ui.menu.selected" = { bg = "gray", fg = "background" }
 "ui.selection" = { bg = "dark_gray" }
@@ -54,12 +55,14 @@
 "error" = { fg = "red", modifiers = ["bold"] }
 "info" = { fg = "blue", modifiers = ["bold"] }
 "hint" = { fg = "blue", modifiers = ["bold"] }
-"diagnostic"= { fg = "red", modifiers = ["underlined"] }
-"diagnostic.info"= { fg = "blue", modifiers = ["underlined"] }
-"diagnostic.warning"= { fg = "yellow", modifiers = ["underlined"] }
-"diagnostic.error"= { fg = "red", modifiers = ["underlined"] }
+"diagnostic.hint"= { underline = { color = "blue", style = "curl" } }
+"diagnostic.info"= { underline = { color = "blue", style = "curl" } }
+"diagnostic.warning"= { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error"= { underline = { color = "red", style = "curl" } }
 "ui.bufferline" = { fg = "gray", bg = "background" }
 "ui.bufferline.active" = { fg = "foreground", bg = "dark_gray" }
+"ui.debug" = { fg = "orange", bg = "background" }
+"ui.highlight.frameline" = { bg = "#0067a3" }
 
 "special" = "orange"
 
diff --git a/runtime/themes/base16_default_dark.toml b/runtime/themes/base16_default_dark.toml
index 74bbcd2e2..1a38a6aeb 100644
--- a/runtime/themes/base16_default_dark.toml
+++ b/runtime/themes/base16_default_dark.toml
@@ -37,6 +37,7 @@
 "markup.list" = "base08"
 "markup.bold" = { fg = "base0A", modifiers = ["bold"] }
 "markup.italic" = { fg = "base0E", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "base09", modifiers = ["underlined"] }
 "markup.link.text" = "base08"
 "markup.quote" = "base0C"
diff --git a/runtime/themes/base16_default_light.toml b/runtime/themes/base16_default_light.toml
index 3784670ff..84dab5305 100644
--- a/runtime/themes/base16_default_light.toml
+++ b/runtime/themes/base16_default_light.toml
@@ -37,6 +37,7 @@
 "markup.list" = "base08"
 "markup.bold" = { fg = "base0A", modifiers = ["bold"] }
 "markup.italic" = { fg = "base0E", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "base09", modifiers = ["underlined"] }
 "markup.link.text" = "base08"
 "markup.quote" = "base0C"
diff --git a/runtime/themes/base16_terminal.toml b/runtime/themes/base16_terminal.toml
index 1f5328dcb..f39758611 100644
--- a/runtime/themes/base16_terminal.toml
+++ b/runtime/themes/base16_terminal.toml
@@ -34,6 +34,7 @@
 "markup.list" = "light-red"
 "markup.bold" = { fg = "light-yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "light-magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", modifiers = ["underlined"] }
 "markup.link.text" = "light-red"
 "markup.quote" = "light-cyan"
diff --git a/runtime/themes/base16_transparent.toml b/runtime/themes/base16_transparent.toml
index f8ee0890d..63aa1f869 100644
--- a/runtime/themes/base16_transparent.toml
+++ b/runtime/themes/base16_transparent.toml
@@ -9,7 +9,7 @@
 "ui.linenr" = { fg = "light-gray" }
 "ui.linenr.selected" = { fg = "white",  modifiers = ["bold"] }
 "ui.popup" = { fg = "white" }
-"ui.window" = { fg = "white" }
+"ui.window" = { fg = "gray" }
 "ui.selection" = { bg = "gray" }
 "comment" = "light-gray"
 "ui.statusline" = { fg = "white" }
@@ -25,6 +25,10 @@
 "ui.virtual.ruler" = { bg = "gray" }
 "ui.virtual.whitespace" = "gray"
 "ui.virtual.indent-guide" = "gray"
+"ui.virtual.inlay-hint" = { fg = "white", bg = "gray" }
+"ui.virtual.inlay-hint.parameter" = { fg = "white", bg = "gray"}
+"ui.virtual.inlay-hint.type" = { fg = "white", bg = "gray"}
+"ui.virtual.wrap" = "gray"
 
 "variable" = "light-red"
 "constant.numeric" = "yellow"
@@ -45,6 +49,7 @@
 "markup.list" = "light-red"
 "markup.bold" = { fg = "light-yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "light-magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", underline = { color = "yellow", style = "line"} }
 "markup.link.text" = "light-red"
 "markup.quote" = "light-cyan"
diff --git a/runtime/themes/bogster.toml b/runtime/themes/bogster.toml
index eb6c4c500..1ea13f1f5 100644
--- a/runtime/themes/bogster.toml
+++ b/runtime/themes/bogster.toml
@@ -31,6 +31,7 @@
 "markup.list" = "bogster-red"
 "markup.bold" = { fg = "bogster-yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "bogster-purp", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "bogster-yellow", modifiers = ["underlined"] }
 "markup.link.text" = "bogster-red"
 "markup.quote" = "bogster-teal"
@@ -72,7 +73,10 @@
 "hint" = "bogster-blue"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "bogster-orange", style = "curl"} }
+"diagnostic.error" = { underline = { color = "bogster-lred", style = "curl"} }
+"diagnostic.info" = { underline = { color = "bogster-teal", style = "curl"} }
+"diagnostic.hint" = { underline = { color = "bogster-blue", style = "curl"} }
 
 [palette]
 bogster-yellow = "#dcb659"
diff --git a/runtime/themes/bogster_light.toml b/runtime/themes/bogster_light.toml
index 25aa4c802..e528d89d9 100644
--- a/runtime/themes/bogster_light.toml
+++ b/runtime/themes/bogster_light.toml
@@ -31,6 +31,7 @@
 "markup.list" = "bogster-red"
 "markup.bold" = { fg = "bogster-yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "bogster-yellow", modifiers = ["underlined"] }
 "markup.link.text" = "bogster-red"
 "markup.quote" = "bogster-lblue"
@@ -72,7 +73,10 @@
 "hint" = "bogster-blue"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "bogster-orange", style = "curl"} }
+"diagnostic.error" = { underline = { color = "bogster-lred", style = "curl"} }
+"diagnostic.info" = { underline = { color = "bogster-teal", style = "curl"} }
+"diagnostic.hint" = { underline = { color = "bogster-blue", style = "curl"} }
 
 [palette]
 bogster-orange = "#dc7759"
diff --git a/runtime/themes/boo_berry.toml b/runtime/themes/boo_berry.toml
index da78db90b..d3a3e2232 100644
--- a/runtime/themes/boo_berry.toml
+++ b/runtime/themes/boo_berry.toml
@@ -22,6 +22,7 @@
 "markup.list" = { fg = "bubblegum" }
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "violet", modifiers = ["underlined"] }
 "markup.link.text" = { fg = "violet" }
 "markup.quote" = { fg = "berry_desaturated" }
@@ -51,6 +52,7 @@
 "ui.virtual.whitespace" = { fg = "berry_desaturated" }
 "ui.virtual.ruler" = { bg = "berry_dim" }
 "ui.virtual.indent-guide" = { fg = "berry_fade" }
+"ui.virtual.inlay-hint" = { fg = "berry_desaturated" }
 
 "diff.plus" = { fg = "mint" }
 "diff.delta" = { fg = "gold" }
@@ -60,7 +62,11 @@
 "warning" = { fg = "gold" }
 "info" = { fg = "lilac" }
 "hint" = { fg = "lilac" }
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.warning" = { underline = { color = "bubblegum", style = "curl"} }
+"diagnostic.error" = { underline = { color = "gold", style = "curl"} }
+"diagnostic.info" = { underline = { color = "lilac", style = "curl"} }
+"diagnostic.hint" = { underline = { color = "lilac", style = "curl"} }
 
 [palette]
 berry = "#3A2A4D"
diff --git a/runtime/themes/catppuccin_frappe.toml b/runtime/themes/catppuccin_frappe.toml
index 89ae77c82..eb1d47194 100644
--- a/runtime/themes/catppuccin_frappe.toml
+++ b/runtime/themes/catppuccin_frappe.toml
@@ -1,108 +1,4 @@
-# Syntax highlighting
-# -------------------
-"type" = "yellow"
-"type.enum.variant" = "peach"
-
-"constructor" = "sapphire"
-
-"constant" = "peach"
-"constant.character" = "teal"
-"constant.character.escape" = "pink"
-
-"string" = "green"
-"string.regexp" = "peach"
-"string.special" = "pink"
-
-"comment" = { fg = "overlay1", modifiers = ["italic"] }
-
-"variable" = "text"
-"variable.parameter" = { fg = "maroon", modifiers = ["italic"] }
-"variable.builtin" = "red"
-"variable.other.member" = "teal"
-
-"label" = "sapphire" # used for lifetimes
-
-"punctuation" = "overlay2"
-
-"keyword" = "mauve"
-"keyword.control.conditional" = { fg = "mauve", modifiers = ["italic"] }
-
-"operator" = "sky"
-
-"function" = "blue"
-"function.builtin" = "peach"
-"function.macro" = "teal"
-
-"tag" = "mauve"
-
-"namespace" = { fg = "blue", modifiers = ["italic"] }
-
-"special" = "blue" # fuzzy highlight
-
-"markup.heading.marker" = { fg = "peach", modifiers = ["bold"] }
-"markup.heading.1" = "lavender"
-"markup.heading.2" = "mauve"
-"markup.heading.3" = "green"
-"markup.heading.4" = "yellow"
-"markup.heading.5" = "pink"
-"markup.heading.6" = "teal"
-"markup.list" = "mauve"
-"markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "peach", modifiers = ["underlined"] }
-"markup.link.text" = "blue"
-"markup.raw" = "flamingo"
-
-"diff.plus" = "green"
-"diff.minus" = "red"
-"diff.delta" = "yellow"
-
-# User Interface
-# --------------
-"ui.background" = { fg = "text", bg = "base" }
-
-"ui.linenr" = { fg = "surface1" }
-"ui.linenr.selected" = { fg = "lavender" }
-
-"ui.statusline" = { fg = "overlay1", bg = "surface0" }
-"ui.statusline.inactive" = { fg = "overlay1", bg = "mantle" }
-"ui.statusline.normal" = { fg = "surface0", bg = "lavender", modifiers = ["bold"] }
-"ui.statusline.insert" = { fg = "surface0", bg = "green", modifiers = ["bold"]  }
-"ui.statusline.select" = { fg = "surface0", bg = "flamingo", modifiers = ["bold"]  }
-
-"ui.bufferline" = { fg = "subtext1", bg = "mantle" }
-"ui.bufferline.active" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
-
-"ui.popup" = { fg = "text", bg = "surface0" }
-"ui.window" = { fg = "crust" }
-"ui.help" = { fg = "overlay2", bg = "surface0" }
-
-"ui.text" = "text" 
-"ui.text.focus" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
-
-"ui.virtual" = "overlay0"
-"ui.virtual.ruler" = { bg = "surface0" }
-"ui.virtual.indent-guide" = "surface0"
-
-"ui.selection" = { bg = "surface1" }
-
-"ui.cursor" = { fg = "base", bg = "secondary_cursor" }
-"ui.cursor.primary" = { fg = "base", bg = "rosewater" }
-"ui.cursor.match" = { fg = "peach", modifiers = ["bold"] }
-
-"ui.cursorline.primary" = { bg = "cursorline" }
-
-"ui.highlight" = { bg = "surface1" }
-
-"ui.menu" = { fg = "overlay2", bg = "surface0" }
-"ui.menu.selected" = { fg = "text", bg = "surface1", modifiers = ["bold"] }
-
-diagnostic = { modifiers = ["underlined"] }
-
-error = "red"
-warning = "yellow"
-info = "sky"
-hint = "teal"
+inherits = "catppuccin_mocha"
 
 [palette]
 # catppuccin palette colors
diff --git a/runtime/themes/catppuccin_latte.toml b/runtime/themes/catppuccin_latte.toml
index 8e8780f9e..e1580c9d7 100644
--- a/runtime/themes/catppuccin_latte.toml
+++ b/runtime/themes/catppuccin_latte.toml
@@ -1,109 +1,4 @@
-# Syntax highlighting
-# -------------------
-"type" = "yellow"
-"type.enum.variant" = "peach"
-
-"constructor" = "sapphire"
-
-"constant" = "peach"
-"constant.character" = "teal"
-"constant.character.escape" = "pink"
-
-"string" = "green"
-"string.regexp" = "peach"
-"string.special" = "pink"
-
-"comment" = { fg = "overlay1", modifiers = ["italic"] }
-
-"variable" = "text"
-"variable.parameter" = { fg = "maroon", modifiers = ["italic"] }
-"variable.builtin" = "red"
-"variable.other.member" = "teal"
-
-"label" = "sapphire" # used for lifetimes
-
-"punctuation" = "overlay2"
-
-"keyword" = "mauve"
-"keyword.control.conditional" = { fg = "mauve", modifiers = ["italic"] }
-
-"operator" = "sky"
-
-"function" = "blue"
-"function.builtin" = "peach"
-"function.macro" = "teal"
-
-"tag" = "mauve"
-
-"namespace" = { fg = "blue", modifiers = ["italic"] }
-
-"special" = "blue" # fuzzy highlight
-
-"markup.heading.marker" = { fg = "peach", modifiers = ["bold"] }
-"markup.heading.1" = "lavender"
-"markup.heading.2" = "mauve"
-"markup.heading.3" = "green"
-"markup.heading.4" = "yellow"
-"markup.heading.5" = "pink"
-"markup.heading.6" = "teal"
-"markup.list" = "mauve"
-"markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "peach", modifiers = ["underlined"] }
-"markup.link.text" = "blue"
-"markup.raw" = "flamingo"
-
-"diff.plus" = "green"
-"diff.minus" = "red"
-"diff.delta" = "yellow"
-
-# User Interface
-# --------------
-"ui.background" = { fg = "text", bg = "base" }
-
-"ui.linenr" = { fg = "surface1" }
-"ui.linenr.selected" = { fg = "lavender" }
-
-"ui.statusline" = { fg = "overlay1", bg = "surface0" }
-"ui.statusline.inactive" = { fg = "overlay1", bg = "mantle" }
-"ui.statusline.normal" = { fg = "surface0", bg = "lavender", modifiers = ["bold"] }
-"ui.statusline.insert" = { fg = "surface0", bg = "green", modifiers = ["bold"]  }
-"ui.statusline.select" = { fg = "surface0", bg = "flamingo", modifiers = ["bold"]  }
-
-"ui.bufferline" = { fg = "overlay2", bg = "surface1", modifiers = ["italic"] }
-"ui.bufferline.active" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
-"ui.bufferline.background" = { bg = "surface1" }
-
-"ui.popup" = { fg = "text", bg = "surface0" }
-"ui.window" = { fg = "crust" }
-"ui.help" = { fg = "overlay2", bg = "surface0" }
-
-"ui.text" = "text" 
-"ui.text.focus" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
-
-"ui.virtual" = "overlay0"
-"ui.virtual.ruler" = { bg = "surface0" }
-"ui.virtual.indent-guide" = "surface0"
-
-"ui.selection" = { bg = "surface1" }
-
-"ui.cursor" = { fg = "base", bg = "secondary_cursor" }
-"ui.cursor.primary" = { fg = "base", bg = "rosewater" }
-"ui.cursor.match" = { fg = "peach", modifiers = ["bold"] }
-
-"ui.cursorline.primary" = { bg = "cursorline" }
-
-"ui.highlight" = { bg = "surface1" }
-
-"ui.menu" = { fg = "overlay2", bg = "surface0" }
-"ui.menu.selected" = { fg = "text", bg = "surface1", modifiers = ["bold"] }
-
-diagnostic = { modifiers = ["underlined"] }
-
-error = "red"
-warning = "yellow"
-info = "sky"
-hint = "teal"
+inherits = "catppuccin_mocha"
 
 [palette]
 # catppuccin palette colors
diff --git a/runtime/themes/catppuccin_macchiato.toml b/runtime/themes/catppuccin_macchiato.toml
index c2fe3184c..e09a82f9b 100644
--- a/runtime/themes/catppuccin_macchiato.toml
+++ b/runtime/themes/catppuccin_macchiato.toml
@@ -1,108 +1,4 @@
-# Syntax highlighting
-# -------------------
-"type" = "yellow"
-"type.enum.variant" = "peach"
-
-"constructor" = "sapphire"
-
-"constant" = "peach"
-"constant.character" = "teal"
-"constant.character.escape" = "pink"
-
-"string" = "green"
-"string.regexp" = "peach"
-"string.special" = "pink"
-
-"comment" = { fg = "overlay1", modifiers = ["italic"] }
-
-"variable" = "text"
-"variable.parameter" = { fg = "maroon", modifiers = ["italic"] }
-"variable.builtin" = "red"
-"variable.other.member" = "teal"
-
-"label" = "sapphire" # used for lifetimes
-
-"punctuation" = "overlay2"
-
-"keyword" = "mauve"
-"keyword.control.conditional" = { fg = "mauve", modifiers = ["italic"] }
-
-"operator" = "sky"
-
-"function" = "blue"
-"function.builtin" = "peach"
-"function.macro" = "teal"
-
-"tag" = "mauve"
-
-"namespace" = { fg = "blue", modifiers = ["italic"] }
-
-"special" = "blue" # fuzzy highlight
-
-"markup.heading.marker" = { fg = "peach", modifiers = ["bold"] }
-"markup.heading.1" = "lavender"
-"markup.heading.2" = "mauve"
-"markup.heading.3" = "green"
-"markup.heading.4" = "yellow"
-"markup.heading.5" = "pink"
-"markup.heading.6" = "teal"
-"markup.list" = "mauve"
-"markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "peach", modifiers = ["underlined"] }
-"markup.link.text" = "blue"
-"markup.raw" = "flamingo"
-
-"diff.plus" = "green"
-"diff.minus" = "red"
-"diff.delta" = "yellow"
-
-# User Interface
-# --------------
-"ui.background" = { fg = "text", bg = "base" }
-
-"ui.linenr" = { fg = "surface1" }
-"ui.linenr.selected" = { fg = "lavender" }
-
-"ui.statusline" = { fg = "overlay1", bg = "surface0" }
-"ui.statusline.inactive" = { fg = "overlay1", bg = "mantle" }
-"ui.statusline.normal" = { fg = "surface0", bg = "lavender", modifiers = ["bold"] }
-"ui.statusline.insert" = { fg = "surface0", bg = "green", modifiers = ["bold"]  }
-"ui.statusline.select" = { fg = "surface0", bg = "flamingo", modifiers = ["bold"]  }
-
-"ui.bufferline.active" = { fg = "text", bg = "base", modifiers = ["bold"] }
-"ui.bufferline" = { fg = "overlay1", bg = "mantle" }
-
-"ui.popup" = { fg = "text", bg = "surface0" }
-"ui.window" = { fg = "crust" }
-"ui.help" = { fg = "overlay2", bg = "surface0" }
-
-"ui.text" = "text" 
-"ui.text.focus" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
-
-"ui.virtual" = "overlay0"
-"ui.virtual.ruler" = { bg = "surface0" }
-"ui.virtual.indent-guide" = "surface0"
-
-"ui.selection" = { bg = "surface1" }
-
-"ui.cursor" = { fg = "base", bg = "secondary_cursor" }
-"ui.cursor.primary" = { fg = "base", bg = "rosewater" }
-"ui.cursor.match" = { fg = "peach", modifiers = ["bold"] }
-
-"ui.cursorline.primary" = { bg = "cursorline" }
-
-"ui.highlight" = { bg = "surface1" }
-
-"ui.menu" = { fg = "overlay2", bg = "surface0" }
-"ui.menu.selected" = { fg = "text", bg = "surface1", modifiers = ["bold"] }
-
-diagnostic = { modifiers = ["underlined"] }
-
-error = "red"
-warning = "yellow"
-info = "sky"
-hint = "teal"
+inherits = "catppuccin_mocha"
 
 [palette]
 # catppuccin palette colors
diff --git a/runtime/themes/catppuccin_mocha.toml b/runtime/themes/catppuccin_mocha.toml
index c4750b281..126613bc7 100644
--- a/runtime/themes/catppuccin_mocha.toml
+++ b/runtime/themes/catppuccin_mocha.toml
@@ -1,17 +1,17 @@
 # Syntax highlighting
 # -------------------
 "type" = "yellow"
-"type.enum.variant" = "peach"
 
 "constructor" = "sapphire"
 
 "constant" = "peach"
+"constant.builtin" = "peach"
 "constant.character" = "teal"
 "constant.character.escape" = "pink"
 
 "string" = "green"
 "string.regexp" = "peach"
-"string.special" = "pink"
+"string.special" = "blue"
 
 "comment" = { fg = "overlay1", modifiers = ["italic"] }
 
@@ -23,17 +23,19 @@
 "label" = "sapphire" # used for lifetimes
 
 "punctuation" = "overlay2"
+"punctuation.special" = "sky"
 
 "keyword" = "mauve"
+"keyword.storage.modifier.ref" = "teal"
 "keyword.control.conditional" = { fg = "mauve", modifiers = ["italic"] }
 
 "operator" = "sky"
 
 "function" = "blue"
-"function.builtin" = "peach"
-"function.macro" = "teal"
+"function.macro" = "mauve"
 
 "tag" = "mauve"
+"attribute" = "blue"
 
 "namespace" = { fg = "blue", modifiers = ["italic"] }
 
@@ -49,13 +51,14 @@
 "markup.list" = "mauve"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "peach", modifiers = ["underlined"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { fg = "rosewater", modifiers = ["underlined"] }
 "markup.link.text" = "blue"
 "markup.raw" = "flamingo"
 
 "diff.plus" = "green"
 "diff.minus" = "red"
-"diff.delta" = "yellow"
+"diff.delta" = "blue"
 
 # User Interface
 # --------------
@@ -64,25 +67,27 @@
 "ui.linenr" = { fg = "surface1" }
 "ui.linenr.selected" = { fg = "lavender" }
 
-"ui.statusline" = { fg = "overlay1", bg = "surface0" }
-"ui.statusline.inactive" = { fg = "overlay1", bg = "mantle" }
-"ui.statusline.normal" = { fg = "surface0", bg = "lavender", modifiers = ["bold"] }
-"ui.statusline.insert" = { fg = "surface0", bg = "green", modifiers = ["bold"]  }
-"ui.statusline.select" = { fg = "surface0", bg = "flamingo", modifiers = ["bold"]  }
-
-"ui.bufferline.active" = { fg = "text", bg = "base", modifiers = ["bold"] }
-"ui.bufferline" = { fg = "overlay1", bg = "mantle" }
+"ui.statusline" = { fg = "subtext1", bg = "mantle" }
+"ui.statusline.inactive" = { fg = "surface2", bg = "mantle" }
+"ui.statusline.normal" = { fg = "base", bg = "lavender", modifiers = ["bold"] }
+"ui.statusline.insert" = { fg = "base", bg = "green", modifiers = ["bold"] }
+"ui.statusline.select" = { fg = "base", bg = "flamingo", modifiers = ["bold"] }
 
 "ui.popup" = { fg = "text", bg = "surface0" }
 "ui.window" = { fg = "crust" }
 "ui.help" = { fg = "overlay2", bg = "surface0" }
 
-"ui.text" = "text" 
+"ui.bufferline" = { fg = "subtext0", bg = "mantle" }
+"ui.bufferline.active" = { fg = "mauve", bg = "base", underline = { color = "mauve", style = "line" } }
+"ui.bufferline.background" = { bg = "crust" }
+
+"ui.text" = "text"
 "ui.text.focus" = { fg = "text", bg = "surface0", modifiers = ["bold"] }
 
 "ui.virtual" = "overlay0"
 "ui.virtual.ruler" = { bg = "surface0" }
 "ui.virtual.indent-guide" = "surface0"
+"ui.virtual.inlay-hint" = { fg = "surface1", bg = "mantle" }
 
 "ui.selection" = { bg = "surface1" }
 
@@ -92,12 +97,15 @@
 
 "ui.cursorline.primary" = { bg = "cursorline" }
 
-"ui.highlight" = { bg = "surface1" }
+"ui.highlight" = { bg = "surface1", modifiers = ["bold"] }
 
 "ui.menu" = { fg = "overlay2", bg = "surface0" }
 "ui.menu.selected" = { fg = "text", bg = "surface1", modifiers = ["bold"] }
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
+"diagnostic.info" = { underline = { color = "sky", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "teal", style = "curl" } }
 
 error = "red"
 warning = "yellow"
diff --git a/runtime/themes/darcula-solid.toml b/runtime/themes/darcula-solid.toml
new file mode 100644
index 000000000..5feac234e
--- /dev/null
+++ b/runtime/themes/darcula-solid.toml
@@ -0,0 +1,19 @@
+# Original source and more info: https://github.com/jesusmgg/darcula-solid-helix
+
+inherits = "darcula"
+
+"ui.background.separator" = { bg = "grey01" }
+"ui.menu.scroll" = { fg = "grey02", bg = "grey00" }
+"ui.popup" = { fg = "grey03", bg = "grey02" }
+"ui.window" = { bg = "grey00" }
+"ui.selection" = { bg = "blue" }
+"ui.cursorline.secondary" = { bg = "grey03" }
+
+[palette]
+grey00 = "#101010"
+grey01 = "#1f1f1f"
+grey02 = "#323232"
+grey03 = "#555555"
+grey04 = "#a8a8a8"
+
+blue = "#104158"
diff --git a/runtime/themes/darcula.toml b/runtime/themes/darcula.toml
index 5e88438e2..2779a9440 100644
--- a/runtime/themes/darcula.toml
+++ b/runtime/themes/darcula.toml
@@ -56,6 +56,7 @@
 "markup.list" = "white"
 "markup.bold" = { fg = "white", modifiers = ["bold"] }
 "markup.italic" = { fg = "white", modifiers = ["italic"] }
+"markup.strikethrough" = { fg = "white", modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "lightblue", modifiers = ["underlined"] }
 "markup.link.text" = "white"
 "markup.quote" = "darkgreen"
@@ -65,7 +66,11 @@
 "diff.delta" = "grey"
 "diff.minus" = "red"
 
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl"} }
+"diagnostic.error" = { underline = { color = "red", style = "curl"} }
+"diagnostic.info" = { underline = { color = "grey05", style = "curl"} }
+"diagnostic.hint" = { underline = { color = "grey05", style = "curl"} }
+
 "info" = "grey05"
 "hint" = "grey05"
 "debug" = "grey05"
diff --git a/runtime/themes/dark_high_contrast.toml b/runtime/themes/dark_high_contrast.toml
index 1c911eb5f..51701cfce 100644
--- a/runtime/themes/dark_high_contrast.toml
+++ b/runtime/themes/dark_high_contrast.toml
@@ -8,9 +8,14 @@
 "ui.text" = "white"
 "ui.text.focus" = { modifiers = ["reversed"] } # file picker selected
 
+"ui.virtual" = "gray"
 "ui.virtual.whitespace" = "gray"
 "ui.virtual.ruler" = { fg = "white", bg = "gray" }
 "ui.virtual.indent-guide" = "white"
+"ui.virtual.inlay-hint" = { fg = "black", bg = "orange" }
+"ui.virtual.inlay-hint.parameter" = { fg = "black", bg = "orange" }
+"ui.virtual.inlay-hint.type" = { fg = "black", bg = "orange" }
+"ui.virtual.wrap" = "gray"
 
 "ui.statusline" = { fg = "white", bg = "deep_blue" }
 "ui.statusline.inactive" = { fg = "gray", bg = "deep_blue" }
@@ -22,7 +27,7 @@
 "ui.cursor" = { fg = "black", bg = "white" }
 "ui.cursor.insert" = { fg = "black", bg = "white" }
 "ui.cursor.select" = { fg = "black", bg = "white" }
-"ui.cursor.match" = { bg = "white", modifiers = ["dim"] }
+"ui.cursor.match" = { modifiers = ["reversed"] }
 "ui.cursor.primary" = { fg = "black", bg = "white", modifiers = ["slow_blink"] }
 "ui.cursor.secondary" = "white"
 "ui.cursorline.primary" = { bg = "deep_blue", underline = { color = "orange", style = "double_line" } }
@@ -84,6 +89,7 @@
 "markup.list" = "pink"
 "markup.bold" = { fg = "emerald_green", modifiers = ["bold"] }
 "markup.italic" = { fg = "blue", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "blue", underline = { color = "blue", style = "line" } }
 "markup.link.text" = "pink"
 "markup.quote" = "yellow"
diff --git a/runtime/themes/dark_plus.toml b/runtime/themes/dark_plus.toml
index b4e307986..9f4d8b87e 100644
--- a/runtime/themes/dark_plus.toml
+++ b/runtime/themes/dark_plus.toml
@@ -44,6 +44,7 @@
 "markup.list" = "blue3"
 "markup.bold" = { fg = "blue2", modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { modifiers = ["underlined"] }
 "markup.link.text" = "orange"
 "markup.quote" = "dark_green"
@@ -88,6 +89,7 @@
 "ui.virtual.whitespace" = { fg = "dark_gray" }
 "ui.virtual.ruler" = { bg = "borders" }
 "ui.virtual.indent-guide" = { fg = "dark_gray4" }
+"ui.virtual.inlay-hint" = { fg = "white", bg = "#444444" }
 
 "warning" = { fg = "gold2" }
 "error" = { fg = "red" }
diff --git a/runtime/themes/doom_acario_dark.toml b/runtime/themes/doom_acario_dark.toml
index 95dc78e0d..47f1dfca8 100644
--- a/runtime/themes/doom_acario_dark.toml
+++ b/runtime/themes/doom_acario_dark.toml
@@ -29,6 +29,7 @@
 
 'markup.bold' = { fg = 'orange', modifiers = ['bold'] }
 'markup.italic' = { fg = 'magenta', modifiers = ['italic'] }
+'markup.strikethrough' = { modifiers = ['crossed_out'] }
 'markup.heading' = { fg = 'red' }
 'markup.link' = { fg = 'orange' }
 'markup.link.url' = { fg = 'magenta' }
@@ -73,10 +74,10 @@
 'info' = { fg = 'blue', modifiers = ['bold'] }
 'hint' = { fg = 'blue', modifiers = ['bold'] }
 
-'diagnostic'= { fg = 'red', modifiers = ['underlined'] }
-'diagnostic.error'= { fg = 'red', modifiers = ['underlined'] }
-'diagnostic.info'= { fg = 'blue', modifiers = ['underlined'] }
-'diagnostic.warning'= { fg = 'yellow', modifiers = ['underlined'] }
+'diagnostic.hint'= { underline = { color = 'red', style = "curl"} }
+'diagnostic.error'= { underline = { color = 'red', style = "curl"} }
+'diagnostic.info'= { underline = { color = 'blue', style = "curl"} }
+'diagnostic.warning'= { underline = { color = 'yellow', style = "curl"} }
 
 'special' = { fg = 'orange' }
 
diff --git a/runtime/themes/dracula.toml b/runtime/themes/dracula.toml
index 90bdb446b..6935b487f 100644
--- a/runtime/themes/dracula.toml
+++ b/runtime/themes/dracula.toml
@@ -25,6 +25,8 @@
 "ui.cursor.primary" = { fg = "background", bg = "cyan", modifiers = ["dim"] }
 "ui.cursorline.primary" = { bg = "background_dark" }
 "ui.help" = { fg = "foreground", bg = "background_dark" }
+"ui.debug" = { fg = "red" }
+"ui.highlight.frameline" = { fg = "black", bg = "red" }
 "ui.linenr" = { fg = "comment" }
 "ui.linenr.selected" = { fg = "foreground" }
 "ui.menu" = { fg = "foreground", bg = "background_dark" }
@@ -40,8 +42,12 @@
 "ui.text" = { fg = "foreground" }
 "ui.text.focus" = { fg = "cyan" }
 "ui.window" = { fg = "foreground" }
-"ui.virtual.whitespace" = { fg = "comment" }
+"ui.virtual.whitespace" = { fg = "subtle" }
+"ui.virtual.wrap" = { fg = "subtle" }
 "ui.virtual.ruler" = { bg = "background_dark"}
+"ui.virtual.inlay-hint" = { fg = "comment" }
+"ui.virtual.inlay-hint.parameter" = { fg = "comment", modifiers = ["italic"] }
+"ui.virtual.inlay-hint.type" = { fg = "comment", modifiers = ["italic"] }
 
 "error" = { fg = "red" }
 "warning" = { fg = "cyan" }
@@ -50,16 +56,21 @@
 "markup.list" = "cyan"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "cyan"
 "markup.link.text" = "pink"
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
 "markup.raw" = { fg = "foreground" }
 
+"diagnostic".underline = { color = "orange", style = "curl" }
+"diagnostic.error".underline = { color = "red", style = "curl" }
+
 [palette]
 background = "#282a36"
 background_dark = "#21222c"
 primary_highlight = "#800049"
 secondary_highlight = "#4d4f66"
+subtle = "#424450"
 foreground = "#f8f8f2"
 comment = "#6272a4"
 red = "#ff5555"
@@ -69,3 +80,4 @@ green = "#50fa7b"
 purple = "#bd93f9"
 cyan = "#8be9fd"
 pink = "#ff79c6"
+
diff --git a/runtime/themes/dracula_at_night.toml b/runtime/themes/dracula_at_night.toml
index 4a32f930f..b2e3b9a9f 100644
--- a/runtime/themes/dracula_at_night.toml
+++ b/runtime/themes/dracula_at_night.toml
@@ -25,6 +25,8 @@
 "ui.cursor.match" = { fg = "green", modifiers = ["underlined"] }
 "ui.cursor.primary" = { fg = "background", bg = "cyan", modifiers = ["dim"] }
 "ui.help" = { fg = "foreground", bg = "background_dark" }
+"ui.debug" = { fg = "red" }
+"ui.highlight.frameline" = { fg = "black", bg = "red" }
 "ui.linenr" = { fg = "comment" }
 "ui.linenr.selected" = { fg = "foreground" }
 "ui.menu" = { fg = "foreground", bg = "background_dark" }
@@ -50,6 +52,7 @@
 "markup.list" = "cyan"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "cyan"
 "markup.link.text" = "pink"
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
diff --git a/runtime/themes/emacs.toml b/runtime/themes/emacs.toml
index cc725df8d..513af60e1 100644
--- a/runtime/themes/emacs.toml
+++ b/runtime/themes/emacs.toml
@@ -37,6 +37,7 @@
 "markup.list" = { fg = "black" }
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "royalblue3", modifiers = ["underlined"] }
 "markup.link.text" = { fg = "royalblue3" }
 "markup.quote" = { fg = "gray60" }
@@ -45,7 +46,7 @@
 
 "ui.background" = { fg = "black", bg = "white" }
 "ui.background.separator" = { fg = "black", bg = "white" }
-"ui.cursor" =  { fg = "white", bg = "gray70" }
+"ui.cursor" = { fg = "white", bg = "gray70" }
 "ui.cursor.primary" = { fg = "white", bg = "black" }
 "ui.cursor.match" = { fg = "black", bg = "turquoise" }
 "ui.cursor.select" = { fg = "white", bg = "black" }
@@ -68,19 +69,24 @@
 "ui.selection" = { bg = "lightgoldenrod1" }
 "ui.selection.primary" = { bg = "lightgoldenrod2" }
 "ui.virtual.whitespace" = "highlight"
-"ui.virtual.ruler" = { bg ="gray95" }
+"ui.virtual.ruler" = { bg = "gray95" }
+"ui.virtual.inlay-hint" = { fg = "gray75" }
 "ui.cursorline.primary" = { bg = "darkseagreen2" }
 "ui.cursorline.secondary" = { bg = "darkseagreen2" }
 
-"diff.plus" = { fg = "#22aa22", bg = "#eeffee" }
-"diff.delta" = { fg = "#aaaa22", bg = "#ffffcc" }
-"diff.minus" = { fg = "#aa2222", bg = "#ffdddd" }
+"diff.plus" = { fg = "green3" }
+"diff.delta" = { fg = "orange2" }
+"diff.minus" = { fg = "red2" }
 
 "error" = { fg = "red1" }
 "warning" = { fg = "dark_orange" }
 "info" = { fg = "forest_green" }
 "hint" = { fg = "dark_cyan" }
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.error" = { underline = { color = "red1", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "dark_orange", style = "curl" } }
+"diagnostic.info" = { underline = { color = "forest_green", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "dark_cyan", style = "curl" } }
 
 [palette]
 black = "#000000"
diff --git a/runtime/themes/everblush.toml b/runtime/themes/everblush.toml
new file mode 100644
index 000000000..edcdaf41b
--- /dev/null
+++ b/runtime/themes/everblush.toml
@@ -0,0 +1,114 @@
+# Author: Isotoxal <isotoxal@proton.me>
+
+"attribute" = { fg = "blue" }
+"comment" = { fg = "comment", modifiers = ["italic"] }
+"constant" = { fg = "cyan" }
+"constant.builtin.boolean" = { fg = "cyan" }
+"constant.character" = { fg = "blue" }
+"constant.numeric.float" = { fg = "black-light" }
+"constant.builtin" = { fg = "blue" }
+"constant.numeric" = { fg = "yellow" }
+"constructor" = { fg = "blue" }
+"function" = { fg = "red" }
+"function.builtin" = { fg = "cyan-light" }
+"function.macro" = { fg = "green" }
+"function.method" = { fg = "blue-light" }
+"keyword" = { fg = "blue" }
+"keyword.function" = { fg = "blue" }
+"keyword.operator" = { fg = "blue-light" }
+"keyword.control.conditional" = { fg = "red" }
+"keyword.control.import" = { fg = "red-light" }
+"keyword.control.return" = { fg = "blue" }
+"keyword.control.repeat" = { fg = "yellow-light" }
+"keyword.control.exception" = { fg = "black-light" }
+"label" = { fg = "blue" }
+"namespace" = { fg = "red-light" }
+"operator" = { fg = "white" }
+#"parameter.reference" = { fg = "red-light" }
+#"property" = { fg = "red" }
+"punctuation.bracket" = { fg = "white" }
+"punctuation.delimiter" = { fg = "white" }
+"punctuation.special" = { fg = "white" }
+"string" = { fg = "green" }
+"string.escape" = { fg = "blue" }
+"string.regex" = { fg = "green" }
+"string.special" = { fg = "blue" }
+"string.special.symbol" = { fg = "red" }
+"tag" = { fg = "blue" }
+"type" = { fg = "yellow" }
+"type.builtin" = { fg = "yellow" }
+"variable" = { fg = "white" }
+"variable.builtin" = { fg = "blue" }
+"variable.parameter" = { fg = "red" }
+"variable.other.member" = { fg = "red" }
+
+"diff.plus" = { fg = "blue" }
+"diff.delta" = { fg = "magenta" }
+"diff.minus" = { fg = "red" }
+
+"ui.background" = { fg = "foreground", bg = "background" }
+"ui.cursor" = { modifiers = ["reversed"] }
+"ui.cursorline.primary" = { bg = "cursorline" }
+"ui.help" = { fg = "foreground", bg = "contrast" }
+"ui.linenr" = { fg = "comment" }
+"ui.linenr.selected" = { fg = "foreground" }
+"ui.menu" = { fg = "foreground", bg = "contrast" }
+"ui.menu.selected" = { bg = "black" }
+"ui.popup" = { fg = "foreground", bg = "contrast" }
+"ui.selection" = { bg = "black" }
+"ui.selection.primary" = { bg = "black" }
+"ui.statusline" = { fg = "foreground", bg = "background" }
+"ui.statusline.inactive" = { fg = "foreground", bg = "background" }
+"ui.statusline.normal" = { fg = "white", bg = "background" }
+"ui.statusline.insert" = { fg = "blue", bg = "background" }
+"ui.statusline.select" = { fg = "cyan", bg = "magenta" }
+"ui.text" = { fg = "foreground" }
+"ui.text.focus" = { fg = "blue" }
+"ui.virtual.ruler" = { bg = "cursorline" }
+"ui.virtual.whitespace" = { fg = "comment" }
+"ui.virtual.wrap" = { fg = "comment" }
+"ui.virtual.indent-guide" = { fg = "comment" }
+"ui.window" = { fg = "black" }
+
+"error" = { fg = "red" }
+"hint" = { fg = "green" }
+"warning" = { fg = "yellow" }
+"info" = { fg = "blue" }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.info" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "green" } }
+"special" = { fg = "red-light" }
+
+"markup.heading" = { fg = "blue", modifiers = ["bold"] }
+"markup.list" = { fg = "cyan" }
+"markup.bold" = { fg = "magenta", modifiers = ["bold"] }
+"markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { fg = "green" }
+"markup.link.text" = { fg = "black-light" }
+"markup.quote" = { fg = "yellow", modifiers = ["italic"] }
+"markup.raw" = { fg = "cyan" }
+
+[palette]
+black = "#232a2d"
+red = "#e57474"
+green = "#8ccf7e"
+yellow = "#e5c76b"
+blue = "#67b0e8"
+magenta = "#c47fd5"
+cyan = "#6cbfbf"
+white = "#b3b9b8"
+black-light = "#2d3437"
+red-light = "#ef7e7e"
+green-light = "#96d988"
+yellow-light = "#f4d67a"
+blue-light = "#71baf2"
+magenta-light = "#ce89df"
+cyan-light = "#67cbe7"
+white-light = "#bdc3c2"
+comment = "#404749"
+contrast = "#161d1f"
+background = "#141b1e"
+foreground = "#dadada"
+cursorline = "#2c3333"
diff --git a/runtime/themes/everforest_dark.toml b/runtime/themes/everforest_dark.toml
index 63997c9c2..4947e4f3b 100644
--- a/runtime/themes/everforest_dark.toml
+++ b/runtime/themes/everforest_dark.toml
@@ -46,6 +46,7 @@
 "markup.list" = "red"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "blue", modifiers = ["underlined"] }
 "markup.link.text" = "purple"
 "markup.quote" = "grey2"
@@ -88,7 +89,12 @@
 "info" = "aqua"
 "warning" = "yellow"
 "error" = "red"
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.hint" = { underline = { color = "blue", style = "curl" } }
+"diagnostic.info" = { underline = { color = "aqua", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+
 
 [palette]
 
diff --git a/runtime/themes/everforest_light.toml b/runtime/themes/everforest_light.toml
index 08876c0c6..f9a55b0a8 100644
--- a/runtime/themes/everforest_light.toml
+++ b/runtime/themes/everforest_light.toml
@@ -46,6 +46,7 @@
 "markup.list" = "red"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "blue", modifiers = ["underlined"] }
 "markup.link.text" = "purple"
 "markup.quote" = "grey2"
@@ -88,7 +89,11 @@
 "info" = "aqua"
 "warning" = "yellow"
 "error" = "red"
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.hint" = { underline = { color = "blue", style = "curl" } }
+"diagnostic.info" = { underline = { color = "aqua", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
 
 [palette]
 
diff --git a/runtime/themes/ferra.toml b/runtime/themes/ferra.toml
new file mode 100644
index 000000000..da5339e2e
--- /dev/null
+++ b/runtime/themes/ferra.toml
@@ -0,0 +1,84 @@
+# Author : Casper Rogild Storm <casper@asynkron.xyz>
+
+"comment" = { fg = "ferra_bark", modifiers = ["italic"] }
+"constant" = { fg = "ferra_sage" }
+"function" = { fg = "ferra_coral" }
+"function.macro" = { fg = "ferra_mist" }
+"keyword" = { fg = "ferra_mist" }
+"operator" = { fg = "ferra_mist" }
+"punctuation" = { fg = "ferra_blush" }
+"string" = { fg = "ferra_sage" }
+"type" = { fg = "ferra_rose" }
+"variable" = { fg = "ferra_blush" }
+"variable.builtin" = { fg = "ferra_rose" }
+"tag" = { fg = "ferra_sage" }
+"label" = { fg = "ferra_sage" }
+"attribute" = { fg = "ferra_blush" }
+"namespace" = { fg = "ferra_blush" }
+"module" = { fg = "ferra_blush" }
+
+"markup.heading" = { fg = "ferra_sage", modifiers = ["bold"] }
+"markup.heading.marker" = { fg = "ferra_bark" }
+"markup.list" = { fg = "ferra_mist" }
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { fg = "ferra_rose", modifiers = ["underlined"] }
+"markup.link.text" = { fg = "ferra_rose" }
+"markup.quote" = { fg = "ferra_bark" }
+"markup.raw" = { fg = "ferra_coral" }
+
+"ui.background" = { bg = "ferra_night" }
+"ui.cursor" = { fg = "ferra_night", bg = "ferra_blush" }
+"ui.cursor.match" = { fg = "ferra_night", bg = "ferra_bark" }
+"ui.cursor.select" = { fg = "ferra_night", bg = "ferra_rose" }
+"ui.cursor.insert" = { fg = "ferra_night", bg = "ferra_coral" }
+"ui.linenr" = { fg = "ferra_bark" }
+"ui.linenr.selected" = { fg = "ferra_blush" }
+"ui.cursorline" = { fg = "ferra_blush", bg = "ferra_ash" }
+"ui.statusline" = { fg = "ferra_blush", bg = "ferra_ash" }
+"ui.statusline.inactive" = { fg = "ferra_bark", bg = "ferra_ash" }
+"ui.statusline.normal" = { fg = "ferra_ash", bg = "ferra_blush" }
+"ui.statusline.insert" = { fg = "ferra_ash", bg = "ferra_coral" }
+"ui.statusline.select" = { fg = "ferra_ash", bg = "ferra_rose" }
+"ui.popup" = { fg = "ferra_blush", bg = "ferra_ash" }
+"ui.window" = { fg = "ferra_bark", bg = "ferra_night" }
+"ui.help" = { fg = "ferra_blush", bg = "ferra_ash" }
+"ui.text" = { fg = "ferra_blush" }
+"ui.text.focus" = { fg = "ferra_coral" }
+"ui.menu" = { fg = "ferra_blush", bg = "ferra_ash" }
+"ui.menu.selected" = { fg = "ferra_coral", bg = "ferra_ash" }
+"ui.selection" = { bg = "ferra_umber", fg = "ferra_night" }
+"ui.selection.primary" = { bg = "ferra_night", fg = "ferra_umber" }
+"ui.virtual" = { fg = "ferra_bark" }
+"ui.virtual.whitespace" = { fg = "ferra_bark" }
+"ui.virtual.ruler" = { fg = "ferra_night", bg = "ferra_ash" }
+"ui.virtual.indent-guide" = { fg = "ferra_ash" }
+"ui.virtual.inlay-hint" = { fg = "ferra_bark" }
+
+"diff.plus" = { fg = "ferra_sage" }
+"diff.delta" = { fg = "ferra_blush" }
+"diff.minus" = { fg = "ferra_ember" }
+
+"error" = { fg = "ferra_ember" }
+"warning" = { fg = "ferra_honey" }
+"info" = { fg = "ferra_blush" }
+"hint" = { fg = "ferra_blush" }
+
+"diagnostic.warning" = { underline = { color = "ferra_honey", style = "curl" } }
+"diagnostic.error" = { underline = { color = "ferra_ember", style = "curl" } }
+"diagnostic.info" = { underline = { color = "ferra_blush", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "ferra_blush", style = "curl" } }
+
+[palette]
+ferra_night = "#2b292d"
+ferra_ash = "#383539"
+ferra_umber = "#4d424b"
+ferra_bark = "#6F5D63"
+ferra_mist = "#D1D1E0"
+ferra_sage = "#B1B695"
+ferra_blush = "#fecdb2"
+ferra_coral = "#ffa07a"
+ferra_rose = "#F6B6C9"
+ferra_ember = "#e06b75"
+ferra_honey = "#F5D76E"
diff --git a/runtime/themes/flatwhite.toml b/runtime/themes/flatwhite.toml
index 2fdc66d0f..d833d5c66 100644
--- a/runtime/themes/flatwhite.toml
+++ b/runtime/themes/flatwhite.toml
@@ -21,6 +21,11 @@
 "variable.parameter" = { fg = "blue_text", bg = "blue_bg" }
 
 "diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.info" = { underline = { color = "orange_text", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "orange_text", style = "curl" } }
+"diagnostic.error" = { underline = { color = "diff_delete", style = "curl" } }
+
 "info" = { fg = "orange_text", bg = "orange_bg" }
 "hint" = { modifiers = ["bold"] }
 "warning" = { fg = "orange_text", bg = "orange_bg" }
@@ -32,14 +37,15 @@
 "markup.raw" = { fg = "orange_text", bg = "orange_bg" }
 "markup.raw.inline" = { fg = "orange_text", bg = "orange_bg" }
 "markup.raw.block" = { fg = "orange_text", bg = "orange_bg" }
+"markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "blue_text", bg = "blue_bg", modifiers = [
   "underlined",
 ] }
 "markup.link.label" = { fg = "blue_text", bg = "blue_bg" }
 "markup.link.text" = { fg = "blue_text", bg = "blue_bg" }
 "markup.quote" = { fg = "teal_text", bg = "teal_bg" }
-"markup.bold" = { modifiers = ["bold"] }
 "markup.list" = { fg = "purple_text", bg = "purple_bg" }
 
 "ui.background" = { fg = "base1", bg = "base7" }
@@ -53,6 +59,9 @@
 "ui.virtual" = { fg = "base5", bg = "base6" }
 "ui.virtual.whitespace" = { fg = "base5" }
 "ui.virtual.ruler" = { bg = "base6" }
+"ui.virtual.inlay-hint" = { fg = "base4", modifiers = ["normal"] }
+"ui.virtual.inlay-hint.parameter" = { fg = "base3", modifiers = ["normal"] }
+"ui.virtual.inlay-hint.type" = { fg = "base3", modifiers = ["italic"] }
 
 "ui.linenr" = { bg = "base6" }
 "ui.linenr.selected" = { bg = "base6", modifiers = ["reversed"] }
diff --git a/runtime/themes/fleet_dark.toml b/runtime/themes/fleet_dark.toml
index f885e4eb6..b5ad1aa3e 100644
--- a/runtime/themes/fleet_dark.toml
+++ b/runtime/themes/fleet_dark.toml
@@ -4,127 +4,163 @@
 # Original author: @krfl
 # Contributors:
 # @matoous
+# @kirawi
 
-"attribute" = "green"
-"type" = "light_blue"
-"type.enum.variant" = "purple"
-"constructor" = "yellow"
-"constant" = "cyan"
+"attribute" = "Lime"
+
+"type" = "Blue"
+"type.return" = "Blue Light"
+"type.parameter" = "Blue Light"
+"constructor" = "Yellow"
+
+"constant" = "Violet"
 # "constant.builtin" = {} # .boolean
-"constant.builtin.boolean" = "yellow"
-"constant.character" = "yellow"
-"constant.characted.escape" = "light"
-"constant.numeric" = "yellow"
-"string" = "pink"
-"string.regexp" = "light"
-"string.special" = { fg = "yellow", modifiers = ["underlined"] } #.path / .url / .symbol
-"comment" = "light_gray" # .line
+"constant.builtin.boolean" = "Cyan"
+"constant.character" = "Yellow"
+"constant.character.escape" = "Cyan"
+"constant.numeric" = "Yellow"
+"string" = "Pink"
+"string.regexp" = "Cyan"
+"string.special" = { fg = "Yellow", modifiers = ["underlined"] } #.path / .url / .symbol
+
+"comment" = "Gray 90" # .line
 # "comment.block" = {} # .documentation
-"variable" = "light" # .builtin
-"variable.builtin" = { fg = "red", modifiers = ["underlined"] }
-"variable.parameter" = "light"
+"variable" = "Gray 120" # .builtin
+"variable.builtin" = { fg = "Coral" }
 # "variable.other" = {} # .member
-"variable.other.member" = "purple"
-"label" = "yellow"
-"punctuation" = "light" # .delimiter / .bracket
-"keyword" = "cyan" # .operator / .directive / .function
-# "keyword.control" = "cyan" # .conditional / .repeat / .import / .return / .exception
-"keyword.control.exception" = "purple"
-"operator" = "light"
-"function" = "yellow"
-"function.macro" = "green"
-"function.builtin" = "green"
-"function.special" = "green"
-"function.method" = "light"
+"variable.other.member" = "Violet"
+"label" = "Yellow"
+"keyword" = "Cyan" # .operator / .directive / .function
+"function" = "Yellow"
+"function.declaration" = "#EFEFEF"
+"function.macro" = "Lime"
+"function.builtin" = "Lime"
+"function.special" = "Lime"
 #"function.declaration.method" = { fg = "lightest", modifiers = ["bold"] } #depends on #4892
-"tag" = "light_blue"
-"special" = "green"
-"namespace" = "light"
+"tag" = "Blue"
+"special" = "Lime"
+"namespace" = "Blue"
 
 # used in theming
 # "markup" = {} # .normal / .quote / .raw
 # "markup.normal" = {} # .completion / .hover
-"markup.bold" = { fg = "lightest", modifiers = ["bold"] }
+"markup.bold" = {  modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
-"markup.heading" = { fg = "cyan", modifiers = ["bold"] } # .marker / .1 / .2 / .3 / .4 / .5 / .6
-"markup.list" = "pink" # .unnumbered / .numbered
-"markup.list.numbered" = "cyan"
-"markup.list.unnumbered" = "cyan"
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.heading" = { fg = "Cyan", modifiers = ["bold"] } # .marker / .1 / .2 / .3 / .4 / .5 / .6
+"markup.list" = "Pink" # .unnumbered / .numbered
+"markup.list.numbered" = "Cyan"
+"markup.list.unnumbered" = "Cyan"
 # "markup.link" = "green"
-"markup.link.url" = { fg = "pink", modifiers = ['italic', 'underlined'] }
-"markup.link.text" = "cyan"
-"markup.link.label" = "purple"
-"markup.quote" = "pink"
-"markup.raw" = "pink"
-"markup.raw.inline" = "cyan" # .completion / .hover
-"markup.raw.block" = "pink"
-
-"diff.plus" = "diff_plus"
-"diff.minus" = "red_accent"
-"diff.delta" = "blue_accent"
+"markup.link.url" = { fg = "Pink", modifiers = ['italic', 'underlined'] }
+"markup.link.text" = "Cyan"
+"markup.link.label" = "Purple 20"
+"markup.quote" = "Pink"
+"markup.raw" = "Pink"
+"markup.raw.inline" = "Cyan" # .completion / .hover
+"markup.raw.block" = "#EB83E2"
+
+"diff.plus" = "Green 50"
+"diff.minus" = "Red 50"
+"diff.delta" = "Blue 80"
 
 # ui specific
-"ui.background" = { bg = "background" } # .separator
-"ui.cursor" = { bg = "dark_gray", modifiers = ["reversed"] } # .insert / .select / .match / .primary
-"ui.cursor.match" = { fg = "light", bg = "selection" } # .insert / .select / .match / .primary
-"ui.cursorline" = { bg = "darker" }
-"ui.linenr" = "dark_gray"
-"ui.linenr.selected" = { fg = "light", bg = "darker" }
-"ui.statusline" = { fg = "light", bg = "darker" } # .inactive / .normal / .insert / .select
-"ui.statusline.inactive" = { fg = "dark", bg = "darker" }
-"ui.statusline.normal" = { fg = "lightest", bg = "darker"}
-"ui.statusline.insert" = { fg = "lightest", bg = "blue_accent" }
-"ui.statusline.select" = { fg = "lightest", bg = "orange_accent" }
-"ui.popup" = { fg = "light", bg = "darkest" } # .info
-"ui.window" = { fg = "dark", bg = "darkest" }
-"ui.help" = { fg = "light", bg = "darkest" }
-"ui.text" = "light" # .focus / .info
-"ui.text.focus" = { fg = "lightest", bg = "focus" }
-"ui.virtual" = "dark" # .whitespace
-"ui.virtual.ruler" = { bg = "darker"}
-"ui.menu" = { fg = "light", bg = "darkest" } # .selected
-"ui.menu.selected" = { fg = "lightest", bg = "focus" } # .selected
-"ui.selection" = { bg = "darker" } # .primary
-"ui.selection.primary" = { bg = "selection" }
-"hint" = "blue"
-"info" = "yellow_accent"
-"warning" = "orange_accent"
-"error" = "red_error"
-"diagnostic" = { modifiers = [] }
-"diagnostic.hint" = { underline = { color = "light", style = "line" } }
-"diagnostic.info" = { underline = { color = "blue_accent", style = "line" } }
-"diagnostic.warning" = { underline = { color = "yellow_accent", style = "line" } }
-"diagnostic.error" = { underline = { color = "red_error", style = "line" } }
+"ui.background" = { bg = "Gray 10" } # .separator
+"ui.statusline" = { fg = "Gray 120", bg = "Gray 20" } # .inactive / .normal / .insert / .select
+"ui.statusline.normal" = { fg = "Gray 120", bg = "Gray 20" }
+"ui.statusline.inactive" = { fg = "Gray 90"}
+"ui.statusline.insert" = { fg = "Gray 20", bg = "Blue 90" }
+"ui.statusline.select" = { fg = "Gray 20", bg = "Yellow 60" }
+
+"ui.cursor" = { modifiers = ["reversed"] } # .insert / .select / .match / .primary
+"ui.cursor.match" = { bg = "Blue 30" } # .insert / .select / .match / .primary
+"ui.selection" = { bg = "Gray 50" } # .primary
+"ui.selection.primary" = { bg = "Blue 40" }
+
+"ui.cursorline" = { bg = "Gray 20" }
+"ui.linenr" = "Gray 70"
+"ui.linenr.selected" = "Gray 110"
+
+"ui.popup" = { fg = "Gray 120", bg = "Gray 20" } # .info
+"ui.window" = { fg = "Gray 50" }
+"ui.help" = { fg = "Gray 120", bg = "Gray 20" }
+"ui.menu" = { fg = "Gray 120", bg = "Gray 20" } # .selected
+"ui.menu.selected" = { fg = "White", bg = "Blue 40" } # .selected
+# Calculated as #ffffff with 30% opacity
+"ui.menu.scroll" = { fg = "#dfdfdf" }
+
+"ui.text" = "Gray 120" # .focus / .info
+"ui.text.focus" = { fg = "White", bg = "Blue 40" }
+
+"ui.virtual" = "Gray 90" # .whitespace
+"ui.virtual.inlay-hint" = { fg = "Gray 70" }
+"ui.virtual.ruler" = { bg = "Gray 20" }
+
+"hint" = "Gray 80"
+"info" = "#A366C4"
+"warning" = "#FACb66"
+"error" = "#FF5269"
+
+"diagnostic.hint" = { underline = { color = "Gray 80", style = "line" } }
+"diagnostic.info" = { underline = { color = "#A366C4", style = "line" } }
+"diagnostic.warning" = { underline = { color = "#FACB66", style = "line" } }
+"diagnostic.error" = { underline = { color = "#FF5269", style = "line" } }
 
 [palette]
-background = "#181818"
-darkest = "#1e1e1e"
-darker = "#292929"
-dark = "#898989"
-
-light = "#d6d6dd"
-lightest = "#ffffff"
-
-dark_gray = "#535353"
-light_gray = "#6d6d6d"
-purple = "#a390f0"
-light_blue = "#7dbeff"
-blue = "#52a7f6"
-pink = "#d898d8"
-green = "#afcb85"
-cyan = "#78d0bd"
-orange = "#efb080"
-yellow = "#e5c995"
-red = "#CC7C8A"
-
-blue_accent = "#2197F3"
-pink_accent = "#E44C7A"
-green_accent = "#00AF99"
-orange_accent = "#EE7F25"
-yellow_accent = "#DEA407"
-red_accent = "#F44747"
-
-red_error = "#EB5F6A"
-selection = "#1F3661"
-diff_plus = "#5A9F81"
-focus = "#204474"
+"White" = "#ffffff"
+"Gray 120" = "#d1d1d1"
+"Gray 110" = "#c2c2c2"
+"Gray 100" = "#a0a0a0"
+"Gray 90" = "#898989"
+"Gray 80" = "#767676"
+"Gray 70" = "#5d5d5d"
+"Gray 60" = "#484848"
+"Gray 50" = "#383838"
+"Gray 40" = "#333333"
+"Gray 30" = "#2d2d2d"
+"Gray 20" = "#292929"
+"Gray 10" = "#181818"
+"Black" = "#000000"
+"Blue 110" = "#6daaf7"
+"Blue 100" = "#4d9bf8"
+"Blue 90" = "#3691f9"
+"Blue 80" = "#1a85f6"
+"Blue 70" = "#0273eb"
+"Blue 60" = "#0c6ddd"
+"Blue 50" = "#195eb5"
+"Blue 40" = "#194176"
+"Blue 30" = "#163764"
+"Blue 20" = "#132c4f"
+"Blue 10" = "#0b1b32"
+"Red 80" = "#ec7388"
+"Red 70" = "#ea4b67"
+"Red 60" = "#d93953"
+"Red 50" = "#ce364d"
+"Red 40" = "#c03248"
+"Red 30" = "#a72a3f"
+"Red 20" = "#761b2d"
+"Red 10" = "#390813"
+"Green 50" = "#4ca988"
+"Green 40" = "#3ea17f"
+"Green 30" = "#028764"
+"Green 20" = "#134939"
+"Green 10" = "#081f19"
+"Yellow 60" = "#f8ab17"
+"Yellow 50" = "#e1971b"
+"Yellow 40" = "#b5791f"
+"Yellow 30" = "#7c511a"
+"Yellow 20" = "#5a3a14"
+"Yellow 10" = "#281806"
+"Purple 20" = "#c07bf3"
+"Purple 10" = "#b35def"
+
+"Blue" = "#87C3FF"
+"Blue Light" = "#ADD1DE"
+"Coral" = "#CC7C8A"
+"Cyan" = "#82D2CE"
+"Cyan Dark" = "#779E9E"
+"Lime" = "#A8CC7C"
+"Orange" = "#E09B70"
+"Pink" = "#E394DC"
+"Violet" = "#AF9CFF"
+"Yellow" = "#EBC88D"
diff --git a/runtime/themes/github_dark.toml b/runtime/themes/github_dark.toml
new file mode 100644
index 000000000..4f9aa562b
--- /dev/null
+++ b/runtime/themes/github_dark.toml
@@ -0,0 +1,229 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+attribute = "fg.default"
+keyword = "scale.red.3"
+"keyword.directive" = "scale.red.3"          # -- preprocessor comments (#if in C)
+namespace = "scale.orange.2"
+punctuation = "fg.default"
+"punctuation.delimiter" = "fg.default"
+operator = "scale.blue.1"
+special = "scale.blue.1"
+"variable.other.member" = "scale.blue.1"
+variable = "fg.default"
+"variable.parameter" = "scale.orange.2"
+"variable.builtin" = "scale.red.3"
+type = "scale.orange.2"
+"type.builtin" = "scale.blue.2"
+constructor = "scale.purple.2"
+function = "scale.purple.2"
+"function.macro" = "scale.purple.2"
+tag = "scale.green.1"
+comment = "fg.muted"
+constant = "scale.blue.2"
+"constant.builtin" = "scale.blue.2"
+string = "scale.blue.1"
+"constant.numeric" = "scale.blue.2"
+"constant.character.escape" = "scale.blue.2"
+# used for lifetimes
+label = "scale.red.3"
+
+"markup.heading" = "scale.blue.2"
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { modifiers = ["underlined"] }
+"markup.link.text" = { fg = "scale.blue.1", modifiers = ["underlined"] }
+"markup.raw" = "scale.blue.2"
+
+"diff.plus" = "open.fg"
+"diff.minus" = "closed.fg"
+"diff.delta" = "attention.fg"
+
+"ui.background" = { bg = "canvas.default" }
+"ui.background.separator" = { fg = "fg.subtle" }
+"ui.linenr" = { fg = "fg.subtle" }
+"ui.linenr.selected" = { fg = "fg.default" }
+"ui.statusline" = { fg = "fg.muted", bg = "scale.gray.7" }
+"ui.statusline.active" = { fg = "fg.default", bg = "canvas.default", underline = { color = "scale.coral.3", style = "line" } }
+"ui.statusline.normal" = { fg = "fg.default", bg = "accent.muted" }
+"ui.statusline.insert" = { fg = "fg.default", bg = "attention.muted" }
+"ui.statusline.select" = { fg = "fg.default", bg = "sponsors.muted" }
+"ui.popup" = { bg = "scale.gray.8" }
+"ui.popup.info" = { fg = "fg.default", bg = "canvas.overlay" }
+"ui.window" = { fg = "border.default" }
+"ui.help" = { fg = "fg.default", bg = "canvas.overlay" }
+
+"ui.text" = { fg = "fg.muted" }
+"ui.text.focus" = { fg = "fg.default" }
+"ui.text.inactive" = "fg.subtle"
+"ui.virtual" = { fg = "scale.gray.6" }
+
+"ui.selection" = { bg = "scale.blue.8" }
+"ui.selection.primary" = { bg = "scale.blue.7" }
+"ui.cursor.match" = { fg = "attention.fg", modifiers = [
+    "bold",
+], underline = { style = "line" } }
+"ui.cursor" = { modifiers = ["reversed"] }
+"ui.cursorline.primary" = { bg = "canvas.subtle" }
+
+"ui.menu" = { fg = "fg.default", bg = "canvas.overlay" }
+"ui.menu.selected" = { bg = "scale.gray.4" }
+"ui.menu.scroll" = { fg = "scale.gray.5", bg = "canvas.overlay" }
+
+"diagnostic.hint" = { underline = { color = "success.fg", style = "curl" } }
+"diagnostic.info" = { underline = { color = "accent.fg", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "attention.fg", style = "curl" } }
+"diagnostic.error" = { underline = { color = "danger.fg", style = "curl" } }
+
+hint = "success.fg"
+info = "accent.fg"
+warning = "attention.fg"
+error = "danger.fg"
+
+[palette]
+"accent.emphasis" = "#1f6feb"
+"accent.fg" = "#58a6ff"
+"accent.muted" = "#388bfd66"
+"accent.subtle" = "#388bfd26"
+"attention.emphasis" = "#9e6a03"
+"attention.fg" = "#d29922"
+"attention.muted" = "#bb800966"
+"attention.subtle" = "#bb800926"
+"border.default" = "#30363d"
+"border.muted" = "#21262d"
+"border.subtle" = "#f0f6fc1a"
+"canvas.default" = "#0d1117"
+"canvas.inset" = "#010409"
+"canvas.overlay" = "#161b22"
+"canvas.subtle" = "#161b22"
+"closed.emphasis" = "#da3633"
+"closed.fg" = "#f85149"
+"closed.muted" = "#f8514966"
+"closed.subtle" = "#f8514926"
+"danger.emphasis" = "#da3633"
+"danger.fg" = "#f85149"
+"danger.muted" = "#f8514966"
+"danger.subtle" = "#f8514926"
+"done.emphasis" = "#8957e5"
+"done.fg" = "#a371f7"
+"done.muted" = "#a371f766"
+"done.subtle" = "#a371f726"
+"fg.default" = "#c9d1d9"
+"fg.muted" = "#8b949e"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7681"
+"neutral.emphasis" = "#6e7681"
+"neutral.emphasisPlus" = "#6e7681"
+"neutral.muted" = "#6e768166"
+"neutral.subtle" = "#6e76811a"
+"open.emphasis" = "#238636"
+"open.fg" = "#3fb950"
+"open.muted" = "#2ea04366"
+"open.subtle" = "#2ea04326"
+"scale.black" = "#010409"
+"scale.blue.0" = "#cae8ff"
+"scale.blue.1" = "#a5d6ff"
+"scale.blue.2" = "#79c0ff"
+"scale.blue.3" = "#58a6ff"
+"scale.blue.4" = "#388bfd"
+"scale.blue.5" = "#1f6feb"
+"scale.blue.6" = "#1158c7"
+"scale.blue.7" = "#0d419d"
+"scale.blue.8" = "#0c2d6b"
+"scale.blue.9" = "#051d4d"
+"scale.coral.0" = "#ffddd2"
+"scale.coral.1" = "#ffc2b2"
+"scale.coral.2" = "#ffa28b"
+"scale.coral.3" = "#f78166"
+"scale.coral.4" = "#ea6045"
+"scale.coral.5" = "#cf462d"
+"scale.coral.6" = "#ac3220"
+"scale.coral.7" = "#872012"
+"scale.coral.8" = "#640d04"
+"scale.coral.9" = "#460701"
+"scale.gray.0" = "#f0f6fc"
+"scale.gray.1" = "#c9d1d9"
+"scale.gray.2" = "#b1bac4"
+"scale.gray.3" = "#8b949e"
+"scale.gray.4" = "#6e7681"
+"scale.gray.5" = "#484f58"
+"scale.gray.6" = "#30363d"
+"scale.gray.7" = "#21262d"
+"scale.gray.8" = "#161b22"
+"scale.gray.9" = "#0d1117"
+"scale.green.0" = "#aff5b4"
+"scale.green.1" = "#7ee787"
+"scale.green.2" = "#56d364"
+"scale.green.3" = "#3fb950"
+"scale.green.4" = "#2ea043"
+"scale.green.5" = "#238636"
+"scale.green.6" = "#196c2e"
+"scale.green.7" = "#0f5323"
+"scale.green.8" = "#033a16"
+"scale.green.9" = "#04260f"
+"scale.orange.0" = "#ffdfb6"
+"scale.orange.1" = "#ffc680"
+"scale.orange.2" = "#ffa657"
+"scale.orange.3" = "#f0883e"
+"scale.orange.4" = "#db6d28"
+"scale.orange.5" = "#bd561d"
+"scale.orange.6" = "#9b4215"
+"scale.orange.7" = "#762d0a"
+"scale.orange.8" = "#5a1e02"
+"scale.orange.9" = "#3d1300"
+"scale.pink.0" = "#ffdaec"
+"scale.pink.1" = "#ffbedd"
+"scale.pink.2" = "#ff9bce"
+"scale.pink.3" = "#f778ba"
+"scale.pink.4" = "#db61a2"
+"scale.pink.5" = "#bf4b8a"
+"scale.pink.6" = "#9e3670"
+"scale.pink.7" = "#7d2457"
+"scale.pink.8" = "#5e103e"
+"scale.pink.9" = "#42062a"
+"scale.purple.0" = "#eddeff"
+"scale.purple.1" = "#e2c5ff"
+"scale.purple.2" = "#d2a8ff"
+"scale.purple.3" = "#bc8cff"
+"scale.purple.4" = "#a371f7"
+"scale.purple.5" = "#8957e5"
+"scale.purple.6" = "#6e40c9"
+"scale.purple.7" = "#553098"
+"scale.purple.8" = "#3c1e70"
+"scale.purple.9" = "#271052"
+"scale.red.0" = "#ffdcd7"
+"scale.red.1" = "#ffc1ba"
+"scale.red.2" = "#ffa198"
+"scale.red.3" = "#ff7b72"
+"scale.red.4" = "#f85149"
+"scale.red.5" = "#da3633"
+"scale.red.6" = "#b62324"
+"scale.red.7" = "#8e1519"
+"scale.red.8" = "#67060c"
+"scale.red.9" = "#490202"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#f8e3a1"
+"scale.yellow.1" = "#f2cc60"
+"scale.yellow.2" = "#e3b341"
+"scale.yellow.3" = "#d29922"
+"scale.yellow.4" = "#bb8009"
+"scale.yellow.5" = "#9e6a03"
+"scale.yellow.6" = "#845306"
+"scale.yellow.7" = "#693e00"
+"scale.yellow.8" = "#4b2900"
+"scale.yellow.9" = "#341a00"
+"severe.emphasis" = "#bd561d"
+"severe.fg" = "#db6d28"
+"severe.muted" = "#db6d2866"
+"severe.subtle" = "#db6d2826"
+"sponsors.emphasis" = "#bf4b8a"
+"sponsors.fg" = "#db61a2"
+"sponsors.muted" = "#db61a266"
+"sponsors.subtle" = "#db61a226"
+"success.emphasis" = "#238636"
+"success.fg" = "#3fb950"
+"success.muted" = "#2ea04366"
+"success.subtle" = "#2ea04326"
diff --git a/runtime/themes/github_dark_colorblind.toml b/runtime/themes/github_dark_colorblind.toml
new file mode 100644
index 000000000..afc806928
--- /dev/null
+++ b/runtime/themes/github_dark_colorblind.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_dark"
+
+[palette]
+"accent.emphasis" = "#1f6feb"
+"accent.fg" = "#58a6ff"
+"accent.muted" = "#388bfd66"
+"accent.subtle" = "#388bfd26"
+"attention.emphasis" = "#9e6a03"
+"attention.fg" = "#d29922"
+"attention.muted" = "#bb800966"
+"attention.subtle" = "#bb800926"
+"border.default" = "#30363d"
+"border.muted" = "#21262d"
+"border.subtle" = "#f0f6fc1a"
+"canvas.default" = "#0d1117"
+"canvas.inset" = "#010409"
+"canvas.overlay" = "#161b22"
+"canvas.subtle" = "#161b22"
+"closed.emphasis" = "#6e7681"
+"closed.fg" = "#8b949e"
+"closed.muted" = "#6e768166"
+"closed.subtle" = "#6e76811a"
+"danger.emphasis" = "#b76100"
+"danger.fg" = "#d47616"
+"danger.muted" = "#d4761666"
+"danger.subtle" = "#d4761626"
+"done.emphasis" = "#8957e5"
+"done.fg" = "#a371f7"
+"done.muted" = "#a371f766"
+"done.subtle" = "#a371f726"
+"fg.default" = "#c9d1d9"
+"fg.muted" = "#8b949e"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7681"
+"neutral.emphasis" = "#6e7681"
+"neutral.emphasisPlus" = "#6e7681"
+"neutral.muted" = "#6e768166"
+"neutral.subtle" = "#6e76811a"
+"open.emphasis" = "#b76100"
+"open.fg" = "#ec8e2c"
+"open.muted" = "#d4761666"
+"open.subtle" = "#d4761626"
+"scale.black" = "#010409"
+"scale.blue.0" = "#cae8ff"
+"scale.blue.1" = "#a5d6ff"
+"scale.blue.2" = "#79c0ff"
+"scale.blue.3" = "#58a6ff"
+"scale.blue.4" = "#388bfd"
+"scale.blue.5" = "#1f6feb"
+"scale.blue.6" = "#1158c7"
+"scale.blue.7" = "#0d419d"
+"scale.blue.8" = "#0c2d6b"
+"scale.blue.9" = "#051d4d"
+"scale.coral.0" = "#ffddd2"
+"scale.coral.1" = "#ffc2b2"
+"scale.coral.2" = "#ffa28b"
+"scale.coral.3" = "#f78166"
+"scale.coral.4" = "#ea6045"
+"scale.coral.5" = "#cf462d"
+"scale.coral.6" = "#ac3220"
+"scale.coral.7" = "#872012"
+"scale.coral.8" = "#640d04"
+"scale.coral.9" = "#460701"
+"scale.gray.0" = "#f0f6fc"
+"scale.gray.1" = "#c9d1d9"
+"scale.gray.2" = "#b1bac4"
+"scale.gray.3" = "#8b949e"
+"scale.gray.4" = "#6e7681"
+"scale.gray.5" = "#484f58"
+"scale.gray.6" = "#30363d"
+"scale.gray.7" = "#21262d"
+"scale.gray.8" = "#161b22"
+"scale.gray.9" = "#0d1117"
+"scale.green.0" = "#cae8ff"
+"scale.green.1" = "#a5d6ff"
+"scale.green.2" = "#79c0ff"
+"scale.green.3" = "#58a6ff"
+"scale.green.4" = "#388bfd"
+"scale.green.5" = "#1f6feb"
+"scale.green.6" = "#1158c7"
+"scale.green.7" = "#0d419d"
+"scale.green.8" = "#0c2d6b"
+"scale.green.9" = "#051d4d"
+"scale.orange.0" = "#ffe2bb"
+"scale.orange.1" = "#ffc981"
+"scale.orange.2" = "#fdac54"
+"scale.orange.3" = "#ec8e2c"
+"scale.orange.4" = "#d47616"
+"scale.orange.5" = "#b76100"
+"scale.orange.6" = "#914d04"
+"scale.orange.7" = "#6c3906"
+"scale.orange.8" = "#4e2906"
+"scale.orange.9" = "#331c04"
+"scale.pink.0" = "#ffdaec"
+"scale.pink.1" = "#ffbedd"
+"scale.pink.2" = "#ff9bce"
+"scale.pink.3" = "#f778ba"
+"scale.pink.4" = "#db61a2"
+"scale.pink.5" = "#bf4b8a"
+"scale.pink.6" = "#9e3670"
+"scale.pink.7" = "#7d2457"
+"scale.pink.8" = "#5e103e"
+"scale.pink.9" = "#42062a"
+"scale.purple.0" = "#eddeff"
+"scale.purple.1" = "#e2c5ff"
+"scale.purple.2" = "#d2a8ff"
+"scale.purple.3" = "#bc8cff"
+"scale.purple.4" = "#a371f7"
+"scale.purple.5" = "#8957e5"
+"scale.purple.6" = "#6e40c9"
+"scale.purple.7" = "#553098"
+"scale.purple.8" = "#3c1e70"
+"scale.purple.9" = "#271052"
+"scale.red.0" = "#ffe2bb"
+"scale.red.1" = "#ffc981"
+"scale.red.2" = "#fdac54"
+"scale.red.3" = "#ec8e2c"
+"scale.red.4" = "#d47616"
+"scale.red.5" = "#b76100"
+"scale.red.6" = "#914d04"
+"scale.red.7" = "#6c3906"
+"scale.red.8" = "#4e2906"
+"scale.red.9" = "#331c04"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#f8e3a1"
+"scale.yellow.1" = "#f2cc60"
+"scale.yellow.2" = "#e3b341"
+"scale.yellow.3" = "#d29922"
+"scale.yellow.4" = "#bb8009"
+"scale.yellow.5" = "#9e6a03"
+"scale.yellow.6" = "#845306"
+"scale.yellow.7" = "#693e00"
+"scale.yellow.8" = "#4b2900"
+"scale.yellow.9" = "#341a00"
+"severe.emphasis" = "#b76100"
+"severe.fg" = "#d47616"
+"severe.muted" = "#d4761666"
+"severe.subtle" = "#d4761626"
+"sponsors.emphasis" = "#bf4b8a"
+"sponsors.fg" = "#db61a2"
+"sponsors.muted" = "#db61a266"
+"sponsors.subtle" = "#db61a226"
+"success.emphasis" = "#1f6feb"
+"success.fg" = "#58a6ff"
+"success.muted" = "#388bfd66"
+"success.subtle" = "#388bfd26"
diff --git a/runtime/themes/github_dark_dimmed.toml b/runtime/themes/github_dark_dimmed.toml
new file mode 100644
index 000000000..b8783d043
--- /dev/null
+++ b/runtime/themes/github_dark_dimmed.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_dark"
+
+[palette]
+"accent.emphasis" = "#316dca"
+"accent.fg" = "#539bf5"
+"accent.muted" = "#4184e466"
+"accent.subtle" = "#4184e426"
+"attention.emphasis" = "#966600"
+"attention.fg" = "#c69026"
+"attention.muted" = "#ae7c1466"
+"attention.subtle" = "#ae7c1426"
+"border.default" = "#444c56"
+"border.muted" = "#373e47"
+"border.subtle" = "#cdd9e51a"
+"canvas.default" = "#22272e"
+"canvas.inset" = "#1c2128"
+"canvas.overlay" = "#2d333b"
+"canvas.subtle" = "#2d333b"
+"closed.emphasis" = "#c93c37"
+"closed.fg" = "#e5534b"
+"closed.muted" = "#e5534b66"
+"closed.subtle" = "#e5534b26"
+"danger.emphasis" = "#c93c37"
+"danger.fg" = "#e5534b"
+"danger.muted" = "#e5534b66"
+"danger.subtle" = "#e5534b26"
+"done.emphasis" = "#8256d0"
+"done.fg" = "#986ee2"
+"done.muted" = "#986ee266"
+"done.subtle" = "#986ee226"
+"fg.default" = "#adbac7"
+"fg.muted" = "#768390"
+"fg.onEmphasis" = "#cdd9e5"
+"fg.subtle" = "#636e7b"
+"neutral.emphasis" = "#636e7b"
+"neutral.emphasisPlus" = "#636e7b"
+"neutral.muted" = "#636e7b66"
+"neutral.subtle" = "#636e7b1a"
+"open.emphasis" = "#347d39"
+"open.fg" = "#57ab5a"
+"open.muted" = "#46954a66"
+"open.subtle" = "#46954a26"
+"scale.black" = "#1c2128"
+"scale.blue.0" = "#c6e6ff"
+"scale.blue.1" = "#96d0ff"
+"scale.blue.2" = "#6cb6ff"
+"scale.blue.3" = "#539bf5"
+"scale.blue.4" = "#4184e4"
+"scale.blue.5" = "#316dca"
+"scale.blue.6" = "#255ab2"
+"scale.blue.7" = "#1b4b91"
+"scale.blue.8" = "#143d79"
+"scale.blue.9" = "#0f2d5c"
+"scale.coral.0" = "#ffdacf"
+"scale.coral.1" = "#ffb9a5"
+"scale.coral.2" = "#f79981"
+"scale.coral.3" = "#ec775c"
+"scale.coral.4" = "#de5b41"
+"scale.coral.5" = "#c2442d"
+"scale.coral.6" = "#a93524"
+"scale.coral.7" = "#8d291b"
+"scale.coral.8" = "#771d13"
+"scale.coral.9" = "#5d1008"
+"scale.gray.0" = "#cdd9e5"
+"scale.gray.1" = "#adbac7"
+"scale.gray.2" = "#909dab"
+"scale.gray.3" = "#768390"
+"scale.gray.4" = "#636e7b"
+"scale.gray.5" = "#545d68"
+"scale.gray.6" = "#444c56"
+"scale.gray.7" = "#373e47"
+"scale.gray.8" = "#2d333b"
+"scale.gray.9" = "#22272e"
+"scale.green.0" = "#b4f1b4"
+"scale.green.1" = "#8ddb8c"
+"scale.green.2" = "#6bc46d"
+"scale.green.3" = "#57ab5a"
+"scale.green.4" = "#46954a"
+"scale.green.5" = "#347d39"
+"scale.green.6" = "#2b6a30"
+"scale.green.7" = "#245829"
+"scale.green.8" = "#1b4721"
+"scale.green.9" = "#113417"
+"scale.orange.0" = "#ffddb0"
+"scale.orange.1" = "#ffbc6f"
+"scale.orange.2" = "#f69d50"
+"scale.orange.3" = "#e0823d"
+"scale.orange.4" = "#cc6b2c"
+"scale.orange.5" = "#ae5622"
+"scale.orange.6" = "#94471b"
+"scale.orange.7" = "#7f3913"
+"scale.orange.8" = "#682d0f"
+"scale.orange.9" = "#4d210c"
+"scale.pink.0" = "#ffd7eb"
+"scale.pink.1" = "#ffb3d8"
+"scale.pink.2" = "#fc8dc7"
+"scale.pink.3" = "#e275ad"
+"scale.pink.4" = "#c96198"
+"scale.pink.5" = "#ae4c82"
+"scale.pink.6" = "#983b6e"
+"scale.pink.7" = "#7e325a"
+"scale.pink.8" = "#69264a"
+"scale.pink.9" = "#551639"
+"scale.purple.0" = "#eedcff"
+"scale.purple.1" = "#dcbdfb"
+"scale.purple.2" = "#dcbdfb"
+"scale.purple.3" = "#b083f0"
+"scale.purple.4" = "#986ee2"
+"scale.purple.5" = "#8256d0"
+"scale.purple.6" = "#6b44bc"
+"scale.purple.7" = "#5936a2"
+"scale.purple.8" = "#472c82"
+"scale.purple.9" = "#352160"
+"scale.red.0" = "#ffd8d3"
+"scale.red.1" = "#ffb8b0"
+"scale.red.2" = "#ff938a"
+"scale.red.3" = "#f47067"
+"scale.red.4" = "#e5534b"
+"scale.red.5" = "#c93c37"
+"scale.red.6" = "#ad2e2c"
+"scale.red.7" = "#922323"
+"scale.red.8" = "#78191b"
+"scale.red.9" = "#5d0f12"
+"scale.white" = "#cdd9e5"
+"scale.yellow.0" = "#fbe090"
+"scale.yellow.1" = "#eac55f"
+"scale.yellow.2" = "#daaa3f"
+"scale.yellow.3" = "#c69026"
+"scale.yellow.4" = "#ae7c14"
+"scale.yellow.5" = "#966600"
+"scale.yellow.6" = "#805400"
+"scale.yellow.7" = "#6c4400"
+"scale.yellow.8" = "#593600"
+"scale.yellow.9" = "#452700"
+"severe.emphasis" = "#ae5622"
+"severe.fg" = "#cc6b2c"
+"severe.muted" = "#cc6b2c66"
+"severe.subtle" = "#cc6b2c26"
+"sponsors.emphasis" = "#ae4c82"
+"sponsors.fg" = "#c96198"
+"sponsors.muted" = "#c9619866"
+"sponsors.subtle" = "#c9619826"
+"success.emphasis" = "#347d39"
+"success.fg" = "#57ab5a"
+"success.muted" = "#46954a66"
+"success.subtle" = "#46954a26"
diff --git a/runtime/themes/github_dark_high_contrast.toml b/runtime/themes/github_dark_high_contrast.toml
new file mode 100644
index 000000000..59d2c8f2e
--- /dev/null
+++ b/runtime/themes/github_dark_high_contrast.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_dark"
+
+[palette]
+"accent.emphasis" = "#409eff"
+"accent.fg" = "#71b7ff"
+"accent.muted" = "#409eff"
+"accent.subtle" = "#409eff26"
+"attention.emphasis" = "#e09b13"
+"attention.fg" = "#f0b72f"
+"attention.muted" = "#e09b13"
+"attention.subtle" = "#e09b1326"
+"border.default" = "#7a828e"
+"border.muted" = "#7a828e"
+"border.subtle" = "#7a828e"
+"canvas.default" = "#0a0c10"
+"canvas.inset" = "#010409"
+"canvas.overlay" = "#272b33"
+"canvas.subtle" = "#272b33"
+"closed.emphasis" = "#ff6a69"
+"closed.fg" = "#ff6a69"
+"closed.muted" = "#ff6a6966"
+"closed.subtle" = "#ff6a6926"
+"danger.emphasis" = "#ff6a69"
+"danger.fg" = "#ff6a69"
+"danger.muted" = "#ff6a69"
+"danger.subtle" = "#ff6a6926"
+"done.emphasis" = "#b87fff"
+"done.fg" = "#b780ff"
+"done.muted" = "#b780ff"
+"done.subtle" = "#b780ff26"
+"fg.default" = "#f0f3f6"
+"fg.muted" = "#f0f3f6"
+"fg.onEmphasis" = "#0a0c10"
+"fg.subtle" = "#9ea7b3"
+"neutral.emphasis" = "#9ea7b3"
+"neutral.emphasisPlus" = "#ffffff"
+"neutral.muted" = "#9ea7b366"
+"neutral.subtle" = "#9ea7b31a"
+"open.emphasis" = "#09b43a"
+"open.fg" = "#26cd4d"
+"open.muted" = "#09b43a66"
+"open.subtle" = "#09b43a26"
+"scale.black" = "#010409"
+"scale.blue.0" = "#caeaff"
+"scale.blue.1" = "#addcff"
+"scale.blue.2" = "#91cbff"
+"scale.blue.3" = "#71b7ff"
+"scale.blue.4" = "#409eff"
+"scale.blue.5" = "#409eff"
+"scale.blue.6" = "#318bf8"
+"scale.blue.7" = "#2672f3"
+"scale.blue.8" = "#1e60d5"
+"scale.blue.9" = "#194fb1"
+"scale.coral.0" = "#ffded4"
+"scale.coral.1" = "#ffcbb9"
+"scale.coral.2" = "#ffb39b"
+"scale.coral.3" = "#ff967d"
+"scale.coral.4" = "#fc704f"
+"scale.coral.5" = "#fc704f"
+"scale.coral.6" = "#f75133"
+"scale.coral.7" = "#e03b21"
+"scale.coral.8" = "#c62612"
+"scale.coral.9" = "#a91500"
+"scale.gray.0" = "#ffffff"
+"scale.gray.1" = "#f0f3f6"
+"scale.gray.2" = "#d9dee3"
+"scale.gray.3" = "#bdc4cc"
+"scale.gray.4" = "#9ea7b3"
+"scale.gray.5" = "#7a828e"
+"scale.gray.6" = "#525964"
+"scale.gray.7" = "#272b33"
+"scale.gray.8" = "#272b33"
+"scale.gray.9" = "#0a0c10"
+"scale.green.0" = "#acf7b6"
+"scale.green.1" = "#72f088"
+"scale.green.2" = "#4ae168"
+"scale.green.3" = "#26cd4d"
+"scale.green.4" = "#09b43a"
+"scale.green.5" = "#09b43a"
+"scale.green.6" = "#02a232"
+"scale.green.7" = "#008c2c"
+"scale.green.8" = "#007728"
+"scale.green.9" = "#006222"
+"scale.orange.0" = "#ffe1b4"
+"scale.orange.1" = "#ffcf86"
+"scale.orange.2" = "#ffb757"
+"scale.orange.3" = "#fe9a2d"
+"scale.orange.4" = "#e7811d"
+"scale.orange.5" = "#e7811d"
+"scale.orange.6" = "#d57014"
+"scale.orange.7" = "#bf5e0a"
+"scale.orange.8" = "#a74c00"
+"scale.orange.9" = "#8f3c00"
+"scale.pink.0" = "#ffdceb"
+"scale.pink.1" = "#ffc7e1"
+"scale.pink.2" = "#ffadd4"
+"scale.pink.3" = "#ff8dc7"
+"scale.pink.4" = "#ef6eb1"
+"scale.pink.5" = "#ef6eb1"
+"scale.pink.6" = "#e456a3"
+"scale.pink.7" = "#d23d91"
+"scale.pink.8" = "#b72c7d"
+"scale.pink.9" = "#9c1d6a"
+"scale.purple.0" = "#f0dfff"
+"scale.purple.1" = "#e6ccff"
+"scale.purple.2" = "#dbb7ff"
+"scale.purple.3" = "#cb9eff"
+"scale.purple.4" = "#b780ff"
+"scale.purple.5" = "#b87fff"
+"scale.purple.6" = "#a66bff"
+"scale.purple.7" = "#954ffd"
+"scale.purple.8" = "#8031f7"
+"scale.purple.9" = "#6921d7"
+"scale.red.0" = "#ffdedb"
+"scale.red.1" = "#ffc9c7"
+"scale.red.2" = "#ffb1af"
+"scale.red.3" = "#ff9492"
+"scale.red.4" = "#ff6a69"
+"scale.red.5" = "#ff6a69"
+"scale.red.6" = "#ff4445"
+"scale.red.7" = "#e82a2f"
+"scale.red.8" = "#cc1421"
+"scale.red.9" = "#ad0116"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#fbe59e"
+"scale.yellow.1" = "#fbd669"
+"scale.yellow.2" = "#f7c843"
+"scale.yellow.3" = "#f0b72f"
+"scale.yellow.4" = "#e09b13"
+"scale.yellow.5" = "#e09b13"
+"scale.yellow.6" = "#c88508"
+"scale.yellow.7" = "#ae7104"
+"scale.yellow.8" = "#945d02"
+"scale.yellow.9" = "#7b4900"
+"severe.emphasis" = "#e7811d"
+"severe.fg" = "#e7811d"
+"severe.muted" = "#e7811d"
+"severe.subtle" = "#e7811d26"
+"sponsors.emphasis" = "#ef6eb1"
+"sponsors.fg" = "#ef6eb1"
+"sponsors.muted" = "#ef6eb1"
+"sponsors.subtle" = "#ef6eb126"
+"success.emphasis" = "#09b43a"
+"success.fg" = "#26cd4d"
+"success.muted" = "#09b43a"
+"success.subtle" = "#09b43a26"
diff --git a/runtime/themes/github_dark_tritanopia.toml b/runtime/themes/github_dark_tritanopia.toml
new file mode 100644
index 000000000..d92217512
--- /dev/null
+++ b/runtime/themes/github_dark_tritanopia.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_dark"
+
+[palette]
+"accent.emphasis" = "#1f6feb"
+"accent.fg" = "#58a6ff"
+"accent.muted" = "#388bfd66"
+"accent.subtle" = "#388bfd26"
+"attention.emphasis" = "#9e6a03"
+"attention.fg" = "#d29922"
+"attention.muted" = "#bb800966"
+"attention.subtle" = "#bb800926"
+"border.default" = "#30363d"
+"border.muted" = "#21262d"
+"border.subtle" = "#f0f6fc1a"
+"canvas.default" = "#0d1117"
+"canvas.inset" = "#010409"
+"canvas.overlay" = "#161b22"
+"canvas.subtle" = "#161b22"
+"closed.emphasis" = "#6e7681"
+"closed.fg" = "#8b949e"
+"closed.muted" = "#6e768166"
+"closed.subtle" = "#6e76811a"
+"danger.emphasis" = "#da3633"
+"danger.fg" = "#f85149"
+"danger.muted" = "#f8514966"
+"danger.subtle" = "#f8514926"
+"done.emphasis" = "#8957e5"
+"done.fg" = "#a371f7"
+"done.muted" = "#a371f766"
+"done.subtle" = "#a371f726"
+"fg.default" = "#c9d1d9"
+"fg.muted" = "#8b949e"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7681"
+"neutral.emphasis" = "#6e7681"
+"neutral.emphasisPlus" = "#6e7681"
+"neutral.muted" = "#6e768166"
+"neutral.subtle" = "#6e76811a"
+"open.emphasis" = "#da3633"
+"open.fg" = "#ff7b72"
+"open.muted" = "#f8514966"
+"open.subtle" = "#f8514926"
+"scale.black" = "#010409"
+"scale.blue.0" = "#cae8ff"
+"scale.blue.1" = "#a5d6ff"
+"scale.blue.2" = "#79c0ff"
+"scale.blue.3" = "#58a6ff"
+"scale.blue.4" = "#388bfd"
+"scale.blue.5" = "#1f6feb"
+"scale.blue.6" = "#1158c7"
+"scale.blue.7" = "#0d419d"
+"scale.blue.8" = "#0c2d6b"
+"scale.blue.9" = "#051d4d"
+"scale.coral.0" = "#ffddd2"
+"scale.coral.1" = "#ffc2b2"
+"scale.coral.2" = "#ffa28b"
+"scale.coral.3" = "#f78166"
+"scale.coral.4" = "#ea6045"
+"scale.coral.5" = "#cf462d"
+"scale.coral.6" = "#ac3220"
+"scale.coral.7" = "#872012"
+"scale.coral.8" = "#640d04"
+"scale.coral.9" = "#460701"
+"scale.gray.0" = "#f0f6fc"
+"scale.gray.1" = "#c9d1d9"
+"scale.gray.2" = "#b1bac4"
+"scale.gray.3" = "#8b949e"
+"scale.gray.4" = "#6e7681"
+"scale.gray.5" = "#484f58"
+"scale.gray.6" = "#30363d"
+"scale.gray.7" = "#21262d"
+"scale.gray.8" = "#161b22"
+"scale.gray.9" = "#0d1117"
+"scale.green.0" = "#cae8ff"
+"scale.green.1" = "#a5d6ff"
+"scale.green.2" = "#79c0ff"
+"scale.green.3" = "#58a6ff"
+"scale.green.4" = "#388bfd"
+"scale.green.5" = "#1f6feb"
+"scale.green.6" = "#1158c7"
+"scale.green.7" = "#0d419d"
+"scale.green.8" = "#0c2d6b"
+"scale.green.9" = "#051d4d"
+"scale.orange.0" = "#ffdcd7"
+"scale.orange.1" = "#ffc1ba"
+"scale.orange.2" = "#ffa198"
+"scale.orange.3" = "#ff7b72"
+"scale.orange.4" = "#f85149"
+"scale.orange.5" = "#da3633"
+"scale.orange.6" = "#b62324"
+"scale.orange.7" = "#8e1519"
+"scale.orange.8" = "#67060c"
+"scale.orange.9" = "#490202"
+"scale.pink.0" = "#ffdaec"
+"scale.pink.1" = "#ffbedd"
+"scale.pink.2" = "#ff9bce"
+"scale.pink.3" = "#f778ba"
+"scale.pink.4" = "#db61a2"
+"scale.pink.5" = "#bf4b8a"
+"scale.pink.6" = "#9e3670"
+"scale.pink.7" = "#7d2457"
+"scale.pink.8" = "#5e103e"
+"scale.pink.9" = "#42062a"
+"scale.purple.0" = "#eddeff"
+"scale.purple.1" = "#e2c5ff"
+"scale.purple.2" = "#d2a8ff"
+"scale.purple.3" = "#bc8cff"
+"scale.purple.4" = "#a371f7"
+"scale.purple.5" = "#8957e5"
+"scale.purple.6" = "#6e40c9"
+"scale.purple.7" = "#553098"
+"scale.purple.8" = "#3c1e70"
+"scale.purple.9" = "#271052"
+"scale.red.0" = "#ffdcd7"
+"scale.red.1" = "#ffc1ba"
+"scale.red.2" = "#ffa198"
+"scale.red.3" = "#ff7b72"
+"scale.red.4" = "#f85149"
+"scale.red.5" = "#da3633"
+"scale.red.6" = "#b62324"
+"scale.red.7" = "#8e1519"
+"scale.red.8" = "#67060c"
+"scale.red.9" = "#490202"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#f8e3a1"
+"scale.yellow.1" = "#f2cc60"
+"scale.yellow.2" = "#e3b341"
+"scale.yellow.3" = "#d29922"
+"scale.yellow.4" = "#bb8009"
+"scale.yellow.5" = "#9e6a03"
+"scale.yellow.6" = "#845306"
+"scale.yellow.7" = "#693e00"
+"scale.yellow.8" = "#4b2900"
+"scale.yellow.9" = "#341a00"
+"severe.emphasis" = "#da3633"
+"severe.fg" = "#f85149"
+"severe.muted" = "#f8514966"
+"severe.subtle" = "#f8514926"
+"sponsors.emphasis" = "#bf4b8a"
+"sponsors.fg" = "#db61a2"
+"sponsors.muted" = "#db61a266"
+"sponsors.subtle" = "#db61a226"
+"success.emphasis" = "#1f6feb"
+"success.fg" = "#58a6ff"
+"success.muted" = "#388bfd66"
+"success.subtle" = "#388bfd26"
diff --git a/runtime/themes/github_light.toml b/runtime/themes/github_light.toml
new file mode 100644
index 000000000..3e2269698
--- /dev/null
+++ b/runtime/themes/github_light.toml
@@ -0,0 +1,229 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+attribute = "fg.default"
+keyword = "scale.red.5"
+"keyword.directive" = "scale.red.5"          # -- preprocessor comments (#if in C)
+namespace = "scale.orange.6"
+punctuation = "fg.default"
+"punctuation.delimiter" = "fg.default"
+operator = "scale.blue.8"
+special = "scale.blue.8"
+"variable.other.member" = "scale.blue.8"
+variable = "fg.default"
+"variable.parameter" = "scale.orange.6"
+"variable.builtin" = "scale.red.5"
+type = "scale.orange.6"
+"type.builtin" = "scale.blue.6"
+constructor = "done.fg"
+function = "done.fg"
+"function.macro" = "done.fg"
+tag = "scale.green.6"
+comment = "fg.muted"
+constant = "scale.blue.6"
+"constant.builtin" = "scale.blue.6"
+string = "scale.blue.8"
+"constant.numeric" = "scale.blue.6"
+"constant.character.escape" = "scale.blue.6"
+# used for lifetimes
+label = "scale.red.5"
+
+"markup.heading" = "scale.blue.6"
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link.url" = { modifiers = ["underlined"] }
+"markup.link.text" = { fg = "scale.blue.8", modifiers = ["underlined"] }
+"markup.raw" = "scale.blue.6"
+
+"diff.plus" = "open.fg"
+"diff.minus" = "closed.fg"
+"diff.delta" = "attention.fg"
+
+"ui.background" = { bg = "canvas.default" }
+"ui.background.separator" = { fg = "fg.subtle" }
+"ui.linenr" = { fg = "fg.subtle" }
+"ui.linenr.selected" = { fg = "fg.default" }
+"ui.statusline" = { fg = "fg.muted", bg = "neutral.subtle" }
+"ui.statusline.active" = { fg = "fg.default", bg = "canvas.default", underline = { color = "scale.coral.3", style = "line" } }
+"ui.statusline.normal" = { fg = "fg.default", bg = "accent.muted" }
+"ui.statusline.insert" = { fg = "fg.default", bg = "attention.muted" }
+"ui.statusline.select" = { fg = "fg.default", bg = "sponsors.muted" }
+"ui.popup" = { bg = "scale.gray.0" }
+"ui.popup.info" = { fg = "fg.default", bg = "scale.gray.0" }
+"ui.window" = { fg = "border.default" }
+"ui.help" = { fg = "fg.default", bg = "scale.gray.0" }
+
+"ui.text" = { fg = "fg.muted" }
+"ui.text.focus" = { fg = "fg.default" }
+"ui.text.inactive" = "fg.subtle"
+"ui.virtual" = { fg = "scale.gray.2" }
+
+"ui.selection" = { bg = "scale.blue.0" }
+"ui.selection.primary" = { bg = "scale.blue.1" }
+"ui.cursor.match" = { fg = "attention.fg", modifiers = [
+    "bold",
+], underline = { style = "line" } }
+"ui.cursor" = { modifiers = ["reversed"] }
+"ui.cursorline.primary" = { bg = "canvas.subtle" }
+
+"ui.menu" = { fg = "fg.default", bg = "scale.gray.0" }
+"ui.menu.selected" = { bg = "scale.gray.1" }
+"ui.menu.scroll" = { fg = "scale.gray.2", bg = "scale.gray.0" }
+
+"diagnostic.hint" = { underline = { color = "success.fg", style = "curl" } }
+"diagnostic.info" = { underline = { color = "accent.fg", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "attention.fg", style = "curl" } }
+"diagnostic.error" = { underline = { color = "danger.fg", style = "curl" } }
+
+hint = "success.fg"
+info = "accent.fg"
+warning = "attention.fg"
+error = "danger.fg"
+
+[palette]
+"accent.emphasis" = "#0969da"
+"accent.fg" = "#0969da"
+"accent.muted" = "#54aeff66"
+"accent.subtle" = "#ddf4ff"
+"attention.emphasis" = "#bf8700"
+"attention.fg" = "#9a6700"
+"attention.muted" = "#d4a72c66"
+"attention.subtle" = "#fff8c5"
+"border.default" = "#d0d7de"
+"border.muted" = "#d8dee4"
+"border.subtle" = "#1b1f2426"
+"canvas.default" = "#ffffff"
+"canvas.inset" = "#f6f8fa"
+"canvas.overlay" = "#ffffff"
+"canvas.subtle" = "#f6f8fa"
+"closed.emphasis" = "#cf222e"
+"closed.fg" = "#cf222e"
+"closed.muted" = "#ff818266"
+"closed.subtle" = "#ffebe9"
+"danger.emphasis" = "#cf222e"
+"danger.fg" = "#cf222e"
+"danger.muted" = "#ff818266"
+"danger.subtle" = "#ffebe9"
+"done.emphasis" = "#8250df"
+"done.fg" = "#8250df"
+"done.muted" = "#c297ff66"
+"done.subtle" = "#fbefff"
+"fg.default" = "#24292f"
+"fg.muted" = "#57606a"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7781"
+"neutral.emphasis" = "#6e7781"
+"neutral.emphasisPlus" = "#24292f"
+"neutral.muted" = "#afb8c133"
+"neutral.subtle" = "#eaeef280"
+"open.emphasis" = "#2da44e"
+"open.fg" = "#1a7f37"
+"open.muted" = "#4ac26b66"
+"open.subtle" = "#dafbe1"
+"scale.black" = "#1b1f24"
+"scale.blue.0" = "#ddf4ff"
+"scale.blue.1" = "#b6e3ff"
+"scale.blue.2" = "#80ccff"
+"scale.blue.3" = "#54aeff"
+"scale.blue.4" = "#218bff"
+"scale.blue.5" = "#0969da"
+"scale.blue.6" = "#0550ae"
+"scale.blue.7" = "#033d8b"
+"scale.blue.8" = "#0a3069"
+"scale.blue.9" = "#002155"
+"scale.coral.0" = "#fff0eb"
+"scale.coral.1" = "#ffd6cc"
+"scale.coral.2" = "#ffb4a1"
+"scale.coral.3" = "#fd8c73"
+"scale.coral.4" = "#ec6547"
+"scale.coral.5" = "#c4432b"
+"scale.coral.6" = "#9e2f1c"
+"scale.coral.7" = "#801f0f"
+"scale.coral.8" = "#691105"
+"scale.coral.9" = "#510901"
+"scale.gray.0" = "#f6f8fa"
+"scale.gray.1" = "#eaeef2"
+"scale.gray.2" = "#d0d7de"
+"scale.gray.3" = "#afb8c1"
+"scale.gray.4" = "#8c959f"
+"scale.gray.5" = "#6e7781"
+"scale.gray.6" = "#57606a"
+"scale.gray.7" = "#424a53"
+"scale.gray.8" = "#32383f"
+"scale.gray.9" = "#24292f"
+"scale.green.0" = "#dafbe1"
+"scale.green.1" = "#aceebb"
+"scale.green.2" = "#6fdd8b"
+"scale.green.3" = "#4ac26b"
+"scale.green.4" = "#2da44e"
+"scale.green.5" = "#1a7f37"
+"scale.green.6" = "#116329"
+"scale.green.7" = "#044f1e"
+"scale.green.8" = "#003d16"
+"scale.green.9" = "#002d11"
+"scale.orange.0" = "#fff1e5"
+"scale.orange.1" = "#ffd8b5"
+"scale.orange.2" = "#ffb77c"
+"scale.orange.3" = "#fb8f44"
+"scale.orange.4" = "#e16f24"
+"scale.orange.5" = "#bc4c00"
+"scale.orange.6" = "#953800"
+"scale.orange.7" = "#762c00"
+"scale.orange.8" = "#5c2200"
+"scale.orange.9" = "#471700"
+"scale.pink.0" = "#ffeff7"
+"scale.pink.1" = "#ffd3eb"
+"scale.pink.2" = "#ffadda"
+"scale.pink.3" = "#ff80c8"
+"scale.pink.4" = "#e85aad"
+"scale.pink.5" = "#bf3989"
+"scale.pink.6" = "#99286e"
+"scale.pink.7" = "#772057"
+"scale.pink.8" = "#611347"
+"scale.pink.9" = "#4d0336"
+"scale.purple.0" = "#fbefff"
+"scale.purple.1" = "#ecd8ff"
+"scale.purple.2" = "#d8b9ff"
+"scale.purple.3" = "#c297ff"
+"scale.purple.4" = "#a475f9"
+"scale.purple.5" = "#8250df"
+"scale.purple.6" = "#6639ba"
+"scale.purple.7" = "#512a97"
+"scale.purple.8" = "#3e1f79"
+"scale.purple.9" = "#2e1461"
+"scale.red.0" = "#ffebe9"
+"scale.red.1" = "#ffcecb"
+"scale.red.2" = "#ffaba8"
+"scale.red.3" = "#ff8182"
+"scale.red.4" = "#fa4549"
+"scale.red.5" = "#cf222e"
+"scale.red.6" = "#a40e26"
+"scale.red.7" = "#82071e"
+"scale.red.8" = "#660018"
+"scale.red.9" = "#4c0014"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#fff8c5"
+"scale.yellow.1" = "#fae17d"
+"scale.yellow.2" = "#eac54f"
+"scale.yellow.3" = "#d4a72c"
+"scale.yellow.4" = "#bf8700"
+"scale.yellow.5" = "#9a6700"
+"scale.yellow.6" = "#7d4e00"
+"scale.yellow.7" = "#633c01"
+"scale.yellow.8" = "#4d2d00"
+"scale.yellow.9" = "#3b2300"
+"severe.emphasis" = "#bc4c00"
+"severe.fg" = "#bc4c00"
+"severe.muted" = "#fb8f4466"
+"severe.subtle" = "#fff1e5"
+"sponsors.emphasis" = "#bf3989"
+"sponsors.fg" = "#bf3989"
+"sponsors.muted" = "#ff80c866"
+"sponsors.subtle" = "#ffeff7"
+"success.emphasis" = "#2da44e"
+"success.fg" = "#1a7f37"
+"success.muted" = "#4ac26b66"
+"success.subtle" = "#dafbe1"
diff --git a/runtime/themes/github_light_colorblind.toml b/runtime/themes/github_light_colorblind.toml
new file mode 100644
index 000000000..295fecd8a
--- /dev/null
+++ b/runtime/themes/github_light_colorblind.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_light"
+
+[palette]
+"accent.emphasis" = "#0969da"
+"accent.fg" = "#0969da"
+"accent.muted" = "#54aeff66"
+"accent.subtle" = "#ddf4ff"
+"attention.emphasis" = "#bf8700"
+"attention.fg" = "#9a6700"
+"attention.muted" = "#d4a72c66"
+"attention.subtle" = "#fff8c5"
+"border.default" = "#d0d7de"
+"border.muted" = "#d8dee4"
+"border.subtle" = "#1b1f2426"
+"canvas.default" = "#ffffff"
+"canvas.inset" = "#f6f8fa"
+"canvas.overlay" = "#ffffff"
+"canvas.subtle" = "#f6f8fa"
+"closed.emphasis" = "#6e7781"
+"closed.fg" = "#6e7781"
+"closed.muted" = "#afb8c166"
+"closed.subtle" = "#f6f8fa"
+"danger.emphasis" = "#b35900"
+"danger.fg" = "#b35900"
+"danger.muted" = "#f7993966"
+"danger.subtle" = "#fff5e8"
+"done.emphasis" = "#8250df"
+"done.fg" = "#8250df"
+"done.muted" = "#c297ff66"
+"done.subtle" = "#fbefff"
+"fg.default" = "#24292f"
+"fg.muted" = "#57606a"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7781"
+"neutral.emphasis" = "#6e7781"
+"neutral.emphasisPlus" = "#24292f"
+"neutral.muted" = "#afb8c133"
+"neutral.subtle" = "#eaeef280"
+"open.emphasis" = "#dd7815"
+"open.fg" = "#b35900"
+"open.muted" = "#f7993966"
+"open.subtle" = "#fff5e8"
+"scale.black" = "#1b1f24"
+"scale.blue.0" = "#ddf4ff"
+"scale.blue.1" = "#b6e3ff"
+"scale.blue.2" = "#80ccff"
+"scale.blue.3" = "#54aeff"
+"scale.blue.4" = "#218bff"
+"scale.blue.5" = "#0969da"
+"scale.blue.6" = "#0550ae"
+"scale.blue.7" = "#033d8b"
+"scale.blue.8" = "#0a3069"
+"scale.blue.9" = "#002155"
+"scale.coral.0" = "#fff0eb"
+"scale.coral.1" = "#ffd6cc"
+"scale.coral.2" = "#ffb4a1"
+"scale.coral.3" = "#fd8c73"
+"scale.coral.4" = "#ec6547"
+"scale.coral.5" = "#c4432b"
+"scale.coral.6" = "#9e2f1c"
+"scale.coral.7" = "#801f0f"
+"scale.coral.8" = "#691105"
+"scale.coral.9" = "#510901"
+"scale.gray.0" = "#f6f8fa"
+"scale.gray.1" = "#eaeef2"
+"scale.gray.2" = "#d0d7de"
+"scale.gray.3" = "#afb8c1"
+"scale.gray.4" = "#8c959f"
+"scale.gray.5" = "#6e7781"
+"scale.gray.6" = "#57606a"
+"scale.gray.7" = "#424a53"
+"scale.gray.8" = "#32383f"
+"scale.gray.9" = "#24292f"
+"scale.green.0" = "#ddf4ff"
+"scale.green.1" = "#b6e3ff"
+"scale.green.2" = "#80ccff"
+"scale.green.3" = "#54aeff"
+"scale.green.4" = "#218bff"
+"scale.green.5" = "#0969da"
+"scale.green.6" = "#0550ae"
+"scale.green.7" = "#033d8b"
+"scale.green.8" = "#0a3069"
+"scale.green.9" = "#002155"
+"scale.orange.0" = "#fff5e8"
+"scale.orange.1" = "#ffddb0"
+"scale.orange.2" = "#ffbc6d"
+"scale.orange.3" = "#f79939"
+"scale.orange.4" = "#dd7815"
+"scale.orange.5" = "#b35900"
+"scale.orange.6" = "#8a4600"
+"scale.orange.7" = "#6f3800"
+"scale.orange.8" = "#572c00"
+"scale.orange.9" = "#412000"
+"scale.pink.0" = "#ffeff7"
+"scale.pink.1" = "#ffd3eb"
+"scale.pink.2" = "#ffadda"
+"scale.pink.3" = "#ff80c8"
+"scale.pink.4" = "#e85aad"
+"scale.pink.5" = "#bf3989"
+"scale.pink.6" = "#99286e"
+"scale.pink.7" = "#772057"
+"scale.pink.8" = "#611347"
+"scale.pink.9" = "#4d0336"
+"scale.purple.0" = "#fbefff"
+"scale.purple.1" = "#ecd8ff"
+"scale.purple.2" = "#d8b9ff"
+"scale.purple.3" = "#c297ff"
+"scale.purple.4" = "#a475f9"
+"scale.purple.5" = "#8250df"
+"scale.purple.6" = "#6639ba"
+"scale.purple.7" = "#512a97"
+"scale.purple.8" = "#3e1f79"
+"scale.purple.9" = "#2e1461"
+"scale.red.0" = "#fff5e8"
+"scale.red.1" = "#ffddb0"
+"scale.red.2" = "#ffbc6d"
+"scale.red.3" = "#f79939"
+"scale.red.4" = "#dd7815"
+"scale.red.5" = "#b35900"
+"scale.red.6" = "#8a4600"
+"scale.red.7" = "#6f3800"
+"scale.red.8" = "#572c00"
+"scale.red.9" = "#412000"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#fff8c5"
+"scale.yellow.1" = "#fae17d"
+"scale.yellow.2" = "#eac54f"
+"scale.yellow.3" = "#d4a72c"
+"scale.yellow.4" = "#bf8700"
+"scale.yellow.5" = "#9a6700"
+"scale.yellow.6" = "#7d4e00"
+"scale.yellow.7" = "#633c01"
+"scale.yellow.8" = "#4d2d00"
+"scale.yellow.9" = "#3b2300"
+"severe.emphasis" = "#b35900"
+"severe.fg" = "#b35900"
+"severe.muted" = "#f7993966"
+"severe.subtle" = "#fff5e8"
+"sponsors.emphasis" = "#bf3989"
+"sponsors.fg" = "#bf3989"
+"sponsors.muted" = "#ff80c866"
+"sponsors.subtle" = "#ffeff7"
+"success.emphasis" = "#218bff"
+"success.fg" = "#0969da"
+"success.muted" = "#54aeff66"
+"success.subtle" = "#ddf4ff"
diff --git a/runtime/themes/github_light_high_contrast.toml b/runtime/themes/github_light_high_contrast.toml
new file mode 100644
index 000000000..f4fbd4df9
--- /dev/null
+++ b/runtime/themes/github_light_high_contrast.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_light"
+
+[palette]
+"accent.emphasis" = "#0349b4"
+"accent.fg" = "#0349b4"
+"accent.muted" = "#368cf9"
+"accent.subtle" = "#dff7ff"
+"attention.emphasis" = "#744500"
+"attention.fg" = "#744500"
+"attention.muted" = "#b58407"
+"attention.subtle" = "#fcf7be"
+"border.default" = "#20252c"
+"border.muted" = "#88929d"
+"border.subtle" = "#010409cc"
+"canvas.default" = "#ffffff"
+"canvas.inset" = "#ffffff"
+"canvas.overlay" = "#ffffff"
+"canvas.subtle" = "#e7ecf0"
+"closed.emphasis" = "#a0111f"
+"closed.fg" = "#a0111f"
+"closed.muted" = "#ee5a5d66"
+"closed.subtle" = "#fff0ee"
+"danger.emphasis" = "#a0111f"
+"danger.fg" = "#a0111f"
+"danger.muted" = "#ee5a5d"
+"danger.subtle" = "#fff0ee"
+"done.emphasis" = "#622cbc"
+"done.fg" = "#622cbc"
+"done.muted" = "#a371f7"
+"done.subtle" = "#faf0fe"
+"fg.default" = "#0e1116"
+"fg.muted" = "#0e1116"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#66707b"
+"neutral.emphasis" = "#66707b"
+"neutral.emphasisPlus" = "#0e1116"
+"neutral.muted" = "#acb6c033"
+"neutral.subtle" = "#e7ecf0"
+"open.emphasis" = "#117f32"
+"open.fg" = "#055d20"
+"open.muted" = "#26a14866"
+"open.subtle" = "#d2fedb"
+"scale.black" = "#010409"
+"scale.blue.0" = "#dff7ff"
+"scale.blue.1" = "#9cd7ff"
+"scale.blue.2" = "#67b3fd"
+"scale.blue.3" = "#368cf9"
+"scale.blue.4" = "#1168e3"
+"scale.blue.5" = "#0349b4"
+"scale.blue.6" = "#023b95"
+"scale.blue.7" = "#022f7a"
+"scale.blue.8" = "#032563"
+"scale.blue.9" = "#021a4a"
+"scale.coral.0" = "#fff0ed"
+"scale.coral.1" = "#ffc2b6"
+"scale.coral.2" = "#ff8f7e"
+"scale.coral.3" = "#ef5b48"
+"scale.coral.4" = "#cd3425"
+"scale.coral.5" = "#9f1710"
+"scale.coral.6" = "#870706"
+"scale.coral.7" = "#6f0107"
+"scale.coral.8" = "#5b0002"
+"scale.coral.9" = "#430200"
+"scale.gray.0" = "#ffffff"
+"scale.gray.1" = "#e7ecf0"
+"scale.gray.2" = "#ced5dc"
+"scale.gray.3" = "#acb6c0"
+"scale.gray.4" = "#88929d"
+"scale.gray.5" = "#66707b"
+"scale.gray.6" = "#4b535d"
+"scale.gray.7" = "#343b43"
+"scale.gray.8" = "#20252c"
+"scale.gray.9" = "#0e1116"
+"scale.green.0" = "#d2fedb"
+"scale.green.1" = "#82e596"
+"scale.green.2" = "#43c663"
+"scale.green.3" = "#26a148"
+"scale.green.4" = "#117f32"
+"scale.green.5" = "#055d20"
+"scale.green.6" = "#024c1a"
+"scale.green.7" = "#013d14"
+"scale.green.8" = "#003110"
+"scale.green.9" = "#00230b"
+"scale.orange.0" = "#fff2d5"
+"scale.orange.1" = "#ffc67b"
+"scale.orange.2" = "#f99636"
+"scale.orange.3" = "#dc6d1a"
+"scale.orange.4" = "#b45105"
+"scale.orange.5" = "#873800"
+"scale.orange.6" = "#702c00"
+"scale.orange.7" = "#5b2300"
+"scale.orange.8" = "#491b00"
+"scale.orange.9" = "#361200"
+"scale.pink.0" = "#feeff7"
+"scale.pink.1" = "#ffbde0"
+"scale.pink.2" = "#fc87ca"
+"scale.pink.3" = "#ed4baf"
+"scale.pink.4" = "#c9248e"
+"scale.pink.5" = "#971368"
+"scale.pink.6" = "#7d0c57"
+"scale.pink.7" = "#660847"
+"scale.pink.8" = "#53043a"
+"scale.pink.9" = "#3e022b"
+"scale.purple.0" = "#faf0fe"
+"scale.purple.1" = "#e0c5ff"
+"scale.purple.2" = "#c49bff"
+"scale.purple.3" = "#a371f7"
+"scale.purple.4" = "#844ae7"
+"scale.purple.5" = "#622cbc"
+"scale.purple.6" = "#512598"
+"scale.purple.7" = "#411d7b"
+"scale.purple.8" = "#341763"
+"scale.purple.9" = "#260f49"
+"scale.red.0" = "#fff0ee"
+"scale.red.1" = "#ffc1bc"
+"scale.red.2" = "#ff8e8a"
+"scale.red.3" = "#ee5a5d"
+"scale.red.4" = "#d5232c"
+"scale.red.5" = "#a0111f"
+"scale.red.6" = "#86061d"
+"scale.red.7" = "#6e011a"
+"scale.red.8" = "#5a0016"
+"scale.red.9" = "#430011"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#fcf7be"
+"scale.yellow.1" = "#f0ce53"
+"scale.yellow.2" = "#d5a824"
+"scale.yellow.3" = "#b58407"
+"scale.yellow.4" = "#956400"
+"scale.yellow.5" = "#744500"
+"scale.yellow.6" = "#603700"
+"scale.yellow.7" = "#4e2c00"
+"scale.yellow.8" = "#3f2200"
+"scale.yellow.9" = "#2e1800"
+"severe.emphasis" = "#873800"
+"severe.fg" = "#873800"
+"severe.muted" = "#dc6d1a"
+"severe.subtle" = "#fff2d5"
+"sponsors.emphasis" = "#971368"
+"sponsors.fg" = "#971368"
+"sponsors.muted" = "#ed4baf"
+"sponsors.subtle" = "#feeff7"
+"success.emphasis" = "#055d20"
+"success.fg" = "#055d20"
+"success.muted" = "#26a148"
+"success.subtle" = "#d2fedb"
diff --git a/runtime/themes/github_light_tritanopia.toml b/runtime/themes/github_light_tritanopia.toml
new file mode 100644
index 000000000..646539ba0
--- /dev/null
+++ b/runtime/themes/github_light_tritanopia.toml
@@ -0,0 +1,151 @@
+# Author : OwOSwordsman <owoswordsman@gmail.com>
+# An unofficial GitHub theme, generated using colors from: https://primer.style/primitives/colors
+# Credit goes to the original VSCode theme: https://github.com/primer/github-vscode-theme
+# Only the Light and Dark variants were specifically tested
+
+inherits = "github_light"
+
+[palette]
+"accent.emphasis" = "#0969da"
+"accent.fg" = "#0969da"
+"accent.muted" = "#54aeff66"
+"accent.subtle" = "#ddf4ff"
+"attention.emphasis" = "#bf8700"
+"attention.fg" = "#9a6700"
+"attention.muted" = "#d4a72c66"
+"attention.subtle" = "#fff8c5"
+"border.default" = "#d0d7de"
+"border.muted" = "#d8dee4"
+"border.subtle" = "#1b1f2426"
+"canvas.default" = "#ffffff"
+"canvas.inset" = "#f6f8fa"
+"canvas.overlay" = "#ffffff"
+"canvas.subtle" = "#f6f8fa"
+"closed.emphasis" = "#6e7781"
+"closed.fg" = "#6e7781"
+"closed.muted" = "#afb8c166"
+"closed.subtle" = "#f6f8fa"
+"danger.emphasis" = "#cf222e"
+"danger.fg" = "#cf222e"
+"danger.muted" = "#ff818266"
+"danger.subtle" = "#ffebe9"
+"done.emphasis" = "#8250df"
+"done.fg" = "#8250df"
+"done.muted" = "#c297ff66"
+"done.subtle" = "#fbefff"
+"fg.default" = "#24292f"
+"fg.muted" = "#57606a"
+"fg.onEmphasis" = "#ffffff"
+"fg.subtle" = "#6e7781"
+"neutral.emphasis" = "#6e7781"
+"neutral.emphasisPlus" = "#24292f"
+"neutral.muted" = "#afb8c133"
+"neutral.subtle" = "#eaeef280"
+"open.emphasis" = "#fa4549"
+"open.fg" = "#cf222e"
+"open.muted" = "#ff818266"
+"open.subtle" = "#ffebe9"
+"scale.black" = "#1b1f24"
+"scale.blue.0" = "#ddf4ff"
+"scale.blue.1" = "#b6e3ff"
+"scale.blue.2" = "#80ccff"
+"scale.blue.3" = "#54aeff"
+"scale.blue.4" = "#218bff"
+"scale.blue.5" = "#0969da"
+"scale.blue.6" = "#0550ae"
+"scale.blue.7" = "#033d8b"
+"scale.blue.8" = "#0a3069"
+"scale.blue.9" = "#002155"
+"scale.coral.0" = "#fff0eb"
+"scale.coral.1" = "#ffd6cc"
+"scale.coral.2" = "#ffb4a1"
+"scale.coral.3" = "#fd8c73"
+"scale.coral.4" = "#ec6547"
+"scale.coral.5" = "#c4432b"
+"scale.coral.6" = "#9e2f1c"
+"scale.coral.7" = "#801f0f"
+"scale.coral.8" = "#691105"
+"scale.coral.9" = "#510901"
+"scale.gray.0" = "#f6f8fa"
+"scale.gray.1" = "#eaeef2"
+"scale.gray.2" = "#d0d7de"
+"scale.gray.3" = "#afb8c1"
+"scale.gray.4" = "#8c959f"
+"scale.gray.5" = "#6e7781"
+"scale.gray.6" = "#57606a"
+"scale.gray.7" = "#424a53"
+"scale.gray.8" = "#32383f"
+"scale.gray.9" = "#24292f"
+"scale.green.0" = "#ddf4ff"
+"scale.green.1" = "#b6e3ff"
+"scale.green.2" = "#80ccff"
+"scale.green.3" = "#54aeff"
+"scale.green.4" = "#218bff"
+"scale.green.5" = "#0969da"
+"scale.green.6" = "#0550ae"
+"scale.green.7" = "#033d8b"
+"scale.green.8" = "#0a3069"
+"scale.green.9" = "#002155"
+"scale.orange.0" = "#ffebe9"
+"scale.orange.1" = "#ffcecb"
+"scale.orange.2" = "#ffaba8"
+"scale.orange.3" = "#ff8182"
+"scale.orange.4" = "#fa4549"
+"scale.orange.5" = "#cf222e"
+"scale.orange.6" = "#a40e26"
+"scale.orange.7" = "#82071e"
+"scale.orange.8" = "#660018"
+"scale.orange.9" = "#4c0014"
+"scale.pink.0" = "#ffeff7"
+"scale.pink.1" = "#ffd3eb"
+"scale.pink.2" = "#ffadda"
+"scale.pink.3" = "#ff80c8"
+"scale.pink.4" = "#e85aad"
+"scale.pink.5" = "#bf3989"
+"scale.pink.6" = "#99286e"
+"scale.pink.7" = "#772057"
+"scale.pink.8" = "#611347"
+"scale.pink.9" = "#4d0336"
+"scale.purple.0" = "#fbefff"
+"scale.purple.1" = "#ecd8ff"
+"scale.purple.2" = "#d8b9ff"
+"scale.purple.3" = "#c297ff"
+"scale.purple.4" = "#a475f9"
+"scale.purple.5" = "#8250df"
+"scale.purple.6" = "#6639ba"
+"scale.purple.7" = "#512a97"
+"scale.purple.8" = "#3e1f79"
+"scale.purple.9" = "#2e1461"
+"scale.red.0" = "#ffebe9"
+"scale.red.1" = "#ffcecb"
+"scale.red.2" = "#ffaba8"
+"scale.red.3" = "#ff8182"
+"scale.red.4" = "#fa4549"
+"scale.red.5" = "#cf222e"
+"scale.red.6" = "#a40e26"
+"scale.red.7" = "#82071e"
+"scale.red.8" = "#660018"
+"scale.red.9" = "#4c0014"
+"scale.white" = "#ffffff"
+"scale.yellow.0" = "#fff8c5"
+"scale.yellow.1" = "#fae17d"
+"scale.yellow.2" = "#eac54f"
+"scale.yellow.3" = "#d4a72c"
+"scale.yellow.4" = "#bf8700"
+"scale.yellow.5" = "#9a6700"
+"scale.yellow.6" = "#7d4e00"
+"scale.yellow.7" = "#633c01"
+"scale.yellow.8" = "#4d2d00"
+"scale.yellow.9" = "#3b2300"
+"severe.emphasis" = "#cf222e"
+"severe.fg" = "#cf222e"
+"severe.muted" = "#ff818266"
+"severe.subtle" = "#ffebe9"
+"sponsors.emphasis" = "#bf3989"
+"sponsors.fg" = "#bf3989"
+"sponsors.muted" = "#ff80c866"
+"sponsors.subtle" = "#ffeff7"
+"success.emphasis" = "#218bff"
+"success.fg" = "#0969da"
+"success.muted" = "#54aeff66"
+"success.subtle" = "#ddf4ff"
diff --git a/runtime/themes/gruvbox.toml b/runtime/themes/gruvbox.toml
index 4f0a7d9f8..c357e26c2 100644
--- a/runtime/themes/gruvbox.toml
+++ b/runtime/themes/gruvbox.toml
@@ -33,10 +33,10 @@
 "diff.delta" = "orange1"
 "diff.minus" = "red1"
 
-"warning" = { fg = "orange1", bg = "bg1" }
-"error" = { fg = "red1", bg = "bg1" }
-"info" = { fg = "aqua1", bg = "bg1" }
-"hint" = { fg = "blue1", bg = "bg1" }
+"warning" = "orange1"
+"error" = "red1"
+"info" = "aqua1"
+"hint" = "blue1"
 
 "ui.background" = { bg = "bg0" }
 "ui.linenr" = { fg = "bg4" }
@@ -53,18 +53,24 @@
 "ui.text" = { fg = "fg1" }
 "ui.text.focus" = { fg = "fg1" }
 "ui.selection" = { bg = "bg2" }
+"ui.selection.primary" = { bg = "bg3" }
 "ui.cursor.primary" = { bg = "fg4", fg = "bg1" }
 "ui.cursor.match" = { bg = "bg3" }
 "ui.menu" = { fg = "fg1", bg = "bg2" }
 "ui.menu.selected" = { fg = "bg2", bg = "blue1", modifiers = ["bold"] }
 "ui.virtual.whitespace" = "bg2"
 "ui.virtual.ruler" = { bg = "bg1" }
+"ui.virtual.inlay-hint" = { fg = "gray1" }
 
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange1", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red1", style = "curl" } }
+"diagnostic.info" = { underline = { color = "aqua1", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "blue1", style = "curl" } }
 
 "markup.heading" = "aqua1"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "green1", modifiers = ["underlined"] }
 "markup.link.text" = "red1"
 "markup.raw" = "red1"
diff --git a/runtime/themes/gruvbox_dark_hard.toml b/runtime/themes/gruvbox_dark_hard.toml
index 27d9ab9b3..d0d42bcde 100644
--- a/runtime/themes/gruvbox_dark_hard.toml
+++ b/runtime/themes/gruvbox_dark_hard.toml
@@ -2,105 +2,14 @@
 # Author : Jakub Bartodziej <kubabartodziej@gmail.com>
 # The theme uses the gruvbox dark palette with hard contrast: github.com/morhetz/gruvbox
 
-"attribute" = "aqua1"
-"keyword" = { fg = "red1" }
-"keyword.directive" = "red0"
-"namespace" = "aqua1"
-"punctuation" = "orange1"
-"punctuation.delimiter" = "orange1"
-"operator" = "purple1"
-"special" = "purple0"
-"variable.other.member" = "blue1"
-"variable" = "fg1"
-"variable.builtin" = "orange1"
-"variable.parameter" = "fg2"
-"type" = "yellow1"
-"type.builtin" = "yellow1"
-"constructor" = { fg = "purple1", modifiers = ["bold"] }
-"function" = { fg = "green1", modifiers = ["bold"] }
-"function.macro" = "aqua1"
-"function.builtin" = "yellow1"
-"tag" = "red1"
-"comment" = { fg = "gray1", modifiers = ["italic"]  }
-"constant" = { fg = "purple1" }
-"constant.builtin" = { fg = "purple1", modifiers = ["bold"] }
-"string" = "green1"
-"constant.numeric" = "purple1"
-"constant.character.escape" = { fg = "fg2", modifiers = ["bold"] }
-"label" = "aqua1"
-"module" = "aqua1"
+inherits = "gruvbox"
 
-"diff.plus" = "green1"
-"diff.delta" = "orange1"
-"diff.minus" = "red1"
-
-"warning" = { fg = "orange1", bg = "bg1" }
-"error" = { fg = "red1", bg = "bg1" }
-"info" = { fg = "aqua1", bg = "bg1" }
-"hint" = { fg = "blue1", bg = "bg1" }
-
-"diagnostic" = { modifiers = ["underlined"] }
-"diagnostic.error" = { underline = { style = "curl", color = "red0" } }
-"diagnostic.warning" = { underline = { style = "curl", color = "orange1" } }
-"diagnostic.info" = { underline = { style = "curl", color = "aqua1" } }
-"diagnostic.hint" = { underline = { style = "curl", color = "blue1" } }
-
-"ui.background" = { bg = "bg0" }
-"ui.linenr" = { fg = "bg4" }
-"ui.linenr.selected" = { fg = "yellow1" }
-"ui.cursorline" = { bg = "bg1" }
-"ui.statusline" = { fg = "fg1", bg = "bg2" }
-"ui.statusline.normal" = { fg = "fg1", bg = "bg2" }
-"ui.statusline.insert" = { fg = "fg1", bg = "blue0" }
-"ui.statusline.select" = { fg = "fg1", bg = "orange0" }
-"ui.statusline.inactive" = { fg = "fg4", bg = "bg1" }
-"ui.popup" = { bg = "bg1" }
-"ui.window" = { bg = "bg1" }
-"ui.help" = { bg = "bg1", fg = "fg1" }
-"ui.text" = { fg = "fg1" }
-"ui.text.focus" = { fg = "fg1" }
 "ui.selection" = { bg = "bg3", modifiers = ["reversed"] }
+"ui.selection.primary" = { bg = "bg4", modifiers = ["reversed"] }
 "ui.cursor.primary" = { modifiers = ["reversed"] }
 "ui.cursor.match" = { bg = "bg2" }
-"ui.menu" = { fg = "fg1", bg = "bg2" }
-"ui.menu.selected" = { fg = "bg2", bg = "blue1", modifiers = ["bold"] }
-"ui.virtual.whitespace" = "bg2"
-"ui.virtual.ruler" = { bg = "bg1" }
 
-"markup.heading" = "aqua1"
-"markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "green1", modifiers = ["underlined"] }
-"markup.link.text" = "red1"
-"markup.raw" = "red1"
+"diagnostic.error" = { underline = { color = "red0", style = "curl"} }
 
 [palette]
 bg0 = "#1d2021" # main background
-bg1 = "#3c3836"
-bg2 = "#504945"
-bg3 = "#665c54"
-bg4 = "#7c6f64"
-
-fg0 = "#fbf1c7"
-fg1 = "#ebdbb2" # main foreground
-fg2 = "#d5c4a1"
-fg3 = "#bdae93"
-fg4 = "#a89984" # gray0
-
-gray0 = "#a89984"
-gray1 = "#928374"
-
-red0 = "#cc241d" # neutral
-red1 = "#fb4934" # bright
-green0 = "#98971a"
-green1 = "#b8bb26"
-yellow0 = "#d79921"
-yellow1 = "#fabd2f"
-blue0 = "#458588"
-blue1 = "#83a598"
-purple0 = "#b16286"
-purple1 = "#d3869b"
-aqua0 = "#689d6a"
-aqua1 = "#8ec07c"
-orange0 = "#d65d0e"
-orange1 = "#fe8019"
diff --git a/runtime/themes/gruvbox_light.toml b/runtime/themes/gruvbox_light.toml
index dc7e3db1f..749df1101 100644
--- a/runtime/themes/gruvbox_light.toml
+++ b/runtime/themes/gruvbox_light.toml
@@ -2,73 +2,12 @@
 # Author : Jakub Bartodziej <kubabartodziej@gmail.com>
 # The theme uses the gruvbox light palette with standard contrast: github.com/morhetz/gruvbox
 
-"attribute" = "aqua1"
-"keyword" = { fg = "red1" }
-"keyword.directive" = "red0"
-"namespace" = "aqua1"
-"punctuation" = "orange1"
-"punctuation.delimiter" = "orange1"
-"operator" = "purple1"
-"special" = "purple0"
-"variable.other.member" = "blue1"
-"variable" = "fg1"
-"variable.builtin" = "orange1"
-"variable.parameter" = "fg2"
-"type" = "yellow1"
-"type.builtin" = "yellow1"
-"constructor" = { fg = "purple1", modifiers = ["bold"] }
-"function" = { fg = "green1", modifiers = ["bold"] }
-"function.macro" = "aqua1"
-"function.builtin" = "yellow1"
-"tag" = "red1"
-"comment" = { fg = "gray1", modifiers = ["italic"]  }
-"constant" = { fg = "purple1" }
-"constant.builtin" = { fg = "purple1", modifiers = ["bold"] }
-"string" = "green1"
-"constant.numeric" = "purple1"
-"constant.character.escape" = { fg = "fg2", modifiers = ["bold"] }
-"label" = "aqua1"
-"module" = "aqua1"
+inherits = "gruvbox"
 
-"diff.plus" = "green1"
-"diff.delta" = "orange1"
-"diff.minus" = "red1"
-
-"warning" = { fg = "orange1", bg = "bg1" }
-"error" = { fg = "red1", bg = "bg1" }
-"info" = { fg = "aqua1", bg = "bg1" }
-"hint" = { fg = "blue1", bg = "bg1" }
-
-"ui.background" = { bg = "bg0" }
-"ui.linenr" = { fg = "bg4" }
-"ui.linenr.selected" = { fg = "yellow1" }
-"ui.cursorline" = { bg = "bg1" }
-"ui.statusline" = { fg = "fg1", bg = "bg2" }
-"ui.statusline.normal" = { fg = "fg1", bg = "bg2" }
-"ui.statusline.insert" = { fg = "fg1", bg = "blue0" }
-"ui.statusline.select" = { fg = "fg1", bg = "orange0" }
-"ui.statusline.inactive" = { fg = "fg4", bg = "bg1" }
-"ui.popup" = { bg = "bg1" }
-"ui.window" = { bg = "bg1" }
-"ui.help" = { bg = "bg1", fg = "fg1" }
-"ui.text" = { fg = "fg1" }
-"ui.text.focus" = { fg = "fg1" }
 "ui.selection" = { bg = "bg3", modifiers = ["reversed"] }
+"ui.selection.primary" = { bg = "bg4", modifiers = ["reversed"] }
 "ui.cursor.primary" = { modifiers = ["reversed"] }
 "ui.cursor.match" = { bg = "bg2" }
-"ui.menu" = { fg = "fg1", bg = "bg2" }
-"ui.menu.selected" = { fg = "bg2", bg = "blue1", modifiers = ["bold"] }
-"ui.virtual.whitespace" = "bg2"
-"ui.virtual.ruler" = { bg = "bg1" }
-
-"diagnostic" = { modifiers = ["underlined"] }
-
-"markup.heading" = "aqua1"
-"markup.bold" = { modifiers = ["bold"] }
-"markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "green1", modifiers = ["underlined"] }
-"markup.link.text" = "red1"
-"markup.raw" = "red1"
 
 [palette]
 bg0 = "#fbf1c7" # main background
@@ -84,19 +23,11 @@ fg3 = "#665c54"
 fg4 = "#7c6f64" # gray0
 
 gray0 = "#7c6f64"
-gray1 = "#928374"
 
-red0 = "#cc241d" # neutral
 red1 = "#9d0006" # bright
-green0 = "#98971a"
 green1 = "#79740e"
-yellow0 = "#d79921"
 yellow1 = "#b57614"
-blue0 = "#458588"
 blue1 = "#076678"
-purple0 = "#b16286"
 purple1 = "#8f3f71"
-aqua0 = "#689d6a"
 aqua1 = "#427b58"
-orange0 = "#d65d0e"
 orange1 = "#af3a03"
diff --git a/runtime/themes/heisenberg.toml b/runtime/themes/heisenberg.toml
index b20d3e9c7..3c127a3e4 100644
--- a/runtime/themes/heisenberg.toml
+++ b/runtime/themes/heisenberg.toml
@@ -59,10 +59,10 @@
 "error" = { fg = "chili_powder_red", modifiers = ["bold"] }
 "info" = { fg = "crystal_blue", modifiers = ["bold"] }
 "hint" = { fg = "crystal_blue", modifiers = ["bold"] }
-"diagnostic"= { fg = "chili_powder_red", modifiers = ["underlined"] }
-"diagnostic.info"= { fg = "crystal_blue", modifiers = ["underlined"] }
-"diagnostic.warning"= { fg = "vapor_yellow", modifiers = ["underlined"] }
-"diagnostic.error"= { fg = "chili_powder_red", modifiers = ["underlined"] }
+"diagnostic.hint" = { underline = {color = "chili_powder_red", style = "curl" } }
+"diagnostic.info" = { underline = {color = "crystal_blue", style = "curl" } }
+"diagnostic.warning" = { underline = {color = "vapor_yellow", style = "curl" } }
+"diagnostic.error" = { underline = {color = "chili_powder_red", style = "curl" } }
 "ui.bufferline" = { fg = "gray", bg = "background" }
 "ui.bufferline.active" = { fg = "foreground", bg = "dark_gray" }
 
diff --git a/runtime/themes/hex_lavender.toml b/runtime/themes/hex_lavender.toml
index 974c486ce..d7c54be69 100644
--- a/runtime/themes/hex_lavender.toml
+++ b/runtime/themes/hex_lavender.toml
@@ -3,7 +3,7 @@ inherits = "hex_steel"
 [palette]
 t1 = "#0e0e0d"
 t2 = "#121311"
-t3 = "#2b3444"  #
+t3 = "#2b3444"
 t4 = "#61586f"
 t5 = "#686e73"
 t6 = "#878480"
diff --git a/runtime/themes/hex_steel.toml b/runtime/themes/hex_steel.toml
index 7a2183f8f..c81df4097 100644
--- a/runtime/themes/hex_steel.toml
+++ b/runtime/themes/hex_steel.toml
@@ -60,7 +60,11 @@
 "ui.virtual.indent-guide" = { fg = "t3" }
 "ui.virtual.whitespace" = { fg = "t3" }
 
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.error" = { underline = { color = "error", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "warning", style = "curl" } }
+"diagnostic.info" = { underline = { color = "info", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "display", style = "curl" } }
+
 "error" = { fg = "error", modifiers = ["bold"] }
 "warning" = { fg = "warning", modifiers = ["bold"] }
 "info" = { fg = "info", modifiers = ["bold"] }
@@ -71,6 +75,7 @@
 "markup.list" = { fg = "t4" }
 "markup.bold" = { fg = "t4" }
 "markup.italic" = { fg = "t4" }
+"markup.strikethrough" = { fg = "t4", modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "t4", modifiers = ["underlined"] }
 "markup.link.text" = { fg = "t4" }
 "markup.quote" = { fg = "t4" }
diff --git a/runtime/themes/ingrid.toml b/runtime/themes/ingrid.toml
index 8e70587ed..8942c3ca2 100644
--- a/runtime/themes/ingrid.toml
+++ b/runtime/themes/ingrid.toml
@@ -33,6 +33,7 @@
 "markup.list" = "red"
 "markup.bold" = { fg = "yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", modifiers = ["underlined"] }
 "markup.link.text" = "red"
 "markup.quote" = "cyan"
@@ -67,3 +68,8 @@
 "error" = "#D74E50"
 "info" = "#839A53"
 "hint" = "#A6B6CE"
+
+"diagnostic.warning" = { underline = { color = "#D4A520", style = "curl" } }
+"diagnostic.error" = { underline = { color = "#D74E50", style = "curl" } }
+"diagnostic.info" = { underline = { color = "#839A53", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "#A6B6CE", style = "curl" } }
diff --git a/runtime/themes/jellybeans.toml b/runtime/themes/jellybeans.toml
new file mode 100644
index 000000000..592db9a92
--- /dev/null
+++ b/runtime/themes/jellybeans.toml
@@ -0,0 +1,138 @@
+#
+#    __       _ _       _                           
+#    \ \  ___| | |_   _| |__   ___  __ _ _ __  ___  
+#     \ \/ _ \ | | | | |  _ \ / _ \/ _  |  _ \/ __| 
+#  /\_/ /  __/ | | |_| | |_| |  __/ |_| | | | \__ \ 
+#  \___/ \___|_|_|\__  |____/ \___|\____|_| |_|___/ 
+#                 \___/                             
+#
+# Jellybeans
+# A take on the Jellybeans theme, please feel free to contribute! 
+#
+# Original author: @nanotech
+# Original repository: nanotech/jellybeans.vim
+# Contributors:
+# @cemalokten
+
+"attribute" = "green"
+"type" = "light_blue"
+"type.enum.variant" = "purple"
+"constructor" = "yellow"
+"constant" = "dark_orange"
+
+"constant.builtin.boolean" = "yellow"
+"constant.character" = "yellow"
+"constant.characted.escape" = "red_error"
+"constant.numeric" = "dark_orange"
+"string" = "dark_green"
+"string.regexp" = "light_purple"
+"string.special" = { fg = "yellow", modifiers = ["underlined"] }
+"comment" = "light_gray"
+
+"variable" = "light_yellow"
+"variable.builtin" = { fg = "dark_green", modifiers = ["underlined"] }
+"variable.parameter" = "yellow"
+"variable.other.member" = "light_purple"
+"label" = "yellow"
+"punctuation" = "mid_blue"
+"keyword" = "mid_blue"
+"keyword.control.exception" = "purple"
+"operator" = "light_purple"
+"function" = "yellow"
+"function.macro" = "green"
+"function.builtin" = "green"
+"function.special" = "green"
+"function.method" = "yellow"
+"tag" = "light_blue"
+"special" = "green"
+"namespace" = "light_purple"
+
+"markup.bold" = { fg = "white", modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.heading" = { fg = "mid_blue", modifiers = ["bold"] }
+"markup.list" = "dark_green"
+"markup.list.numbered" = "mid_blue"
+"markup.list.unnumbered" = "mid_blue"
+"markup.link.url" = { fg = "dark_green", modifiers = ['italic', 'underlined'] }
+"markup.link.text" = "mid_blue"
+"markup.link.label" = "purple"
+"markup.quote" = "dark_green"
+"markup.raw" = "dark_green"
+"markup.raw.inline" = "mid_blue"
+"markup.raw.block" = "dark_green"
+
+"diff.plus" = "diff_plus"
+"diff.minus" = "red_accent"
+"diff.delta" = "blue_accent"
+
+# ui specific
+"ui.background" = { bg = "background" }                                            # .separator
+"ui.cursor" = { bg = "background", modifiers = ["reversed"] }
+"ui.cursor.insert" = { bg = "light_yellow", fg = "background" }
+"ui.cursor.match" = { fg = "background", bg = "dark_orange" }
+"ui.cursorline" = { bg = "darker" }
+"ui.linenr" = "dark_gray"
+"ui.linenr.selected" = { fg = "light_yellow", bg = "darker" }
+"ui.statusline" = { fg = "light_yellow", bg = "darker" }
+"ui.statusline.inactive" = { fg = "dark", bg = "darker" }
+"ui.statusline.normal" = { fg = "light_yellow", bg = "darker" }
+"ui.statusline.insert" = { fg = "darker", bg = "purple" }
+"ui.statusline.select" = { fg = "selectionFG", bg = "selection" }
+"ui.popup" = { fg = "light_yellow", bg = "darkest" }
+"ui.window" = { fg = "dark", bg = "darkest" }
+"ui.help" = { fg = "light_yellow", bg = "darkest" }
+"ui.text" = "light_yellow"
+"ui.text.focus" = { fg = "white", bg = "dark_blue" }
+"ui.virtual" = "dark"
+"ui.virtual.ruler" = { bg = "darker" }
+"ui.menu" = { fg = "light_purple", bg = "darkest" }
+"ui.menu.selected" = { fg = "white", bg = "dark_blue" }
+"ui.selection" = { bg = "darker" }
+"ui.selection.primary" = { bg = "selection", fg = "selectionFG" }
+"hint" = "blue"
+"info" = "yellow_accent"
+"warning" = "orange_accent"
+"error" = "red_error"
+"diagnostic" = { modifiers = [] }
+"diagnostic.hint" = { underline = { color = "light_purple", style = "line" } }
+"diagnostic.info" = { underline = { color = "blue_accent", style = "line" } }
+"diagnostic.warning" = { underline = { color = "yellow_accent", style = "line" } }
+"diagnostic.error" = { underline = { color = "red_error", style = "line" } }
+
+[palette]
+background = "#151515"
+darkest = "#1e1e1e"
+darker = "#292929"
+dark = "#898989"
+white = "#ffffff"
+dark_gray = "#535353"
+light_gray = "#6d6d6d"
+
+purple = "#a390f0"
+light_purple = "#CDBEF0"
+
+blue = "#52a7f6"
+light_blue = "#8fbfdc"
+mid_blue = "#8197bf"
+dark_blue = "#204474"
+blue_accent = "#2197F3"
+
+green = "#99ad6a"
+dark_green = "#84A775"
+
+red = "#CC7C8A"
+red_error = "#902020"
+red_accent = "#F44747"
+
+orange = "#efb080"
+dark_orange = "#cf6a4c"
+orange_accent = "#EE7F25"
+
+yellow = "#fad07a"
+light_yellow = "#EBEBD8"
+yellow_accent = "#DEA407"
+
+diff_plus = "#5A9F81"
+selection = "#37232D"
+selectionFG = "#F2AAC7"
diff --git a/runtime/themes/kanagawa.toml b/runtime/themes/kanagawa.toml
index 50a7c0a78..a7d33f3ee 100644
--- a/runtime/themes/kanagawa.toml
+++ b/runtime/themes/kanagawa.toml
@@ -7,46 +7,69 @@
 # because of some theming differences, it's not an exact copy of the original.
 
 ## User interface
-"ui.selection" = { bg = "waveBlue1" }
+"ui.selection" = { bg = "waveBlue2" }
+"ui.selection.primary" = { bg = "waveBlue1" }
 "ui.background" = { fg = "fujiWhite", bg = "sumiInk1" }
 
 "ui.linenr" = { fg = "sumiInk4" }
+"ui.linenr.selected" = { fg = "roninYellow" }
+
+"ui.virtual" = "sumiInk4"
+"ui.virtual.ruler" = { bg = "sumiInk2" }
 
 "ui.statusline" = { fg = "oldWhite", bg = "sumiInk0" }
 "ui.statusline.inactive" = { fg = "fujiGray", bg = "sumiInk0" }
 "ui.statusline.normal" = { fg = "sumiInk0", bg = "crystalBlue", modifiers = ["bold"] }
-"ui.statusline.insert" = { fg = "sumiInk0", bg = "autumnGreen"  }
-"ui.statusline.select" = { fg = "sumiInk0", bg = "oniViolet" }
+"ui.statusline.insert" = { fg = "sumiInk0", bg = "autumnGreen", modifiers = ["bold"] }
+"ui.statusline.select" = { fg = "sumiInk0", bg = "oniViolet", modifiers = ["bold"] }
 
-"ui.bufferline" = { fg = "oldWhite", bg = "sumiInk0" }
-"ui.bufferline.inactive" = { fg = "fujiGray", bg = "sumiInk0" }
+"ui.bufferline" = { fg = "fujiGray", bg = "sumiInk0" }
+"ui.bufferline.active" = { fg = "oldWhite", bg = "sumiInk0" }
+"ui.bufferline.background" = { bg = "sumiInk0" }
 
 "ui.popup" = { fg = "fujiWhite", bg = "sumiInk0" }
-"ui.window" = { fg = "fujiWhite" }
-"ui.help" = { fg = "fujiWhite", bg = "waveBlue1" }
+"ui.window" = { fg = "sumiInk0" }
+"ui.help" = { fg = "fujiWhite", bg = "sumiInk0" }
 "ui.text" = "fujiWhite"
 "ui.text.focus" = { fg = "fujiWhite", bg = "waveBlue1", modifiers = ["bold"] }
-"ui.virtual" = "waveBlue1"
 
-"ui.cursor" = { fg = "fujiWhite", bg = "waveBlue1"}
-"ui.cursor.primary" = { fg = "seaFoam", bg = "waveBlue1" }
-"ui.cursor.match" = { fg = "seaFoam", modifiers = ["bold"] }
+"ui.cursor" = { fg = "waveBlue1", bg = "waveAqua2"}
+"ui.cursor.primary" = { fg = "waveBlue1", bg = "fujiWhite" }
+"ui.cursor.match" = { fg = "waveRed", modifiers = ["bold"] }
 "ui.highlight" = { fg = "fujiWhite", bg = "waveBlue2" }
+"ui.menu" = { fg = "fujiWhite", bg = "waveBlue1" }
+"ui.menu.selected" = { fg = "fujiWhite", bg = "waveBlue2", modifiers = ["bold"] }
+"ui.menu.scroll" = { fg = "oldWhite", bg = "waveBlue1" }
+
+"ui.cursorline.primary" = { bg = "sumiInk3"}
+"ui.cursorcolumn.primary" = { bg = "sumiInk3" }
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.error" = { underline = { color = "samuraiRed", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "roninYellow", style = "curl" } }
+"diagnostic.info" = { underline = { color = "waveAqua1", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "dragonBlue", style = "curl" } }
 
 error = "samuraiRed"
 warning = "roninYellow"
 info = "waveAqua1"
 hint = "dragonBlue"
 
+## Git gutter
+"diff.plus" = "autumnGreen"
+"diff.minus" = "autumnRed"
+"diff.delta" = "autumnYellow"
+
 ## Syntax highlighting
+"attribute" = "waveRed"
 "type" = "waveAqua2"
+"constructor" = "springBlue"
 "constant" = "surimiOrange"
 "constant.numeric" = "sakuraPink"
 "constant.character.escape" = "springBlue"
 "string" = "springGreen"
 "string.regexp" = "boatYellow2"
+"string.special.url" = "springBlue"
+"string.special.symbol" = "oniViolet"
 "comment" = "fujiGray"
 "variable" = "fujiWhite"
 "variable.builtin" = "waveRed"
@@ -54,36 +77,36 @@ hint = "dragonBlue"
 "variable.other.member" = "carpYellow"
 "label" = "springBlue"
 "punctuation" = "springViolet2"
-"punctuation.delimiter" = "springViolet2" 
-"punctuation.bracket" = "springViolet2" 
 "keyword" = "oniViolet"
+"keyword.control.return" = "peachRed"
+"keyword.control.exception" = "peachRed"
 "keyword.directive" = "peachRed"
 "operator" = "boatYellow2"
 "function" = "crystalBlue"
-"function.builtin" = "peachRed"
+"function.builtin" = "springBlue"
 "function.macro" = "waveRed"
-"tag" = "springBlue"
+"tag" = "waveAqua2"
 "namespace" = "surimiOrange"
-"attribute" = "peachRed"
-"constructor" = "springBlue"
-"module" = "waveAqua2"
 "special" = "peachRed"
 
 ## Markup modifiers
-"markup.heading.marker" = "fujiGray"
+"markup.heading.marker" = "springViolet2"
 "markup.heading.1" = { fg = "surimiOrange", modifiers = ["bold"] }
 "markup.heading.2" = { fg = "carpYellow", modifiers = ["bold"] }
 "markup.heading.3" = { fg = "waveAqua2", modifiers = ["bold"] }
-"markup.heading.4" = { fg = "springGreen", modifiers = ["bold"] }
-"markup.heading.5" = { fg = "waveRed", modifiers = ["bold"] }
-"markup.heading.6" = { fg = "autumnRed", modifiers = ["bold"] }
-"markup.list" = "oniViolet"
+"markup.heading.4" = { fg = "lightBlue", modifiers = ["bold"] }
+"markup.heading.5" = { fg = "oniViolet", modifiers = ["bold"] }
+"markup.heading.6" = { fg = "springViolet1", modifiers = ["bold"] }
+"markup.list.numbered" = "sakuraPink"
+"markup.list.unnumbered" = "waveRed"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
-"markup.link.url" = { fg = "springBlue", modifiers = ["underlined"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.text" = "crystalBlue"
-"markup.quote" = "seaFoam"
-"markup.raw" = "seaFoam"
+"markup.link.url" = { fg = "springBlue", underline.style = "line" }
+"markup.link.label" = "surimiOrange"
+"markup.quote" = "springViolet1"
+"markup.raw" = "springGreen"
 
 [palette]
 seaFoam       = "#C7CCD1" # custom lighter foreground
@@ -91,7 +114,8 @@ fujiWhite     = "#DCD7BA" # default foreground
 oldWhite      = "#C8C093" # dark foreground, e.g. statuslines
 sumiInk0      = "#16161D" # dark background, e.g. statuslines, floating windows
 sumiInk1      = "#1F1F28" # default background
-sumiInk3      = "#363646" # lighter background, e.g. colorcolumns and folds
+sumiInk2      = "#2A2A37" # lighter background, e.g. colorcolumns, folds
+sumiInk3      = "#363646" # lighter background, e.g. cursorline
 sumiInk4      = "#54546D" # darker foreground, e.g. linenumbers, fold column
 waveBlue1     = "#223249" # popup background, visual selection background
 waveBlue2     = "#2D4F67" # popup selection background, search background
@@ -122,4 +146,4 @@ sakuraPink    = "#D27E99" # numbers
 waveRed       = "#E46876" # standout specials 1, e.g. builtin variables
 peachRed      = "#FF5D62" # standout specials 2, e.g. exception handling, returns
 surimiOrange  = "#FFA066" # constants, imports, booleans
-katanaGray    = "#717C7C" # deprecated
\ No newline at end of file
+katanaGray    = "#717C7C" # deprecated
diff --git a/runtime/themes/meliora.toml b/runtime/themes/meliora.toml
index ecc19f46e..e7037e18d 100644
--- a/runtime/themes/meliora.toml
+++ b/runtime/themes/meliora.toml
@@ -54,7 +54,11 @@
 "ui.virtual.indent-guide" = { fg = "dark_grey2" }
 "ui.virtual.whitespace" = { fg = "grey" }
  
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.info" = { underline = { color = "blue", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "magenta", style = "curl" } }
+
 "error" = { fg = "red" }
 "warning" = { fg = "orange" }
 "info" = { fg = "blue" }
@@ -63,8 +67,9 @@
 
 "markup.heading" = { fg = "orange" }
 "markup.list" = { fg = "blue" }
-"markup.bold" = { fg = "magenta" }
-"markup.italic" = { fg = "blue" }
+"markup.bold" = { fg = "magenta", modifiers = ["bold"] }
+"markup.italic" = { fg = "blue", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "comment" , modifiers = ["underlined"] }
 "markup.link.text" = { fg = "comment" }
 "markup.quote" = { fg = "yellow" }
diff --git a/runtime/themes/mellow.toml b/runtime/themes/mellow.toml
index 675cd9160..16d7b6086 100644
--- a/runtime/themes/mellow.toml
+++ b/runtime/themes/mellow.toml
@@ -50,6 +50,7 @@
 "markup.list" = "gray06"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "green", modifiers = ["underlined"] }
 "markup.link.text" = { fg = "blue", modifiers = ["italic"] }
 "markup.raw" = "yellow"
@@ -79,6 +80,7 @@
 
 "ui.virtual" = { fg = "gray02" }
 "ui.virtual.indent-guide" = { fg = "gray02" }
+"ui.virtual.inlay-hint" = { fg = "gray04" }
 
 "ui.selection" = { bg = "gray03" }
 "ui.selection.primary" = { bg = "gray03" }
@@ -93,7 +95,10 @@
 "ui.menu.selected" = { fg = "bright_white", bg = "gray03" }
 "ui.menu.scroll" = { fg = "gray04", bg = "gray01" }
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "bright_yellow", style = "curl" } }
+"diagnostic.error" = { underline = { color = "bright_red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "bright_blue", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "bright_cyan", style = "curl" } }
 
 warning = "bright_yellow"
 error = "bright_red"
diff --git a/runtime/themes/molokai.toml b/runtime/themes/molokai.toml
new file mode 100644
index 000000000..fc8e533d5
--- /dev/null
+++ b/runtime/themes/molokai.toml
@@ -0,0 +1,48 @@
+# Author : Maxwell Anderson <zaechus@pm.me>
+
+inherits = "monokai"
+
+"comment" = "comment"
+"comment.block.documentation" = { fg = "comment", modifiers = ["bold"] }
+"constant.character.escape" = { fg = "light-blue", modifiers = ["italic"] }
+"function.macro" = { fg = "#c4be89", modifiers = ["italic"] }
+"keyword" = { fg = "keyword", modifiers = ["bold"] }
+"keyword.control" = { fg = "keyword", modifiers = ["bold"] }
+"keyword.control.exception" = { fg = "fn_declaration", modifiers = ["bold"] }
+"keyword.directive" = { fg = "fn_declaration", modifiers = ["bold"] }
+"keyword.storage.modifier" = { fg = "#fd971f", modifiers = ["italic"] }
+"label" = "#e6db74"
+"operator" = "keyword"
+"punctuation.delimeter" = "#8f8f8f"
+"type" = "light-blue"
+"variable.builtin" = { fg = "#ae81ff", modifiers = ["bold"] }
+"tag.builtin" = { fg = "#ae81ff", modifiers = ["bold"] }
+"variable.parameter" = "variable"
+
+"diff.plus" = "text"
+"diff.delta" = "#89807d"
+"diff.minus" = "#960050"
+
+"ui.cursor.primary" = { fg = "#000000", bg = "#f8f8f0" }
+"ui.cursor.match" = { fg = "#000000", bg = "#fd971f", modifiers = ["bold"] }
+"ui.selection" = { bg = "#403d3d" }
+"ui.linenr" = "#465457"
+"ui.linenr.selected" = "#fd971f"
+
+"ui.help" = { fg = "light-blue", bg = "#000000" }
+"ui.menu" = { fg = "light-blue", bg = "#000000" }
+"ui.popup" = { fg = "light-blue", bg = "#000000" }
+"ui.popup.info" = { fg = "light-blue", bg = "#000000" }
+"ui.text.info" = { fg = "light-blue", bg = "#000000" }
+
+"warning" = { fg = "#ffffff", modifiers = ["bold"] }
+"error" = { fg = "#ffffff", modifiers = ["bold"] }
+"info" = { fg = "#ffffff", modifiers = ["bold"] }
+"hint" = { fg = "#ffffff", modifiers = ["bold"] }
+
+[palette]
+light-blue = "#66d9ef"
+
+background = "#1b1d1e"
+
+comment = "#7e8e91"
diff --git a/runtime/themes/monokai.toml b/runtime/themes/monokai.toml
index 0935ceff7..913cc49b8 100644
--- a/runtime/themes/monokai.toml
+++ b/runtime/themes/monokai.toml
@@ -46,6 +46,7 @@
 "markup.list" = "red"
 "markup.bold" = { fg = "yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", modifiers = ["underlined"] }
 "markup.link.text" = "red"
 "markup.quote" = "cyan"
@@ -77,15 +78,18 @@
 "ui.statusline" = { fg = "active_text", bg = "#414339" }
 "ui.statusline.inactive" = { fg = "active_text", bg = "#75715e" }
 
-"ui.text" = { fg = "text", bg = "background" }
+"ui.text" = { fg = "text" }
 "ui.text.focus" = { fg = "active_text" }
 
 "warning" = { fg = "#cca700" }
 "error" = { fg = "#f48771" }
 "info" = { fg = "#75beff" }
-"hint" = { fg = "#eeeeeb3" }
+"hint" = { fg = "#eeeeb3" }
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "#cca700", style = "curl" } }
+"diagnostic.error" = { underline = { color = "#f48771", style = "curl" } }
+"diagnostic.info" = { underline = { color = "#75beff", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "#eeeeb3", style = "curl" } }
 
 [palette]
 type = "#A6E22E"
diff --git a/runtime/themes/monokai_aqua.toml b/runtime/themes/monokai_aqua.toml
new file mode 100644
index 000000000..0fe482546
--- /dev/null
+++ b/runtime/themes/monokai_aqua.toml
@@ -0,0 +1,17 @@
+inherits = "monokai"
+
+"keyword.control.import" = { fg = "cyan", modifiers = ["italic"] }
+"keyword.function" = { fg = "cyan", modifiers = ["italic"] }
+"keyword.storage.type" = { fg = "cyan", modifiers = ["italic"] }
+
+"namespace" = { fg = "text" }
+
+"type" = { fg = "type", modifiers = ["bold"] }
+
+"ui.statusline.normal" = { fg = "light-black", bg = "cyan" }
+"ui.statusline.insert" = { fg = "light-black", bg = "green" }
+"ui.statusline.select" = { fg = "light-black", bg = "purple" }
+
+[palette]
+cyan = "#66D9EF"
+type = "#66D9EF"
diff --git a/runtime/themes/monokai_pro.toml b/runtime/themes/monokai_pro.toml
index a5cbfdcff..57bede94a 100644
--- a/runtime/themes/monokai_pro.toml
+++ b/runtime/themes/monokai_pro.toml
@@ -90,12 +90,16 @@
 "diff.minus" = "red"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "base8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base8", style = "curl" } }
 
 # markup highlight, no need for `markup.raw` and `markup.list`, make them to be default
 "markup.heading" = "green"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "orange", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "orange", modifiers = ["underlined"] }
 "markup.link.text" = "yellow"
 "markup.quote" = "green"
diff --git a/runtime/themes/monokai_pro_machine.toml b/runtime/themes/monokai_pro_machine.toml
index 4360d622b..b292e6b02 100644
--- a/runtime/themes/monokai_pro_machine.toml
+++ b/runtime/themes/monokai_pro_machine.toml
@@ -87,12 +87,16 @@
 "diff.minus" = "red"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "base8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base8", style = "curl" } }
 
 # markup highlight, no need for `markup.raw` and `markup.list`, make them to be default
 "markup.heading" = "green"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "orange", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "orange", modifiers = ["underlined"] }
 "markup.link.text" = "yellow"
 "markup.quote" = "green"
diff --git a/runtime/themes/monokai_pro_octagon.toml b/runtime/themes/monokai_pro_octagon.toml
index 8bcaeebcc..3236fc167 100644
--- a/runtime/themes/monokai_pro_octagon.toml
+++ b/runtime/themes/monokai_pro_octagon.toml
@@ -90,12 +90,16 @@
 "diff.minus" = "red"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "base8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base8", style = "curl" } }
 
 # markup highlight, no need for `markup.raw` and `markup.list`, make them to be default
 "markup.heading" = "green"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "orange", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "orange", modifiers = ["underlined"] }
 "markup.link.text" = "yellow"
 "markup.quote" = "green"
diff --git a/runtime/themes/monokai_pro_ristretto.toml b/runtime/themes/monokai_pro_ristretto.toml
index 0dad50d47..f897bddbd 100644
--- a/runtime/themes/monokai_pro_ristretto.toml
+++ b/runtime/themes/monokai_pro_ristretto.toml
@@ -87,12 +87,16 @@
 "diff.minus" = "red"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "base8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base8", style = "curl" } }
 
 # markup highlight, no need for `markup.raw` and `markup.list`, make them to be default
 "markup.heading" = "green"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "orange", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "orange", modifiers = ["underlined"] }
 "markup.link.text" = "yellow"
 "markup.quote" = "green"
diff --git a/runtime/themes/monokai_pro_spectrum.toml b/runtime/themes/monokai_pro_spectrum.toml
index 89575e3a1..74533404e 100644
--- a/runtime/themes/monokai_pro_spectrum.toml
+++ b/runtime/themes/monokai_pro_spectrum.toml
@@ -53,7 +53,7 @@
 "constructor" = "blue"
 "function" = "green"
 "function.macro" = { fg = "blue" }
-"function.builtin" = { fg = "cyan" }
+"function.builtin" = { fg = "blue" }
 
 # operator, tags, units, punctuations
 "operator" = "red"
@@ -65,7 +65,7 @@
 "variable.parameter" = "#f59762"
 
 # error
-"error" = { bg = "magenta", fg = "yellow" }
+"error" = { fg = "red", modifiers = ["bold"] }
 
 # annotations, decorators
 "special" = "#f59762"
@@ -87,12 +87,16 @@
 "diff.minus" = "red"
 
 # make diagnostic underlined, to distinguish with selection text.
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { color = "orange", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "base8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base8", style = "curl" } }
 
 # markup highlight, no need for `markup.raw` and `markup.list`, make them to be default
 "markup.heading" = "green"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "orange", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "orange", modifiers = ["underlined"] }
 "markup.link.text" = "yellow"
 "markup.quote" = "green"
diff --git a/runtime/themes/night_owl.toml b/runtime/themes/night_owl.toml
index 55b09fbc2..fc27dc7cc 100644
--- a/runtime/themes/night_owl.toml
+++ b/runtime/themes/night_owl.toml
@@ -5,7 +5,11 @@
 'error' = { fg = 'red', modifiers = ['dim'] }
 'info' = { fg = 'blue', modifiers = ['dim'] }
 'hint' = { fg = 'paleblue', modifiers = ['dim'] }
-'diagnostic' = { modifiers = ['underlined'] }
+
+"diagnostic.warning" = { underline = { color = "peach", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "blue", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "paleblue", style = "curl" } }
 
 # UI
 'ui.background' = { fg = 'foreground', bg = 'background' }
@@ -76,6 +80,7 @@
 'markup.list' = { fg = 'pink' }
 'markup.bold' = { fg = 'foreground', modifiers = ['bold'] }
 'markup.italic' = { fg = 'foreground', modifiers = ['italic'] }
+'markup.strikethrough' = { fg = 'foreground', modifiers = ['crossed_out'] }
 'markup.link' = { fg = 'pink', modifiers = ['underlined'] }
 'markup.link.url' = { fg = 'slate', modifiers = ['underlined'] }
 'markup.quote' = { fg = 'green', modifiers = ['italic'] }
diff --git a/runtime/themes/nightfox.toml b/runtime/themes/nightfox.toml
index c4cbbce0f..fad56d189 100644
--- a/runtime/themes/nightfox.toml
+++ b/runtime/themes/nightfox.toml
@@ -33,6 +33,7 @@
 "ui.virtual.ruler" = { bg = "bg3" } # Vertical rulers (colored columns in editing area).
 "ui.virtual.whitespace" = { fg = "bg3" } # Whitespace markers in editing area.
 "ui.virtual.indent-guide" = { fg = "black" } # Vertical indent width guides
+"ui.virtual.inlay-hint" = { fg = "comment", bg = "bg2" } # Default style for inlay hints of all kinds
 
 "ui.statusline" = { fg = "fg2", bg = "bg0" } # Status line.
 "ui.statusline.inactive" = { fg = "fg3", bg = "bg0" } # Status line in unfocused windows.
@@ -55,20 +56,21 @@
 "markup.list" = { fg = "magenta", modifiers = ["bold"] }
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "pink" }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link" = { fg = "yellow-bright", modifiers = ["bold"] }
 "markup.quote" = { fg = "blue" }
 
 
 # DIAGNOSTICS
-"warning" = { fg ="yellow", bg = "bg1" } # Diagnostics warning (gutter)
+"warning" = { fg = "yellow", bg = "bg1" } # Diagnostics warning (gutter)
 "error" = { fg = "red", bg = "bg1" } # Diagnostics error (gutter)
 "info" = { fg = "blue", bg = "bg1" } # Diagnostics info (gutter)
 "hint" = { fg = "green", bg = "bg1" } # Diagnostics hint (gutter)
-"diagnostic" = { modifiers = ["underlined"] } # Diagnostics fallback style (editing area)
-"diagnostic.error" = { fg = "red" } #	Diagnostics error (editing area)
-"diagnostic.warning" = { fg = "yellow" } #	Diagnostics warning (editing area)
-"diagnostic.info" = { fg = "blue" } #	Diagnostics info (editing area)
-"diagnostic.hint" = { fg = "green" } #	Diagnostics hint (editing area)
+
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } } #	Diagnostics warning (editing area)
+"diagnostic.error" = { underline = { color = "red", style = "curl" } } #	Diagnostics error (editing area)
+"diagnostic.info" = { underline = { color = "blue", style = "curl" } } #	Diagnostics info (editing area)
+"diagnostic.hint" = { underline = { color = "green", style = "curl" } } #	Diagnostics hint (editing area)
 
 
 # SYNTAX HIGHLIGHTING
diff --git a/runtime/themes/noctis.toml b/runtime/themes/noctis.toml
index 1740a9247..81733e637 100644
--- a/runtime/themes/noctis.toml
+++ b/runtime/themes/noctis.toml
@@ -10,7 +10,12 @@
 "info" = { fg = "mid-blue", bg = "mid-green" } # Code diagnostic info in gutter (LSP).
 # ? Difference between info and hint ?
 "hint" = { fg = "light-green", modifiers = ["bold"] } # Code diagnostics hint in gutter (LSP).
-"diagnostic" = { modifiers = ["underlined"] } # Code diagnostics in editing area (LSP).
+
+# Code diagnostics in editing area (LSP).
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+"diagnostic.info" = { underline = { color = "mid-blue", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "light-green", style = "curl" } }
 
 # UI ==============================
 # For styling helix itself.
@@ -145,6 +150,7 @@
 
 'markup.bold' = { modifiers = ["bold"] } # Bold text.
 'markup.italic' = { modifiers = ["italic"] } # Italicised text.
+"markup.strikethrough" = { modifiers = ["crossed_out"] } # Crossed out text.
 
 'markup.link' = { fg = "light-blue", modifiers = ["underlined"] }
 'markup.link.url' = { } # Urls pointed to by links.
diff --git a/runtime/themes/noctis_bordo.toml b/runtime/themes/noctis_bordo.toml
index b15a3f8e7..c3bbe79c9 100644
--- a/runtime/themes/noctis_bordo.toml
+++ b/runtime/themes/noctis_bordo.toml
@@ -49,12 +49,17 @@
 "markup.list" = "base08"
 "markup.quote" = "base0C"
 "markup.raw" = "base0B"
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 
 "diff.delta" = "base09"
 "diff.plus" = "base0B"
 "diff.minus" = "base08"
 
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.info" = { underline = { color = "base0D", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "base03", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "base09", style = "curl" } }
+"diagnostic.error" = { underline = { color = "base08", style = "curl" } }
+
 "ui.gutter" = { bg = "base01" }
 "info" = "base0D"
 "hint" = "base03"
diff --git a/runtime/themes/nord.toml b/runtime/themes/nord.toml
index 6260ddbea..f38ede547 100644
--- a/runtime/themes/nord.toml
+++ b/runtime/themes/nord.toml
@@ -19,6 +19,7 @@
 "ui.statusline.insert" = { fg = "nord0", bg = "nord13" }
 "ui.statusline.select" = { fg = "nord0", bg = "nord15" }
 
+
 # nord1 - status bars, panels, modals, autocompletion
 "ui.statusline" = { fg = "nord4", bg = "nord1" }
 "ui.popup" = { bg = "nord1" }
@@ -33,6 +34,8 @@
 "comment" = { fg = "nord3_bright", modifiers = ["italic"] }
 "ui.linenr" = "nord3_bright"
 "ui.virtual.whitespace" = "nord3_bright"
+"ui.virtual.inlay-hint" = { fg = "nord3_bright" }
+
 
 # Snow Storm
 # nord4 - cursor, variables, constants, attributes, fields
@@ -95,9 +98,16 @@
 "markup.list" = "nord9"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.text" = "nord8"
 "markup.raw" = "nord7"
 
+# lsp diagnostics
+"diagnostic.error" = { underline = { color = "nord11", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "nord13", style = "curl" } }
+"diagnostic.info" = { underline = { color = "nord8", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "nord8", style = "curl" } }
+
 # vcs
 "diff.plus" = "nord14"
 "diff.delta" = "nord12"
diff --git a/runtime/themes/nord_light.toml b/runtime/themes/nord_light.toml
index eb947d034..b37d35962 100644
--- a/runtime/themes/nord_light.toml
+++ b/runtime/themes/nord_light.toml
@@ -26,9 +26,10 @@
 "ui.statusline.select" = { fg = "nord0", bg = "nord15" }
 
 
-"diagnostic.error" = {fg="nord11", modifiers=["bold"]}
-"diagnostic.warning" = {bg="nord13", modifiers=["bold"]}
-"diagnostic.hint" = {fg="nord13", modifiers=["bold"]}
+"diagnostic.error" = { underline = { color = "nord11", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "nord13", style = "curl" } }
+"diagnostic.info" = { underline = { color = "nord13", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "nord13", style = "curl" } }
 
 "constant.numeric" = {fg="nord15"}
 "constant.builtin" = {fg="nord15"}
diff --git a/runtime/themes/onedark.toml b/runtime/themes/onedark.toml
index c4a56b90f..21101ea75 100644
--- a/runtime/themes/onedark.toml
+++ b/runtime/themes/onedark.toml
@@ -30,6 +30,7 @@
 "markup.raw.inline" = { fg = "green" }
 "markup.bold" = { fg = "gold", modifiers = ["bold"] }
 "markup.italic" = { fg = "purple", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.list" = { fg = "red" }
 "markup.quote" = { fg = "yellow" }
 "markup.link.url" = { fg = "cyan", modifiers = ["underlined"]}
@@ -53,15 +54,19 @@
 "ui.virtual.indent-guide" = { fg = "faint-gray" }
 "ui.virtual.whitespace" = { fg = "light-gray" }
 "ui.virtual.ruler" = { bg = "gray" }
+"ui.virtual.inlay-hint" = { fg = "light-gray" }
 
 "ui.cursor" = { fg = "white", modifiers = ["reversed"] }
 "ui.cursor.primary" = { fg = "white", modifiers = ["reversed"] }
 "ui.cursor.match" = { fg = "blue", modifiers = ["underlined"]}
 
-"ui.selection" = { bg = "light-gray" }
+"ui.selection" = { bg = "faint-gray" }
 "ui.selection.primary" = { bg = "gray" }
 "ui.cursorline.primary" = { bg = "light-black" }
 
+"ui.highlight" = { bg = "gray" }
+"ui.highlight.frameline" = { bg = "#97202a" }
+
 "ui.linenr" = { fg = "linenr" }
 "ui.linenr.selected" = { fg = "white" }
 
@@ -81,6 +86,8 @@
 "ui.menu.selected" = { fg = "black", bg = "blue" }
 "ui.menu.scroll" = { fg = "white", bg = "light-gray" }
 
+"ui.debug" = { fg = "red" }
+
 [palette]
 
 yellow = "#E5C07B"
diff --git a/runtime/themes/onedarker.toml b/runtime/themes/onedarker.toml
index 665f10ed2..7169fd025 100644
--- a/runtime/themes/onedarker.toml
+++ b/runtime/themes/onedarker.toml
@@ -31,6 +31,7 @@
 "markup.raw.block" = { fg = "white" }
 "markup.bold" = { fg = "gold", modifiers = ["bold"] }
 "markup.italic" = { fg = "purple", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.list" = { fg = "red" }
 "markup.quote" = { fg = "yellow" }
 "markup.link.url" = { fg = "blue", modifiers = ["underlined"]}
@@ -41,7 +42,11 @@
 "diff.delta" = "gold"
 "diff.minus" = "red"
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.info".underline = { color = "blue", style = "curl" } 
+"diagnostic.hint".underline = { color = "green", style = "curl" } 
+"diagnostic.warning".underline = { color = "yellow", style = "curl" } 
+"diagnostic.error".underline = { color = "red", style = "curl" } 
+
 "info" = { fg = "blue", modifiers = ["bold"] }
 "hint" = { fg = "green", modifiers = ["bold"] }
 "warning" = { fg = "yellow", modifiers = ["bold"] }
@@ -73,6 +78,8 @@ diagnostic = { modifiers = ["underlined"] }
 "ui.text.focus" = { fg = "white", bg = "light-black", modifiers = ["bold"] }
 
 "ui.help" = { fg = "white", bg = "gray" }
+"ui.debug" = { fg = "red" }
+"ui.highlight.frameline" = { bg = "#97202a" }
 "ui.popup" = { bg = "gray" }
 "ui.window" = { fg = "gray" }
 "ui.menu" = { fg = "white", bg = "gray" }
diff --git a/runtime/themes/onelight.toml b/runtime/themes/onelight.toml
index a21c8ba2b..e35abdb37 100644
--- a/runtime/themes/onelight.toml
+++ b/runtime/themes/onelight.toml
@@ -1,124 +1,190 @@
-# One Light
 # Author : erasin<erasinoo@gmail.com>
 
 "attribute" = { fg = "yellow" }
-"comment" = { fg = "gray", modifiers = ["italic"] }
-
-"constant" = { fg = "cyan" }
-"constant.numeric" = { fg = "gold" }
-"constant.builtin" = { fg = "gold" }
-"constant.character.escape" = { fg = "gold" }
+"label" = { fg = "cyan" }
+"operator" = { fg = "red" }
+"tag" = { fg = "cyan" }
+"special" = { fg = "deep-purple" }
+"property" = { fg = "purple" }
+"constructor" = { fg = "blue" }
+"namespace" = { fg = "blue" }
+"module" = { fg = "blue" }
+
+"type" = { fg = "gold" }
+"type.builtin" = { fg = "yellow" }
+"type.enum" = { fg = "cyan" }
+"type.enum.variant" = { fg = "cyan" }
+
+"constant" = { fg = "cyan", modifiers = ["bold"] }
+"constant.builtin" = { fg = "deep-purple" }
+"constant.builtin.boolean" = { fg = "purple" }
+"constant.character" = { fg = "green" }
+"constant.character.escape" = { fg = "brown" }
+"constant.numeric" = { fg = "brown" }
+"constant.numeric.integer" = { fg = "brown" }
+"constant.numeric.float" = { fg = "brown" }
 
-"constructor" = { fg = "yellow" }
+"string" = { fg = "green" }
+"string.regexp" = { fg = "purple" }
+"string.special" = { fg = "green" }
+"string.special.path" = { fg = "blue" }
+"string.special.url" = { fg = "light-blue" }
+"string.special.symbol" = { fg = "pink" }
+
+"comment" = { fg = "grey", modifiers = ["italic"] }
+"comment.line" = { fg = "grey", modifiers = ["italic"] }
+"comment.block" = { fg = "grey", modifiers = ["italic"] }
+"comment.block.documentation" = { fg = "grey", modifiers = ["italic"] }
+
+# "variable" = { fg = "black" }
+"variable.builtin" = { fg = "light-blue" }
+"variable.parameter" = { fg = "red" }
+"variable.other" = { fg = "pink" }
+"variable.other.member" = { fg = "pink" }
 
-"function" = { fg = "blue" }
-"function.builtin" = { fg = "cyan" }
-"function.macro" = { fg = "red" }
+"punctuation" = { fg = "black" }
+"punctuation.delimiter" = { fg = "purple" }
+"punctuation.bracket" = { fg = "brown" }
+"punctuation.special" = { fg = "brown" }
 
 "keyword" = { fg = "purple" }
-"keyword.function" = { fg = "purple" }
 "keyword.control" = { fg = "purple" }
-"keyword.control.import" = { fg = "purple" }
-"keyword.directive" = { fg = "purple" }
-"keyword.operator" = { fg = "purple" }
+"keyword.control.conditional" = { fg = "red", modifiers = ["bold"] }
+"keyword.control.repeat" = { fg = "pink", modifiers = ["bold"] }
+"keyword.control.import" = { fg = "red" }
+"keyword.control.return" = { fg = "deep-purple", modifiers = ["bold"] }
+"keyword.control.exception" = { fg = "purple" }
+"keyword.operator" = { fg = "red" }
+"keyword.directive" = { fg = "deep-purple" }
+"keyword.function" = { fg = "purple" }
+"keyword.storage" = { fg = "purple" }
 "keyword.storage.type" = { fg = "purple" }
+"keyword.storage.modifier" = { fg = "purple", modifiers = ["bold"] }
 
-"tag" = "cyan"
-"label" = { fg = "cyan" }
-"namespace" = { fg = "red" }
-"operator" = { fg = "red" }
-"special" = { fg = "purple" }
-"string" = { fg = "green" }
-"module" = { fg = "cyan" }
-
-"type" = { fg = "yellow" }
-"type.builtin" = { fg = "purple" }
-
-"punctuation" = { fg = "gray" }
-"punctuation.delimiter" = { fg = "black" }
-"punctuation.bracket" = { fg = "gray" }
-
-"variable" = { fg = "black" }
-"variable.builtin" = { fg = "light-blue" }
-"variable.parameter" = { fg = "red" }
-"variable.other.member" = { fg = "red" }
+"function" = { fg = "blue" }
+"function.builtin" = { fg = "cyan" }
+"function.method" = { fg = "light-blue" }
+"function.macro" = { fg = "pink", modifiers = ["bold"] }
+"function.special" = { fg = "cyan" }
 
 "markup.heading" = { fg = "red" }
-"markup.raw" = { fg = "gray" }
-"markup.raw.inline" = { fg = "green", bg = "grey-200" }
-"markup.bold" = { fg = "yellow", modifiers = ["bold"] }
-"markup.italic" = { fg = "purple", modifiers = ["italic"] }
-"markup.list" = { fg = "light-blue" }
-"markup.quote" = { fg = "gray" }
-"markup.link.url" = { fg = "cyan", modifiers = ["underlined"] }
-"markup.link.text" = { fg = "light-blue" }
+"markup.heading.marker" = { fg = "red" }
 "markup.heading.1" = { fg = "red", modifiers = ["bold"] }
-"markup.heading.2" = { fg = "gold", modifiers = ["bold"] }
+"markup.heading.2" = { fg = "gold", modifiers = [
+  "bold",
+], underline = { style = "line" } }
 "markup.heading.3" = { fg = "yellow", modifiers = ["bold"] }
 "markup.heading.4" = { fg = "green", modifiers = ["bold"] }
 "markup.heading.5" = { fg = "blue", modifiers = ["bold"] }
 "markup.heading.6" = { fg = "purple", modifiers = ["bold"] }
+"markup.list" = { fg = "light-blue" }
+"markup.list.unnumbered" = { fg = "light-blue" }
+"markup.list.numbered" = { fg = "light-blue" }
+"markup.list.checked" = { fg = "green" }
+"markup.list.unchecked" = { fg = "blue" }
+"markup.bold" = { fg = "yellow", modifiers = ["bold"] }
+"markup.italic" = { fg = "purple", modifiers = ["italic"] }
+"markup.strikethrough" = { fg = "red", modifiers = ["crossed_out"] }
+"markup.link" = { fg = "light-blue" }
+"markup.link.url" = { fg = "cyan", modifiers = ["underlined"] }
+"markup.link.text" = { fg = "light-blue" }
+"markup.quote" = { fg = "grey" }
+"markup.raw" = { fg = "brown" }
+"markup.raw.inline" = { fg = "green" }
+"markup.raw.block" = { fg = "grey" }
 
-"diff.plus" = "green"
-"diff.delta" = "gold"
-"diff.minus" = "red"
-
-"diagnostic" = { modifiers = ["underlined"] }
-"info" = { fg = "blue", modifiers = ["bold"] }
-"hint" = { fg = "green", modifiers = ["bold"] }
-"warning" = { fg = "yellow", modifiers = ["bold"] }
-"error" = { fg = "red", modifiers = ["bold"] }
+"diff" = { fg = "red" }
+"diff.plus" = { fg = "green" }
+"diff.minus" = { fg = "red" }
+"diff.delta" = { fg = "cyan" }
+"diff.delta.moved" = { fg = "cyan" }
 
 "ui.background" = { bg = "white" }
+"ui.background.separator" = { bg = "white" }
 
-"ui.cursor" = { fg = "white", bg = "gray" }
+"ui.cursor" = { fg = "white", bg = "grey" }
+"ui.cursor.normal" = { fg = "white", bg = "grey" }
+"ui.cursor.insert" = { fg = "white", bg = "grey" }
+"ui.cursor.select" = { fg = "white", bg = "grey" }
+"ui.cursor.match" = { bg = "grey-300", modifiers = ["bold"] }
 "ui.cursor.primary" = { fg = "white", bg = "black" }
-"ui.cursor.match" = { bg = "light-gray" }
+"ui.cursor.primary.normal" = { fg = "white", bg = "black" }
+"ui.cursor.primary.insert" = { fg = "red", bg = "black" }
+"ui.cursor.primary.select" = { fg = "white", bg = "black" }
 
-"ui.cursorline.primary" = { fg = "white", bg = "grey-100" }
-# "ui.cursorline.secondary" = { fg = "white", bg = "grey-200" }
+"ui.gutter" = { fg = "grey-500" }
+"ui.gutter.selected" = { fg = "black" }
 
-"ui.highlight" = { bg = "light-white" }
+"ui.linenr" = { fg = "grey-500" }
+"ui.linenr.selected" = { fg = "black", modifiers = ["bold"] }
+
+"ui.statusline" = { fg = "black", bg = "grey-300" }
+"ui.statusline.inactive" = { fg = "grey", bg = "grey-200" }
+"ui.statusline.normal" = { fg = "grey-300", bg = "light-blue" }
+"ui.statusline.insert" = { fg = "grey-300", bg = "green" }
+"ui.statusline.select" = { fg = "grey-300", bg = "purple" }
 
-"ui.selection" = { bg = "light-white", modifiers = ["dim"] }
-"ui.selection.primary" = { bg = "light-white" }
+"ui.popup" = { fg = "black", bg = "grey-200" }
+"ui.popup.info" = { fg = "black", bg = "grey-200" }
+"ui.window" = { fg = "grey-500", bg = "grey-100" }
+"ui.help" = { fg = "black", bg = "grey-200" }
 
-"ui.virtual" = { fg = "light-white" }
+"ui.text" = { fg = "black" }
+"ui.text.focus" = { fg = "red", bg = "grey-300", modifiers = ["bold"] }
+"ui.text.inactive" = { fg = "grey" }
+"ui.text.info" = { fg = "black" }
+
+"ui.virtual" = { fg = "grey-500" }
+"ui.virtual.ruler" = { bg = "grey-200" }
+"ui.virtual.wrap" = { fg = "grey-500" }
+"ui.virtual.whitespace" = { fg = "grey-300" }
 "ui.virtual.indent-guide" = { fg = "grey-500" }
-"ui.virtual.ruler" = { bg = "light-white" }
-"ui.virtual.whitespace" = { fg = "light-white" }
+"ui.virtual.inlay-hint" = { fg = "grey-500" }
+"ui.virtual.inlay-hint.parameter" = { fg = "grey-500", modifiers = ["italic"] }
+"ui.virtual.inlay-hint.type" = { fg = "grey-500" }
 
-"ui.linenr" = { fg = "grey-500" }
-"ui.linenr.selected" = { fg = "black", modifiers = ["dim"] }
+"ui.menu" = { fg = "black", bg = "grey-300" }
+"ui.menu.selected" = { fg = "white", bg = "light-blue" }
+"ui.menu.scroll" = { fg = "light-blue", bg = "white" }
 
-"ui.statusline" = { fg = "black", bg = "light-white" }
-"ui.statusline.inactive" = { fg = "gray", bg = "light-white" }
-"ui.statusline.normal" = { fg = "light-white", bg = "light-blue" }
-"ui.statusline.insert" = { fg = "light-white", bg = "green" }
-"ui.statusline.select" = { fg = "light-white", bg = "purple" }
+"ui.selection" = { bg = "grey-300", modifiers = ["dim"] }
+"ui.selection.primary" = { bg = "grey-300" }
 
-"ui.text" = { fg = "black" }
-"ui.text.focus" = { fg = "red", bg = "light-white", modifiers = ["bold"] }
+"ui.cursorline.primary" = { fg = "white", bg = "grey-100" }
+"ui.cursorline.secondary" = { fg = "white", bg = "grey-200" }
 
-"ui.help" = { fg = "black", bg = "grey-200" }
-"ui.popup" = { fg = "black", bg = "grey-200" }
-"ui.window" = { fg = "black", bg = "light-white" }
-"ui.menu" = { fg = "black", bg = "light-white" }
-"ui.menu.selected" = { fg = "white", bg = "light-blue" }
+"ui.cursorcolumn.primary" = { fg = "white", bg = "grey-100" }
+"ui.cursorcolumn.secondary" = { fg = "white", bg = "grey-200" }
+
+"ui.highlight" = { bg = "grey-300" }
+
+"diagnostic.info" = { underline = { color = "blue", style = "dotted" } }
+"diagnostic.hint" = { underline = { color = "green", style = "dashed" } }
+"diagnostic.warning" = { underline = { color = "yellow", style = "curl" } }
+"diagnostic.error" = { underline = { color = "red", style = "curl" } }
+
+"info" = { fg = "blue", modifiers = ["bold"] }
+"hint" = { fg = "green", modifiers = ["bold"] }
+"warning" = { fg = "yellow", modifiers = ["bold"] }
+"error" = { fg = "red", modifiers = ["bold"] }
 
 [palette]
 white = "#FAFAFA"
-yellow = "#A06600"
+yellow = "#FF6F00"
+gold = "#D35400"
+brown = "#795548"
 blue = "#0061FF"
-light-blue = "#1877F2"
-red = "#DC003F"
+light-blue = "#0091EA"
+red = "#D50000"
+pink = "#C2185B"
 purple = "#B500A9"
+deep-purple = "#651FFF"
 green = "#24A443"
-gold = "#D35400"
 cyan = "#0086C1"
 black = "#282C34"
-light-white = "#E3E3E3"
-gray = "#5C6370"
-grey-100 = "#F3F3F3"
-grey-200 = "#EDEDED"
+grey = "#5C6370"
 grey-500 = "#9E9E9E"
+grey-400 = "#BDBDBD"
+grey-300 = "#E0E0E0"
+grey-200 = "#EEEEEE"
+grey-100 = "#F2F2F2"
diff --git a/runtime/themes/papercolor-dark.toml b/runtime/themes/papercolor-dark.toml
index 940aacfe2..eaaa36dcf 100644
--- a/runtime/themes/papercolor-dark.toml
+++ b/runtime/themes/papercolor-dark.toml
@@ -7,6 +7,7 @@
 "ui.text.focus" = { fg = "selection_background", modifiers = ["bold"]}
 "ui.selection" = {bg="selection_background", fg="selection_foreground"}
 "ui.cursorline" = {bg="cursorline_background"}
+"ui.highlight" = {bg="cursorline_background"}
 "ui.statusline" = {bg="paper_bar_bg", fg="regular0"}
 "ui.statusline.select" = {bg="background", fg="bright7"}
 "ui.statusline.normal" = {bg="background", fg="bright3"}
@@ -31,6 +32,7 @@
 "markup.list" = "bright3"
 "markup.bold" = { fg = "foreground", modifiers = ["bold"] }
 "markup.italic" = { fg = "bright0", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "bright6", modifiers = ["underlined"] }
 "markup.link.text" = "bright2"
 "markup.link.label" = { fg = "regular2", modifiers = ["bold"] }
@@ -73,7 +75,11 @@
 "warning" = "bright4"
 "error" = "regular1"
 "info" = "bright4"
-diagnostic = { modifiers = ["bold", "underlined"]}
+
+"diagnostic.warning".underline = { color = "bright4", style = "curl" } 
+"diagnostic.error".underline = { color = "regular1", style = "curl" } 
+"diagnostic.info".underline = { color = "bright4", style = "curl" } 
+"diagnostic.hint".underline = { color = "bright4", style = "curl" } 
 
 
 [palette]
diff --git a/runtime/themes/papercolor-light.toml b/runtime/themes/papercolor-light.toml
index 70b973d3e..63671e1b3 100644
--- a/runtime/themes/papercolor-light.toml
+++ b/runtime/themes/papercolor-light.toml
@@ -6,6 +6,7 @@
 "ui.text" = "foreground"
 "ui.text.focus" = { fg = "selection_background", modifiers = ["bold"]}
 "ui.selection" = {bg="selection_background", fg="selection_foreground"}
+"ui.highlight" = {bg="cursorline_background"}
 "ui.cursorline" = {bg="cursorline_background"}
 "ui.statusline" = {bg="paper_bar_bg", fg="regular0"}
 "ui.statusline.select" = {bg="background", fg="bright7"}
@@ -32,6 +33,7 @@
 "markup.list" = "regular4"
 "markup.bold" = { fg = "foreground", modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "regular4", modifiers = ["underlined"] }
 "markup.link.text" = "bright2"
 "markup.link.label" = { fg = "regular7", modifiers = ["bold"] }
@@ -72,7 +74,11 @@
 "warning" = "bright4"
 "error" = "regular1"
 "info" = "#FFAF00"
-diagnostic = { modifiers = ["bold", "underlined"]}
+
+"diagnostic.warning".underline = { color = "bright4", style = "curl" } 
+"diagnostic.error".underline = { color = "regular1", style = "curl" } 
+"diagnostic.info".underline = { color = "#FFAF00", style = "curl" } 
+"diagnostic.hint".underline = { color = "#FFAF00", style = "curl" } 
 
 
 [palette]
diff --git a/runtime/themes/penumbra+.toml b/runtime/themes/penumbra+.toml
index 790598323..bc53e82e0 100644
--- a/runtime/themes/penumbra+.toml
+++ b/runtime/themes/penumbra+.toml
@@ -43,7 +43,10 @@ info = "sky"
 warning = "yellow"
 error = "red"
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.hint".underline = { color = "sky-", style = "curl" } 
+"diagnostic.info".underline = { color = "sky", style = "curl" } 
+"diagnostic.warning".underline = { color = "yellow", style = "curl" } 
+"diagnostic.error".underline = { color = "red", style = "curl" } 
 
 "ui.background" = { bg = "shade" }
 "ui.background.separator" = "sky"
@@ -92,6 +95,7 @@ diagnostic = { modifiers = ["underlined"] }
 "markup.list" = "sky"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { modifiers = ["underlined"] }
 "markup.link.text" = "magenta"
 "markup.quote" = "green"
diff --git a/runtime/themes/pop-dark.toml b/runtime/themes/pop-dark.toml
index 6ad0111b7..6393dd730 100644
--- a/runtime/themes/pop-dark.toml
+++ b/runtime/themes/pop-dark.toml
@@ -8,10 +8,13 @@ info = { fg = 'yellowH', bg = 'brownD' }
 hint = { fg = 'brownD', bg = 'yellowH', modifiers = ['bold'] }
 warning = { fg = 'brownD', bg = 'orangeW', modifiers = ['bold'] }
 error = { fg = 'brownD', bg = 'redE', modifiers = ['bold'] }
-diagnostic = { fg = 'greyT', bg = 'redD' }
+'diagnostic.info'.underline = { color = 'yellowH', style = 'curl' } 
+'diagnostic.hint'.underline = { color = 'yellowH', style = 'curl' } 
+'diagnostic.warning'.underline = { color = 'orangeW', style = 'curl' } 
+'diagnostic.error'.underline = { color = 'redE', style = 'curl' } 
 'ui.background' = { bg = 'brownN' }
-'ui.window' = { bg = 'brownH', fg = "brownD" } 
-'ui.gutter' = { bg = 'brownH' }
+'ui.window' = { bg = 'brownH', fg = 'brownD' } 
+'ui.gutter' = { bg = 'brownU' }
 'ui.text' = { fg = 'greyT' }
 'ui.text.focus' = { fg = 'orangeN' }
 'ui.text.info' = { fg = 'orangeH', bg = 'brownH' }
@@ -22,18 +25,22 @@ diagnostic = { fg = 'greyT', bg = 'redD' }
 'ui.cursor.primary' = { fg = 'black', bg = 'orangeN' }
 'ui.selection' = { bg = 'blueH', fg = 'white' }
 'ui.selection.primary' = { bg = 'blueD', fg = 'white' }
-'ui.linenr' = { bg = "brownN", fg = 'greyL' }
-'ui.linenr.selected' = { bg = 'brownH', fg = 'orangeH' }
-'ui.cursorline' = { bg = 'brownD' }
-'ui.statusline' = { fg = "greyT", bg = 'brownH' }
-'ui.statusline.inactive' = { fg = "greyT", bg = 'brownN' }
-'ui.help' = { fg = "greyT", bg = 'brownD' }
+'ui.linenr' = { bg = 'brownU', fg = 'greyL' }
+'ui.linenr.selected' = { fg = 'orangeH' }
+'ui.cursorline' = { bg = 'brownH' }
+'ui.statusline' = { fg = 'greyT', bg = 'brownU' }
+'ui.statusline.inactive' = { fg = 'greyT', bg = 'brownN' }
+'ui.statusline.normal' = { fg = 'greyT', bg = 'brownD', modifiers = ['bold'] }
+'ui.statusline.select' = { bg = 'blueL', fg = 'brownD', modifiers = ['bold'] }
+'ui.statusline.insert' = { bg = 'orangeL', fg = 'brownD', modifiers = ['bold'] }
+'ui.help' = { fg = 'greyT', bg = 'brownD' }
 'ui.highlight' = { bg = 'brownH' }
 'ui.virtual' = { fg = 'brownV' }
 'ui.virtual.ruler' = { bg = 'brownR' }
 'ui.virtual.whitespace' = { fg = 'brownV' }
 'ui.virtual.indent-guide' = { fg = 'brownR' }
-'ui.menu' = { fg = "greyT", bg = 'brownD' }
+'ui.virtual.inlay-hint' = {fg = 'brownD', bg = 'brownU'}
+'ui.menu' = { fg = 'greyT', bg = 'brownD' }
 'ui.menu.selected' = { fg = 'orangeH', bg = 'brownH' }
 'ui.popup' = { bg = 'brownD' }
 'ui.popup.info' = { bg = 'brownH', fg = 'greyT' }
@@ -100,6 +107,7 @@ namespace = { fg = 'orangeL' }
 'markup.list.unnumbered' = { fg = 'greenN' }
 'markup.bold' = { modifiers = ['bold'] }
 'markup.italic' = { modifiers = ['italic'] }
+'markup.strikethrough' = { modifiers = ['crossed_out'] }
 'markup.link' = { fg = 'blueD' }
 'markup.link.url' = { fg = 'blueL' }
 'markup.link.label' = { fg = 'blueH' }
@@ -147,8 +155,8 @@ blueL = '#6dd2fa'
 blueN = '#39B7C7'
 blueD = '#4AAAD6'
 brownV = '#67634F'
-brownH = '#56524E'
-brownN = '#3F3B39'
+brownH = '#4b4845'
+brownN = '#3E3B39'
 brownR = '#35312f'
 brownD = '#2B2928'
-
+brownU = '#4C4643'
diff --git a/runtime/themes/rasmus.toml b/runtime/themes/rasmus.toml
index a7baa83c6..bcfb0c66c 100644
--- a/runtime/themes/rasmus.toml
+++ b/runtime/themes/rasmus.toml
@@ -55,6 +55,7 @@
 "markup.list" = "gray07"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "cyan", modifiers = ["underlined"] }
 "markup.link.text" = "blue"
 "markup.raw" = "yellow"
@@ -84,6 +85,7 @@
 
 "ui.virtual" = { fg = "gray03" }
 "ui.virtual.indent-guide" = { fg = "gray04" }
+"ui.virtual.inlay-hint" = { fg = "gray05" }
 
 "ui.selection" = { bg = "gray03" }
 "ui.selection.primary" = { bg = "gray03" }
@@ -100,7 +102,10 @@
 "ui.menu.selected" = { fg = "fg", bg = "gray03" }
 "ui.menu.scroll" = { fg = "white", bg = "gray01" }
 
-diagnostic = { modifiers = ["underlined"] }
+"diagnostic.warning".underline = { color = "bright_yellow", style = "curl" } 
+"diagnostic.error".underline = { color = "bright_red", style = "curl" } 
+"diagnostic.info".underline = { color = "bright_blue", style = "curl" } 
+"diagnostic.hint".underline = { color = "bright_cyan", style = "curl" } 
 
 warning = "bright_yellow"
 error = "bright_red"
diff --git a/runtime/themes/rose_pine.toml b/runtime/themes/rose_pine.toml
index 14e240dd5..ea17ac224 100644
--- a/runtime/themes/rose_pine.toml
+++ b/runtime/themes/rose_pine.toml
@@ -1,84 +1,189 @@
-# Author: RayGervais<raygervais@hotmail.ca>
-# Author: ChrisHa<chunghha@users.noreply.github.com>
+# Author: Ros Pine <hi@rosepinetheme.com>
+# Upstream: https://github.com/rose-pine/helix
+# Contributing:
+#   Please submit changes to https://github.com/rose-pine/helix.
+#   The Ros Pine team will update Helix, including you as a co-author.
 
 "ui.background" = { bg = "base" }
-"ui.menu" = { fg = "text", bg = "overlay" }
-"ui.menu.selected" = { fg = "iris", bg = "surface" }
-"ui.linenr" = {fg = "subtle" }
-"ui.liner.selected" = "highlightOverlay"
-"ui.selection" = { bg = "highlight" }
-"comment" = "subtle"
-"ui.cursorline" = { bg = "surface" }
-"ui.statusline" = {fg = "foam", bg = "surface" }
-"ui.statusline.insert" = {fg = "base", bg = "foam", modifiers = ["bold"]}
-"ui.statusline.normal" = {fg = "base", bg = "rose", modifiers = ["bold"]}
-"ui.statusline.select" = {fg = "base", bg = "iris", modifiers = ["bold"]}
-"ui.statusline.inactive" = { fg = "iris", bg = "surface" }
-"ui.cursor" = { fg = "rose", modifiers = ["reversed"] }
-"ui.text" = { fg = "text" }
-"ui.text.focus" = { fg = "foam", modifiers = ["bold"]}
-"ui.text.info" = {fg = "pine", modifiers = ["bold"]}
-"ui.virtual.whitespace" = "highlight"
-"ui.virtual.ruler" = { bg = "surface" }
-"operator" = "rose"
-"variable" = "text"
-"constant.numeric" = "iris"
-"constant" = "gold"
-"attribute" = "gold" 
-"type" = "foam"
-"ui.cursor.match" = { fg = "gold", modifiers = ["underlined"] }
-"string"  = "gold"
-"constant.character.escape" = "subtle"
-"function" = "rose"
-"function.builtin" = "rose"
-"function.method"  = "foam"
-"constructor" = "gold"
-"special" = "gold"
-"keyword" = "pine"
-"label" = "iris"
-"namespace" = "pine"
+"ui.background.separator" = { bg = "base" }
+
+"ui.cursor" = { fg = "text", bg = "highlight_high" }
+# "ui.cursor.select" = {}
+"ui.cursor.match" = { fg = "text", bg = "highlight_med" }
+"ui.cursor.primary" = { fg = "text", bg = "muted"}
+
+# "ui.gutter" = {}
+# "ui.gutter.selected" = {}
+
+"ui.linenr" = { fg = "muted" }
+"ui.linenr.selected" = { fg = "text" }
+
+"ui.statusline" = { fg = "subtle", bg = "surface" }
+"ui.statusline.inactive" = { fg = "muted", bg = "surface" }
+"ui.statusline.normal" = { fg = "rose", bg = "rose_10" }
+"ui.statusline.insert" = { fg = "foam", bg = "foam_10" }
+"ui.statusline.select" = { fg = "iris", bg = "iris_10" }
+# "ui.statusline.separator" = {}
+
 "ui.popup" = { bg = "surface" }
 "ui.popup.info" = { bg = "surface" }
-"ui.window" = { bg = "base" }
-"ui.help" = { bg = "overlay", fg = "foam" }
-"diff.plus" = "foam"
-"diff.delta" = "rose"
-"diff.minus" = "love"
 
-"info" = "gold"
-"hint" = "gold"
-"debug" = "rose"
-"diagnostic" = "rose"
+"ui.window" = { fg = "overlay", bg = "base" }
+"ui.help" = { fg = "subtle", bg = "overlay" }
+
+"ui.text" = { fg = "text" }
+# "ui.text.focus" = {}
+"ui.text.info" = { fg = "subtle" }
+
+"ui.virtual.ruler" = { bg = "overlay" }
+"ui.virtual.whitespace" = { fg = "highlight_low" }
+"ui.virtual.indent-guide" = { fg = "muted" }
+"ui.virtual.inlay-hint" = { fg = "subtle" }
+
+"ui.menu" = { fg = "subtle", bg = "surface" }
+"ui.menu.selected" = { fg = "text" }
+"ui.menu.scroll" = { fg = "muted", bg = "highlight_med" }
+
+"ui.selection" = { bg = "overlay" }
+"ui.selection.primary" = { bg = "highlight_med" }
+
+"ui.cursorline.primary" = { bg = "highlight_low" }
+"ui.cursorline.secondary" = { bg = "surface" }
+
+"warning" = "gold"
 "error" = "love"
+"info" = "foam"
+"hint" = "iris"
+"debug" = "rose"
+
+"diagnostic" = { underline = { color = "subtle", style = "curl" } }
+"diagnostic.hint" = { underline = { color = "iris", style = "curl" } }
+"diagnostic.info" = { underline = { color = "foam", style = "curl" } }
+"diagnostic.warning" = { underline = { color = "gold", style = "curl" } }
+"diagnostic.error" = { underline = { color = "love", style = "curl" } }
 
-"markup.heading.marker" = "subtle"
-"markup.heading.1" = { fg = "love", modifiers = ["bold"] }
-"markup.heading.2" = { fg = "gold", modifiers = ["bold"] }
+"attribute" = "iris"
+
+"type" = "foam"
+# "type.builtin" = ""
+
+"constructor" = "foam"
+
+"constant" = "foam"
+"constant.builtin" = "rose"
+# "constant.builtin.boolean" = ""
+"constant.character" = "gold"
+"constant.character.escape" = "pine"
+"constant.numeric" = "gold"
+# "constant.numeric.integer" = ""
+# "constant.numeric.float" = ""
+
+"string" = "gold"
+# "string.regexp" = ""
+# "string.special" = ""
+# "string.special.path" = ""
+# "string.special.url" = ""
+# "string.special.symbol" = ""
+
+"comment" = { fg = "muted", modifiers = ["italic"]}
+# "comment.line" = ""
+# "comment.block" = ""
+# "comment.block.documenation" = ""
+
+"variable" = "text"
+"variable.builtin" = "love"
+"variable.parameter" = "iris"
+# "variable.other" = ""
+# "variable.other.member" = ""
+
+"label" = "foam"
+
+"punctuation" = "subtle"
+# "punctuation.delimiter" = ""
+# "punctuation.bracket" = ""
+# "punctuation.special" = ""
+
+"keyword" = "pine"
+# "keyword.control" = ""
+# "keyword.control.conditional" = ""
+# "keyword.control.repeat" = ""
+# "keyword.control.import" = ""
+# "keyword.control.return" = ""
+# "keyword.control.exception" = ""
+"keyword.operator" = "subtle"
+# "keyword.directive" = ""
+# "keyword.function" = ""
+# "keyword.storage" = ""
+# "keyword.storage.type" = ""
+# "keyword.storage.modifier" = ""
+
+"operator" = "subtle"
+
+"function" = "rose" # maybe pine
+"function.builtin" = "love"
+# "function.method" = ""
+# "function.macro" = ""
+# "function.special" = ""
+
+"tag" = "foam"
+
+"namespace" = "iris"
+
+"markup.heading.marker" = "muted"
+"markup.heading" = { fg = "iris", modifiers = ["bold"] }
+"markup.heading.1" = { fg = "iris", modifiers = ["bold"] }
+"markup.heading.2" = { fg = "foam", modifiers = ["bold"] }
 "markup.heading.3" = { fg = "rose", modifiers = ["bold"] }
-"markup.heading.4" = { fg = "pine", modifiers = ["bold"] }
-"markup.heading.5" = { fg = "foam", modifiers = ["bold"] }
-"markup.heading.6" = { fg = "iris", modifiers = ["bold"] }
-"markup.list" = { fg = "love" }
-"markup.bold" = { fg = "gold", modifiers = ["bold"] }
-"markup.italic" = { fg = "iris", modifiers = ["italic"] }
-"markup.link.url" = { fg = "pine", modifiers = ["underlined"]}
-"markup.link.text" = { fg = "foam" }
-"markup.quote" = { fg = "rose" }
-"markup.raw" = { fg = "foam" }
+"markup.heading.4" = { fg = "gold", modifiers = ["bold"] }
+"markup.heading.5" = { fg = "pine", modifiers = ["bold"] }
+"markup.heading.6" = { fg = "foam", modifiers = ["bold"] }
+# "markup.heading.completion" = ""
+# "markup.heading.hover" = ""
+"markup.list" = "muted"
+# "markup.list.unnumbered" = ""
+# "markup.list.numbered" = ""
+"markup.bold" = { modifiers = ["bold"] }
+"markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
+"markup.link" = "iris"
+"markup.link.url" = { fg = "iris",  underline = { color = "iris", style = "line" } } 
+"markup.link.label" = "subtle"
+"markup.link.text" = "text"
+"markup.quote" = "subtle"
+"markup.raw" = "subtle"
+# "markup.raw.inline" = {}
+# "markup.raw.inline.completion" = {}
+# "markup.raw.inline.hover" = {}
+# "markup.raw.block" = {}
+# "markup.normal" = ""
+# "markup.normal.completion" = ""
+# "markup.normal.hover" = ""
+
+"diff" = "overlay"
+"diff.plus" = "foam"
+"diff.minus" = "love"
+"diff.delta" = "highlight_high"
+# "diff.delta.moved" = ""
 
 [palette]
-base     = "#191724" 
-surface  = "#1f1d2e" 
-overlay  = "#26233a"
-inactive = "#555169"
-subtle   = "#6e6a86"
-text     = "#e0def4"
-love     = "#eb6f92"
-gold     = "#f6c177"
-rose     = "#ebbcba"
-pine     = "#31748f"
-foam     = "#9ccfd8"
-iris     = "#c4a7e7"
-highlight = "#403d52"
-highlightInactive = "#21202e"
-highlightOverlay = "#524f67"
+base           = "#191724" 
+surface        = "#1f1d2e" 
+overlay        = "#26233a"
+muted          = "#6e6a86"
+subtle         = "#908caa"
+text           = "#e0def4"
+love           = "#eb6f92"
+love_10        = "#311f30"
+gold           = "#f6c177"
+gold_10        = "#30282c"
+rose           = "#ebbcba"
+rose_10        = "#2f2834"
+pine           = "#31748f"
+pine_10        = "#1a2030"
+foam           = "#9ccfd8"
+foam_10        = "#252937"
+iris           = "#c4a7e7"
+iris_10        = "#2b2539"
+highlight_low  = "#21202e"
+highlight_med  = "#403d52"
+highlight_high = "#524f67"
diff --git a/runtime/themes/rose_pine_dawn.toml b/runtime/themes/rose_pine_dawn.toml
index c6609c218..d3949e1a5 100644
--- a/runtime/themes/rose_pine_dawn.toml
+++ b/runtime/themes/rose_pine_dawn.toml
@@ -1,81 +1,30 @@
-# Author: RayGervais<raygervais@hotmail.ca>
-# Author: ChrisHa<chunghha@users.noreply.github.com>
+# Author: Ros Pine <hi@rosepinetheme.com>
+# Upstream: https://github.com/rose-pine/helix
+# Contributing:
+#   Please submit changes to https://github.com/rose-pine/helix.
+#   The Ros Pine team will update Helix, including you as a co-author.
 
-"ui.background" = { bg = "surface" }
-"ui.menu" = { fg = "text", bg = "overlay" }
-"ui.menu.selected" = { fg = "iris", bg = "surface" }
-"ui.linenr" = {fg = "subtle" }
-"ui.liner.selected" = "highlightOverlay"
-"ui.selection" = { bg = "highlight" }
-"comment" = "subtle"
-"ui.cursorline" = {bg = "base" }
-"ui.statusline" = {fg = "foam", bg = "surface" }
-"ui.statusline.inactive" = { fg = "iris", bg = "surface" }
-"ui.cursor" = { fg = "rose", modifiers = ["reversed"] }
-"ui.text" = { fg = "text" }
-"ui.text.focus" = { fg = "foam", modifiers = ["bold"]}
-"ui.text.info" = {fg = "pine", modifiers = ["bold"]}
-"ui.virtual.whitespace" = "highlight"
-"ui.virtual.ruler" = { bg = "base" }
-"operator" = "rose"
-"variable" = "text"
-"number" = "iris"
-"constant" = "gold"
-"attribute" = "gold" 
-"type" = "foam"
-"ui.cursor.match" = { fg = "gold", modifiers = ["underlined"] }
-"string"  = "gold"
-"escape" = "subtle"
-"function" = "rose"
-"function.builtin" = "rose"
-"function.method"  = "foam"
-"constructor" = "gold"
-"special" = "gold"
-"keyword" = "pine"
-"label" = "iris"
-"namespace" = "pine"
-"ui.popup" = { bg = "surface" }
-"ui.popup.info" = { bg = "surface" }
-"ui.window" = { bg = "base" }
-"ui.help" = { bg = "overlay", fg = "foam" }
-"diff.plus" = "foam"
-"diff.delta" = "rose"
-"diff.minus" = "love"
-
-"info" = "gold"
-"hint" = "gold"
-"debug" = "rose"
-"diagnostic" = "rose"
-"error" = "love"
-
-"markup.heading.marker" = "subtle"
-"markup.heading.1" = { fg = "love", modifiers = ["bold"] }
-"markup.heading.2" = { fg = "gold", modifiers = ["bold"] }
-"markup.heading.3" = { fg = "rose", modifiers = ["bold"] }
-"markup.heading.4" = { fg = "pine", modifiers = ["bold"] }
-"markup.heading.5" = { fg = "foam", modifiers = ["bold"] }
-"markup.heading.6" = { fg = "iris", modifiers = ["bold"] }
-"markup.list" = { fg = "love" }
-"markup.bold" = { fg = "gold", modifiers = ["bold"] }
-"markup.italic" = { fg = "iris", modifiers = ["italic"] }
-"markup.link.url" = { fg = "pine", modifiers = ["underlined"]}
-"markup.link.text" = { fg = "foam" }
-"markup.quote" = { fg = "rose" }
-"markup.raw" = { fg = "foam" }
+inherits = "rose_pine"
 
 [palette]
-base     = "#faf4ed" 
-surface  = "#fffaf3" 
-overlay  = "#f2e9de"
-inactive = "#9893a5"
-subtle   = "#6e6a86"
-text     = "#575279"
-love     = "#b4637a"
-gold     = "#ea9d34"
-rose     = "#d7827e"
-pine     = "#286983"
-foam     = "#56949f"
-iris     = "#907aa9"
-highlight = "#dfdad9"
-highlightInactive = "#f4ede8"
-highlightOverlay = "#cecacd"
+base           = "#faf4ed" 
+surface        = "#fffaf3" 
+overlay        = "#f2e9e1"
+muted          = "#9893a5"
+subtle         = "#797593"
+text           = "#575279"
+love           = "#b4637a"
+love_10        = "#f6e4e0"
+gold           = "#ea9d34"
+gold_10        = "#fbead8"
+rose           = "#d7827e"
+rose_10        = "#fae8e1"
+pine           = "#286983"
+pine_10        = "#e5e6e2"
+foam           = "#56949f"
+foam_10        = "#eaeae5"
+iris           = "#907aa9"
+iris_10        = "#f1e8e6"
+highlight_low  = "#f4ede8"
+highlight_med  = "#dfdad9"
+highlight_high = "#cecacd"
diff --git a/runtime/themes/rose_pine_moon.toml b/runtime/themes/rose_pine_moon.toml
index fc27d2c0a..f1d04dd32 100644
--- a/runtime/themes/rose_pine_moon.toml
+++ b/runtime/themes/rose_pine_moon.toml
@@ -1,88 +1,30 @@
-# Author: RayGervais<raygervais@hotmail.ca>
-# Author: ChrisHa<chunghha@users.noreply.github.com>
-# Author: ATahaBaki<atahabaki@pm.me>
-# This theme is based on rose_pine theme. I just converted their
-# rose_pine theme.
+# Author: Ros Pine <hi@rosepinetheme.com>
+# Upstream: https://github.com/rose-pine/helix
+# Contributing:
+#   Please submit changes to https://github.com/rose-pine/helix.
+#   The Ros Pine team will update Helix, including you as a co-author.
 
-"ui.background" = { bg = "base" }
-"ui.menu" = { fg = "text", bg = "overlay" }
-"ui.menu.selected" = { fg = "iris", bg = "surface" }
-"ui.linenr" = {fg = "subtle" }
-"ui.liner.selected" = "highlightOverlay"
-"ui.selection" = { bg = "highlight" }
-"comment" = "subtle"
-"ui.cursorline" = {bg = "dimBase" }
-"ui.statusline" = {fg = "foam", bg = "surface" }
-"ui.statusline.insert" = {fg = "base", bg = "foam", modifiers = ["bold"]}
-"ui.statusline.normal" = {fg = "base", bg = "rose", modifiers = ["bold"]}
-"ui.statusline.select" = {fg = "base", bg = "iris", modifiers = ["bold"]}
-"ui.statusline.inactive" = { fg = "iris", bg = "surface" }
-"ui.cursor" = { fg = "rose", modifiers = ["reversed"] }
-"ui.text" = { fg = "text" }
-"ui.text.focus" = { fg = "foam", modifiers = ["bold"]}
-"ui.text.info" = {fg = "pine", modifiers = ["bold"]}
-"ui.virtual.whitespace" = "highlight"
-"ui.virtual.ruler" = {bg = "dimBase" }
-"operator" = "rose"
-"variable" = "text"
-"constant.numeric" = "iris"
-"constant" = "gold"
-"attribute" = "gold" 
-"type" = "foam"
-"ui.cursor.match" = { fg = "gold", modifiers = ["underlined"] }
-"string"  = "gold"
-"constant.character.escape" = "subtle"
-"function" = "rose"
-"function.builtin" = "rose"
-"function.method"  = "foam"
-"constructor" = "gold"
-"special" = "gold"
-"keyword" = "pine"
-"label" = "iris"
-"namespace" = "pine"
-"ui.popup" = { bg = "surface" }
-"ui.popup.info" = { bg = "surface" }
-"ui.window" = { bg = "base" }
-"ui.help" = { bg = "overlay", fg = "foam" }
-"diff.plus" = "foam"
-"diff.delta" = "rose"
-"diff.minus" = "love"
-
-"info" = "gold"
-"hint" = "gold"
-"debug" = "rose"
-"diagnostic" = "rose"
-"error" = "love"
-
-"markup.heading.marker" = "subtle"
-"markup.heading.1" = { fg = "love", modifiers = ["bold"] }
-"markup.heading.2" = { fg = "gold", modifiers = ["bold"] }
-"markup.heading.3" = { fg = "rose", modifiers = ["bold"] }
-"markup.heading.4" = { fg = "pine", modifiers = ["bold"] }
-"markup.heading.5" = { fg = "foam", modifiers = ["bold"] }
-"markup.heading.6" = { fg = "iris", modifiers = ["bold"] }
-"markup.list" = { fg = "love" }
-"markup.bold" = { fg = "gold", modifiers = ["bold"] }
-"markup.italic" = { fg = "iris", modifiers = ["italic"] }
-"markup.link.url" = { fg = "pine", modifiers = ["underlined"]}
-"markup.link.text" = { fg = "foam" }
-"markup.quote" = { fg = "rose" }
-"markup.raw" = { fg = "foam" }
+inherits = "rose_pine"
 
 [palette]
-dimBase  = "#201e30" 
-base     = "#232136" 
-surface  = "#2a273f" 
-overlay  = "#393552"
-inactive = "#6e6a86"
-subtle   = "#908caa"
-text     = "#e0def4"
-love     = "#eb6f92"
-gold     = "#f6c177"
-rose     = "#ea9a97"
-pine     = "#3e8fb0"
-foam     = "#9ccfd8"
-iris     = "#c4a7e7"
-highlight = "#44415a"
-highlightInactive = "#2a283e"
-highlightOverlay = "#56526e"
+base           = "#232136" 
+surface        = "#2a273f" 
+overlay        = "#393552"
+muted          = "#6e6a86"
+subtle         = "#908caa"
+text           = "#e0def4"
+love           = "#eb6f92"
+love_10        = "#3a2841"
+gold           = "#f6c177"
+gold_10        = "#39313e"
+rose           = "#ea9a97"
+rose_10        = "#392d41"
+pine           = "#3e8fb0"
+pine_10        = "#252c44"
+foam           = "#9ccfd8"
+foam_10        = "#2e3248"
+iris           = "#c4a7e7"
+iris_10        = "#342e4a"
+highlight_low  = "#2a283e"
+highlight_med  = "#44415a"
+highlight_high = "#56526e"
diff --git a/runtime/themes/serika-dark.toml b/runtime/themes/serika-dark.toml
index 2b4000ac2..d18419798 100644
--- a/runtime/themes/serika-dark.toml
+++ b/runtime/themes/serika-dark.toml
@@ -18,7 +18,7 @@
 "variable.property" = "yellow"
 "label" = "aqua"
 "punctuation" = "grey0"
-"punctuation.delimiter" = "grey2"
+"punctuation.delimiter" = "bg4"
 "punctuation.bracket" = "fg"
 "keyword" = "red"
 "operator" = "grey0"
@@ -52,12 +52,17 @@
 "ui.selection" = { bg = "bg3" }
 "ui.virtual.whitespace" = "bg2"
 "ui.virtual.ruler" = { bg = "grey2" } 
+"ui.virtual.inlay-hint" = { fg = "grey2", modifiers = ["italic"] }
 
 "hint" = "blue"
 "info" = "aqua"
 "warning" = "yellow"
 "error" = "nasty-red"
-"diagnostic" = { fg = "nasty-red", modifiers = ["underlined"] }
+
+"diagnostic.hint" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.info" = { underline = { style = "curl", color = "aqua" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.error" = { underline = { style = "curl", color = "nasty-red" } }
 
 "diff.plus" = { fg = "green" }
 "diff.delta" = { fg = "orange" }
@@ -67,6 +72,7 @@
 "markup.list" = "cyan"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "cyan"
 "markup.link.text" = "pink"
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
diff --git a/runtime/themes/serika-light.toml b/runtime/themes/serika-light.toml
index 99d4b7f1b..1e3901ef2 100644
--- a/runtime/themes/serika-light.toml
+++ b/runtime/themes/serika-light.toml
@@ -52,12 +52,17 @@
 "ui.selection" = { fg = "bg0", bg = "bg3" }
 "ui.virtual.whitespace" = { fg = "bg2" }
 "ui.virtual.ruler" = { bg = "bg01" }
+"ui.virtual.inlay-hint" = { fg = "grey2", modifiers = ["italic"] }
 
 "hint" = "blue"
 "info" = "aqua"
 "warning" = "yellow"
 "error" = "nasty-red"
-"diagnostic" = { fg = "nasty-red", modifiers = ["underlined"] }
+
+"diagnostic.hint" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.info" = { underline = { style = "curl", color = "aqua" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.error" = { underline = { style = "curl", color = "nasty-red" } }
 
 "diff.plus" = { fg = "bg_green" }
 "diff.delta" = { fg = "bg_blue" }
@@ -67,6 +72,7 @@
 "markup.list" = "cyan"
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "cyan"
 "markup.link.text" = "pink"
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
diff --git a/runtime/themes/snazzy.toml b/runtime/themes/snazzy.toml
index b36d12430..eb88c5eb8 100644
--- a/runtime/themes/snazzy.toml
+++ b/runtime/themes/snazzy.toml
@@ -1,25 +1,55 @@
-# Author : Sebastian Zivota <loewenheim@mailbox.org>
 # Author : Timothy DeHerrera <tim@nrdxp.dev>
-"comment" = { fg = "comment" }
-"constant" = { fg = "purple" }
-"constant.character.escape" = { fg = "magenta" }
-"function" = { fg = "green" }
-"keyword" = { fg = "magenta" }
-"operator" = { fg = "magenta" }
-"punctuation" = { fg = "foreground" }
-"string" = { fg = "yellow" }
-"string.special.path" = { fg = "blue" }
-"string.regexp" = { fg = "red" }
-"tag" = { fg = "magenta" }
-"type" = { fg = "cyan", modifiers = ["italic"] }
-"type.enum.variant" = { fg = "foreground", modifiers = ["italic"] }
-"variable" = { fg = "foreground" }
-"variable.builtin" = { fg = "cyan", modifiers = ["italic"] }
+"comment".fg = "comment"
+
+"constant".fg = "purple"
+"constant.builtin".fg = "olive"
+"constant.character".fg = "carnation"
+"constant.character.escape".fg = "magenta"
+"constant.numeric".fg = "cyan"
+"constant.numeric.float".fg = "red"
+
+"function".fg = "green"
+"function.builtin".fg = "sand"
+"function.macro".fg = "blue"
+"function.method".fg = "opal"
+
+"keyword" = { fg = "magenta", modifiers = ["bold"] }
+"keyword.operator" = { fg = "coral", modifiers = ["bold"] }
+"keyword.function" = { fg = "lilac", modifiers = ["bold"] }
+"keyword.control" = { fg = "carnation", modifiers = ["bold"]}
+"keyword.control.exception" = { fg = "red", modifiers = ["bold"] }
+"keyword.storage" = { fg = "coral", modifiers = ["bold"] }
+
+"operator".fg = "coral"
+
+"punctuation".fg = "magenta"
+"punctuation.delimiter".fg = "coral"
+"punctuation.bracket".fg = "foreground"
+
+"string".fg = "yellow"
+"string.special".fg = "blue"
+"string.regexp".fg = "red"
+"tag".fg = "carnation"
+"attribute".fg = "opal"
+
+"type".fg = "opal"
+"type.variant".fg = "sand"
+"type.builtin".fg = "yellow"
+"type.enum.variant".fg = "sand"
+
+"variable".fg = "cyan"
+"variable.builtin".fg = "olive"
+"variable.other.member".fg = "lilac"
 "variable.parameter" = { fg ="blue", modifiers = ["italic"] }
 
-"diff.plus" = { fg = "green" }
-"diff.delta" = { fg = "blue" }
-"diff.minus" = { fg = "red" }
+"namespace".fg = "olive"
+"constructor".fg = "sand"
+"special".fg = "magenta"
+"label".fg = "magenta"
+
+"diff.plus".fg = "green"
+"diff.delta".fg = "blue"
+"diff.minus".fg = "red"
 
 "ui.background" = { fg = "foreground", bg = "background" }
 "ui.cursor" =  { fg = "background", bg = "blue", modifiers = ["dim"] }
@@ -36,19 +66,25 @@
 "ui.cursorline" = { bg = "background_dark" }
 "ui.statusline" = { fg = "foreground", bg = "background_dark" }
 "ui.statusline.inactive" = { fg = "comment", bg = "background_dark" }
+"ui.statusline.insert" = { fg = "olive", bg = "background_dark" }
+"ui.statusline.normal" = { fg = "opal", bg = "background_dark" }
+"ui.statusline.select" = { fg = "carnation", bg = "background_dark" }
 "ui.text" = { fg = "foreground" }
 "ui.text.focus" = { fg = "cyan" }
 "ui.window" = { fg = "foreground" }
 "ui.virtual.whitespace" = { fg = "comment" }
+"ui.virtual.indent-guide" = { fg = "opal" }
 "ui.virtual.ruler" = { bg = "background_dark" }
 
 "error" = { fg = "red" }
 "warning" = { fg = "cyan" }
 
 "markup.heading" = { fg = "purple", modifiers = ["bold"] }
+"markup.link.label" = { fg = "blue", modifiers = ["italic"] }
 "markup.list" = "cyan"
 "markup.bold" = { fg = "blue", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = "cyan"
 "markup.link.text" = "magenta"
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
@@ -61,6 +97,8 @@ primary_highlight = "#800049"
 secondary_highlight = "#4d4f66"
 foreground = "#eff0eb"
 comment = "#a39e9b"
+
+# main colors
 red = "#ff5c57"
 blue = "#57c7ff"
 yellow = "#f3f99d"
@@ -68,3 +106,11 @@ green = "#5af78e"
 purple = "#bd93f9"
 cyan = "#9aedfe"
 magenta = "#ff6ac1"
+
+# aux colors
+lilac = "#c9c5fb"
+coral = "#f97c7c"
+sand = "#ffab6f"
+carnation = "#f99fc6"
+olive = "#b6d37c"
+opal = "#b1d7c7"
diff --git a/runtime/themes/solarized_dark.toml b/runtime/themes/solarized_dark.toml
index 1083b0c89..88f857d3d 100644
--- a/runtime/themes/solarized_dark.toml
+++ b/runtime/themes/solarized_dark.toml
@@ -27,6 +27,7 @@
 "markup.list" = "red"
 "markup.bold" = { fg = "yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", modifiers = ["underlined"] }
 "markup.link.text" = "red"
 "markup.quote" = "cyan"
@@ -40,6 +41,7 @@
 "ui.background" = { bg = "base03" }
 
 "ui.virtual.whitespace" = { fg = "base01" }
+"ui.virtual.inlay-hint" = { fg = "base01", modifiers = ["italic"] }
 
 # 
 "ui.linenr" = { fg = "base0", bg = "base02" }
@@ -68,7 +70,7 @@
 "ui.help" = { modifiers = ["reversed"] }
 
 #  
-"ui.popup.info" = { bg = "base1" }
+"ui.popup.info" = {fg = "base02", bg = "base1", modifiers = ["bold"]}
 # 
 "ui.text.info" = {fg = "base02", modifiers = ["bold"]}
 
@@ -101,7 +103,11 @@
 "error" = { fg = "red", modifiers= ["bold", "underlined"] }
 "info" = { fg = "blue", modifiers= ["bold", "underlined"] }
 "hint" = { fg = "base01", modifiers= ["bold", "underlined"] }
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.warning" = { underline = { style = "curl", color = "orange" } }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
+"diagnostic.info" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "base01" } }
 
 [palette]
 #  
diff --git a/runtime/themes/solarized_light.toml b/runtime/themes/solarized_light.toml
index 737829a6d..cd2d2b364 100644
--- a/runtime/themes/solarized_light.toml
+++ b/runtime/themes/solarized_light.toml
@@ -27,6 +27,7 @@
 "markup.list" = "red"
 "markup.bold" = { fg = "yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "yellow", modifiers = ["underlined"] }
 "markup.link.text" = "red"
 "markup.quote" = "cyan"
@@ -41,6 +42,7 @@
 "ui.background" = { bg = "base03" }
 
 "ui.virtual.whitespace" = { fg = "base01" }
+"ui.virtual.inlay-hint" = { fg = "base01", modifiers = ["italic"] }
 
 # 
 # line number column
@@ -118,7 +120,12 @@
 "error" = { fg = "red", modifiers= ["bold", "underlined"] }
 "info" = { fg = "blue", modifiers= ["bold", "underlined"] }
 "hint" = { fg = "base01", modifiers= ["bold", "underlined"] }
-"diagnostic" = { modifiers = ["underlined"] }
+
+"diagnostic.warning" = { underline = { style = "curl", color = "orange" } }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
+"diagnostic.info" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "base01" } }
+
 
 [palette]
 red      = '#dc322f'
diff --git a/runtime/themes/sonokai.toml b/runtime/themes/sonokai.toml
index 18417f009..f60bd4dbf 100644
--- a/runtime/themes/sonokai.toml
+++ b/runtime/themes/sonokai.toml
@@ -41,6 +41,7 @@
 "markup.list" = "red"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "blue", modifiers = ["underlined"] }
 "markup.link.text" = "purple"
 "markup.quote" = "grey"
@@ -55,7 +56,8 @@
 "ui.cursor.match" = { fg = "orange", bg = "diff_yellow" }
 "ui.cursor.insert" = { fg = "black", bg = "grey" }
 "ui.cursor.select" = { fg = "bg0", bg = "blue" }
-"ui.selection" = { bg = "bg4" }
+"ui.selection" = { bg = "bg5" }
+"ui.selection.primary" = { bg = "bg4" }
 "ui.linenr" = "grey"
 "ui.linenr.selected" = "fg"
 "ui.cursorline.primary" = { bg = "bg1" }
@@ -75,7 +77,11 @@ info = { fg = 'green', bg = 'bg2' }
 hint = { fg = 'blue', bg = 'bg2', modifiers = ['bold'] }
 warning = { fg = 'yellow', bg = 'bg2', modifiers = ['bold'] }
 error = { fg = 'red', bg = 'bg2', modifiers = ['bold'] }
-diagnostic = { modifiers = ['underlined'] }
+
+"diagnostic.info" = { underline = { style = "curl", color = "green" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
 
 
 
@@ -86,7 +92,8 @@ bg0 = "#2c2e34"
 bg1 = "#33353f"
 bg2 = "#363944"
 bg3 = "#3b3e48"
-bg4 = "#545862"
+bg4 = "#5C606A"
+bg5 = "#444852"
 bg_red = "#ff6077"
 diff_red = "#55393d"
 bg_green = "#a7df78"
diff --git a/runtime/themes/spacebones_light.toml b/runtime/themes/spacebones_light.toml
index 0956afd22..a62c7c82e 100644
--- a/runtime/themes/spacebones_light.toml
+++ b/runtime/themes/spacebones_light.toml
@@ -34,6 +34,7 @@
 "markup.list" = "theme_red"
 "markup.bold" = { fg = "theme_yellow", modifiers = ["bold"] }
 "markup.italic" = { fg = "theme_magenta", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "theme_yellow", modifiers = ["underlined"] }
 "markup.link.text" = "theme_red"
 "markup.quote" = "theme_cyan"
@@ -72,7 +73,10 @@
 "ui.virtual" = "base-dim"
 "ui.virtual.ruler" = { bg = "bg1" }
 
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.warning" = { underline = { style = "curl", color = "meta" } }
+"diagnostic.error" = { underline = { style = "curl", color = "#e0211d" } }
+"diagnostic.info" = { underline = { style = "curl", color = "theme_yellow" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "bg2" } }
 
 [palette]
 base = "#655370"
diff --git a/runtime/themes/tokyonight.toml b/runtime/themes/tokyonight.toml
index 4847d92ca..cc99689fc 100644
--- a/runtime/themes/tokyonight.toml
+++ b/runtime/themes/tokyonight.toml
@@ -48,19 +48,24 @@
 "ui.text.focus" = { fg = "cyan" }
 "ui.virtual.ruler" = { bg = "foreground_gutter" }
 "ui.virtual.whitespace" = { fg = "foreground_gutter" }
+"ui.virtual.inlay-hint" = { fg = "comment" }
 "ui.window" = { fg = "black" }
 
 "error" = { fg = "red" }
 "warning" = { fg = "yellow" }
 "info" = { fg = "blue" }
 "hint" = { fg = "teal" }
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.info" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.hint" = { underline = { style = "curl", color = "teal" } }
 "special" = { fg = "orange" }
 
 "markup.heading" = { fg = "cyan", modifiers = ["bold"] }
 "markup.list" = { fg = "cyan" }
 "markup.bold" = { fg = "orange", modifiers = ["bold"] }
 "markup.italic" = { fg = "yellow", modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "green" }
 "markup.link.text" = { fg = "light-gray" }
 "markup.quote" = { fg = "yellow", modifiers = ["italic"] }
diff --git a/runtime/themes/varua.toml b/runtime/themes/varua.toml
index 7ef502a6a..b07ab08dc 100644
--- a/runtime/themes/varua.toml
+++ b/runtime/themes/varua.toml
@@ -65,12 +65,17 @@
 "ui.virtual.whitespace" = "grey0"
 "ui.statusline.insert" = { bg = "green", fg = "bg2" }
 "ui.statusline.select" = { bg = "blue", fg = "bg2" }
+"ui.virtual.wrap" = { fg = "grey0" }
+"ui.virtual.inlay-hint" = { fg = "grey1" }
 
 "hint" = "blue"
 "info" = "aqua"
 "warning" = "yellow"
 "error" = "red"
-"diagnostic" = { modifiers = ["underlined"] }
+"diagnostic.hint" = { underline = { style = "curl", color = "blue" } }
+"diagnostic.info" = { underline = { style = "curl", color = "aqua" } }
+"diagnostic.warning" = { underline = { style = "curl", color = "yellow" } }
+"diagnostic.error" = { underline = { style = "curl", color = "red" } }
 
 [palette]
 bg0 = "#282828"
diff --git a/runtime/themes/zenburn.toml b/runtime/themes/zenburn.toml
index 63f4ac722..8518e78f8 100644
--- a/runtime/themes/zenburn.toml
+++ b/runtime/themes/zenburn.toml
@@ -6,8 +6,10 @@
 "ui.linenr" = { fg = "#9fafaf", bg = "#262626"}
 "ui.linenr.selected" = { modifiers = ["bold"]}
 "ui.popup" = { bg = "uibg" }
-"ui.selection" = { bg = "#2f2f2f" }
-"comment" = { fg = "#7f9f7f" }
+"ui.selection" = { bg = "#304a3d" }
+"ui.selection.primary" = { bg = "#2f2f2f" }
+"comment" = { fg = "comment" }
+"ui.virtual.inlay-hint" = { fg = "comment" }
 "comment.block.documentation" = { fg = "black", modifiers = ["bold"] }
 "ui.statusline" = { bg = "statusbg", fg = "#ccdc90" }
 "ui.statusline.inactive" = { fg = '#2e3330', bg = '#88b090' }
@@ -49,6 +51,7 @@
 "error" = "errorfg"
 
 [palette]
+comment = "#7f9f7f"
 bg = "#3f3f3f"
 uibg = "#2c2e2e"
 constant = "#dca3a3"
diff --git a/runtime/tutor b/runtime/tutor
index 418c41954..a6682ed92 100644
--- a/runtime/tutor
+++ b/runtime/tutor
@@ -1,13 +1,29 @@
-                  _   _                 __    __
-                 | | | |         _      \ \  / /
-                 | |_| |   ___  | | (_)  \ \/ /
-                 |  _  |  / _ \ | |  _    )  (
-                 | | | | |  __/ | | | |  / /\ \
-                 |_| |_|  \___| |_| |_| /_/  \_\
 
-                 A post-modern modal text editor.
-_________________________________________________________________
 
+       .
+       ###x.        .|
+       d#####x,   ,v||
+        '+#####v||||||
+           ,v|||||+'.      _     _           _
+        ,v|||||^'>####    | |   | |   ___   | | (_) __  __
+       |||||^'  .v####    | |___| |  /   \  | |  _  \ \/ /
+       ||||=..v#####P'    |  ___  | /  ^  | | | | |  \  /
+       ''v'>#####P'       | |   | | |  ---  | | | |  /  \
+       ,######/P||x.      |_|   |_|  \___/  |_| |_| /_/\_\
+       ####P' "x|||||,
+       |/'       'x|||    A post-modern modal text editor.
+        '           '|
+
+
+                 Welcome to the Helix tutorial!
+        Press the j key until you reach the introduction.
+
+
+
+=================================================================
+=                        INTRODUCTION                           =
+=================================================================
+                                                                 
  Welcome to the Helix editor! Helix is different from editors
  you might be used to in that it is modal, meaning that it has
  different modes for editing text. The primary modes you will
@@ -20,6 +36,12 @@ _________________________________________________________________
  the first lesson.
 
 
+
+
+
+
+
+
 =================================================================
 =                  1.1 BASIC CURSOR MOVEMENT                    =
 =================================================================
@@ -48,13 +70,13 @@ _________________________________________________________________
 
  1. Type : to enter Command mode. Your cursor will
     move to the bottom of the screen.
- 2. Type q or quit and type Enter to exit Helix.
+ 2. Type q or quit and press Enter to exit Helix.
 
  Note: The quit command will fail if there are unsaved changes.
        To force quit and DISCARD these changes, type q! or quit!.
        You will learn how to save files later.
 
- To exit Command mode without entering a command, type Escape.
+ To exit Command mode without entering a command, press Escape.
 
  Now, move on to the next lesson.
 
@@ -96,7 +118,7 @@ _________________________________________________________________
  2. Move to a place in the line which is missing text and type
     i to enter Insert mode. Keys you type will now type text.
  3. Enter the missing text.
- 4. Type Escape to exit Insert mode and return to Normal mode.
+ 4. Press Escape to exit Insert mode and return to Normal mode.
  5. Repeat until the line matches the line below it.
 
  --> Th stce misg so.
@@ -119,7 +141,7 @@ _________________________________________________________________
  2. Open a file in Helix by running: hx FILENAME
  3. Make some edits to the file.
  4. Type : to enter Command mode.
- 5. Type w or write, and type Enter to save the file.
+ 5. Type w or write, and press Enter to save the file.
 
  You can also type wq or write-quit to save and exit.
 
@@ -145,7 +167,7 @@ _________________________________________________________________
 
  * Type d to delete the character at the cursor.
 
- * Type i to enter Insert mode and type text. Type Escape to
+ * Type i to enter Insert mode and type text. Press Escape to
    return to Normal mode.
 
 
@@ -241,7 +263,7 @@ _________________________________________________________________
 
 
 =================================================================
-=                     3.2 MORE ON MOTIONS                       =
+=                     3.2 MORE MOTIONS                          =
 =================================================================
 
  As you saw, typing w moves the cursor forward until the start
@@ -253,17 +275,39 @@ _________________________________________________________________
    e - Move forward to the end of the current word.
    b - Move backward to the beginning of the current word.
 
+ To select the word under cursor, combine e and b.
+
+ 1. Move the cursor to the line marked '-->' below.
+ 2. Move to a 'd' letter.
+ 3. Type e to select a half of the word.
+ 4. Type b to select the rest.
+
+--> The Middle Kingdom.
+
+=================================================================
+=                     3.3 WORDS AND words                       =
+=================================================================
+
  The w,e,b motions also have counterparts - W,E,B - which
  traverse WORDS instead of words. WORDS are only separated by
  whitespace, whereas words can be separated by other characters
  in addition to whitespace.
 
- All of these motions select the text they traverse.
+ 1. Move the cursor to the beginning of the line marked with '-->'.
+ 2. Type w repeatedly to select individual words until you
+    reach the end of the line.
+ 3. Note that 'one-of-a-kind' required 7 keystrokes to be
+    traversed. '"modal"' required 3 keystrokes.
+ 4. Move the cursor back to beginning of the line marked '-->'.
+ 5. Type W repeatedly to select individual WORDS.
+ 6. Note that 'one-of-a-kind' and '"modal"' have been selected
+    both with one keystroke each.
 
+--> Helix is a one-of-a-kind "modal" text editor
 
 
 =================================================================
-=                    3.3 THE CHANGE COMMAND                     =
+=                    3.4 THE CHANGE COMMAND                     =
 =================================================================
 
  Type c to change the current selection.
@@ -285,7 +329,7 @@ _________________________________________________________________
 
 
 =================================================================
-=                   3.4 COUNTS WITH MOTIONS                     =
+=                   3.5 COUNTS WITH MOTIONS                     =
 =================================================================
 
  Type a number before a motion to repeat it that many times.
@@ -307,7 +351,7 @@ _________________________________________________________________
 
 
 =================================================================
-=                    3.5 SELECT / EXTEND MODE                   =
+=                    3.6 SELECT / EXTEND MODE                   =
 =================================================================
 
  Type v to enter Select mode.
@@ -329,7 +373,7 @@ _________________________________________________________________
 
 
 =================================================================
-=                     3.6 SELECTING LINES                       =
+=                     3.7 SELECTING LINES                       =
 =================================================================
 
  Type x to select a whole line. Type x again to select the next.
@@ -351,7 +395,7 @@ _________________________________________________________________
       subsequent lines. X on an empty line does nothing.
 
 =================================================================
-=                   3.7 COLLAPSING SELECTIONS                   =
+=                   3.8 COLLAPSING SELECTIONS                   =
 =================================================================
 
  Type ; to collapse selections to single cursors.
@@ -447,7 +491,7 @@ _________________________________________________________________
  Type N to go to the previous search match.
 
  1. Type / and type in a common word, like 'banana'.
- 2. Type Enter to confirm the search.
+ 2. Press Enter to confirm the search.
  3. Use n and N to cycle through the matches.
 
  Searching uses regular expressions, allowing you to target more
@@ -502,7 +546,7 @@ _________________________________________________________________
  --> Fix th two nes at same ime.
      Fix these two lines at the same time.
 
- Note: Type Alt-C to do the same above the cursor.
+ Note: Press Alt-C to do the same above the cursor.
 
 =================================================================
 =                    5.2 THE SELECT COMMAND                     =
@@ -513,11 +557,11 @@ _________________________________________________________________
  1. Move the cursor to the line marked '-->' below.
  2. Type x to select the line.
  3. Type s. A prompt will appear.
- 4. Type 'apples' and type Enter. Both occurrences of
+ 4. Type 'apples' and press Enter. Both occurrences of
     'apples' in the line will be selected.
  5. You can now type c and change 'apples' to something else,
     like 'oranges'.
- 6. Type Escape to exit Insert mode.
+ 6. Press Escape to exit Insert mode.
  7. Type , to remove the second cursor.
 
  --> I like to eat apples since my favorite fruit is apples.
@@ -536,7 +580,7 @@ _________________________________________________________________
  1. Move the cursor to the line marked '-->' below.
  2. Select the line with x and then type s.
  3. Type '  +' to select any amount of consecutive spaces >1,
-    then type Enter.
+    then press Enter.
  4. Type c and change the matches to single spaces.
 
  --> This  sentence has   some      extra spaces.
@@ -574,11 +618,11 @@ _________________________________________________________________
 =                 5.5 SPLIT SELECTION INTO LINES                =
 =================================================================
 
- Type Alt-s to split the selection(s) on newlines.
+ Press Alt-s to split the selection(s) on newlines.
 
  1. Move the cursor to the first row of the table below.
  2. Select the entire table with 6x.
- 3. Type Alt-s to split into selections at each line.
+ 3. Press Alt-s to split into selections at each line.
  4. Align the table with &.
 
     | FRUIT   | AMOUNT |
@@ -604,7 +648,7 @@ _________________________________________________________________
 
  * Type & to align selections.
 
- * Type Alt-s to split the selection into lines.
+ * Press Alt-s to split the selection into lines.
 
 
 
@@ -663,7 +707,7 @@ _________________________________________________________________
 =================================================================
 
  Type . to repeat the last insert command.
- Type Alt-. to repeat the last f / t selection.
+ Press Alt-. to repeat the last f / t selection.
 
  1. Move the cursor to the line marked '-->' below.
  2. Make a change, insertion or appendage and repeat it with . .
@@ -690,7 +734,7 @@ _________________________________________________________________
  * Type r to replace selected characters.
 
  * Type . to repeat the last insertion.
-   * Type Alt-. to repeat the last f / t selection.
+   * Press Alt-. to repeat the last f / t selection.
 
 
 
@@ -772,13 +816,13 @@ lines.
 =               7.4 INCREMENTING AND DECREMENTING               =
 =================================================================
 
- Type Ctrl-a to increment the number under selection.
- Type Ctrl-x to decrement the number under selection.
+ Press Ctrl-a to increment the number under selection.
+ Press Ctrl-x to decrement the number under selection.
 
  1. Move the cursor to the third line marked '-->' below.
- 2. Type Ctrl-a to increment the second point marked 2.
+ 2. Press Ctrl-a to increment the second point marked 2.
  3. Repeat for the point marked 3.
- 4. Move to the last point and type Ctrl-x to decrement the 6.
+ 4. Move to the last point and press Ctrl-x to decrement the 6.
 
  --> 1) First point.
  --> 2) Added point.
@@ -786,8 +830,8 @@ lines.
  --> 3) Another point.
  --> 6) Last point.
 
- Note: If there isn't a number under the selection the cursor
-       will jump to the next number in the line and act on it.
+
+
 
 
 =================================================================
@@ -800,8 +844,8 @@ lines.
 
  * Type < and > to indent / outdent lines.
 
- * Type Ctrl-a to increment the selected number.
-   * Type Ctrl-x to decrement the selected number.
+ * Press Ctrl-a to increment the selected number.
+   * Press Ctrl-x to decrement the selected number.
 
 
 
@@ -848,13 +892,13 @@ lines.
     Ensure your cursor is on the '>' of the arrow.
  2. Type Q to start recording.
  3. Edit the line to look like the bottom one.
- 4. Exit insert and Type Q again to stop recording.
+ 4. Exit insert and type Q again to stop recording.
  5. Move to the line below and put your cursor on '>' again.
  6. Type q to repeat the macro.
 
- --> ... sentence doesn't have it's first and last ... .
- --> ... sentence doesn't have it's first and last ... .
-     This sentence doesn't have it's first and last word.
+ --> ... sentence doesn't have its first and last ... .
+ --> ... sentence doesn't have its first and last ... .
+     This sentence doesn't have its first and last word.
 
 =================================================================
 =                        CHAPTER 8 RECAP                        =
@@ -930,15 +974,15 @@ lines.
  searching or jumping to the definition of a function in code. It
  stores these in what's called the jumplist.
 
- Type Ctrl-s to manually save your current position to
+ Press Ctrl-s to manually save your current position to
  the jumplist.
 
- Type Ctrl-i ("in") and Ctrl-o ("out") to move forward and
+ Press Ctrl-i ("in") and Ctrl-o ("out") to move forward and
  backwards in the jumplist respectively.
 
- 1. Type Ctrl-s somewhere.
+ 1. Press Ctrl-s somewhere.
  2. Move far away in the file.
- 3. Type Ctrl-o (just once!) to come back to where you saved.
+ 3. Press Ctrl-o (just once!) to come back to where you saved.
 
 
 
@@ -953,8 +997,8 @@ lines.
  * Type n / N in Visual mode to add selections on each search
    match.
 
- * Type Ctrl-s to save position to the jumplist.
-   * Type Ctrl-i and Ctrl-o to go forward and backward in the
+ * Press Ctrl-s to save position to the jumplist.
+   * Press Ctrl-i and Ctrl-o to go forward and backward in the
      jumplist.
 
 
@@ -973,7 +1017,7 @@ lines.
  Type ) and ( to cycle the primary selection forward and backward
  through selections respectively.
 
- Type Alt-, to remove the primary selection.
+ Press Alt-, to remove the primary selection.
 
  1. Move the cursor to the line marked '-->' below.
  2. Select both lines with xx or 2x.
@@ -985,16 +1029,38 @@ lines.
  --> How much would would a wouldchuck chuck
  --> if a wouldchuck could chuck would?
 
- Note: Additionally, Alt-( and Alt-) cycle the *contents* of the
-       selections as well.
+
+
 
 =================================================================
-=                     10.2 CHANGING CASE                        =
+=             10.2 CYCLING THE CONTENT OF SELECTIONS            =
+=================================================================
+
+ Press Alt-) and Alt-( to cycle the content of the selections
+ forward and backward respectively.
+
+ 1. Move the cursor to the line marked '-->' below.
+ 2. Select both lines with xx or 2x.
+ 3. Type s to select, type "through|water|know" and enter.
+ 4. Use Alt-( and Alt-) to cycle the content of the selections.
+
+ --> Jumping through the water,
+ --> daring to know.
+
+
+
+
+
+
+
+
+=================================================================
+=                     10.3 CHANGING CASE                        =
 =================================================================
 
  Type ~ to switch the case of all selected letters.
  Type ` to set all selected letters to lowercase.
- Type Alt-` to set all selected letters to uppercase.
+ Press Alt-` to set all selected letters to uppercase.
 
  1. Move the cursor to the first line marked '-->' below.
  2. Select each wrongly capitalised or lowercase letter
@@ -1004,14 +1070,14 @@ lines.
  5. Type ` to change the line to lowercase.
  6. Move to the third line marked '-->'.
  7. Type x to select the line.
- 8. Type Alt-` to change the line to uppercase.
+ 8. Press Alt-` to change the line to uppercase.
 
  --> thIs sENtencE hAs MIS-cApitalIsed leTTerS.
  --> this SENTENCE SHOULD all be in LOWERCASE.
  --> THIS sentence should ALL BE IN uppercase!
 
 =================================================================
-=                   10.3 SPLITTING SELECTIONS                   =
+=                   10.4 SPLITTING SELECTIONS                   =
 =================================================================
 
  Type S to split each selection on a regex pattern.
@@ -1021,10 +1087,10 @@ lines.
  3. Type S then \. |! Enter (note the spaces after . and !).
     This effectively splits the selection into sentences at each
     dot or exclamation mark.
- 4. Type Alt-; to reverse the selections.
+ 4. Press Alt-; to reverse the selections.
  5. Type ; to reduce selections to a single character - the first
     letter of each sentence.
- 6. Type Alt-` to convert all selected letters to uppercase.
+ 6. Press Alt-` to convert all selected letters to uppercase.
 
 ---
 these are sentences. some sentences don't start with uppercase
@@ -1038,11 +1104,12 @@ letters! that is not good grammar. you can fix this.
 
  * Use ) and ( to cycle the primary selection back and forward
    through selections respectively.
-   * Type Alt-, to remove the primary selection.
+   * Press Alt-, to remove the primary selection.
+   * Press Alt-) and Alt-( to cycle the content of the selections.
 
  * Type ~ to alternate case of selected letters.
    * Use ` and Alt-` to set the case of selected letters to
-     upper and lower respectively.
+     lower and upper respectively.
 
  * Type S to split selections on regex.
 
@@ -1053,12 +1120,59 @@ letters! that is not good grammar. you can fix this.
 
 
 
+=================================================================
+=                     11.1 COMMENTING A LINE                    =
+=================================================================
+
+Press Ctrl-c to comment the line under your cursor.
+To uncomment the line, press Ctrl-c again.
+
+1. Move your cursor to the line marked '-->' below.
+2. Now comment the line marked with '-->'.
+3. Now try uncommenting the line.
+
+--> Comment me please
+
+
+
+
+
+
+
+
+
 
 =================================================================
-=                                                               =
+=                 11.2 COMMENTING MULTIPLE LINES                =
 =================================================================
 
+Using the selections and multi-cursor functionality, you can 
+comment multiple lines as long as it is under the selection or
+cursors. 
+
+1. Move your cursor to the line marked with '-->' below.
+2. Now try to select or add more cursors the other lines marked 
+   with '-->'. 
+3. Comment those lines.
+
+--> How many are you going to comment?
+--> Is this enough for a comment?
+--> What are you doing?!
+--> Stop commenting me!
+--> AAAAaargh!!!
+
+Note: If there are already commented lines under selections or
+multiple cursors, they won't be uncommented but commented again.
+
+=================================================================
+=                       CHAPTER 11 RECAP                        =
+=================================================================
 
+ * Use Ctrl-c to comment a line under your cursor. Press Ctrl-c
+   again to uncomment.
+ * To comment multiple lines, use the selections 
+   and multi-cursors before typing Ctrl-c.
+   * Commented lines cannot be uncommented but commented again.
 
 
 
diff --git a/rust-toolchain.toml b/rust-toolchain.toml
index b169d31e6..2abc56652 100644
--- a/rust-toolchain.toml
+++ b/rust-toolchain.toml
@@ -1,3 +1,3 @@
 [toolchain]
-channel = "1.61.0"
+channel = "1.65.0"
 components = ["rustfmt", "rust-src"]
diff --git a/theme.toml b/theme.toml
index 054093195..dd1a5d889 100644
--- a/theme.toml
+++ b/theme.toml
@@ -31,6 +31,7 @@ label = "honey"
 "markup.heading" = "lilac"
 "markup.bold" = { modifiers = ["bold"] }
 "markup.italic" = { modifiers = ["italic"] }
+"markup.strikethrough" = { modifiers = ["crossed_out"] }
 "markup.link.url" = { fg = "silver", modifiers = ["underlined"] }
 "markup.link.text" = "almond"
 "markup.raw" = "almond"
@@ -54,6 +55,7 @@ label = "honey"
 
 "ui.text" = { fg = "lavender" }
 "ui.text.focus" = { fg = "white" }
+"ui.text.inactive" = "sirocco"
 "ui.virtual" = { fg = "comet" }
 
 "ui.virtual.indent-guide" = { fg = "comet" }
@@ -67,7 +69,9 @@ label = "honey"
 "ui.cursor" = { modifiers = ["reversed"] }
 "ui.cursorline.primary" = { bg = "bossanova" }
 "ui.highlight" = { bg = "bossanova" }
-
+"ui.highlight.frameline" = { bg = "#634450" }
+"ui.debug" = { fg = "#634450" }
+"ui.debug.breakpoint" = { fg = "apricot" }
 "ui.menu" = { fg = "lavender", bg = "revolver" }
 "ui.menu.selected" = { fg = "revolver", bg = "white" }
 "ui.menu.scroll" = { fg = "lavender", bg = "comet" }
diff --git a/xtask/Cargo.toml b/xtask/Cargo.toml
index 127b931cf..ed1182947 100644
--- a/xtask/Cargo.toml
+++ b/xtask/Cargo.toml
@@ -10,4 +10,4 @@ helix-term = { version = "0.6", path = "../helix-term" }
 helix-core = { version = "0.6", path = "../helix-core" }
 helix-view = { version = "0.6", path = "../helix-view" }
 helix-loader = { version = "0.6", path = "../helix-loader" }
-toml = "0.5"
+toml = "0.7"
diff --git a/xtask/src/helpers.rs b/xtask/src/helpers.rs
index 4f759e74f..f96cdfb38 100644
--- a/xtask/src/helpers.rs
+++ b/xtask/src/helpers.rs
@@ -39,6 +39,6 @@ pub fn find_files(dir: &Path, filename: &str) -> Vec<PathBuf> {
 }
 
 pub fn lang_config() -> LangConfig {
-    let bytes = std::fs::read(path::lang_config()).unwrap();
-    toml::from_slice(&bytes).unwrap()
+    let text = std::fs::read_to_string(path::lang_config()).unwrap();
+    toml::from_str(&text).unwrap()
 }
diff --git a/xtask/src/themelint.rs b/xtask/src/themelint.rs
index 06dfae407..f7efb7d9a 100644
--- a/xtask/src/themelint.rs
+++ b/xtask/src/themelint.rs
@@ -36,6 +36,8 @@ fn get_rules() -> Vec<Require> {
         Require::Difference("ui.statusline.normal", "ui.statusline.select"),
         // Check for editor.cursorline
         Require::Existence(Rule::has_bg("ui.cursorline.primary")),
+        // Check for general ui.virtual (such as inlay-hint)
+        Require::Existence(Rule::has_fg("ui.virtual")),
         // Check for editor.whitespace
         Require::Existence(Rule::has_fg("ui.virtual.whitespace")),
         // Check fir rulers
@@ -156,8 +158,8 @@ pub fn lint(file: String) -> Result<(), DynError> {
         return Ok(());
     }
     let path = path::themes().join(file.clone() + ".toml");
-    let theme = std::fs::read(&path).unwrap();
-    let theme: Theme = toml::from_slice(&theme).expect("Failed to parse theme");
+    let theme = std::fs::read_to_string(path).unwrap();
+    let theme: Theme = toml::from_str(&theme).expect("Failed to parse theme");
 
     let mut messages: Vec<String> = vec![];
     get_rules().iter().for_each(|lint| match lint {
